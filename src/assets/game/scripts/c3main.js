// Generated by Construct, the game and animation creation tool
// Visit: https://www.construct.net

{
    let k = function(t) {
        vh = t;
    }, L = function(t) {
        return t * kh;
    }, B = function(t, s) {
        return Math.abs(t - s) <= Mh * Math.max(1, Math.abs(t), Math.abs(s));
    }, N = function() {
        var t = new vh(4);
        return vh != Float32Array && (t[1] = 0, t[2] = 0), t[0] = 1, t[3] = 1, t;
    }, W = function(t) {
        var s = new vh(4);
        return s[0] = t[0], s[1] = t[1], s[2] = t[2], s[3] = t[3], s;
    }, j = function(t, s) {
        return t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[3], t;
    }, V = function(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t;
    }, U = function(t, s, i, e) {
        var h = new vh(4);
        return h[0] = t, h[1] = s, h[2] = i, h[3] = e, h;
    }, H = function(t, s, i, e, h) {
        return t[0] = s, t[1] = i, t[2] = e, t[3] = h, t;
    }, z = function(t, s) {
        var i;
        return t === s ? (i = s[1], t[1] = s[2], t[2] = i) : (t[0] = s[0], t[1] = s[2], 
        t[2] = s[1], t[3] = s[3]), t;
    }, J = function(t, s) {
        var i = s[0], e = s[1], h = s[2], s = s[3], r = i * s - h * e;
        return r ? (t[0] = s * (r = 1 / r), t[1] = -e * r, t[2] = -h * r, t[3] = i * r, 
        t) : null;
    }, q = function(t, s) {
        var i = s[0];
        return t[0] = s[3], t[1] = -s[1], t[2] = -s[2], t[3] = i, t;
    }, X = function(t) {
        return t[0] * t[3] - t[2] * t[1];
    }, t = function(t, s, i) {
        var e = s[0], h = s[1], r = s[2], s = s[3], n = i[0], o = i[1], a = i[2], i = i[3];
        return t[0] = e * n + r * o, t[1] = h * n + s * o, t[2] = e * a + r * i, 
        t[3] = h * a + s * i, t;
    }, Y = function(t, s, i) {
        var e = s[0], h = s[1], r = s[2], s = s[3], n = Math.sin(i), i = Math.cos(i);
        return t[0] = e * i + r * n, t[1] = h * i + s * n, t[2] = e * -n + r * i, 
        t[3] = h * -n + s * i, t;
    }, $ = function(t, s, i) {
        var e = s[0], h = s[1], r = s[2], s = s[3], n = i[0], i = i[1];
        return t[0] = e * n, t[1] = h * n, t[2] = r * i, t[3] = s * i, t;
    }, K = function(t, s) {
        var i = Math.sin(s), s = Math.cos(s);
        return t[0] = s, t[1] = i, t[2] = -i, t[3] = s, t;
    }, Z = function(t, s) {
        return t[0] = s[0], t[1] = 0, t[2] = 0, t[3] = s[1], t;
    }, Q = function(t) {
        return "mat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
    }, tt = function(t) {
        return Math.hypot(t[0], t[1], t[2], t[3]);
    }, st = function(t, s, i, e) {
        return t[2] = e[2] / e[0], i[0] = e[0], i[1] = e[1], i[3] = e[3] - t[2] * i[1], 
        [ t, s, i ];
    }, it = function(t, s, i) {
        return t[0] = s[0] + i[0], t[1] = s[1] + i[1], t[2] = s[2] + i[2], t[3] = s[3] + i[3], 
        t;
    }, s = function(t, s, i) {
        return t[0] = s[0] - i[0], t[1] = s[1] - i[1], t[2] = s[2] - i[2], t[3] = s[3] - i[3], 
        t;
    }, et = function(t, s) {
        return t[0] === s[0] && t[1] === s[1] && t[2] === s[2] && t[3] === s[3];
    }, ht = function(t, s) {
        var i = t[0], e = t[1], h = t[2], t = t[3], r = s[0], n = s[1], o = s[2], s = s[3];
        return Math.abs(i - r) <= Mh * Math.max(1, Math.abs(i), Math.abs(r)) && Math.abs(e - n) <= Mh * Math.max(1, Math.abs(e), Math.abs(n)) && Math.abs(h - o) <= Mh * Math.max(1, Math.abs(h), Math.abs(o)) && Math.abs(t - s) <= Mh * Math.max(1, Math.abs(t), Math.abs(s));
    }, rt = function(t, s, i) {
        return t[0] = s[0] * i, t[1] = s[1] * i, t[2] = s[2] * i, t[3] = s[3] * i, 
        t;
    }, nt = function(t, s, i, e) {
        return t[0] = s[0] + i[0] * e, t[1] = s[1] + i[1] * e, t[2] = s[2] + i[2] * e, 
        t[3] = s[3] + i[3] * e, t;
    }, ot = function() {
        var t = new vh(6);
        return vh != Float32Array && (t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0), t[0] = 1, 
        t[3] = 1, t;
    }, at = function(t) {
        var s = new vh(6);
        return s[0] = t[0], s[1] = t[1], s[2] = t[2], s[3] = t[3], s[4] = t[4], 
        s[5] = t[5], s;
    }, lt = function(t, s) {
        return t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[3], t[4] = s[4], 
        t[5] = s[5], t;
    }, ut = function(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t;
    }, ct = function(t, s, i, e, h, r) {
        var n = new vh(6);
        return n[0] = t, n[1] = s, n[2] = i, n[3] = e, n[4] = h, n[5] = r, n;
    }, ft = function(t, s, i, e, h, r, n) {
        return t[0] = s, t[1] = i, t[2] = e, t[3] = h, t[4] = r, t[5] = n, t;
    }, dt = function(t, s) {
        var i = s[0], e = s[1], h = s[2], r = s[3], n = s[4], s = s[5], o = i * r - e * h;
        return o ? (t[0] = r * (o = 1 / o), t[1] = -e * o, t[2] = -h * o, t[3] = i * o, 
        t[4] = (h * s - r * n) * o, t[5] = (e * n - i * s) * o, t) : null;
    }, pt = function(t) {
        return t[0] * t[3] - t[1] * t[2];
    }, i = function(t, s, i) {
        var e = s[0], h = s[1], r = s[2], n = s[3], o = s[4], s = s[5], a = i[0], l = i[1], u = i[2], c = i[3], f = i[4], i = i[5];
        return t[0] = e * a + r * l, t[1] = h * a + n * l, t[2] = e * u + r * c, 
        t[3] = h * u + n * c, t[4] = e * f + r * i + o, t[5] = h * f + n * i + s, 
        t;
    }, mt = function(t, s, i) {
        var e = s[0], h = s[1], r = s[2], n = s[3], o = s[4], s = s[5], a = Math.sin(i), i = Math.cos(i);
        return t[0] = e * i + r * a, t[1] = h * i + n * a, t[2] = e * -a + r * i, 
        t[3] = h * -a + n * i, t[4] = o, t[5] = s, t;
    }, gt = function(t, s, i) {
        var e = s[0], h = s[1], r = s[2], n = s[3], o = s[4], s = s[5], a = i[0], i = i[1];
        return t[0] = e * a, t[1] = h * a, t[2] = r * i, t[3] = n * i, t[4] = o, 
        t[5] = s, t;
    }, yt = function(t, s, i) {
        var e = s[0], h = s[1], r = s[2], n = s[3], o = s[4], s = s[5], a = i[0], i = i[1];
        return t[0] = e, t[1] = h, t[2] = r, t[3] = n, t[4] = e * a + r * i + o, 
        t[5] = h * a + n * i + s, t;
    }, wt = function(t, s) {
        var i = Math.sin(s), s = Math.cos(s);
        return t[0] = s, t[1] = i, t[2] = -i, t[3] = s, t[4] = 0, t[5] = 0, t;
    }, St = function(t, s) {
        return t[0] = s[0], t[1] = 0, t[2] = 0, t[3] = s[1], t[4] = 0, t[5] = 0, 
        t;
    }, bt = function(t, s) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = s[0], t[5] = s[1], 
        t;
    }, Mt = function(t) {
        return "mat2d(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ")";
    }, vt = function(t) {
        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], 1);
    }, xt = function(t, s, i) {
        return t[0] = s[0] + i[0], t[1] = s[1] + i[1], t[2] = s[2] + i[2], t[3] = s[3] + i[3], 
        t[4] = s[4] + i[4], t[5] = s[5] + i[5], t;
    }, e = function(t, s, i) {
        return t[0] = s[0] - i[0], t[1] = s[1] - i[1], t[2] = s[2] - i[2], t[3] = s[3] - i[3], 
        t[4] = s[4] - i[4], t[5] = s[5] - i[5], t;
    }, Gt = function(t, s, i) {
        return t[0] = s[0] * i, t[1] = s[1] * i, t[2] = s[2] * i, t[3] = s[3] * i, 
        t[4] = s[4] * i, t[5] = s[5] * i, t;
    }, Tt = function(t, s, i, e) {
        return t[0] = s[0] + i[0] * e, t[1] = s[1] + i[1] * e, t[2] = s[2] + i[2] * e, 
        t[3] = s[3] + i[3] * e, t[4] = s[4] + i[4] * e, t[5] = s[5] + i[5] * e, 
        t;
    }, _t = function(t, s) {
        return t[0] === s[0] && t[1] === s[1] && t[2] === s[2] && t[3] === s[3] && t[4] === s[4] && t[5] === s[5];
    }, It = function(t, s) {
        var i = t[0], e = t[1], h = t[2], r = t[3], n = t[4], t = t[5], o = s[0], a = s[1], l = s[2], u = s[3], c = s[4], s = s[5];
        return Math.abs(i - o) <= Mh * Math.max(1, Math.abs(i), Math.abs(o)) && Math.abs(e - a) <= Mh * Math.max(1, Math.abs(e), Math.abs(a)) && Math.abs(h - l) <= Mh * Math.max(1, Math.abs(h), Math.abs(l)) && Math.abs(r - u) <= Mh * Math.max(1, Math.abs(r), Math.abs(u)) && Math.abs(n - c) <= Mh * Math.max(1, Math.abs(n), Math.abs(c)) && Math.abs(t - s) <= Mh * Math.max(1, Math.abs(t), Math.abs(s));
    }, h = function() {
        var t = new vh(9);
        return vh != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, 
        t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;
    }, Ct = function(t, s) {
        return t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[4], t[4] = s[5], 
        t[5] = s[6], t[6] = s[8], t[7] = s[9], t[8] = s[10], t;
    }, Rt = function(t) {
        var s = new vh(9);
        return s[0] = t[0], s[1] = t[1], s[2] = t[2], s[3] = t[3], s[4] = t[4], 
        s[5] = t[5], s[6] = t[6], s[7] = t[7], s[8] = t[8], s;
    }, Pt = function(t, s) {
        return t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[3], t[4] = s[4], 
        t[5] = s[5], t[6] = s[6], t[7] = s[7], t[8] = s[8], t;
    }, Et = function(t, s, i, e, h, r, n, o, a) {
        var l = new vh(9);
        return l[0] = t, l[1] = s, l[2] = i, l[3] = e, l[4] = h, l[5] = r, l[6] = n, 
        l[7] = o, l[8] = a, l;
    }, At = function(t, s, i, e, h, r, n, o, a, l) {
        return t[0] = s, t[1] = i, t[2] = e, t[3] = h, t[4] = r, t[5] = n, t[6] = o, 
        t[7] = a, t[8] = l, t;
    }, Ft = function(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, 
        t[7] = 0, t[8] = 1, t;
    }, Ot = function(t, s) {
        var i, e, h;
        return t === s ? (i = s[1], e = s[2], h = s[5], t[1] = s[3], t[2] = s[6], 
        t[3] = i, t[5] = s[7], t[6] = e, t[7] = h) : (t[0] = s[0], t[1] = s[3], 
        t[2] = s[6], t[3] = s[1], t[4] = s[4], t[5] = s[7], t[6] = s[2], t[7] = s[5], 
        t[8] = s[8]), t;
    }, Dt = function(t, s) {
        var i = s[0], e = s[1], h = s[2], r = s[3], n = s[4], o = s[5], a = s[6], l = s[7], s = s[8], u = s * n - o * l, c = -s * r + o * a, f = l * r - n * a, d = i * u + e * c + h * f;
        return d ? (t[0] = u * (d = 1 / d), t[1] = (-s * e + h * l) * d, t[2] = (o * e - h * n) * d, 
        t[3] = c * d, t[4] = (s * i - h * a) * d, t[5] = (-o * i + h * r) * d, t[6] = f * d, 
        t[7] = (-l * i + e * a) * d, t[8] = (n * i - e * r) * d, t) : null;
    }, kt = function(t, s) {
        var i = s[0], e = s[1], h = s[2], r = s[3], n = s[4], o = s[5], a = s[6], l = s[7], s = s[8];
        return t[0] = n * s - o * l, t[1] = h * l - e * s, t[2] = e * o - h * n, 
        t[3] = o * a - r * s, t[4] = i * s - h * a, t[5] = h * r - i * o, t[6] = r * l - n * a, 
        t[7] = e * a - i * l, t[8] = i * n - e * r, t;
    }, Lt = function(t) {
        var s = t[0], i = t[3], e = t[4], h = t[5], r = t[6], n = t[7], o = t[8];
        return s * (o * e - h * n) + t[1] * (-o * i + h * r) + t[2] * (n * i - e * r);
    }, r = function(t, s, i) {
        var e = s[0], h = s[1], r = s[2], n = s[3], o = s[4], a = s[5], l = s[6], u = s[7], s = s[8], c = i[0], f = i[1], d = i[2], p = i[3], m = i[4], g = i[5], y = i[6], w = i[7], i = i[8];
        return t[0] = c * e + f * n + d * l, t[1] = c * h + f * o + d * u, t[2] = c * r + f * a + d * s, 
        t[3] = p * e + m * n + g * l, t[4] = p * h + m * o + g * u, t[5] = p * r + m * a + g * s, 
        t[6] = y * e + w * n + i * l, t[7] = y * h + w * o + i * u, t[8] = y * r + w * a + i * s, 
        t;
    }, Bt = function(t, s, i) {
        var e = s[0], h = s[1], r = s[2], n = s[3], o = s[4], a = s[5], l = s[6], u = s[7], s = s[8], c = i[0], i = i[1];
        return t[0] = e, t[1] = h, t[2] = r, t[3] = n, t[4] = o, t[5] = a, t[6] = c * e + i * n + l, 
        t[7] = c * h + i * o + u, t[8] = c * r + i * a + s, t;
    }, Nt = function(t, s, i) {
        var e = s[0], h = s[1], r = s[2], n = s[3], o = s[4], a = s[5], l = s[6], u = s[7], s = s[8], c = Math.sin(i), i = Math.cos(i);
        return t[0] = i * e + c * n, t[1] = i * h + c * o, t[2] = i * r + c * a, 
        t[3] = i * n - c * e, t[4] = i * o - c * h, t[5] = i * a - c * r, t[6] = l, 
        t[7] = u, t[8] = s, t;
    }, Wt = function(t, s, i) {
        var e = i[0], i = i[1];
        return t[0] = e * s[0], t[1] = e * s[1], t[2] = e * s[2], t[3] = i * s[3], 
        t[4] = i * s[4], t[5] = i * s[5], t[6] = s[6], t[7] = s[7], t[8] = s[8], 
        t;
    }, jt = function(t, s) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = s[0], 
        t[7] = s[1], t[8] = 1, t;
    }, Vt = function(t, s) {
        var i = Math.sin(s), s = Math.cos(s);
        return t[0] = s, t[1] = i, t[2] = 0, t[3] = -i, t[4] = s, t[5] = 0, t[6] = 0, 
        t[7] = 0, t[8] = 1, t;
    }, Ut = function(t, s) {
        return t[0] = s[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = s[1], t[5] = 0, 
        t[6] = 0, t[7] = 0, t[8] = 1, t;
    }, Ht = function(t, s) {
        return t[0] = s[0], t[1] = s[1], t[2] = 0, t[3] = s[2], t[4] = s[3], t[5] = 0, 
        t[6] = s[4], t[7] = s[5], t[8] = 1, t;
    }, zt = function(t, s) {
        var i = s[0], e = s[1], h = s[2], s = s[3], r = i + i, n = e + e, o = h + h, i = i * r, a = e * r, e = e * n, l = h * r, u = h * n, h = h * o, r = s * r, n = s * n, s = s * o;
        return t[0] = 1 - e - h, t[3] = a - s, t[6] = l + n, t[1] = a + s, t[4] = 1 - i - h, 
        t[7] = u - r, t[2] = l - n, t[5] = u + r, t[8] = 1 - i - e, t;
    }, Jt = function(t, s) {
        var i = s[0], e = s[1], h = s[2], r = s[3], n = s[4], o = s[5], a = s[6], l = s[7], u = s[8], c = s[9], f = s[10], d = s[11], p = s[12], m = s[13], g = s[14], s = s[15], y = i * o - e * n, w = i * a - h * n, S = i * l - r * n, b = e * a - h * o, M = e * l - r * o, v = h * l - r * a, x = u * m - c * p, G = u * g - f * p, u = u * s - d * p, T = c * g - f * m, c = c * s - d * m, f = f * s - d * g, d = y * f - w * c + S * T + b * u - M * G + v * x;
        return d ? (t[0] = (o * f - a * c + l * T) * (d = 1 / d), t[1] = (a * u - n * f - l * G) * d, 
        t[2] = (n * c - o * u + l * x) * d, t[3] = (h * c - e * f - r * T) * d, 
        t[4] = (i * f - h * u + r * G) * d, t[5] = (e * u - i * c - r * x) * d, 
        t[6] = (m * v - g * M + s * b) * d, t[7] = (g * S - p * v - s * w) * d, 
        t[8] = (p * M - m * S + s * y) * d, t) : null;
    }, qt = function(t, s, i) {
        return t[0] = 2 / s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = -2 / i, t[5] = 0, 
        t[6] = -1, t[7] = 1, t[8] = 1, t;
    }, Xt = function(t) {
        return "mat3(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ")";
    }, Yt = function(t) {
        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);
    }, $t = function(t, s, i) {
        return t[0] = s[0] + i[0], t[1] = s[1] + i[1], t[2] = s[2] + i[2], t[3] = s[3] + i[3], 
        t[4] = s[4] + i[4], t[5] = s[5] + i[5], t[6] = s[6] + i[6], t[7] = s[7] + i[7], 
        t[8] = s[8] + i[8], t;
    }, n = function(t, s, i) {
        return t[0] = s[0] - i[0], t[1] = s[1] - i[1], t[2] = s[2] - i[2], t[3] = s[3] - i[3], 
        t[4] = s[4] - i[4], t[5] = s[5] - i[5], t[6] = s[6] - i[6], t[7] = s[7] - i[7], 
        t[8] = s[8] - i[8], t;
    }, Kt = function(t, s, i) {
        return t[0] = s[0] * i, t[1] = s[1] * i, t[2] = s[2] * i, t[3] = s[3] * i, 
        t[4] = s[4] * i, t[5] = s[5] * i, t[6] = s[6] * i, t[7] = s[7] * i, t[8] = s[8] * i, 
        t;
    }, Zt = function(t, s, i, e) {
        return t[0] = s[0] + i[0] * e, t[1] = s[1] + i[1] * e, t[2] = s[2] + i[2] * e, 
        t[3] = s[3] + i[3] * e, t[4] = s[4] + i[4] * e, t[5] = s[5] + i[5] * e, 
        t[6] = s[6] + i[6] * e, t[7] = s[7] + i[7] * e, t[8] = s[8] + i[8] * e, 
        t;
    }, Qt = function(t, s) {
        return t[0] === s[0] && t[1] === s[1] && t[2] === s[2] && t[3] === s[3] && t[4] === s[4] && t[5] === s[5] && t[6] === s[6] && t[7] === s[7] && t[8] === s[8];
    }, ts = function(t, s) {
        var i = t[0], e = t[1], h = t[2], r = t[3], n = t[4], o = t[5], a = t[6], l = t[7], t = t[8], u = s[0], c = s[1], f = s[2], d = s[3], p = s[4], m = s[5], g = s[6], y = s[7], s = s[8];
        return Math.abs(i - u) <= Mh * Math.max(1, Math.abs(i), Math.abs(u)) && Math.abs(e - c) <= Mh * Math.max(1, Math.abs(e), Math.abs(c)) && Math.abs(h - f) <= Mh * Math.max(1, Math.abs(h), Math.abs(f)) && Math.abs(r - d) <= Mh * Math.max(1, Math.abs(r), Math.abs(d)) && Math.abs(n - p) <= Mh * Math.max(1, Math.abs(n), Math.abs(p)) && Math.abs(o - m) <= Mh * Math.max(1, Math.abs(o), Math.abs(m)) && Math.abs(a - g) <= Mh * Math.max(1, Math.abs(a), Math.abs(g)) && Math.abs(l - y) <= Mh * Math.max(1, Math.abs(l), Math.abs(y)) && Math.abs(t - s) <= Mh * Math.max(1, Math.abs(t), Math.abs(s));
    }, ss = function() {
        var t = new vh(16);
        return vh != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, 
        t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), 
        t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;
    }, is = function(t) {
        var s = new vh(16);
        return s[0] = t[0], s[1] = t[1], s[2] = t[2], s[3] = t[3], s[4] = t[4], 
        s[5] = t[5], s[6] = t[6], s[7] = t[7], s[8] = t[8], s[9] = t[9], s[10] = t[10], 
        s[11] = t[11], s[12] = t[12], s[13] = t[13], s[14] = t[14], s[15] = t[15], 
        s;
    }, es = function(t, s) {
        return t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[3], t[4] = s[4], 
        t[5] = s[5], t[6] = s[6], t[7] = s[7], t[8] = s[8], t[9] = s[9], t[10] = s[10], 
        t[11] = s[11], t[12] = s[12], t[13] = s[13], t[14] = s[14], t[15] = s[15], 
        t;
    }, hs = function(t, s, i, e, h, r, n, o, a, l, u, c, f, d, p, m) {
        var g = new vh(16);
        return g[0] = t, g[1] = s, g[2] = i, g[3] = e, g[4] = h, g[5] = r, g[6] = n, 
        g[7] = o, g[8] = a, g[9] = l, g[10] = u, g[11] = c, g[12] = f, g[13] = d, 
        g[14] = p, g[15] = m, g;
    }, rs = function(t, s, i, e, h, r, n, o, a, l, u, c, f, d, p, m, g) {
        return t[0] = s, t[1] = i, t[2] = e, t[3] = h, t[4] = r, t[5] = n, t[6] = o, 
        t[7] = a, t[8] = l, t[9] = u, t[10] = c, t[11] = f, t[12] = d, t[13] = p, 
        t[14] = m, t[15] = g, t;
    }, p = function(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, 
        t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, 
        t[14] = 0, t[15] = 1, t;
    }, ns = function(t, s) {
        var i, e, h, r, n, o;
        return t === s ? (i = s[1], e = s[2], h = s[3], r = s[6], n = s[7], o = s[11], 
        t[1] = s[4], t[2] = s[8], t[3] = s[12], t[4] = i, t[6] = s[9], t[7] = s[13], 
        t[8] = e, t[9] = r, t[11] = s[14], t[12] = h, t[13] = n, t[14] = o) : (t[0] = s[0], 
        t[1] = s[4], t[2] = s[8], t[3] = s[12], t[4] = s[1], t[5] = s[5], t[6] = s[9], 
        t[7] = s[13], t[8] = s[2], t[9] = s[6], t[10] = s[10], t[11] = s[14], t[12] = s[3], 
        t[13] = s[7], t[14] = s[11], t[15] = s[15]), t;
    }, os = function(t, s) {
        var i = s[0], e = s[1], h = s[2], r = s[3], n = s[4], o = s[5], a = s[6], l = s[7], u = s[8], c = s[9], f = s[10], d = s[11], p = s[12], m = s[13], g = s[14], s = s[15], y = i * o - e * n, w = i * a - h * n, S = i * l - r * n, b = e * a - h * o, M = e * l - r * o, v = h * l - r * a, x = u * m - c * p, G = u * g - f * p, T = u * s - d * p, _ = c * g - f * m, I = c * s - d * m, C = f * s - d * g, R = y * C - w * I + S * _ + b * T - M * G + v * x;
        return R ? (t[0] = (o * C - a * I + l * _) * (R = 1 / R), t[1] = (h * I - e * C - r * _) * R, 
        t[2] = (m * v - g * M + s * b) * R, t[3] = (f * M - c * v - d * b) * R, 
        t[4] = (a * T - n * C - l * G) * R, t[5] = (i * C - h * T + r * G) * R, 
        t[6] = (g * S - p * v - s * w) * R, t[7] = (u * v - f * S + d * w) * R, 
        t[8] = (n * I - o * T + l * x) * R, t[9] = (e * T - i * I - r * x) * R, 
        t[10] = (p * M - m * S + s * y) * R, t[11] = (c * S - u * M - d * y) * R, 
        t[12] = (o * G - n * _ - a * x) * R, t[13] = (i * _ - e * G + h * x) * R, 
        t[14] = (m * w - p * b - g * y) * R, t[15] = (u * b - c * w + f * y) * R, 
        t) : null;
    }, as = function(t, s) {
        var i = s[0], e = s[1], h = s[2], r = s[3], n = s[4], o = s[5], a = s[6], l = s[7], u = s[8], c = s[9], f = s[10], d = s[11], p = s[12], m = s[13], g = s[14], s = s[15], y = i * o - e * n, w = i * a - h * n, S = i * l - r * n, b = e * a - h * o, M = e * l - r * o, v = h * l - r * a, x = u * m - c * p, G = u * g - f * p, T = u * s - d * p, _ = c * g - f * m, I = c * s - d * m, C = f * s - d * g;
        return t[0] = o * C - a * I + l * _, t[1] = h * I - e * C - r * _, t[2] = m * v - g * M + s * b, 
        t[3] = f * M - c * v - d * b, t[4] = a * T - n * C - l * G, t[5] = i * C - h * T + r * G, 
        t[6] = g * S - p * v - s * w, t[7] = u * v - f * S + d * w, t[8] = n * I - o * T + l * x, 
        t[9] = e * T - i * I - r * x, t[10] = p * M - m * S + s * y, t[11] = c * S - u * M - d * y, 
        t[12] = o * G - n * _ - a * x, t[13] = i * _ - e * G + h * x, t[14] = m * w - p * b - g * y, 
        t[15] = u * b - c * w + f * y, t;
    }, ls = function(t) {
        var s = t[0], i = t[1], e = t[2], h = t[4], r = t[5], n = t[6], o = t[8], a = t[9], l = t[10], u = t[12], c = t[13], f = t[14], d = s * r - i * h, p = s * n - e * h, m = i * n - e * r, g = o * c - a * u, y = o * f - l * u, w = a * f - l * c;
        return t[7] * (s * w - i * y + e * g) - t[3] * (h * w - r * y + n * g) + t[15] * (o * m - a * p + l * d) - t[11] * (u * m - c * p + f * d);
    }, o = function(t, s, i) {
        var e = s[0], h = s[1], r = s[2], n = s[3], o = s[4], a = s[5], l = s[6], u = s[7], c = s[8], f = s[9], d = s[10], p = s[11], m = s[12], g = s[13], y = s[14], s = s[15], w = i[0], S = i[1], b = i[2], M = i[3];
        return t[0] = w * e + S * o + b * c + M * m, t[1] = w * h + S * a + b * f + M * g, 
        t[2] = w * r + S * l + b * d + M * y, t[3] = w * n + S * u + b * p + M * s, 
        t[4] = (w = i[4]) * e + (S = i[5]) * o + (b = i[6]) * c + (M = i[7]) * m, 
        t[5] = w * h + S * a + b * f + M * g, t[6] = w * r + S * l + b * d + M * y, 
        t[7] = w * n + S * u + b * p + M * s, t[8] = (w = i[8]) * e + (S = i[9]) * o + (b = i[10]) * c + (M = i[11]) * m, 
        t[9] = w * h + S * a + b * f + M * g, t[10] = w * r + S * l + b * d + M * y, 
        t[11] = w * n + S * u + b * p + M * s, t[12] = (w = i[12]) * e + (S = i[13]) * o + (b = i[14]) * c + (M = i[15]) * m, 
        t[13] = w * h + S * a + b * f + M * g, t[14] = w * r + S * l + b * d + M * y, 
        t[15] = w * n + S * u + b * p + M * s, t;
    }, us = function(t, s, i) {
        var e, h, r, n, o, a, l, u, c, f, d, p, m = i[0], g = i[1], i = i[2];
        return s === t ? (t[12] = s[0] * m + s[4] * g + s[8] * i + s[12], t[13] = s[1] * m + s[5] * g + s[9] * i + s[13], 
        t[14] = s[2] * m + s[6] * g + s[10] * i + s[14], t[15] = s[3] * m + s[7] * g + s[11] * i + s[15]) : (e = s[0], 
        h = s[1], r = s[2], n = s[3], o = s[4], a = s[5], l = s[6], u = s[7], c = s[8], 
        f = s[9], d = s[10], p = s[11], t[0] = e, t[1] = h, t[2] = r, t[3] = n, 
        t[4] = o, t[5] = a, t[6] = l, t[7] = u, t[8] = c, t[9] = f, t[10] = d, t[11] = p, 
        t[12] = e * m + o * g + c * i + s[12], t[13] = h * m + a * g + f * i + s[13], 
        t[14] = r * m + l * g + d * i + s[14], t[15] = n * m + u * g + p * i + s[15]), 
        t;
    }, cs = function(t, s, i) {
        var e = i[0], h = i[1], i = i[2];
        return t[0] = s[0] * e, t[1] = s[1] * e, t[2] = s[2] * e, t[3] = s[3] * e, 
        t[4] = s[4] * h, t[5] = s[5] * h, t[6] = s[6] * h, t[7] = s[7] * h, t[8] = s[8] * i, 
        t[9] = s[9] * i, t[10] = s[10] * i, t[11] = s[11] * i, t[12] = s[12], t[13] = s[13], 
        t[14] = s[14], t[15] = s[15], t;
    }, fs = function(t, s, i, e) {
        var h, r, n, o, a, l, u, c, f, d, p, m, g, y, w, S, b, M, v, x, G = e[0], T = e[1], e = e[2], _ = Math.hypot(G, T, e);
        return _ < Mh ? null : (G *= _ = 1 / _, T *= _, e *= _, _ = Math.sin(i), 
        i = Math.cos(i), r = s[0], n = s[1], o = s[2], a = s[3], u = s[5], c = s[6], 
        f = s[7], p = s[9], m = s[10], g = s[11], w = G * T * (h = 1 - i) - e * _, 
        S = T * T * h + i, b = e * T * h + G * _, M = G * e * h + T * _, v = T * e * h - G * _, 
        x = e * e * h + i, t[0] = r * (i = G * G * h + i) + (l = s[4]) * (y = T * G * h + e * _) + (d = s[8]) * (e = e * G * h - T * _), 
        t[1] = n * i + u * y + p * e, t[2] = o * i + c * y + m * e, t[3] = a * i + f * y + g * e, 
        t[4] = r * w + l * S + d * b, t[5] = n * w + u * S + p * b, t[6] = o * w + c * S + m * b, 
        t[7] = a * w + f * S + g * b, t[8] = r * M + l * v + d * x, t[9] = n * M + u * v + p * x, 
        t[10] = o * M + c * v + m * x, t[11] = a * M + f * v + g * x, s !== t && (t[12] = s[12], 
        t[13] = s[13], t[14] = s[14], t[15] = s[15]), t);
    }, ds = function(t, s, i) {
        var e = Math.sin(i), i = Math.cos(i), h = s[4], r = s[5], n = s[6], o = s[7], a = s[8], l = s[9], u = s[10], c = s[11];
        return s !== t && (t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[3], t[12] = s[12], 
        t[13] = s[13], t[14] = s[14], t[15] = s[15]), t[4] = h * i + a * e, t[5] = r * i + l * e, 
        t[6] = n * i + u * e, t[7] = o * i + c * e, t[8] = a * i - h * e, t[9] = l * i - r * e, 
        t[10] = u * i - n * e, t[11] = c * i - o * e, t;
    }, ps = function(t, s, i) {
        var e = Math.sin(i), i = Math.cos(i), h = s[0], r = s[1], n = s[2], o = s[3], a = s[8], l = s[9], u = s[10], c = s[11];
        return s !== t && (t[4] = s[4], t[5] = s[5], t[6] = s[6], t[7] = s[7], t[12] = s[12], 
        t[13] = s[13], t[14] = s[14], t[15] = s[15]), t[0] = h * i - a * e, t[1] = r * i - l * e, 
        t[2] = n * i - u * e, t[3] = o * i - c * e, t[8] = h * e + a * i, t[9] = r * e + l * i, 
        t[10] = n * e + u * i, t[11] = o * e + c * i, t;
    }, ms = function(t, s, i) {
        var e = Math.sin(i), i = Math.cos(i), h = s[0], r = s[1], n = s[2], o = s[3], a = s[4], l = s[5], u = s[6], c = s[7];
        return s !== t && (t[8] = s[8], t[9] = s[9], t[10] = s[10], t[11] = s[11], 
        t[12] = s[12], t[13] = s[13], t[14] = s[14], t[15] = s[15]), t[0] = h * i + a * e, 
        t[1] = r * i + l * e, t[2] = n * i + u * e, t[3] = o * i + c * e, t[4] = a * i - h * e, 
        t[5] = l * i - r * e, t[6] = u * i - n * e, t[7] = c * i - o * e, t;
    }, gs = function(t, s) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, 
        t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = s[0], t[13] = s[1], 
        t[14] = s[2], t[15] = 1, t;
    }, ys = function(t, s) {
        return t[0] = s[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = s[1], 
        t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = s[2], t[11] = 0, t[12] = 0, 
        t[13] = 0, t[14] = 0, t[15] = 1, t;
    }, ws = function(t, s, i) {
        var e, h = i[0], r = i[1], i = i[2], n = Math.hypot(h, r, i);
        return n < Mh ? null : (h *= n = 1 / n, r *= n, i *= n, n = Math.sin(s), 
        s = Math.cos(s), t[0] = h * h * (e = 1 - s) + s, t[1] = r * h * e + i * n, 
        t[2] = i * h * e - r * n, t[3] = 0, t[4] = h * r * e - i * n, t[5] = r * r * e + s, 
        t[6] = i * r * e + h * n, t[7] = 0, t[8] = h * i * e + r * n, t[9] = r * i * e - h * n, 
        t[10] = i * i * e + s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, 
        t);
    }, Ss = function(t, s) {
        var i = Math.sin(s), s = Math.cos(s);
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = s, t[6] = i, 
        t[7] = 0, t[8] = 0, t[9] = -i, t[10] = s, t[11] = 0, t[12] = 0, t[13] = 0, 
        t[14] = 0, t[15] = 1, t;
    }, bs = function(t, s) {
        var i = Math.sin(s), s = Math.cos(s);
        return t[0] = s, t[1] = 0, t[2] = -i, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, 
        t[7] = 0, t[8] = i, t[9] = 0, t[10] = s, t[11] = 0, t[12] = 0, t[13] = 0, 
        t[14] = 0, t[15] = 1, t;
    }, Ms = function(t, s) {
        var i = Math.sin(s), s = Math.cos(s);
        return t[0] = s, t[1] = i, t[2] = 0, t[3] = 0, t[4] = -i, t[5] = s, t[6] = 0, 
        t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, 
        t[14] = 0, t[15] = 1, t;
    }, f = function(t, s, i) {
        var e = s[0], h = s[1], r = s[2], s = s[3], n = e + e, o = h + h, a = r + r, l = e * n, u = e * o, e = e * a, c = h * o, h = h * a, r = r * a, n = s * n, o = s * o, s = s * a;
        return t[0] = 1 - (c + r), t[1] = u + s, t[2] = e - o, t[3] = 0, t[4] = u - s, 
        t[5] = 1 - (l + r), t[6] = h + n, t[7] = 0, t[8] = e + o, t[9] = h - n, 
        t[10] = 1 - (l + c), t[11] = 0, t[12] = i[0], t[13] = i[1], t[14] = i[2], 
        t[15] = 1, t;
    }, vs = function(t, s) {
        var i = new vh(3), e = -s[0], h = -s[1], r = -s[2], n = s[3], o = s[4], a = s[5], l = s[6], u = s[7], c = e * e + h * h + r * r + n * n;
        return 0 < c ? (i[0] = 2 * (o * n + u * e + a * r - l * h) / c, i[1] = 2 * (a * n + u * h + l * e - o * r) / c, 
        i[2] = 2 * (l * n + u * r + o * h - a * e) / c) : (i[0] = 2 * (o * n + u * e + a * r - l * h), 
        i[1] = 2 * (a * n + u * h + l * e - o * r), i[2] = 2 * (l * n + u * r + o * h - a * e)), 
        f(t, s, i), t;
    }, a = function(t, s) {
        return t[0] = s[12], t[1] = s[13], t[2] = s[14], t;
    }, d = function(t, s) {
        var i = s[0], e = s[4], h = s[5], r = s[6], n = s[8], o = s[9], a = s[10];
        return t[0] = Math.hypot(i, s[1], s[2]), t[1] = Math.hypot(e, h, r), t[2] = Math.hypot(n, o, a), 
        t;
    }, l = function(t, s) {
        var i = new vh(3), e = (d(i, s), 1 / i[0]), h = 1 / i[1], i = 1 / i[2], r = s[0] * e, n = s[1] * h, o = s[2] * i, a = s[4] * e, l = s[5] * h, u = s[6] * i, e = s[8] * e, h = s[9] * h, s = s[10] * i, i = r + l + s, c = 0;
        return 0 < i ? (c = 2 * Math.sqrt(1 + i), t[3] = .25 * c, t[0] = (u - h) / c, 
        t[1] = (e - o) / c, t[2] = (n - a) / c) : l < r && s < r ? (c = 2 * Math.sqrt(1 + r - l - s), 
        t[3] = (u - h) / c, t[0] = .25 * c, t[1] = (n + a) / c, t[2] = (e + o) / c) : s < l ? (c = 2 * Math.sqrt(1 + l - r - s), 
        t[3] = (e - o) / c, t[0] = (n + a) / c, t[1] = .25 * c, t[2] = (u + h) / c) : (c = 2 * Math.sqrt(1 + s - r - l), 
        t[3] = (n - a) / c, t[0] = (e + o) / c, t[1] = (u + h) / c, t[2] = .25 * c), 
        t;
    }, xs = function(t, s, i, e) {
        s[0] = e[12], s[1] = e[13], s[2] = e[14];
        var s = e[0], h = e[1], r = e[2], n = e[4], o = e[5], a = e[6], l = e[8], u = e[9], e = e[10], c = (i[0] = Math.hypot(s, h, r), 
        i[1] = Math.hypot(n, o, a), i[2] = Math.hypot(l, u, e), 1 / i[0]), f = 1 / i[1], i = 1 / i[2], s = s * c, h = h * f, r = r * i, n = n * c, o = o * f, a = a * i, l = l * c, c = u * f, u = e * i, f = s + o + u, e = 0;
        return 0 < f ? (e = 2 * Math.sqrt(1 + f), t[3] = .25 * e, t[0] = (a - c) / e, 
        t[1] = (l - r) / e, t[2] = (h - n) / e) : o < s && u < s ? (e = 2 * Math.sqrt(1 + s - o - u), 
        t[3] = (a - c) / e, t[0] = .25 * e, t[1] = (h + n) / e, t[2] = (l + r) / e) : u < o ? (e = 2 * Math.sqrt(1 + o - s - u), 
        t[3] = (l - r) / e, t[0] = (h + n) / e, t[1] = .25 * e, t[2] = (a + c) / e) : (e = 2 * Math.sqrt(1 + u - s - o), 
        t[3] = (h - n) / e, t[0] = (l + r) / e, t[1] = (a + c) / e, t[2] = .25 * e), 
        t;
    }, Gs = function(t, s, i, e) {
        var h = s[0], r = s[1], n = s[2], s = s[3], o = h + h, a = r + r, l = n + n, u = h * o, c = h * a, h = h * l, f = r * a, r = r * l, n = n * l, o = s * o, a = s * a, s = s * l, l = e[0], d = e[1], e = e[2];
        return t[0] = (1 - (f + n)) * l, t[1] = (c + s) * l, t[2] = (h - a) * l, 
        t[3] = 0, t[4] = (c - s) * d, t[5] = (1 - (u + n)) * d, t[6] = (r + o) * d, 
        t[7] = 0, t[8] = (h + a) * e, t[9] = (r - o) * e, t[10] = (1 - (u + f)) * e, 
        t[11] = 0, t[12] = i[0], t[13] = i[1], t[14] = i[2], t[15] = 1, t;
    }, Ts = function(t, s, i, e, h) {
        var r = s[0], n = s[1], o = s[2], s = s[3], a = r + r, l = n + n, u = o + o, c = r * a, f = r * l, r = r * u, d = n * l, n = n * u, o = o * u, a = s * a, l = s * l, s = s * u, u = e[0], p = e[1], e = e[2], m = h[0], g = h[1], h = h[2], y = (1 - (d + o)) * u, w = (f + s) * u, u = (r - l) * u, f = (f - s) * p, s = (1 - (c + o)) * p, o = (n + a) * p, p = (r + l) * e, r = (n - a) * e, l = (1 - (c + d)) * e;
        return t[0] = y, t[1] = w, t[2] = u, t[3] = 0, t[4] = f, t[5] = s, t[6] = o, 
        t[7] = 0, t[8] = p, t[9] = r, t[10] = l, t[11] = 0, t[12] = i[0] + m - (y * m + f * g + p * h), 
        t[13] = i[1] + g - (w * m + s * g + r * h), t[14] = i[2] + h - (u * m + o * g + l * h), 
        t[15] = 1, t;
    }, _s = function(t, s) {
        var i = s[0], e = s[1], h = s[2], s = s[3], r = i + i, n = e + e, o = h + h, i = i * r, a = e * r, e = e * n, l = h * r, u = h * n, h = h * o, r = s * r, n = s * n, s = s * o;
        return t[0] = 1 - e - h, t[1] = a + s, t[2] = l - n, t[3] = 0, t[4] = a - s, 
        t[5] = 1 - i - h, t[6] = u + r, t[7] = 0, t[8] = l + n, t[9] = u - r, t[10] = 1 - i - e, 
        t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
    }, Is = function(t, s, i, e, h, r, n) {
        var o = 1 / (i - s), a = 1 / (h - e), l = 1 / (r - n);
        return t[0] = 2 * r * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 2 * r * a, 
        t[6] = 0, t[7] = 0, t[8] = (i + s) * o, t[9] = (h + e) * a, t[10] = (n + r) * l, 
        t[11] = -1, t[12] = 0, t[13] = 0, t[14] = n * r * 2 * l, t[15] = 0, t;
    }, u = function(t, s, i, e, h) {
        s = 1 / Math.tan(s / 2);
        return t[0] = s / i, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = s, t[6] = 0, 
        t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, 
        null != h && h !== 1 / 0 ? (t[10] = (h + e) * (i = 1 / (e - h)), t[14] = 2 * h * e * i) : (t[10] = -1, 
        t[14] = -2 * e), t;
    }, Cs = function(t, s, i, e, h) {
        s = 1 / Math.tan(s / 2);
        return t[0] = s / i, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = s, t[6] = 0, 
        t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, 
        null != h && h !== 1 / 0 ? (t[10] = h * (i = 1 / (e - h)), t[14] = h * e * i) : (t[10] = -1, 
        t[14] = -e), t;
    }, Rs = function(t, s, i, e) {
        var h = Math.tan(s.upDegrees * Math.PI / 180), r = Math.tan(s.downDegrees * Math.PI / 180), n = Math.tan(s.leftDegrees * Math.PI / 180), s = Math.tan(s.rightDegrees * Math.PI / 180), o = 2 / (n + s), a = 2 / (h + r);
        return t[0] = o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, 
        t[7] = 0, t[8] = -(n - s) * o * .5, t[9] = (h - r) * a * .5, t[10] = e / (i - e), 
        t[11] = -1, t[12] = 0, t[13] = 0, t[14] = e * i / (i - e), t[15] = 0, t;
    }, c = function(t, s, i, e, h, r, n) {
        var o = 1 / (s - i), a = 1 / (e - h), l = 1 / (r - n);
        return t[0] = -2 * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * a, 
        t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * l, t[11] = 0, t[12] = (s + i) * o, 
        t[13] = (h + e) * a, t[14] = (n + r) * l, t[15] = 1, t;
    }, Ps = function(t, s, i, e, h, r, n) {
        var o = 1 / (s - i), a = 1 / (e - h), n = 1 / (r - n);
        return t[0] = -2 * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * a, 
        t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = n, t[11] = 0, t[12] = (s + i) * o, 
        t[13] = (h + e) * a, t[14] = r * n, t[15] = 1, t;
    }, Es = function(t, s, i, e) {
        var h, r, n, o, a = s[0], l = s[1], s = s[2], u = e[0], c = e[1], e = e[2], f = i[0], d = i[1], i = i[2];
        return Math.abs(a - f) < Mh && Math.abs(l - d) < Mh && Math.abs(s - i) < Mh ? p(t) : (f = a - f, 
        d = l - d, i = s - i, h = c * (i *= o = 1 / Math.hypot(f, d, i)) - e * (d *= o), 
        e = e * (f *= o) - u * i, u = u * d - c * f, (o = Math.hypot(h, e, u)) ? (h *= o = 1 / o, 
        e *= o, u *= o) : u = e = h = 0, c = d * u - i * e, r = i * h - f * u, n = f * e - d * h, 
        (o = Math.hypot(c, r, n)) ? (c *= o = 1 / o, r *= o, n *= o) : n = r = c = 0, 
        t[0] = h, t[1] = c, t[2] = f, t[3] = 0, t[4] = e, t[5] = r, t[6] = d, t[7] = 0, 
        t[8] = u, t[9] = n, t[10] = i, t[11] = 0, t[12] = -(h * a + e * l + u * s), 
        t[13] = -(c * a + r * l + n * s), t[14] = -(f * a + d * l + i * s), t[15] = 1, 
        t);
    }, As = function(t, s, i, e) {
        var h = s[0], r = s[1], s = s[2], n = e[0], o = e[1], e = e[2], a = h - i[0], l = r - i[1], i = s - i[2], u = a * a + l * l + i * i, c = (0 < u && (a *= u = 1 / Math.sqrt(u), 
        l *= u, i *= u), o * i - e * l), e = e * a - n * i, n = n * l - o * a;
        return 0 < (u = c * c + e * e + n * n) && (c *= u = 1 / Math.sqrt(u), e *= u, 
        n *= u), t[0] = c, t[1] = e, t[2] = n, t[3] = 0, t[4] = l * n - i * e, t[5] = i * c - a * n, 
        t[6] = a * e - l * c, t[7] = 0, t[8] = a, t[9] = l, t[10] = i, t[11] = 0, 
        t[12] = h, t[13] = r, t[14] = s, t[15] = 1, t;
    }, Fs = function(t) {
        return "mat4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ", " + t[9] + ", " + t[10] + ", " + t[11] + ", " + t[12] + ", " + t[13] + ", " + t[14] + ", " + t[15] + ")";
    }, Os = function(t) {
        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]);
    }, Ds = function(t, s, i) {
        return t[0] = s[0] + i[0], t[1] = s[1] + i[1], t[2] = s[2] + i[2], t[3] = s[3] + i[3], 
        t[4] = s[4] + i[4], t[5] = s[5] + i[5], t[6] = s[6] + i[6], t[7] = s[7] + i[7], 
        t[8] = s[8] + i[8], t[9] = s[9] + i[9], t[10] = s[10] + i[10], t[11] = s[11] + i[11], 
        t[12] = s[12] + i[12], t[13] = s[13] + i[13], t[14] = s[14] + i[14], t[15] = s[15] + i[15], 
        t;
    }, ks = function(t, s, i) {
        return t[0] = s[0] - i[0], t[1] = s[1] - i[1], t[2] = s[2] - i[2], t[3] = s[3] - i[3], 
        t[4] = s[4] - i[4], t[5] = s[5] - i[5], t[6] = s[6] - i[6], t[7] = s[7] - i[7], 
        t[8] = s[8] - i[8], t[9] = s[9] - i[9], t[10] = s[10] - i[10], t[11] = s[11] - i[11], 
        t[12] = s[12] - i[12], t[13] = s[13] - i[13], t[14] = s[14] - i[14], t[15] = s[15] - i[15], 
        t;
    }, Ls = function(t, s, i) {
        return t[0] = s[0] * i, t[1] = s[1] * i, t[2] = s[2] * i, t[3] = s[3] * i, 
        t[4] = s[4] * i, t[5] = s[5] * i, t[6] = s[6] * i, t[7] = s[7] * i, t[8] = s[8] * i, 
        t[9] = s[9] * i, t[10] = s[10] * i, t[11] = s[11] * i, t[12] = s[12] * i, 
        t[13] = s[13] * i, t[14] = s[14] * i, t[15] = s[15] * i, t;
    }, Bs = function(t, s, i, e) {
        return t[0] = s[0] + i[0] * e, t[1] = s[1] + i[1] * e, t[2] = s[2] + i[2] * e, 
        t[3] = s[3] + i[3] * e, t[4] = s[4] + i[4] * e, t[5] = s[5] + i[5] * e, 
        t[6] = s[6] + i[6] * e, t[7] = s[7] + i[7] * e, t[8] = s[8] + i[8] * e, 
        t[9] = s[9] + i[9] * e, t[10] = s[10] + i[10] * e, t[11] = s[11] + i[11] * e, 
        t[12] = s[12] + i[12] * e, t[13] = s[13] + i[13] * e, t[14] = s[14] + i[14] * e, 
        t[15] = s[15] + i[15] * e, t;
    }, Ns = function(t, s) {
        return t[0] === s[0] && t[1] === s[1] && t[2] === s[2] && t[3] === s[3] && t[4] === s[4] && t[5] === s[5] && t[6] === s[6] && t[7] === s[7] && t[8] === s[8] && t[9] === s[9] && t[10] === s[10] && t[11] === s[11] && t[12] === s[12] && t[13] === s[13] && t[14] === s[14] && t[15] === s[15];
    }, Ws = function(t, s) {
        var i = t[0], e = t[1], h = t[2], r = t[3], n = t[4], o = t[5], a = t[6], l = t[7], u = t[8], c = t[9], f = t[10], d = t[11], p = t[12], m = t[13], g = t[14], t = t[15], y = s[0], w = s[1], S = s[2], b = s[3], M = s[4], v = s[5], x = s[6], G = s[7], T = s[8], _ = s[9], I = s[10], C = s[11], R = s[12], P = s[13], E = s[14], s = s[15];
        return Math.abs(i - y) <= Mh * Math.max(1, Math.abs(i), Math.abs(y)) && Math.abs(e - w) <= Mh * Math.max(1, Math.abs(e), Math.abs(w)) && Math.abs(h - S) <= Mh * Math.max(1, Math.abs(h), Math.abs(S)) && Math.abs(r - b) <= Mh * Math.max(1, Math.abs(r), Math.abs(b)) && Math.abs(n - M) <= Mh * Math.max(1, Math.abs(n), Math.abs(M)) && Math.abs(o - v) <= Mh * Math.max(1, Math.abs(o), Math.abs(v)) && Math.abs(a - x) <= Mh * Math.max(1, Math.abs(a), Math.abs(x)) && Math.abs(l - G) <= Mh * Math.max(1, Math.abs(l), Math.abs(G)) && Math.abs(u - T) <= Mh * Math.max(1, Math.abs(u), Math.abs(T)) && Math.abs(c - _) <= Mh * Math.max(1, Math.abs(c), Math.abs(_)) && Math.abs(f - I) <= Mh * Math.max(1, Math.abs(f), Math.abs(I)) && Math.abs(d - C) <= Mh * Math.max(1, Math.abs(d), Math.abs(C)) && Math.abs(p - R) <= Mh * Math.max(1, Math.abs(p), Math.abs(R)) && Math.abs(m - P) <= Mh * Math.max(1, Math.abs(m), Math.abs(P)) && Math.abs(g - E) <= Mh * Math.max(1, Math.abs(g), Math.abs(E)) && Math.abs(t - s) <= Mh * Math.max(1, Math.abs(t), Math.abs(s));
    }, m = function() {
        var t = new vh(3);
        return vh != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;
    }, js = function(t) {
        var s = new vh(3);
        return s[0] = t[0], s[1] = t[1], s[2] = t[2], s;
    }, Vs = function(t) {
        var s = t[0];
        return Math.hypot(s, t[1], t[2]);
    }, g = function(t, s, i) {
        var e = new vh(3);
        return e[0] = t, e[1] = s, e[2] = i, e;
    }, Us = function(t, s) {
        return t[0] = s[0], t[1] = s[1], t[2] = s[2], t;
    }, Hs = function(t, s, i, e) {
        return t[0] = s, t[1] = i, t[2] = e, t;
    }, zs = function(t, s, i) {
        return t[0] = s[0] + i[0], t[1] = s[1] + i[1], t[2] = s[2] + i[2], t;
    }, Js = function(t, s, i) {
        return t[0] = s[0] - i[0], t[1] = s[1] - i[1], t[2] = s[2] - i[2], t;
    }, qs = function(t, s, i) {
        return t[0] = s[0] * i[0], t[1] = s[1] * i[1], t[2] = s[2] * i[2], t;
    }, Xs = function(t, s, i) {
        return t[0] = s[0] / i[0], t[1] = s[1] / i[1], t[2] = s[2] / i[2], t;
    }, Ys = function(t, s) {
        return t[0] = Math.ceil(s[0]), t[1] = Math.ceil(s[1]), t[2] = Math.ceil(s[2]), 
        t;
    }, $s = function(t, s) {
        return t[0] = Math.floor(s[0]), t[1] = Math.floor(s[1]), t[2] = Math.floor(s[2]), 
        t;
    }, Ks = function(t, s, i) {
        return t[0] = Math.min(s[0], i[0]), t[1] = Math.min(s[1], i[1]), t[2] = Math.min(s[2], i[2]), 
        t;
    }, Zs = function(t, s, i) {
        return t[0] = Math.max(s[0], i[0]), t[1] = Math.max(s[1], i[1]), t[2] = Math.max(s[2], i[2]), 
        t;
    }, Qs = function(t, s) {
        return t[0] = Math.round(s[0]), t[1] = Math.round(s[1]), t[2] = Math.round(s[2]), 
        t;
    }, ti = function(t, s, i) {
        return t[0] = s[0] * i, t[1] = s[1] * i, t[2] = s[2] * i, t;
    }, si = function(t, s, i, e) {
        return t[0] = s[0] + i[0] * e, t[1] = s[1] + i[1] * e, t[2] = s[2] + i[2] * e, 
        t;
    }, ii = function(t, s) {
        var i = s[0] - t[0];
        return Math.hypot(i, s[1] - t[1], s[2] - t[2]);
    }, ei = function(t, s) {
        var i = s[0] - t[0], e = s[1] - t[1], s = s[2] - t[2];
        return i * i + e * e + s * s;
    }, hi = function(t) {
        var s = t[0], i = t[1], t = t[2];
        return s * s + i * i + t * t;
    }, ri = function(t, s) {
        return t[0] = -s[0], t[1] = -s[1], t[2] = -s[2], t;
    }, ni = function(t, s) {
        return t[0] = 1 / s[0], t[1] = 1 / s[1], t[2] = 1 / s[2], t;
    }, y = function(t, s) {
        var i = s[0], e = s[1], h = s[2], i = i * i + e * e + h * h;
        return 0 < i && (i = 1 / Math.sqrt(i)), t[0] = s[0] * i, t[1] = s[1] * i, 
        t[2] = s[2] * i, t;
    }, w = function(t, s) {
        return t[0] * s[0] + t[1] * s[1] + t[2] * s[2];
    }, S = function(t, s, i) {
        var e = s[0], h = s[1], s = s[2], r = i[0], n = i[1], i = i[2];
        return t[0] = h * i - s * n, t[1] = s * r - e * i, t[2] = e * n - h * r, 
        t;
    }, oi = function(t, s, i, e) {
        var h = s[0], r = s[1], s = s[2];
        return t[0] = h + e * (i[0] - h), t[1] = r + e * (i[1] - r), t[2] = s + e * (i[2] - s), 
        t;
    }, ai = function(t, s, i, e) {
        var h = Math.acos(Math.min(Math.max(w(s, i), -1), 1)), r = Math.sin(h), n = Math.sin((1 - e) * h) / r, e = Math.sin(e * h) / r;
        return t[0] = n * s[0] + e * i[0], t[1] = n * s[1] + e * i[1], t[2] = n * s[2] + e * i[2], 
        t;
    }, li = function(t, s, i, e, h, r) {
        var n = r * r, o = n * (2 * r - 3) + 1, a = n * (r - 2) + r, l = n * (r - 1), n = n * (3 - 2 * r);
        return t[0] = s[0] * o + i[0] * a + e[0] * l + h[0] * n, t[1] = s[1] * o + i[1] * a + e[1] * l + h[1] * n, 
        t[2] = s[2] * o + i[2] * a + e[2] * l + h[2] * n, t;
    }, ui = function(t, s, i, e, h, r) {
        var n = 1 - r, o = n * n, a = r * r, l = o * n, o = 3 * r * o, n = 3 * a * n, a = a * r;
        return t[0] = s[0] * l + i[0] * o + e[0] * n + h[0] * a, t[1] = s[1] * l + i[1] * o + e[1] * n + h[1] * a, 
        t[2] = s[2] * l + i[2] * o + e[2] * n + h[2] * a, t;
    }, ci = function(t, s) {
        s = s || 1;
        var i = 2 * Oh() * Math.PI, e = 2 * Oh() - 1, h = Math.sqrt(1 - e * e) * s;
        return t[0] = Math.cos(i) * h, t[1] = Math.sin(i) * h, t[2] = e * s, t;
    }, fi = function(t, s, i) {
        var e = s[0], h = s[1], s = s[2], r = i[3] * e + i[7] * h + i[11] * s + i[15];
        return t[0] = (i[0] * e + i[4] * h + i[8] * s + i[12]) / (r = r || 1), t[1] = (i[1] * e + i[5] * h + i[9] * s + i[13]) / r, 
        t[2] = (i[2] * e + i[6] * h + i[10] * s + i[14]) / r, t;
    }, di = function(t, s, i) {
        var e = s[0], h = s[1], s = s[2];
        return t[0] = e * i[0] + h * i[3] + s * i[6], t[1] = e * i[1] + h * i[4] + s * i[7], 
        t[2] = e * i[2] + h * i[5] + s * i[8], t;
    }, pi = function(t, s, i) {
        var e = i[0], h = i[1], r = i[2], n = s[0], o = s[1], s = s[2], a = h * s - r * o, l = r * n - e * s, u = e * o - h * n, c = h * u - r * l, r = r * a - e * u, e = e * l - h * a, h = 2 * i[3];
        return l *= h, u *= h, r *= 2, e *= 2, t[0] = n + (a *= h) + (c *= 2), t[1] = o + l + r, 
        t[2] = s + u + e, t;
    }, mi = function(t, s, i, e) {
        var h = [], r = [];
        return h[0] = s[0] - i[0], h[1] = s[1] - i[1], h[2] = s[2] - i[2], r[0] = h[0], 
        r[1] = h[1] * Math.cos(e) - h[2] * Math.sin(e), r[2] = h[1] * Math.sin(e) + h[2] * Math.cos(e), 
        t[0] = r[0] + i[0], t[1] = r[1] + i[1], t[2] = r[2] + i[2], t;
    }, gi = function(t, s, i, e) {
        var h = [], r = [];
        return h[0] = s[0] - i[0], h[1] = s[1] - i[1], h[2] = s[2] - i[2], r[0] = h[2] * Math.sin(e) + h[0] * Math.cos(e), 
        r[1] = h[1], r[2] = h[2] * Math.cos(e) - h[0] * Math.sin(e), t[0] = r[0] + i[0], 
        t[1] = r[1] + i[1], t[2] = r[2] + i[2], t;
    }, yi = function(t, s, i, e) {
        var h = [], r = [];
        return h[0] = s[0] - i[0], h[1] = s[1] - i[1], h[2] = s[2] - i[2], r[0] = h[0] * Math.cos(e) - h[1] * Math.sin(e), 
        r[1] = h[0] * Math.sin(e) + h[1] * Math.cos(e), r[2] = h[2], t[0] = r[0] + i[0], 
        t[1] = r[1] + i[1], t[2] = r[2] + i[2], t;
    }, wi = function(t, s) {
        var i = t[0], e = t[1], h = t[2], r = s[0], n = s[1], o = s[2], i = Math.sqrt((i * i + e * e + h * h) * (r * r + n * n + o * o)), e = i && w(t, s) / i;
        return Math.acos(Math.min(Math.max(e, -1), 1));
    }, Si = function(t) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t;
    }, bi = function(t) {
        return "vec3(" + t[0] + ", " + t[1] + ", " + t[2] + ")";
    }, Mi = function(t, s) {
        return t[0] === s[0] && t[1] === s[1] && t[2] === s[2];
    }, vi = function(t, s) {
        var i = t[0], e = t[1], t = t[2], h = s[0], r = s[1], s = s[2];
        return Math.abs(i - h) <= Mh * Math.max(1, Math.abs(i), Math.abs(h)) && Math.abs(e - r) <= Mh * Math.max(1, Math.abs(e), Math.abs(r)) && Math.abs(t - s) <= Mh * Math.max(1, Math.abs(t), Math.abs(s));
    }, b = function() {
        var t = new vh(4);
        return vh != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t;
    }, xi = function(t) {
        var s = new vh(4);
        return s[0] = t[0], s[1] = t[1], s[2] = t[2], s[3] = t[3], s;
    }, Gi = function(t, s, i, e) {
        var h = new vh(4);
        return h[0] = t, h[1] = s, h[2] = i, h[3] = e, h;
    }, Ti = function(t, s) {
        return t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[3], t;
    }, _i = function(t, s, i, e, h) {
        return t[0] = s, t[1] = i, t[2] = e, t[3] = h, t;
    }, Ii = function(t, s, i) {
        return t[0] = s[0] + i[0], t[1] = s[1] + i[1], t[2] = s[2] + i[2], t[3] = s[3] + i[3], 
        t;
    }, Ci = function(t, s, i) {
        return t[0] = s[0] - i[0], t[1] = s[1] - i[1], t[2] = s[2] - i[2], t[3] = s[3] - i[3], 
        t;
    }, Ri = function(t, s, i) {
        return t[0] = s[0] * i[0], t[1] = s[1] * i[1], t[2] = s[2] * i[2], t[3] = s[3] * i[3], 
        t;
    }, Pi = function(t, s, i) {
        return t[0] = s[0] / i[0], t[1] = s[1] / i[1], t[2] = s[2] / i[2], t[3] = s[3] / i[3], 
        t;
    }, Ei = function(t, s) {
        return t[0] = Math.ceil(s[0]), t[1] = Math.ceil(s[1]), t[2] = Math.ceil(s[2]), 
        t[3] = Math.ceil(s[3]), t;
    }, Ai = function(t, s) {
        return t[0] = Math.floor(s[0]), t[1] = Math.floor(s[1]), t[2] = Math.floor(s[2]), 
        t[3] = Math.floor(s[3]), t;
    }, Fi = function(t, s, i) {
        return t[0] = Math.min(s[0], i[0]), t[1] = Math.min(s[1], i[1]), t[2] = Math.min(s[2], i[2]), 
        t[3] = Math.min(s[3], i[3]), t;
    }, Oi = function(t, s, i) {
        return t[0] = Math.max(s[0], i[0]), t[1] = Math.max(s[1], i[1]), t[2] = Math.max(s[2], i[2]), 
        t[3] = Math.max(s[3], i[3]), t;
    }, Di = function(t, s) {
        return t[0] = Math.round(s[0]), t[1] = Math.round(s[1]), t[2] = Math.round(s[2]), 
        t[3] = Math.round(s[3]), t;
    }, ki = function(t, s, i) {
        return t[0] = s[0] * i, t[1] = s[1] * i, t[2] = s[2] * i, t[3] = s[3] * i, 
        t;
    }, Li = function(t, s, i, e) {
        return t[0] = s[0] + i[0] * e, t[1] = s[1] + i[1] * e, t[2] = s[2] + i[2] * e, 
        t[3] = s[3] + i[3] * e, t;
    }, Bi = function(t, s) {
        var i = s[0] - t[0];
        return Math.hypot(i, s[1] - t[1], s[2] - t[2], s[3] - t[3]);
    }, Ni = function(t, s) {
        var i = s[0] - t[0], e = s[1] - t[1], h = s[2] - t[2], s = s[3] - t[3];
        return i * i + e * e + h * h + s * s;
    }, M = function(t) {
        var s = t[0];
        return Math.hypot(s, t[1], t[2], t[3]);
    }, v = function(t) {
        var s = t[0], i = t[1], e = t[2], t = t[3];
        return s * s + i * i + e * e + t * t;
    }, Wi = function(t, s) {
        return t[0] = -s[0], t[1] = -s[1], t[2] = -s[2], t[3] = -s[3], t;
    }, ji = function(t, s) {
        return t[0] = 1 / s[0], t[1] = 1 / s[1], t[2] = 1 / s[2], t[3] = 1 / s[3], 
        t;
    }, Vi = function(t, s) {
        var i = s[0], e = s[1], h = s[2], s = s[3], r = i * i + e * e + h * h + s * s;
        return 0 < r && (r = 1 / Math.sqrt(r)), t[0] = i * r, t[1] = e * r, t[2] = h * r, 
        t[3] = s * r, t;
    }, x = function(t, s) {
        return t[0] * s[0] + t[1] * s[1] + t[2] * s[2] + t[3] * s[3];
    }, Ui = function(t, s, i, e) {
        var h = i[0] * e[1] - i[1] * e[0], r = i[0] * e[2] - i[2] * e[0], n = i[0] * e[3] - i[3] * e[0], o = i[1] * e[2] - i[2] * e[1], a = i[1] * e[3] - i[3] * e[1], i = i[2] * e[3] - i[3] * e[2], e = s[0], l = s[1], u = s[2], s = s[3];
        return t[0] = l * i - u * a + s * o, t[1] = -e * i + u * n - s * r, t[2] = e * a - l * n + s * h, 
        t[3] = -e * o + l * r - u * h, t;
    }, Hi = function(t, s, i, e) {
        var h = s[0], r = s[1], n = s[2], s = s[3];
        return t[0] = h + e * (i[0] - h), t[1] = r + e * (i[1] - r), t[2] = n + e * (i[2] - n), 
        t[3] = s + e * (i[3] - s), t;
    }, zi = function(t, s) {
        var i, e, h, r, n, o;
        for (s = s || 1; 1 <= (n = (i = 2 * Oh() - 1) * i + (e = 2 * Oh() - 1) * e); );
        for (;1 <= (o = (h = 2 * Oh() - 1) * h + (r = 2 * Oh() - 1) * r); );
        var a = Math.sqrt((1 - n) / o);
        return t[0] = s * i, t[1] = s * e, t[2] = s * h * a, t[3] = s * r * a, t;
    }, Ji = function(t, s, i) {
        var e = s[0], h = s[1], r = s[2], s = s[3];
        return t[0] = i[0] * e + i[4] * h + i[8] * r + i[12] * s, t[1] = i[1] * e + i[5] * h + i[9] * r + i[13] * s, 
        t[2] = i[2] * e + i[6] * h + i[10] * r + i[14] * s, t[3] = i[3] * e + i[7] * h + i[11] * r + i[15] * s, 
        t;
    }, qi = function(t, s, i) {
        var e = s[0], h = s[1], r = s[2], n = i[0], o = i[1], a = i[2], i = i[3], l = i * e + o * r - a * h, u = i * h + a * e - n * r, c = i * r + n * h - o * e, e = -n * e - o * h - a * r;
        return t[0] = l * i + e * -n + u * -a - c * -o, t[1] = u * i + e * -o + c * -n - l * -a, 
        t[2] = c * i + e * -a + l * -o - u * -n, t[3] = s[3], t;
    }, Xi = function(t) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t;
    }, Yi = function(t) {
        return "vec4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
    }, $i = function(t, s) {
        return t[0] === s[0] && t[1] === s[1] && t[2] === s[2] && t[3] === s[3];
    }, Ki = function(t, s) {
        var i = t[0], e = t[1], h = t[2], t = t[3], r = s[0], n = s[1], o = s[2], s = s[3];
        return Math.abs(i - r) <= Mh * Math.max(1, Math.abs(i), Math.abs(r)) && Math.abs(e - n) <= Mh * Math.max(1, Math.abs(e), Math.abs(n)) && Math.abs(h - o) <= Mh * Math.max(1, Math.abs(h), Math.abs(o)) && Math.abs(t - s) <= Mh * Math.max(1, Math.abs(t), Math.abs(s));
    }, G = function() {
        var t = new vh(4);
        return vh != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;
    }, Zi = function(t) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;
    }, T = function(t, s, i) {
        i *= .5;
        var e = Math.sin(i);
        return t[0] = e * s[0], t[1] = e * s[1], t[2] = e * s[2], t[3] = Math.cos(i), 
        t;
    }, Qi = function(t, s) {
        var i = 2 * Math.acos(s[3]), e = Math.sin(i / 2);
        return Mh < e ? (t[0] = s[0] / e, t[1] = s[1] / e, t[2] = s[2] / e) : (t[0] = 1, 
        t[1] = 0, t[2] = 0), i;
    }, te = function(t, s) {
        t = zh(t, s);
        return Math.acos(2 * t * t - 1);
    }, se = function(t, s, i) {
        var e = s[0], h = s[1], r = s[2], s = s[3], n = i[0], o = i[1], a = i[2], i = i[3];
        return t[0] = e * i + s * n + h * a - r * o, t[1] = h * i + s * o + r * n - e * a, 
        t[2] = r * i + s * a + e * o - h * n, t[3] = s * i - e * n - h * o - r * a, 
        t;
    }, _ = function(t, s, i) {
        i *= .5;
        var e = s[0], h = s[1], r = s[2], s = s[3], n = Math.sin(i), i = Math.cos(i);
        return t[0] = e * i + s * n, t[1] = h * i + r * n, t[2] = r * i - h * n, 
        t[3] = s * i - e * n, t;
    }, I = function(t, s, i) {
        i *= .5;
        var e = s[0], h = s[1], r = s[2], s = s[3], n = Math.sin(i), i = Math.cos(i);
        return t[0] = e * i - r * n, t[1] = h * i + s * n, t[2] = r * i + e * n, 
        t[3] = s * i - h * n, t;
    }, C = function(t, s, i) {
        i *= .5;
        var e = s[0], h = s[1], r = s[2], s = s[3], n = Math.sin(i), i = Math.cos(i);
        return t[0] = e * i + h * n, t[1] = h * i - e * n, t[2] = r * i + s * n, 
        t[3] = s * i - r * n, t;
    }, ie = function(t, s) {
        var i = s[0], e = s[1], s = s[2];
        return t[0] = i, t[1] = e, t[2] = s, t[3] = Math.sqrt(Math.abs(1 - i * i - e * e - s * s)), 
        t;
    }, R = function(t, s) {
        var i = s[0], e = s[1], h = s[2], s = s[3], r = Math.sqrt(i * i + e * e + h * h), s = Math.exp(s), n = 0 < r ? s * Math.sin(r) / r : 0;
        return t[0] = i * n, t[1] = e * n, t[2] = h * n, t[3] = s * Math.cos(r), 
        t;
    }, P = function(t, s) {
        var i = s[0], e = s[1], h = s[2], s = s[3], r = Math.sqrt(i * i + e * e + h * h), r = 0 < r ? Math.atan2(r, s) / r : 0;
        return t[0] = i * r, t[1] = e * r, t[2] = h * r, t[3] = .5 * Math.log(i * i + e * e + h * h + s * s), 
        t;
    }, ee = function(t, s, i) {
        return P(t, s), Hh(t, t, i), R(t, t), t;
    }, E = function(t, s, i, e) {
        var h, r, n = s[0], o = s[1], a = s[2], s = s[3], l = i[0], u = i[1], c = i[2], i = i[3], f = n * l + o * u + a * c + s * i;
        return f < 0 && (f = -f, l = -l, u = -u, c = -c, i = -i), f = Mh < 1 - f ? (f = Math.acos(f), 
        h = Math.sin(f), r = Math.sin((1 - e) * f) / h, Math.sin(e * f) / h) : (r = 1 - e, 
        e), t[0] = r * n + f * l, t[1] = r * o + f * u, t[2] = r * a + f * c, t[3] = r * s + f * i, 
        t;
    }, he = function(t) {
        var s = Oh(), i = Oh(), e = Oh(), h = Math.sqrt(1 - s), s = Math.sqrt(s);
        return t[0] = h * Math.sin(2 * Math.PI * i), t[1] = h * Math.cos(2 * Math.PI * i), 
        t[2] = s * Math.sin(2 * Math.PI * e), t[3] = s * Math.cos(2 * Math.PI * e), 
        t;
    }, re = function(t, s) {
        var i = s[0], e = s[1], h = s[2], s = s[3], r = i * i + e * e + h * h + s * s, r = r ? 1 / r : 0;
        return t[0] = -i * r, t[1] = -e * r, t[2] = -h * r, t[3] = s * r, t;
    }, ne = function(t, s) {
        return t[0] = -s[0], t[1] = -s[1], t[2] = -s[2], t[3] = s[3], t;
    }, A = function(t, s) {
        var i, e, h, r = s[0] + s[4] + s[8];
        return 0 < r ? (h = Math.sqrt(r + 1), t[3] = .5 * h, t[0] = (s[5] - s[7]) * (h = .5 / h), 
        t[1] = (s[6] - s[2]) * h, t[2] = (s[1] - s[3]) * h) : (i = ((r = s[3 * (r = s[4] > s[r = 0] ? 1 : r) + r] < s[8] ? 2 : r) + 1) % 3, 
        e = (r + 2) % 3, h = Math.sqrt(s[3 * r + r] - s[3 * i + i] - s[3 * e + e] + 1), 
        t[r] = .5 * h, t[3] = (s[3 * i + e] - s[3 * e + i]) * (h = .5 / h), t[i] = (s[3 * i + r] + s[3 * r + i]) * h, 
        t[e] = (s[3 * e + r] + s[3 * r + e]) * h), t;
    }, oe = function(t, s, i, e) {
        var h = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : Dh, r = Math.PI / 360, n = (e *= r, 
        i *= r, Math.sin(s *= r)), o = Math.cos(s), a = Math.sin(i), l = Math.cos(i), u = Math.sin(e), c = Math.cos(e);
        switch (h) {
          case "xyz":
            t[0] = n * l * c + o * a * u, t[1] = o * a * c - n * l * u, t[2] = o * l * u + n * a * c, 
            t[3] = o * l * c - n * a * u;
            break;

          case "xzy":
            t[0] = n * l * c - o * a * u, t[1] = o * a * c - n * l * u, t[2] = o * l * u + n * a * c, 
            t[3] = o * l * c + n * a * u;
            break;

          case "yxz":
            t[0] = n * l * c + o * a * u, t[1] = o * a * c - n * l * u, t[2] = o * l * u - n * a * c, 
            t[3] = o * l * c + n * a * u;
            break;

          case "yzx":
            t[0] = n * l * c + o * a * u, t[1] = o * a * c + n * l * u, t[2] = o * l * u - n * a * c, 
            t[3] = o * l * c - n * a * u;
            break;

          case "zxy":
            t[0] = n * l * c - o * a * u, t[1] = o * a * c + n * l * u, t[2] = o * l * u + n * a * c, 
            t[3] = o * l * c - n * a * u;
            break;

          case "zyx":
            t[0] = n * l * c - o * a * u, t[1] = o * a * c + n * l * u, t[2] = o * l * u - n * a * c, 
            t[3] = o * l * c + n * a * u;
            break;

          default:
            throw new Error("Unknown angle order " + h);
        }
        return t;
    }, ae = function(t) {
        return "quat(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
    }, le = function(t, s) {
        return Math.abs(x(t, s)) >= 1 - Mh;
    }, ue = function() {
        var t = new vh(8);
        return vh != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0, 
        t[6] = 0, t[7] = 0), t[3] = 1, t;
    }, ce = function(t) {
        var s = new vh(8);
        return s[0] = t[0], s[1] = t[1], s[2] = t[2], s[3] = t[3], s[4] = t[4], 
        s[5] = t[5], s[6] = t[6], s[7] = t[7], s;
    }, fe = function(t, s, i, e, h, r, n, o) {
        var a = new vh(8);
        return a[0] = t, a[1] = s, a[2] = i, a[3] = e, a[4] = h, a[5] = r, a[6] = n, 
        a[7] = o, a;
    }, de = function(t, s, i, e, h, r, n) {
        var o = new vh(8), h = (o[0] = t, o[1] = s, o[2] = i, o[3] = e, .5 * h), r = .5 * r, n = .5 * n;
        return o[4] = h * e + r * i - n * s, o[5] = r * e + n * t - h * i, o[6] = n * e + h * s - r * t, 
        o[7] = -h * t - r * s - n * i, o;
    }, F = function(t, s, i) {
        var e = .5 * i[0], h = .5 * i[1], i = .5 * i[2], r = s[0], n = s[1], o = s[2], s = s[3];
        return t[0] = r, t[1] = n, t[2] = o, t[3] = s, t[4] = e * s + h * o - i * n, 
        t[5] = h * s + i * r - e * o, t[6] = i * s + e * n - h * r, t[7] = -e * r - h * n - i * o, 
        t;
    }, pe = function(t, s) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = .5 * s[0], t[5] = .5 * s[1], 
        t[6] = .5 * s[2], t[7] = 0, t;
    }, me = function(t, s) {
        return t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[3], t[4] = 0, t[5] = 0, 
        t[6] = 0, t[7] = 0, t;
    }, ge = function(t, s) {
        var i = G(), e = (l(i, s), new vh(3));
        return a(e, s), F(t, i, e), t;
    }, O = function(t, s) {
        return t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[3], t[4] = s[4], 
        t[5] = s[5], t[6] = s[6], t[7] = s[7], t;
    }, ye = function(t) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t[6] = 0, 
        t[7] = 0, t;
    }, we = function(t, s, i, e, h, r, n, o, a) {
        return t[0] = s, t[1] = i, t[2] = e, t[3] = h, t[4] = r, t[5] = n, t[6] = o, 
        t[7] = a, t;
    }, Se = function(t, s) {
        return t[0] = s[4], t[1] = s[5], t[2] = s[6], t[3] = s[7], t;
    }, be = function(t, s) {
        return t[4] = s[0], t[5] = s[1], t[6] = s[2], t[7] = s[3], t;
    }, Me = function(t, s) {
        var i = s[4], e = s[5], h = s[6], r = s[7], n = -s[0], o = -s[1], a = -s[2], s = s[3];
        return t[0] = 2 * (i * s + r * n + e * a - h * o), t[1] = 2 * (e * s + r * o + h * n - i * a), 
        t[2] = 2 * (h * s + r * a + i * o - e * n), t;
    }, ve = function(t, s, i) {
        var e = s[0], h = s[1], r = s[2], n = s[3], o = .5 * i[0], a = .5 * i[1], i = .5 * i[2], l = s[4], u = s[5], c = s[6], s = s[7];
        return t[0] = e, t[1] = h, t[2] = r, t[3] = n, t[4] = n * o + h * i - r * a + l, 
        t[5] = n * a + r * o - e * i + u, t[6] = n * i + e * a - h * o + c, t[7] = -e * o - h * a - r * i + s, 
        t;
    }, xe = function(t, s, i) {
        var e = -s[0], h = -s[1], r = -s[2], n = s[3], o = s[4], a = s[5], l = s[6], u = s[7], c = o * n + u * e + a * r - l * h, f = a * n + u * h + l * e - o * r, d = l * n + u * r + o * h - a * e, u = u * n - o * e - a * h - l * r;
        return _(t, s, i), e = t[0], t[4] = c * (n = t[3]) + u * e + f * (r = t[2]) - d * (h = t[1]), 
        t[5] = f * n + u * h + d * e - c * r, t[6] = d * n + u * r + c * h - f * e, 
        t[7] = u * n - c * e - f * h - d * r, t;
    }, Ge = function(t, s, i) {
        var e = -s[0], h = -s[1], r = -s[2], n = s[3], o = s[4], a = s[5], l = s[6], u = s[7], c = o * n + u * e + a * r - l * h, f = a * n + u * h + l * e - o * r, d = l * n + u * r + o * h - a * e, u = u * n - o * e - a * h - l * r;
        return I(t, s, i), e = t[0], t[4] = c * (n = t[3]) + u * e + f * (r = t[2]) - d * (h = t[1]), 
        t[5] = f * n + u * h + d * e - c * r, t[6] = d * n + u * r + c * h - f * e, 
        t[7] = u * n - c * e - f * h - d * r, t;
    }, Te = function(t, s, i) {
        var e = -s[0], h = -s[1], r = -s[2], n = s[3], o = s[4], a = s[5], l = s[6], u = s[7], c = o * n + u * e + a * r - l * h, f = a * n + u * h + l * e - o * r, d = l * n + u * r + o * h - a * e, u = u * n - o * e - a * h - l * r;
        return C(t, s, i), e = t[0], t[4] = c * (n = t[3]) + u * e + f * (r = t[2]) - d * (h = t[1]), 
        t[5] = f * n + u * h + d * e - c * r, t[6] = d * n + u * r + c * h - f * e, 
        t[7] = u * n - c * e - f * h - d * r, t;
    }, _e = function(t, s, i) {
        var e = i[0], h = i[1], r = i[2], i = i[3], n = s[0], o = s[1], a = s[2], l = s[3];
        return t[0] = n * i + l * e + o * r - a * h, t[1] = o * i + l * h + a * e - n * r, 
        t[2] = a * i + l * r + n * h - o * e, t[3] = l * i - n * e - o * h - a * r, 
        t[4] = (n = s[4]) * i + (l = s[7]) * e + (o = s[5]) * r - (a = s[6]) * h, 
        t[5] = o * i + l * h + a * e - n * r, t[6] = a * i + l * r + n * h - o * e, 
        t[7] = l * i - n * e - o * h - a * r, t;
    }, Ie = function(t, s, i) {
        var e = s[0], h = s[1], r = s[2], s = s[3], n = i[0], o = i[1], a = i[2], l = i[3];
        return t[0] = e * l + s * n + h * a - r * o, t[1] = h * l + s * o + r * n - e * a, 
        t[2] = r * l + s * a + e * o - h * n, t[3] = s * l - e * n - h * o - r * a, 
        t[4] = e * (l = i[7]) + s * (n = i[4]) + h * (a = i[6]) - r * (o = i[5]), 
        t[5] = h * l + s * o + r * n - e * a, t[6] = r * l + s * a + e * o - h * n, 
        t[7] = s * l - e * n - h * o - r * a, t;
    }, Ce = function(t, s, i, e) {
        var h, r, n, o, a, l;
        return Math.abs(e) < Mh ? O(t, s) : (l = Math.hypot(i[0], i[1], i[2]), e *= .5, 
        h = (n = Math.sin(e)) * i[0] / l, r = n * i[1] / l, n = n * i[2] / l, i = Math.cos(e), 
        l = s[0], t[0] = l * i + (e = s[3]) * h + (o = s[1]) * n - (a = s[2]) * r, 
        t[1] = o * i + e * r + a * h - l * n, t[2] = a * i + e * n + l * r - o * h, 
        t[3] = e * i - l * h - o * r - a * n, t[4] = (e = s[4]) * i + (l = s[7]) * h + (o = s[5]) * n - (a = s[6]) * r, 
        t[5] = o * i + l * r + a * h - e * n, t[6] = a * i + l * n + e * r - o * h, 
        t[7] = l * i - e * h - o * r - a * n, t);
    }, Re = function(t, s, i) {
        return t[0] = s[0] + i[0], t[1] = s[1] + i[1], t[2] = s[2] + i[2], t[3] = s[3] + i[3], 
        t[4] = s[4] + i[4], t[5] = s[5] + i[5], t[6] = s[6] + i[6], t[7] = s[7] + i[7], 
        t;
    }, Pe = function(t, s, i) {
        var e = s[0], h = s[1], r = s[2], n = s[3], o = i[4], a = i[5], l = i[6], u = i[7], c = s[4], f = s[5], d = s[6], s = s[7], p = i[0], m = i[1], g = i[2], i = i[3];
        return t[0] = e * i + n * p + h * g - r * m, t[1] = h * i + n * m + r * p - e * g, 
        t[2] = r * i + n * g + e * m - h * p, t[3] = n * i - e * p - h * m - r * g, 
        t[4] = e * u + n * o + h * l - r * a + c * i + s * p + f * g - d * m, t[5] = h * u + n * a + r * o - e * l + f * i + s * m + d * p - c * g, 
        t[6] = r * u + n * l + e * a - h * o + d * i + s * g + c * m - f * p, t[7] = n * u - e * o - h * a - r * l + s * i - c * p - f * m - d * g, 
        t;
    }, Ee = function(t, s, i) {
        return t[0] = s[0] * i, t[1] = s[1] * i, t[2] = s[2] * i, t[3] = s[3] * i, 
        t[4] = s[4] * i, t[5] = s[5] * i, t[6] = s[6] * i, t[7] = s[7] * i, t;
    }, Ae = function(t, s, i, e) {
        var h = 1 - e;
        return $h(s, i) < 0 && (e = -e), t[0] = s[0] * h + i[0] * e, t[1] = s[1] * h + i[1] * e, 
        t[2] = s[2] * h + i[2] * e, t[3] = s[3] * h + i[3] * e, t[4] = s[4] * h + i[4] * e, 
        t[5] = s[5] * h + i[5] * e, t[6] = s[6] * h + i[6] * e, t[7] = s[7] * h + i[7] * e, 
        t;
    }, Fe = function(t, s) {
        var i = Kh(s);
        return t[0] = -s[0] / i, t[1] = -s[1] / i, t[2] = -s[2] / i, t[3] = s[3] / i, 
        t[4] = -s[4] / i, t[5] = -s[5] / i, t[6] = -s[6] / i, t[7] = s[7] / i, t;
    }, Oe = function(t, s) {
        return t[0] = -s[0], t[1] = -s[1], t[2] = -s[2], t[3] = s[3], t[4] = -s[4], 
        t[5] = -s[5], t[6] = -s[6], t[7] = s[7], t;
    }, De = function(t, s) {
        var i, e, h, r, n, o, a, l, u = Kh(s);
        return 0 < u && (u = Math.sqrt(u), l = (i = s[0] / u) * (n = s[4]) + (e = s[1] / u) * (o = s[5]) + (h = s[2] / u) * (a = s[6]) + (r = s[3] / u) * (s = s[7]), 
        t[0] = i, t[1] = e, t[2] = h, t[3] = r, t[4] = (n - i * l) / u, t[5] = (o - e * l) / u, 
        t[6] = (a - h * l) / u, t[7] = (s - r * l) / u), t;
    }, ke = function(t) {
        return "quat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ")";
    }, Le = function(t, s) {
        return t[0] === s[0] && t[1] === s[1] && t[2] === s[2] && t[3] === s[3] && t[4] === s[4] && t[5] === s[5] && t[6] === s[6] && t[7] === s[7];
    }, Be = function(t, s) {
        var i = t[0], e = t[1], h = t[2], r = t[3], n = t[4], o = t[5], a = t[6], t = t[7], l = s[0], u = s[1], c = s[2], f = s[3], d = s[4], p = s[5], m = s[6], s = s[7];
        return Math.abs(i - l) <= Mh * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(e - u) <= Mh * Math.max(1, Math.abs(e), Math.abs(u)) && Math.abs(h - c) <= Mh * Math.max(1, Math.abs(h), Math.abs(c)) && Math.abs(r - f) <= Mh * Math.max(1, Math.abs(r), Math.abs(f)) && Math.abs(n - d) <= Mh * Math.max(1, Math.abs(n), Math.abs(d)) && Math.abs(o - p) <= Mh * Math.max(1, Math.abs(o), Math.abs(p)) && Math.abs(a - m) <= Mh * Math.max(1, Math.abs(a), Math.abs(m)) && Math.abs(t - s) <= Mh * Math.max(1, Math.abs(t), Math.abs(s));
    }, D = function() {
        var t = new vh(2);
        return vh != Float32Array && (t[0] = 0, t[1] = 0), t;
    }, Ne = function(t) {
        var s = new vh(2);
        return s[0] = t[0], s[1] = t[1], s;
    }, We = function(t, s) {
        var i = new vh(2);
        return i[0] = t, i[1] = s, i;
    }, je = function(t, s) {
        return t[0] = s[0], t[1] = s[1], t;
    }, Ve = function(t, s, i) {
        return t[0] = s, t[1] = i, t;
    }, Ue = function(t, s, i) {
        return t[0] = s[0] + i[0], t[1] = s[1] + i[1], t;
    }, He = function(t, s, i) {
        return t[0] = s[0] - i[0], t[1] = s[1] - i[1], t;
    }, ze = function(t, s, i) {
        return t[0] = s[0] * i[0], t[1] = s[1] * i[1], t;
    }, Je = function(t, s, i) {
        return t[0] = s[0] / i[0], t[1] = s[1] / i[1], t;
    }, qe = function(t, s) {
        return t[0] = Math.ceil(s[0]), t[1] = Math.ceil(s[1]), t;
    }, Xe = function(t, s) {
        return t[0] = Math.floor(s[0]), t[1] = Math.floor(s[1]), t;
    }, Ye = function(t, s, i) {
        return t[0] = Math.min(s[0], i[0]), t[1] = Math.min(s[1], i[1]), t;
    }, $e = function(t, s, i) {
        return t[0] = Math.max(s[0], i[0]), t[1] = Math.max(s[1], i[1]), t;
    }, Ke = function(t, s) {
        return t[0] = Math.round(s[0]), t[1] = Math.round(s[1]), t;
    }, Ze = function(t, s, i) {
        return t[0] = s[0] * i, t[1] = s[1] * i, t;
    }, Qe = function(t, s, i, e) {
        return t[0] = s[0] + i[0] * e, t[1] = s[1] + i[1] * e, t;
    }, th = function(t, s) {
        var i = s[0] - t[0];
        return Math.hypot(i, s[1] - t[1]);
    }, sh = function(t, s) {
        var i = s[0] - t[0], s = s[1] - t[1];
        return i * i + s * s;
    }, ih = function(t) {
        var s = t[0];
        return Math.hypot(s, t[1]);
    }, eh = function(t) {
        var s = t[0], t = t[1];
        return s * s + t * t;
    }, hh = function(t, s) {
        return t[0] = -s[0], t[1] = -s[1], t;
    }, rh = function(t, s) {
        return t[0] = 1 / s[0], t[1] = 1 / s[1], t;
    }, nh = function(t, s) {
        var i = s[0], e = s[1], i = i * i + e * e;
        return 0 < i && (i = 1 / Math.sqrt(i)), t[0] = s[0] * i, t[1] = s[1] * i, 
        t;
    }, oh = function(t, s) {
        return t[0] * s[0] + t[1] * s[1];
    }, ah = function(t, s, i) {
        s = s[0] * i[1] - s[1] * i[0];
        return t[0] = t[1] = 0, t[2] = s, t;
    }, lh = function(t, s, i, e) {
        var h = s[0], s = s[1];
        return t[0] = h + e * (i[0] - h), t[1] = s + e * (i[1] - s), t;
    }, uh = function(t, s) {
        s = s || 1;
        var i = 2 * Oh() * Math.PI;
        return t[0] = Math.cos(i) * s, t[1] = Math.sin(i) * s, t;
    }, ch = function(t, s, i) {
        var e = s[0], s = s[1];
        return t[0] = i[0] * e + i[2] * s, t[1] = i[1] * e + i[3] * s, t;
    }, fh = function(t, s, i) {
        var e = s[0], s = s[1];
        return t[0] = i[0] * e + i[2] * s + i[4], t[1] = i[1] * e + i[3] * s + i[5], 
        t;
    }, dh = function(t, s, i) {
        var e = s[0], s = s[1];
        return t[0] = i[0] * e + i[3] * s + i[6], t[1] = i[1] * e + i[4] * s + i[7], 
        t;
    }, ph = function(t, s, i) {
        var e = s[0], s = s[1];
        return t[0] = i[0] * e + i[4] * s + i[12], t[1] = i[1] * e + i[5] * s + i[13], 
        t;
    }, mh = function(t, s, i, e) {
        var h = s[0] - i[0], s = s[1] - i[1], r = Math.sin(e), e = Math.cos(e);
        return t[0] = h * e - s * r + i[0], t[1] = h * r + s * e + i[1], t;
    }, gh = function(t, s) {
        var i = t[0], t = t[1], e = s[0], s = s[1], h = Math.sqrt((i * i + t * t) * (e * e + s * s));
        return Math.acos(Math.min(Math.max(h && (i * e + t * s) / h, -1), 1));
    }, yh = function(t) {
        return t[0] = 0, t[1] = 0, t;
    }, wh = function(t) {
        return "vec2(" + t[0] + ", " + t[1] + ")";
    }, Sh = function(t, s) {
        return t[0] === s[0] && t[1] === s[1];
    }, bh = function(t, s) {
        var i = t[0], t = t[1], e = s[0], s = s[1];
        return Math.abs(i - e) <= Mh * Math.max(1, Math.abs(i), Math.abs(e)) && Math.abs(t - s) <= Mh * Math.max(1, Math.abs(t), Math.abs(s));
    };
    h, p, f, a, d, l, m, g, y, w, S, b, x, G, T, _, I, C, R, P, E, A, F, O, D, Mh = 1e-6, 
    vh = "undefined" != typeof Float32Array ? Float32Array : Array, Oh = Math.random, 
    Dh = "zyx", kh = Math.PI / 180, Math.hypot || (Math.hypot = function() {
        for (var t = 0, s = arguments.length; s--; ) t += arguments[s] * arguments[s];
        return Math.sqrt(t);
    }), Lh = {
        __proto__: null,
        EPSILON: Mh,
        get _$ARRAY_TYPE$_() {
            return vh;
        },
        _$RANDOM$_: Oh,
        _$ANGLE_ORDER$_: Dh,
        _$setMatrixArrayType$_: k,
        _$toRadian$_: L,
        equals: B
    }, Bh = Object.freeze({
        __proto__: null,
        create: N,
        clone: W,
        _$copy$_: j,
        identity: V,
        _$fromValues$_: U,
        set: H,
        _$transpose$_: z,
        _$invert$_: J,
        _$adjoint$_: q,
        _$determinant$_: X,
        multiply: t,
        rotate: Y,
        scale: $,
        _$fromRotation$_: K,
        _$fromScaling$_: Z,
        _$str$_: Q,
        _$frob$_: tt,
        _$LDU$_: st,
        add: it,
        _$subtract$_: s,
        _$exactEquals$_: et,
        equals: ht,
        _$multiplyScalar$_: rt,
        _$multiplyScalarAndAdd$_: nt,
        mul: t,
        sub: s
    }), Nh = Object.freeze({
        __proto__: null,
        create: ot,
        clone: at,
        _$copy$_: lt,
        identity: ut,
        _$fromValues$_: ct,
        set: ft,
        _$invert$_: dt,
        _$determinant$_: pt,
        multiply: i,
        rotate: mt,
        scale: gt,
        translate: yt,
        _$fromRotation$_: wt,
        _$fromScaling$_: St,
        _$fromTranslation$_: bt,
        _$str$_: Mt,
        _$frob$_: vt,
        add: xt,
        _$subtract$_: e,
        _$multiplyScalar$_: Gt,
        _$multiplyScalarAndAdd$_: Tt,
        _$exactEquals$_: _t,
        equals: It,
        mul: i,
        sub: e
    }), Wh = Object.freeze({
        __proto__: null,
        create: h,
        _$fromMat4$_: Ct,
        clone: Rt,
        _$copy$_: Pt,
        _$fromValues$_: Et,
        set: At,
        identity: Ft,
        _$transpose$_: Ot,
        _$invert$_: Dt,
        _$adjoint$_: kt,
        _$determinant$_: Lt,
        multiply: r,
        translate: Bt,
        rotate: Nt,
        scale: Wt,
        _$fromTranslation$_: jt,
        _$fromRotation$_: Vt,
        _$fromScaling$_: Ut,
        _$fromMat2d$_: Ht,
        _$fromQuat$_: zt,
        _$normalFromMat4$_: Jt,
        _$projection$_: qt,
        _$str$_: Xt,
        _$frob$_: Yt,
        add: $t,
        _$subtract$_: n,
        _$multiplyScalar$_: Kt,
        _$multiplyScalarAndAdd$_: Zt,
        _$exactEquals$_: Qt,
        equals: ts,
        mul: r,
        sub: n
    }), xh = Object.freeze({
        __proto__: null,
        create: ss,
        clone: is,
        _$copy$_: es,
        _$fromValues$_: hs,
        set: rs,
        identity: p,
        _$transpose$_: ns,
        _$invert$_: os,
        _$adjoint$_: as,
        _$determinant$_: ls,
        multiply: o,
        translate: us,
        scale: cs,
        rotate: fs,
        _$rotateX$_: ds,
        _$rotateY$_: ps,
        _$rotateZ$_: ms,
        _$fromTranslation$_: gs,
        _$fromScaling$_: ys,
        _$fromRotation$_: ws,
        _$fromXRotation$_: Ss,
        _$fromYRotation$_: bs,
        _$fromZRotation$_: Ms,
        _$fromRotationTranslation$_: f,
        _$fromQuat2$_: vs,
        _$getTranslation$_: a,
        _$getScaling$_: d,
        _$getRotation$_: l,
        _$decompose$_: xs,
        _$fromRotationTranslationScale$_: Gs,
        _$fromRotationTranslationScaleOrigin$_: Ts,
        _$fromQuat$_: _s,
        _$frustum$_: Is,
        _$perspectiveNO$_: u,
        perspective: u,
        _$perspectiveZO$_: Cs,
        _$perspectiveFromFieldOfView$_: Rs,
        _$orthoNO$_: c,
        ortho: c,
        _$orthoZO$_: Ps,
        _$lookAt$_: Es,
        _$targetTo$_: As,
        _$str$_: Fs,
        _$frob$_: Os,
        add: Ds,
        _$subtract$_: ks,
        _$multiplyScalar$_: Ls,
        _$multiplyScalarAndAdd$_: Bs,
        _$exactEquals$_: Ns,
        equals: Ws,
        mul: o,
        sub: ks
    }), Yh = Js, Zh = qs, Uh = Xs, Qh = ii, tr = ei, jh = Vs, sr = hi, Fh = m(), 
    Gh = Object.freeze({
        __proto__: null,
        create: m,
        clone: js,
        length: Vs,
        _$fromValues$_: g,
        _$copy$_: Us,
        set: Hs,
        add: zs,
        _$subtract$_: Js,
        multiply: qs,
        _$divide$_: Xs,
        ceil: Ys,
        floor: $s,
        min: Ks,
        max: Zs,
        round: Qs,
        scale: ti,
        _$scaleAndAdd$_: si,
        _$distance$_: ii,
        _$squaredDistance$_: ei,
        _$squaredLength$_: hi,
        _$negate$_: ri,
        inverse: ni,
        normalize: y,
        _$dot$_: w,
        _$cross$_: S,
        _$lerp$_: oi,
        _$slerp$_: ai,
        _$hermite$_: li,
        _$bezier$_: ui,
        random: ci,
        _$transformMat4$_: fi,
        _$transformMat3$_: di,
        _$transformQuat$_: pi,
        _$rotateX$_: mi,
        _$rotateY$_: gi,
        _$rotateZ$_: yi,
        angle: wi,
        _$zero$_: Si,
        _$str$_: bi,
        _$exactEquals$_: Mi,
        equals: vi,
        sub: Yh,
        mul: Zh,
        div: Uh,
        _$dist$_: Qh,
        _$sqrDist$_: tr,
        _$len$_: jh,
        _$sqrLen$_: sr,
        forEach: function(t, s, i, e, h, r) {
            var n, o;
            for (s = s || 3, i = i || 0, o = e ? Math.min(e * s + i, t.length) : t.length, 
            n = i; n < o; n += s) Fh[0] = t[n], Fh[1] = t[n + 1], Fh[2] = t[n + 2], 
            h(Fh, Fh, r), t[n] = Fh[0], t[n + 1] = Fh[1], t[n + 2] = Fh[2];
            return t;
        }
    }), Yh = Ci, Zh = Ri, Uh = Pi, Qh = Bi, tr = Ni, sr = M, ir = v, Ah = b(), Vh = Object.freeze({
        __proto__: null,
        create: b,
        clone: xi,
        _$fromValues$_: Gi,
        _$copy$_: Ti,
        set: _i,
        add: Ii,
        _$subtract$_: Ci,
        multiply: Ri,
        _$divide$_: Pi,
        ceil: Ei,
        floor: Ai,
        min: Fi,
        max: Oi,
        round: Di,
        scale: ki,
        _$scaleAndAdd$_: Li,
        _$distance$_: Bi,
        _$squaredDistance$_: Ni,
        length: M,
        _$squaredLength$_: v,
        _$negate$_: Wi,
        inverse: ji,
        normalize: Vi,
        _$dot$_: x,
        _$cross$_: Ui,
        _$lerp$_: Hi,
        random: zi,
        _$transformMat4$_: Ji,
        _$transformQuat$_: qi,
        _$zero$_: Xi,
        _$str$_: Yi,
        _$exactEquals$_: $i,
        equals: Ki,
        sub: Yh,
        mul: Zh,
        div: Uh,
        _$dist$_: Qh,
        _$sqrDist$_: tr,
        _$len$_: sr,
        _$sqrLen$_: ir,
        forEach: function(t, s, i, e, h, r) {
            var n, o;
            for (s = s || 4, i = i || 0, o = e ? Math.min(e * s + i, t.length) : t.length, 
            n = i; n < o; n += s) Ah[0] = t[n], Ah[1] = t[n + 1], Ah[2] = t[n + 2], 
            Ah[3] = t[n + 3], h(Ah, Ah, r), t[n] = Ah[0], t[n + 1] = Ah[1], t[n + 2] = Ah[2], 
            t[n + 3] = Ah[3];
            return t;
        }
    }), Yh = xi, Zh = Gi, Uh = Ti, Qh = _i, tr = Ii, sr = se, Hh = ki, zh = x, ir = Hi, 
    er = Jh = M, hr = qh = v, Xh = Vi, rr = $i, Rh = m(), Ph = g(1, 0, 0), Eh = g(0, 1, 0), 
    nr = function(t, s, i) {
        var e = w(s, i);
        return e < -.999999 ? (S(Rh, Ph, s), jh(Rh) < 1e-6 && S(Rh, Eh, s), y(Rh, Rh), 
        T(t, Rh, Math.PI), t) : .999999 < e ? (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, 
        t) : (S(Rh, s, i), t[0] = Rh[0], t[1] = Rh[1], t[2] = Rh[2], t[3] = 1 + e, 
        Xh(t, t));
    }, Ih = G(), Ch = G(), or = function(t, s, i, e, h, r) {
        return E(Ih, s, h, r), E(Ch, i, e, r), E(t, Ih, Ch, 2 * r * (1 - r)), t;
    }, _h = h(), Yh = Object.freeze({
        __proto__: null,
        create: G,
        identity: Zi,
        _$setAxisAngle$_: T,
        _$getAxisAngle$_: Qi,
        _$getAngle$_: te,
        multiply: se,
        _$rotateX$_: _,
        _$rotateY$_: I,
        _$rotateZ$_: C,
        _$calculateW$_: ie,
        exp: R,
        _$ln$_: P,
        pow: ee,
        _$slerp$_: E,
        random: he,
        _$invert$_: re,
        _$conjugate$_: ne,
        _$fromMat3$_: A,
        _$fromEuler$_: oe,
        _$str$_: ae,
        clone: Yh,
        _$fromValues$_: Zh,
        _$copy$_: Uh,
        set: Qh,
        add: tr,
        mul: sr,
        scale: Hh,
        _$dot$_: zh,
        _$lerp$_: ir,
        length: Jh,
        _$len$_: er,
        _$squaredLength$_: qh,
        _$sqrLen$_: hr,
        normalize: Xh,
        _$exactEquals$_: rr,
        equals: le,
        _$rotationTo$_: nr,
        _$sqlerp$_: or,
        _$setAxes$_: function(t, s, i, e) {
            return _h[0] = i[0], _h[3] = i[1], _h[6] = i[2], _h[1] = e[0], _h[4] = e[1], 
            _h[7] = e[2], _h[2] = -s[0], _h[5] = -s[1], _h[8] = -s[2], Xh(t, A(t, _h));
        }
    }), $h = zh, Zh = Kh = qh, Qh = Object.freeze({
        __proto__: null,
        create: ue,
        clone: ce,
        _$fromValues$_: fe,
        _$fromRotationTranslationValues$_: de,
        _$fromRotationTranslation$_: F,
        _$fromTranslation$_: pe,
        _$fromRotation$_: me,
        _$fromMat4$_: ge,
        _$copy$_: O,
        identity: ye,
        set: we,
        _$getReal$_: Uh,
        _$getDual$_: Se,
        _$setReal$_: Uh,
        _$setDual$_: be,
        _$getTranslation$_: Me,
        translate: ve,
        _$rotateX$_: xe,
        _$rotateY$_: Ge,
        _$rotateZ$_: Te,
        _$rotateByQuatAppend$_: _e,
        _$rotateByQuatPrepend$_: Ie,
        _$rotateAroundAxis$_: Ce,
        add: Re,
        multiply: Pe,
        mul: Pe,
        scale: Ee,
        _$dot$_: $h,
        _$lerp$_: Ae,
        _$invert$_: Fe,
        _$conjugate$_: Oe,
        length: Jh,
        _$len$_: Jh,
        _$squaredLength$_: Kh,
        _$sqrLen$_: Zh,
        normalize: De,
        _$str$_: ke,
        _$exactEquals$_: Le,
        equals: Be
    }), tr = ih, sr = He, ir = ze, er = Je, hr = th, rr = sh, nr = eh, Th = D(), 
    or = Object.freeze({
        __proto__: null,
        create: D,
        clone: Ne,
        _$fromValues$_: We,
        _$copy$_: je,
        set: Ve,
        add: Ue,
        _$subtract$_: He,
        multiply: ze,
        _$divide$_: Je,
        ceil: qe,
        floor: Xe,
        min: Ye,
        max: $e,
        round: Ke,
        scale: Ze,
        _$scaleAndAdd$_: Qe,
        _$distance$_: th,
        _$squaredDistance$_: sh,
        length: ih,
        _$squaredLength$_: eh,
        _$negate$_: hh,
        inverse: rh,
        normalize: nh,
        _$dot$_: oh,
        _$cross$_: ah,
        _$lerp$_: lh,
        random: uh,
        _$transformMat2$_: ch,
        _$transformMat2d$_: fh,
        _$transformMat3$_: dh,
        _$transformMat4$_: ph,
        rotate: mh,
        angle: gh,
        _$zero$_: yh,
        _$str$_: wh,
        _$exactEquals$_: Sh,
        equals: bh,
        _$len$_: tr,
        sub: sr,
        mul: ir,
        div: er,
        _$dist$_: hr,
        _$sqrDist$_: rr,
        _$sqrLen$_: nr,
        forEach: function(t, s, i, e, h, r) {
            var n, o;
            for (s = s || 2, i = i || 0, o = e ? Math.min(e * s + i, t.length) : t.length, 
            n = i; n < o; n += s) Th[0] = t[n], Th[1] = t[n + 1], h(Th, Th, r), 
            t[n] = Th[0], t[n + 1] = Th[1];
            return t;
        }
    }), globalThis._$glMatrix$_ = Lh, globalThis._$glMatrix$_._$mat2$_ = Bh, globalThis._$glMatrix$_._$mat2d$_ = Nh, 
    globalThis._$glMatrix$_._$mat3$_ = Wh, globalThis._$glMatrix$_._$mat4$_ = xh, 
    globalThis._$glMatrix$_._$quat$_ = Yh, globalThis._$glMatrix$_._$quat2$_ = Qh, 
    globalThis._$glMatrix$_._$vec2$_ = or, globalThis._$glMatrix$_._$vec3$_ = Gh, 
    globalThis._$glMatrix$_._$vec4$_ = Vh;
}

var Th, _h, Ih, Ch, Rh, Ph, Eh, Ah, Fh, Mh, vh, Oh, Dh, kh, Lh, Bh, Nh, Wh, xh, jh, Gh, Vh, Uh, Hh, zh, Jh, qh, Xh, Yh, $h, Kh, Zh, Qh, tr, sr, ir, er, hr, rr, nr, or, O, D, k, L;

{
    let t = function() {
        function c(t, s) {
            var i, e = t.charCodeAt(s = void 0 === s ? 0 : s);
            return 55296 <= e && e <= 56319 && s < t.length - 1 ? (i = e, 56320 <= (t = t.charCodeAt(s + 1)) && t <= 57343 ? 1024 * (i - 55296) + (t - 56320) + 65536 : i) : 56320 <= e && e <= 57343 && 1 <= s ? (i = t.charCodeAt(s - 1), 
            t = e, 55296 <= i && i <= 56319 ? 1024 * (i - 55296) + (t - 56320) + 65536 : t) : e;
        }
        function f(t) {
            return 1536 <= t && t <= 1541 || 1757 == t || 1807 == t || 2274 == t || 3406 == t || 69821 == t || 70082 <= t && t <= 70083 || 72250 == t || 72326 <= t && t <= 72329 || 73030 == t ? 12 : 13 == t ? 0 : 10 == t ? 1 : 0 <= t && t <= 9 || 11 <= t && t <= 12 || 14 <= t && t <= 31 || 127 <= t && t <= 159 || 173 == t || 1564 == t || 6158 == t || 8203 == t || 8206 <= t && t <= 8207 || 8232 == t || 8233 == t || 8234 <= t && t <= 8238 || 8288 <= t && t <= 8292 || 8293 == t || 8294 <= t && t <= 8303 || 55296 <= t && t <= 57343 || 65279 == t || 65520 <= t && t <= 65528 || 65529 <= t && t <= 65531 || 113824 <= t && t <= 113827 || 119155 <= t && t <= 119162 || 917504 == t || 917505 == t || 917506 <= t && t <= 917535 || 917632 <= t && t <= 917759 || 918e3 <= t && t <= 921599 ? 2 : 768 <= t && t <= 879 || 1155 <= t && t <= 1159 || 1160 <= t && t <= 1161 || 1425 <= t && t <= 1469 || 1471 == t || 1473 <= t && t <= 1474 || 1476 <= t && t <= 1477 || 1479 == t || 1552 <= t && t <= 1562 || 1611 <= t && t <= 1631 || 1648 == t || 1750 <= t && t <= 1756 || 1759 <= t && t <= 1764 || 1767 <= t && t <= 1768 || 1770 <= t && t <= 1773 || 1809 == t || 1840 <= t && t <= 1866 || 1958 <= t && t <= 1968 || 2027 <= t && t <= 2035 || 2070 <= t && t <= 2073 || 2075 <= t && t <= 2083 || 2085 <= t && t <= 2087 || 2089 <= t && t <= 2093 || 2137 <= t && t <= 2139 || 2260 <= t && t <= 2273 || 2275 <= t && t <= 2306 || 2362 == t || 2364 == t || 2369 <= t && t <= 2376 || 2381 == t || 2385 <= t && t <= 2391 || 2402 <= t && t <= 2403 || 2433 == t || 2492 == t || 2494 == t || 2497 <= t && t <= 2500 || 2509 == t || 2519 == t || 2530 <= t && t <= 2531 || 2561 <= t && t <= 2562 || 2620 == t || 2625 <= t && t <= 2626 || 2631 <= t && t <= 2632 || 2635 <= t && t <= 2637 || 2641 == t || 2672 <= t && t <= 2673 || 2677 == t || 2689 <= t && t <= 2690 || 2748 == t || 2753 <= t && t <= 2757 || 2759 <= t && t <= 2760 || 2765 == t || 2786 <= t && t <= 2787 || 2810 <= t && t <= 2815 || 2817 == t || 2876 == t || 2878 == t || 2879 == t || 2881 <= t && t <= 2884 || 2893 == t || 2902 == t || 2903 == t || 2914 <= t && t <= 2915 || 2946 == t || 3006 == t || 3008 == t || 3021 == t || 3031 == t || 3072 == t || 3134 <= t && t <= 3136 || 3142 <= t && t <= 3144 || 3146 <= t && t <= 3149 || 3157 <= t && t <= 3158 || 3170 <= t && t <= 3171 || 3201 == t || 3260 == t || 3263 == t || 3266 == t || 3270 == t || 3276 <= t && t <= 3277 || 3285 <= t && t <= 3286 || 3298 <= t && t <= 3299 || 3328 <= t && t <= 3329 || 3387 <= t && t <= 3388 || 3390 == t || 3393 <= t && t <= 3396 || 3405 == t || 3415 == t || 3426 <= t && t <= 3427 || 3530 == t || 3535 == t || 3538 <= t && t <= 3540 || 3542 == t || 3551 == t || 3633 == t || 3636 <= t && t <= 3642 || 3655 <= t && t <= 3662 || 3761 == t || 3764 <= t && t <= 3769 || 3771 <= t && t <= 3772 || 3784 <= t && t <= 3789 || 3864 <= t && t <= 3865 || 3893 == t || 3895 == t || 3897 == t || 3953 <= t && t <= 3966 || 3968 <= t && t <= 3972 || 3974 <= t && t <= 3975 || 3981 <= t && t <= 3991 || 3993 <= t && t <= 4028 || 4038 == t || 4141 <= t && t <= 4144 || 4146 <= t && t <= 4151 || 4153 <= t && t <= 4154 || 4157 <= t && t <= 4158 || 4184 <= t && t <= 4185 || 4190 <= t && t <= 4192 || 4209 <= t && t <= 4212 || 4226 == t || 4229 <= t && t <= 4230 || 4237 == t || 4253 == t || 4957 <= t && t <= 4959 || 5906 <= t && t <= 5908 || 5938 <= t && t <= 5940 || 5970 <= t && t <= 5971 || 6002 <= t && t <= 6003 || 6068 <= t && t <= 6069 || 6071 <= t && t <= 6077 || 6086 == t || 6089 <= t && t <= 6099 || 6109 == t || 6155 <= t && t <= 6157 || 6277 <= t && t <= 6278 || 6313 == t || 6432 <= t && t <= 6434 || 6439 <= t && t <= 6440 || 6450 == t || 6457 <= t && t <= 6459 || 6679 <= t && t <= 6680 || 6683 == t || 6742 == t || 6744 <= t && t <= 6750 || 6752 == t || 6754 == t || 6757 <= t && t <= 6764 || 6771 <= t && t <= 6780 || 6783 == t || 6832 <= t && t <= 6845 || 6846 == t || 6912 <= t && t <= 6915 || 6964 == t || 6966 <= t && t <= 6970 || 6972 == t || 6978 == t || 7019 <= t && t <= 7027 || 7040 <= t && t <= 7041 || 7074 <= t && t <= 7077 || 7080 <= t && t <= 7081 || 7083 <= t && t <= 7085 || 7142 == t || 7144 <= t && t <= 7145 || 7149 == t || 7151 <= t && t <= 7153 || 7212 <= t && t <= 7219 || 7222 <= t && t <= 7223 || 7376 <= t && t <= 7378 || 7380 <= t && t <= 7392 || 7394 <= t && t <= 7400 || 7405 == t || 7412 == t || 7416 <= t && t <= 7417 || 7616 <= t && t <= 7673 || 7675 <= t && t <= 7679 || 8204 == t || 8400 <= t && t <= 8412 || 8413 <= t && t <= 8416 || 8417 == t || 8418 <= t && t <= 8420 || 8421 <= t && t <= 8432 || 11503 <= t && t <= 11505 || 11647 == t || 11744 <= t && t <= 11775 || 12330 <= t && t <= 12333 || 12334 <= t && t <= 12335 || 12441 <= t && t <= 12442 || 42607 == t || 42608 <= t && t <= 42610 || 42612 <= t && t <= 42621 || 42654 <= t && t <= 42655 || 42736 <= t && t <= 42737 || 43010 == t || 43014 == t || 43019 == t || 43045 <= t && t <= 43046 || 43204 <= t && t <= 43205 || 43232 <= t && t <= 43249 || 43302 <= t && t <= 43309 || 43335 <= t && t <= 43345 || 43392 <= t && t <= 43394 || 43443 == t || 43446 <= t && t <= 43449 || 43452 == t || 43493 == t || 43561 <= t && t <= 43566 || 43569 <= t && t <= 43570 || 43573 <= t && t <= 43574 || 43587 == t || 43596 == t || 43644 == t || 43696 == t || 43698 <= t && t <= 43700 || 43703 <= t && t <= 43704 || 43710 <= t && t <= 43711 || 43713 == t || 43756 <= t && t <= 43757 || 43766 == t || 44005 == t || 44008 == t || 44013 == t || 64286 == t || 65024 <= t && t <= 65039 || 65056 <= t && t <= 65071 || 65438 <= t && t <= 65439 || 66045 == t || 66272 == t || 66422 <= t && t <= 66426 || 68097 <= t && t <= 68099 || 68101 <= t && t <= 68102 || 68108 <= t && t <= 68111 || 68152 <= t && t <= 68154 || 68159 == t || 68325 <= t && t <= 68326 || 69633 == t || 69688 <= t && t <= 69702 || 69759 <= t && t <= 69761 || 69811 <= t && t <= 69814 || 69817 <= t && t <= 69818 || 69888 <= t && t <= 69890 || 69927 <= t && t <= 69931 || 69933 <= t && t <= 69940 || 70003 == t || 70016 <= t && t <= 70017 || 70070 <= t && t <= 70078 || 70090 <= t && t <= 70092 || 70191 <= t && t <= 70193 || 70196 == t || 70198 <= t && t <= 70199 || 70206 == t || 70367 == t || 70371 <= t && t <= 70378 || 70400 <= t && t <= 70401 || 70460 == t || 70462 == t || 70464 == t || 70487 == t || 70502 <= t && t <= 70508 || 70512 <= t && t <= 70516 || 70712 <= t && t <= 70719 || 70722 <= t && t <= 70724 || 70726 == t || 70832 == t || 70835 <= t && t <= 70840 || 70842 == t || 70845 == t || 70847 <= t && t <= 70848 || 70850 <= t && t <= 70851 || 71087 == t || 71090 <= t && t <= 71093 || 71100 <= t && t <= 71101 || 71103 <= t && t <= 71104 || 71132 <= t && t <= 71133 || 71219 <= t && t <= 71226 || 71229 == t || 71231 <= t && t <= 71232 || 71339 == t || 71341 == t || 71344 <= t && t <= 71349 || 71351 == t || 71453 <= t && t <= 71455 || 71458 <= t && t <= 71461 || 71463 <= t && t <= 71467 || 72193 <= t && t <= 72198 || 72201 <= t && t <= 72202 || 72243 <= t && t <= 72248 || 72251 <= t && t <= 72254 || 72263 == t || 72273 <= t && t <= 72278 || 72281 <= t && t <= 72283 || 72330 <= t && t <= 72342 || 72344 <= t && t <= 72345 || 72752 <= t && t <= 72758 || 72760 <= t && t <= 72765 || 72767 == t || 72850 <= t && t <= 72871 || 72874 <= t && t <= 72880 || 72882 <= t && t <= 72883 || 72885 <= t && t <= 72886 || 73009 <= t && t <= 73014 || 73018 == t || 73020 <= t && t <= 73021 || 73023 <= t && t <= 73029 || 73031 == t || 92912 <= t && t <= 92916 || 92976 <= t && t <= 92982 || 94095 <= t && t <= 94098 || 113821 <= t && t <= 113822 || 119141 == t || 119143 <= t && t <= 119145 || 119150 <= t && t <= 119154 || 119163 <= t && t <= 119170 || 119173 <= t && t <= 119179 || 119210 <= t && t <= 119213 || 119362 <= t && t <= 119364 || 121344 <= t && t <= 121398 || 121403 <= t && t <= 121452 || 121461 == t || 121476 == t || 121499 <= t && t <= 121503 || 121505 <= t && t <= 121519 || 122880 <= t && t <= 122886 || 122888 <= t && t <= 122904 || 122907 <= t && t <= 122913 || 122915 <= t && t <= 122916 || 122918 <= t && t <= 122922 || 125136 <= t && t <= 125142 || 125252 <= t && t <= 125258 || 917536 <= t && t <= 917631 || 917760 <= t && t <= 917999 ? 3 : 127462 <= t && t <= 127487 ? 4 : 2307 == t || 2363 == t || 2366 <= t && t <= 2368 || 2377 <= t && t <= 2380 || 2382 <= t && t <= 2383 || 2434 <= t && t <= 2435 || 2495 <= t && t <= 2496 || 2503 <= t && t <= 2504 || 2507 <= t && t <= 2508 || 2563 == t || 2622 <= t && t <= 2624 || 2691 == t || 2750 <= t && t <= 2752 || 2761 == t || 2763 <= t && t <= 2764 || 2818 <= t && t <= 2819 || 2880 == t || 2887 <= t && t <= 2888 || 2891 <= t && t <= 2892 || 3007 == t || 3009 <= t && t <= 3010 || 3014 <= t && t <= 3016 || 3018 <= t && t <= 3020 || 3073 <= t && t <= 3075 || 3137 <= t && t <= 3140 || 3202 <= t && t <= 3203 || 3262 == t || 3264 <= t && t <= 3265 || 3267 <= t && t <= 3268 || 3271 <= t && t <= 3272 || 3274 <= t && t <= 3275 || 3330 <= t && t <= 3331 || 3391 <= t && t <= 3392 || 3398 <= t && t <= 3400 || 3402 <= t && t <= 3404 || 3458 <= t && t <= 3459 || 3536 <= t && t <= 3537 || 3544 <= t && t <= 3550 || 3570 <= t && t <= 3571 || 3635 == t || 3763 == t || 3902 <= t && t <= 3903 || 3967 == t || 4145 == t || 4155 <= t && t <= 4156 || 4182 <= t && t <= 4183 || 4228 == t || 6070 == t || 6078 <= t && t <= 6085 || 6087 <= t && t <= 6088 || 6435 <= t && t <= 6438 || 6441 <= t && t <= 6443 || 6448 <= t && t <= 6449 || 6451 <= t && t <= 6456 || 6681 <= t && t <= 6682 || 6741 == t || 6743 == t || 6765 <= t && t <= 6770 || 6916 == t || 6965 == t || 6971 == t || 6973 <= t && t <= 6977 || 6979 <= t && t <= 6980 || 7042 == t || 7073 == t || 7078 <= t && t <= 7079 || 7082 == t || 7143 == t || 7146 <= t && t <= 7148 || 7150 == t || 7154 <= t && t <= 7155 || 7204 <= t && t <= 7211 || 7220 <= t && t <= 7221 || 7393 == t || 7410 <= t && t <= 7411 || 7415 == t || 43043 <= t && t <= 43044 || 43047 == t || 43136 <= t && t <= 43137 || 43188 <= t && t <= 43203 || 43346 <= t && t <= 43347 || 43395 == t || 43444 <= t && t <= 43445 || 43450 <= t && t <= 43451 || 43453 <= t && t <= 43456 || 43567 <= t && t <= 43568 || 43571 <= t && t <= 43572 || 43597 == t || 43755 == t || 43758 <= t && t <= 43759 || 43765 == t || 44003 <= t && t <= 44004 || 44006 <= t && t <= 44007 || 44009 <= t && t <= 44010 || 44012 == t || 69632 == t || 69634 == t || 69762 == t || 69808 <= t && t <= 69810 || 69815 <= t && t <= 69816 || 69932 == t || 70018 == t || 70067 <= t && t <= 70069 || 70079 <= t && t <= 70080 || 70188 <= t && t <= 70190 || 70194 <= t && t <= 70195 || 70197 == t || 70368 <= t && t <= 70370 || 70402 <= t && t <= 70403 || 70463 == t || 70465 <= t && t <= 70468 || 70471 <= t && t <= 70472 || 70475 <= t && t <= 70477 || 70498 <= t && t <= 70499 || 70709 <= t && t <= 70711 || 70720 <= t && t <= 70721 || 70725 == t || 70833 <= t && t <= 70834 || 70841 == t || 70843 <= t && t <= 70844 || 70846 == t || 70849 == t || 71088 <= t && t <= 71089 || 71096 <= t && t <= 71099 || 71102 == t || 71216 <= t && t <= 71218 || 71227 <= t && t <= 71228 || 71230 == t || 71340 == t || 71342 <= t && t <= 71343 || 71350 == t || 71456 <= t && t <= 71457 || 71462 == t || 72199 <= t && t <= 72200 || 72249 == t || 72279 <= t && t <= 72280 || 72343 == t || 72751 == t || 72766 == t || 72873 == t || 72881 == t || 72884 == t || 94033 <= t && t <= 94078 || 119142 == t || 119149 == t ? 5 : 4352 <= t && t <= 4447 || 43360 <= t && t <= 43388 ? 6 : 4448 <= t && t <= 4519 || 55216 <= t && t <= 55238 ? 7 : 4520 <= t && t <= 4607 || 55243 <= t && t <= 55291 ? 8 : 44032 == t || 44060 == t || 44088 == t || 44116 == t || 44144 == t || 44172 == t || 44200 == t || 44228 == t || 44256 == t || 44284 == t || 44312 == t || 44340 == t || 44368 == t || 44396 == t || 44424 == t || 44452 == t || 44480 == t || 44508 == t || 44536 == t || 44564 == t || 44592 == t || 44620 == t || 44648 == t || 44676 == t || 44704 == t || 44732 == t || 44760 == t || 44788 == t || 44816 == t || 44844 == t || 44872 == t || 44900 == t || 44928 == t || 44956 == t || 44984 == t || 45012 == t || 45040 == t || 45068 == t || 45096 == t || 45124 == t || 45152 == t || 45180 == t || 45208 == t || 45236 == t || 45264 == t || 45292 == t || 45320 == t || 45348 == t || 45376 == t || 45404 == t || 45432 == t || 45460 == t || 45488 == t || 45516 == t || 45544 == t || 45572 == t || 45600 == t || 45628 == t || 45656 == t || 45684 == t || 45712 == t || 45740 == t || 45768 == t || 45796 == t || 45824 == t || 45852 == t || 45880 == t || 45908 == t || 45936 == t || 45964 == t || 45992 == t || 46020 == t || 46048 == t || 46076 == t || 46104 == t || 46132 == t || 46160 == t || 46188 == t || 46216 == t || 46244 == t || 46272 == t || 46300 == t || 46328 == t || 46356 == t || 46384 == t || 46412 == t || 46440 == t || 46468 == t || 46496 == t || 46524 == t || 46552 == t || 46580 == t || 46608 == t || 46636 == t || 46664 == t || 46692 == t || 46720 == t || 46748 == t || 46776 == t || 46804 == t || 46832 == t || 46860 == t || 46888 == t || 46916 == t || 46944 == t || 46972 == t || 47e3 == t || 47028 == t || 47056 == t || 47084 == t || 47112 == t || 47140 == t || 47168 == t || 47196 == t || 47224 == t || 47252 == t || 47280 == t || 47308 == t || 47336 == t || 47364 == t || 47392 == t || 47420 == t || 47448 == t || 47476 == t || 47504 == t || 47532 == t || 47560 == t || 47588 == t || 47616 == t || 47644 == t || 47672 == t || 47700 == t || 47728 == t || 47756 == t || 47784 == t || 47812 == t || 47840 == t || 47868 == t || 47896 == t || 47924 == t || 47952 == t || 47980 == t || 48008 == t || 48036 == t || 48064 == t || 48092 == t || 48120 == t || 48148 == t || 48176 == t || 48204 == t || 48232 == t || 48260 == t || 48288 == t || 48316 == t || 48344 == t || 48372 == t || 48400 == t || 48428 == t || 48456 == t || 48484 == t || 48512 == t || 48540 == t || 48568 == t || 48596 == t || 48624 == t || 48652 == t || 48680 == t || 48708 == t || 48736 == t || 48764 == t || 48792 == t || 48820 == t || 48848 == t || 48876 == t || 48904 == t || 48932 == t || 48960 == t || 48988 == t || 49016 == t || 49044 == t || 49072 == t || 49100 == t || 49128 == t || 49156 == t || 49184 == t || 49212 == t || 49240 == t || 49268 == t || 49296 == t || 49324 == t || 49352 == t || 49380 == t || 49408 == t || 49436 == t || 49464 == t || 49492 == t || 49520 == t || 49548 == t || 49576 == t || 49604 == t || 49632 == t || 49660 == t || 49688 == t || 49716 == t || 49744 == t || 49772 == t || 49800 == t || 49828 == t || 49856 == t || 49884 == t || 49912 == t || 49940 == t || 49968 == t || 49996 == t || 50024 == t || 50052 == t || 50080 == t || 50108 == t || 50136 == t || 50164 == t || 50192 == t || 50220 == t || 50248 == t || 50276 == t || 50304 == t || 50332 == t || 50360 == t || 50388 == t || 50416 == t || 50444 == t || 50472 == t || 50500 == t || 50528 == t || 50556 == t || 50584 == t || 50612 == t || 50640 == t || 50668 == t || 50696 == t || 50724 == t || 50752 == t || 50780 == t || 50808 == t || 50836 == t || 50864 == t || 50892 == t || 50920 == t || 50948 == t || 50976 == t || 51004 == t || 51032 == t || 51060 == t || 51088 == t || 51116 == t || 51144 == t || 51172 == t || 51200 == t || 51228 == t || 51256 == t || 51284 == t || 51312 == t || 51340 == t || 51368 == t || 51396 == t || 51424 == t || 51452 == t || 51480 == t || 51508 == t || 51536 == t || 51564 == t || 51592 == t || 51620 == t || 51648 == t || 51676 == t || 51704 == t || 51732 == t || 51760 == t || 51788 == t || 51816 == t || 51844 == t || 51872 == t || 51900 == t || 51928 == t || 51956 == t || 51984 == t || 52012 == t || 52040 == t || 52068 == t || 52096 == t || 52124 == t || 52152 == t || 52180 == t || 52208 == t || 52236 == t || 52264 == t || 52292 == t || 52320 == t || 52348 == t || 52376 == t || 52404 == t || 52432 == t || 52460 == t || 52488 == t || 52516 == t || 52544 == t || 52572 == t || 52600 == t || 52628 == t || 52656 == t || 52684 == t || 52712 == t || 52740 == t || 52768 == t || 52796 == t || 52824 == t || 52852 == t || 52880 == t || 52908 == t || 52936 == t || 52964 == t || 52992 == t || 53020 == t || 53048 == t || 53076 == t || 53104 == t || 53132 == t || 53160 == t || 53188 == t || 53216 == t || 53244 == t || 53272 == t || 53300 == t || 53328 == t || 53356 == t || 53384 == t || 53412 == t || 53440 == t || 53468 == t || 53496 == t || 53524 == t || 53552 == t || 53580 == t || 53608 == t || 53636 == t || 53664 == t || 53692 == t || 53720 == t || 53748 == t || 53776 == t || 53804 == t || 53832 == t || 53860 == t || 53888 == t || 53916 == t || 53944 == t || 53972 == t || 54e3 == t || 54028 == t || 54056 == t || 54084 == t || 54112 == t || 54140 == t || 54168 == t || 54196 == t || 54224 == t || 54252 == t || 54280 == t || 54308 == t || 54336 == t || 54364 == t || 54392 == t || 54420 == t || 54448 == t || 54476 == t || 54504 == t || 54532 == t || 54560 == t || 54588 == t || 54616 == t || 54644 == t || 54672 == t || 54700 == t || 54728 == t || 54756 == t || 54784 == t || 54812 == t || 54840 == t || 54868 == t || 54896 == t || 54924 == t || 54952 == t || 54980 == t || 55008 == t || 55036 == t || 55064 == t || 55092 == t || 55120 == t || 55148 == t || 55176 == t ? 9 : 44033 <= t && t <= 44059 || 44061 <= t && t <= 44087 || 44089 <= t && t <= 44115 || 44117 <= t && t <= 44143 || 44145 <= t && t <= 44171 || 44173 <= t && t <= 44199 || 44201 <= t && t <= 44227 || 44229 <= t && t <= 44255 || 44257 <= t && t <= 44283 || 44285 <= t && t <= 44311 || 44313 <= t && t <= 44339 || 44341 <= t && t <= 44367 || 44369 <= t && t <= 44395 || 44397 <= t && t <= 44423 || 44425 <= t && t <= 44451 || 44453 <= t && t <= 44479 || 44481 <= t && t <= 44507 || 44509 <= t && t <= 44535 || 44537 <= t && t <= 44563 || 44565 <= t && t <= 44591 || 44593 <= t && t <= 44619 || 44621 <= t && t <= 44647 || 44649 <= t && t <= 44675 || 44677 <= t && t <= 44703 || 44705 <= t && t <= 44731 || 44733 <= t && t <= 44759 || 44761 <= t && t <= 44787 || 44789 <= t && t <= 44815 || 44817 <= t && t <= 44843 || 44845 <= t && t <= 44871 || 44873 <= t && t <= 44899 || 44901 <= t && t <= 44927 || 44929 <= t && t <= 44955 || 44957 <= t && t <= 44983 || 44985 <= t && t <= 45011 || 45013 <= t && t <= 45039 || 45041 <= t && t <= 45067 || 45069 <= t && t <= 45095 || 45097 <= t && t <= 45123 || 45125 <= t && t <= 45151 || 45153 <= t && t <= 45179 || 45181 <= t && t <= 45207 || 45209 <= t && t <= 45235 || 45237 <= t && t <= 45263 || 45265 <= t && t <= 45291 || 45293 <= t && t <= 45319 || 45321 <= t && t <= 45347 || 45349 <= t && t <= 45375 || 45377 <= t && t <= 45403 || 45405 <= t && t <= 45431 || 45433 <= t && t <= 45459 || 45461 <= t && t <= 45487 || 45489 <= t && t <= 45515 || 45517 <= t && t <= 45543 || 45545 <= t && t <= 45571 || 45573 <= t && t <= 45599 || 45601 <= t && t <= 45627 || 45629 <= t && t <= 45655 || 45657 <= t && t <= 45683 || 45685 <= t && t <= 45711 || 45713 <= t && t <= 45739 || 45741 <= t && t <= 45767 || 45769 <= t && t <= 45795 || 45797 <= t && t <= 45823 || 45825 <= t && t <= 45851 || 45853 <= t && t <= 45879 || 45881 <= t && t <= 45907 || 45909 <= t && t <= 45935 || 45937 <= t && t <= 45963 || 45965 <= t && t <= 45991 || 45993 <= t && t <= 46019 || 46021 <= t && t <= 46047 || 46049 <= t && t <= 46075 || 46077 <= t && t <= 46103 || 46105 <= t && t <= 46131 || 46133 <= t && t <= 46159 || 46161 <= t && t <= 46187 || 46189 <= t && t <= 46215 || 46217 <= t && t <= 46243 || 46245 <= t && t <= 46271 || 46273 <= t && t <= 46299 || 46301 <= t && t <= 46327 || 46329 <= t && t <= 46355 || 46357 <= t && t <= 46383 || 46385 <= t && t <= 46411 || 46413 <= t && t <= 46439 || 46441 <= t && t <= 46467 || 46469 <= t && t <= 46495 || 46497 <= t && t <= 46523 || 46525 <= t && t <= 46551 || 46553 <= t && t <= 46579 || 46581 <= t && t <= 46607 || 46609 <= t && t <= 46635 || 46637 <= t && t <= 46663 || 46665 <= t && t <= 46691 || 46693 <= t && t <= 46719 || 46721 <= t && t <= 46747 || 46749 <= t && t <= 46775 || 46777 <= t && t <= 46803 || 46805 <= t && t <= 46831 || 46833 <= t && t <= 46859 || 46861 <= t && t <= 46887 || 46889 <= t && t <= 46915 || 46917 <= t && t <= 46943 || 46945 <= t && t <= 46971 || 46973 <= t && t <= 46999 || 47001 <= t && t <= 47027 || 47029 <= t && t <= 47055 || 47057 <= t && t <= 47083 || 47085 <= t && t <= 47111 || 47113 <= t && t <= 47139 || 47141 <= t && t <= 47167 || 47169 <= t && t <= 47195 || 47197 <= t && t <= 47223 || 47225 <= t && t <= 47251 || 47253 <= t && t <= 47279 || 47281 <= t && t <= 47307 || 47309 <= t && t <= 47335 || 47337 <= t && t <= 47363 || 47365 <= t && t <= 47391 || 47393 <= t && t <= 47419 || 47421 <= t && t <= 47447 || 47449 <= t && t <= 47475 || 47477 <= t && t <= 47503 || 47505 <= t && t <= 47531 || 47533 <= t && t <= 47559 || 47561 <= t && t <= 47587 || 47589 <= t && t <= 47615 || 47617 <= t && t <= 47643 || 47645 <= t && t <= 47671 || 47673 <= t && t <= 47699 || 47701 <= t && t <= 47727 || 47729 <= t && t <= 47755 || 47757 <= t && t <= 47783 || 47785 <= t && t <= 47811 || 47813 <= t && t <= 47839 || 47841 <= t && t <= 47867 || 47869 <= t && t <= 47895 || 47897 <= t && t <= 47923 || 47925 <= t && t <= 47951 || 47953 <= t && t <= 47979 || 47981 <= t && t <= 48007 || 48009 <= t && t <= 48035 || 48037 <= t && t <= 48063 || 48065 <= t && t <= 48091 || 48093 <= t && t <= 48119 || 48121 <= t && t <= 48147 || 48149 <= t && t <= 48175 || 48177 <= t && t <= 48203 || 48205 <= t && t <= 48231 || 48233 <= t && t <= 48259 || 48261 <= t && t <= 48287 || 48289 <= t && t <= 48315 || 48317 <= t && t <= 48343 || 48345 <= t && t <= 48371 || 48373 <= t && t <= 48399 || 48401 <= t && t <= 48427 || 48429 <= t && t <= 48455 || 48457 <= t && t <= 48483 || 48485 <= t && t <= 48511 || 48513 <= t && t <= 48539 || 48541 <= t && t <= 48567 || 48569 <= t && t <= 48595 || 48597 <= t && t <= 48623 || 48625 <= t && t <= 48651 || 48653 <= t && t <= 48679 || 48681 <= t && t <= 48707 || 48709 <= t && t <= 48735 || 48737 <= t && t <= 48763 || 48765 <= t && t <= 48791 || 48793 <= t && t <= 48819 || 48821 <= t && t <= 48847 || 48849 <= t && t <= 48875 || 48877 <= t && t <= 48903 || 48905 <= t && t <= 48931 || 48933 <= t && t <= 48959 || 48961 <= t && t <= 48987 || 48989 <= t && t <= 49015 || 49017 <= t && t <= 49043 || 49045 <= t && t <= 49071 || 49073 <= t && t <= 49099 || 49101 <= t && t <= 49127 || 49129 <= t && t <= 49155 || 49157 <= t && t <= 49183 || 49185 <= t && t <= 49211 || 49213 <= t && t <= 49239 || 49241 <= t && t <= 49267 || 49269 <= t && t <= 49295 || 49297 <= t && t <= 49323 || 49325 <= t && t <= 49351 || 49353 <= t && t <= 49379 || 49381 <= t && t <= 49407 || 49409 <= t && t <= 49435 || 49437 <= t && t <= 49463 || 49465 <= t && t <= 49491 || 49493 <= t && t <= 49519 || 49521 <= t && t <= 49547 || 49549 <= t && t <= 49575 || 49577 <= t && t <= 49603 || 49605 <= t && t <= 49631 || 49633 <= t && t <= 49659 || 49661 <= t && t <= 49687 || 49689 <= t && t <= 49715 || 49717 <= t && t <= 49743 || 49745 <= t && t <= 49771 || 49773 <= t && t <= 49799 || 49801 <= t && t <= 49827 || 49829 <= t && t <= 49855 || 49857 <= t && t <= 49883 || 49885 <= t && t <= 49911 || 49913 <= t && t <= 49939 || 49941 <= t && t <= 49967 || 49969 <= t && t <= 49995 || 49997 <= t && t <= 50023 || 50025 <= t && t <= 50051 || 50053 <= t && t <= 50079 || 50081 <= t && t <= 50107 || 50109 <= t && t <= 50135 || 50137 <= t && t <= 50163 || 50165 <= t && t <= 50191 || 50193 <= t && t <= 50219 || 50221 <= t && t <= 50247 || 50249 <= t && t <= 50275 || 50277 <= t && t <= 50303 || 50305 <= t && t <= 50331 || 50333 <= t && t <= 50359 || 50361 <= t && t <= 50387 || 50389 <= t && t <= 50415 || 50417 <= t && t <= 50443 || 50445 <= t && t <= 50471 || 50473 <= t && t <= 50499 || 50501 <= t && t <= 50527 || 50529 <= t && t <= 50555 || 50557 <= t && t <= 50583 || 50585 <= t && t <= 50611 || 50613 <= t && t <= 50639 || 50641 <= t && t <= 50667 || 50669 <= t && t <= 50695 || 50697 <= t && t <= 50723 || 50725 <= t && t <= 50751 || 50753 <= t && t <= 50779 || 50781 <= t && t <= 50807 || 50809 <= t && t <= 50835 || 50837 <= t && t <= 50863 || 50865 <= t && t <= 50891 || 50893 <= t && t <= 50919 || 50921 <= t && t <= 50947 || 50949 <= t && t <= 50975 || 50977 <= t && t <= 51003 || 51005 <= t && t <= 51031 || 51033 <= t && t <= 51059 || 51061 <= t && t <= 51087 || 51089 <= t && t <= 51115 || 51117 <= t && t <= 51143 || 51145 <= t && t <= 51171 || 51173 <= t && t <= 51199 || 51201 <= t && t <= 51227 || 51229 <= t && t <= 51255 || 51257 <= t && t <= 51283 || 51285 <= t && t <= 51311 || 51313 <= t && t <= 51339 || 51341 <= t && t <= 51367 || 51369 <= t && t <= 51395 || 51397 <= t && t <= 51423 || 51425 <= t && t <= 51451 || 51453 <= t && t <= 51479 || 51481 <= t && t <= 51507 || 51509 <= t && t <= 51535 || 51537 <= t && t <= 51563 || 51565 <= t && t <= 51591 || 51593 <= t && t <= 51619 || 51621 <= t && t <= 51647 || 51649 <= t && t <= 51675 || 51677 <= t && t <= 51703 || 51705 <= t && t <= 51731 || 51733 <= t && t <= 51759 || 51761 <= t && t <= 51787 || 51789 <= t && t <= 51815 || 51817 <= t && t <= 51843 || 51845 <= t && t <= 51871 || 51873 <= t && t <= 51899 || 51901 <= t && t <= 51927 || 51929 <= t && t <= 51955 || 51957 <= t && t <= 51983 || 51985 <= t && t <= 52011 || 52013 <= t && t <= 52039 || 52041 <= t && t <= 52067 || 52069 <= t && t <= 52095 || 52097 <= t && t <= 52123 || 52125 <= t && t <= 52151 || 52153 <= t && t <= 52179 || 52181 <= t && t <= 52207 || 52209 <= t && t <= 52235 || 52237 <= t && t <= 52263 || 52265 <= t && t <= 52291 || 52293 <= t && t <= 52319 || 52321 <= t && t <= 52347 || 52349 <= t && t <= 52375 || 52377 <= t && t <= 52403 || 52405 <= t && t <= 52431 || 52433 <= t && t <= 52459 || 52461 <= t && t <= 52487 || 52489 <= t && t <= 52515 || 52517 <= t && t <= 52543 || 52545 <= t && t <= 52571 || 52573 <= t && t <= 52599 || 52601 <= t && t <= 52627 || 52629 <= t && t <= 52655 || 52657 <= t && t <= 52683 || 52685 <= t && t <= 52711 || 52713 <= t && t <= 52739 || 52741 <= t && t <= 52767 || 52769 <= t && t <= 52795 || 52797 <= t && t <= 52823 || 52825 <= t && t <= 52851 || 52853 <= t && t <= 52879 || 52881 <= t && t <= 52907 || 52909 <= t && t <= 52935 || 52937 <= t && t <= 52963 || 52965 <= t && t <= 52991 || 52993 <= t && t <= 53019 || 53021 <= t && t <= 53047 || 53049 <= t && t <= 53075 || 53077 <= t && t <= 53103 || 53105 <= t && t <= 53131 || 53133 <= t && t <= 53159 || 53161 <= t && t <= 53187 || 53189 <= t && t <= 53215 || 53217 <= t && t <= 53243 || 53245 <= t && t <= 53271 || 53273 <= t && t <= 53299 || 53301 <= t && t <= 53327 || 53329 <= t && t <= 53355 || 53357 <= t && t <= 53383 || 53385 <= t && t <= 53411 || 53413 <= t && t <= 53439 || 53441 <= t && t <= 53467 || 53469 <= t && t <= 53495 || 53497 <= t && t <= 53523 || 53525 <= t && t <= 53551 || 53553 <= t && t <= 53579 || 53581 <= t && t <= 53607 || 53609 <= t && t <= 53635 || 53637 <= t && t <= 53663 || 53665 <= t && t <= 53691 || 53693 <= t && t <= 53719 || 53721 <= t && t <= 53747 || 53749 <= t && t <= 53775 || 53777 <= t && t <= 53803 || 53805 <= t && t <= 53831 || 53833 <= t && t <= 53859 || 53861 <= t && t <= 53887 || 53889 <= t && t <= 53915 || 53917 <= t && t <= 53943 || 53945 <= t && t <= 53971 || 53973 <= t && t <= 53999 || 54001 <= t && t <= 54027 || 54029 <= t && t <= 54055 || 54057 <= t && t <= 54083 || 54085 <= t && t <= 54111 || 54113 <= t && t <= 54139 || 54141 <= t && t <= 54167 || 54169 <= t && t <= 54195 || 54197 <= t && t <= 54223 || 54225 <= t && t <= 54251 || 54253 <= t && t <= 54279 || 54281 <= t && t <= 54307 || 54309 <= t && t <= 54335 || 54337 <= t && t <= 54363 || 54365 <= t && t <= 54391 || 54393 <= t && t <= 54419 || 54421 <= t && t <= 54447 || 54449 <= t && t <= 54475 || 54477 <= t && t <= 54503 || 54505 <= t && t <= 54531 || 54533 <= t && t <= 54559 || 54561 <= t && t <= 54587 || 54589 <= t && t <= 54615 || 54617 <= t && t <= 54643 || 54645 <= t && t <= 54671 || 54673 <= t && t <= 54699 || 54701 <= t && t <= 54727 || 54729 <= t && t <= 54755 || 54757 <= t && t <= 54783 || 54785 <= t && t <= 54811 || 54813 <= t && t <= 54839 || 54841 <= t && t <= 54867 || 54869 <= t && t <= 54895 || 54897 <= t && t <= 54923 || 54925 <= t && t <= 54951 || 54953 <= t && t <= 54979 || 54981 <= t && t <= 55007 || 55009 <= t && t <= 55035 || 55037 <= t && t <= 55063 || 55065 <= t && t <= 55091 || 55093 <= t && t <= 55119 || 55121 <= t && t <= 55147 || 55149 <= t && t <= 55175 || 55177 <= t && t <= 55203 ? 10 : 9757 == t || 9977 == t || 9994 <= t && t <= 9997 || 127877 == t || 127938 <= t && t <= 127940 || 127943 == t || 127946 <= t && t <= 127948 || 128066 <= t && t <= 128067 || 128070 <= t && t <= 128080 || 128110 == t || 128112 <= t && t <= 128120 || 128124 == t || 128129 <= t && t <= 128131 || 128133 <= t && t <= 128135 || 128170 == t || 128372 <= t && t <= 128373 || 128378 == t || 128400 == t || 128405 <= t && t <= 128406 || 128581 <= t && t <= 128583 || 128587 <= t && t <= 128591 || 128675 == t || 128692 <= t && t <= 128694 || 128704 == t || 128716 == t || 129304 <= t && t <= 129308 || 129310 <= t && t <= 129311 || 129318 == t || 129328 <= t && t <= 129337 || 129341 <= t && t <= 129342 || 129489 <= t && t <= 129501 ? 13 : 127995 <= t && t <= 127999 ? 14 : 8205 == t ? 15 : 9792 == t || 9794 == t || 9877 <= t && t <= 9878 || 9992 == t || 10084 == t || 127752 == t || 127806 == t || 127859 == t || 127891 == t || 127908 == t || 127912 == t || 127979 == t || 127981 == t || 128139 == t || 128187 <= t && t <= 128188 || 128295 == t || 128300 == t || 128488 == t || 128640 == t || 128658 == t ? 16 : 128102 <= t && t <= 128105 ? 17 : 11;
        }
        return this._$nextBreak$_ = function(t, s) {
            if ((s = void 0 === s ? 0 : s) < 0) return 0;
            if (!(s >= t.length - 1)) {
                var i, e, h, r, n, o = f(c(t, s)), a = [];
                for (s += 1; s < t.length; s++) {
                    var l = t, u = s - 1;
                    if (!(55296 <= l.charCodeAt(u) && l.charCodeAt(u) <= 56319 && 56320 <= l.charCodeAt(1 + u) && l.charCodeAt(1 + u) <= 57343)) {
                        if (l = f(c(t, s)), u = l, n = r = h = void 0, h = [ i = o ].concat(e = a).concat([ u ]), 
                        r = h[h.length - 2], 1 < (n = h.lastIndexOf(14)) && h.slice(1, n).every(function(t) {
                            return 3 == t;
                        }) && -1 == [ 3, 13, 17 ].indexOf(i) || (0 < (i = h.lastIndexOf(4)) && h.slice(1, i).every(function(t) {
                            return 4 == t;
                        }) && -1 == [ 12, 4 ].indexOf(r) ? (h.filter(function(t) {
                            return 4 == t;
                        }).length, 1) : (0 != r || 1 != u) && (2 == r || 0 == r || 1 == r ? (14 == u && e.every(function(t) {
                            return 3 == t;
                        }), 1) : 2 == u || 0 == u || 1 == u || (6 != r || 6 != u && 7 != u && 9 != u && 10 != u) && (9 != r && 7 != r || 7 != u && 8 != u) && (10 != r && 8 != r || 8 != u) && 3 != u && 15 != u && 5 != u && 12 != r && (i = -1 != h.indexOf(3) ? h.lastIndexOf(3) - 1 : h.length - 2, 
                        !(-1 != [ 13, 17 ].indexOf(h[i]) && h.slice(i + 1, -1).every(function(t) {
                            return 3 == t;
                        }) && 14 == u || 15 == r && -1 != [ 16, 17 ].indexOf(u) || -1 == e.indexOf(4) && 4 == r && 4 == u))))) return s;
                        a.push(l);
                    }
                }
            }
            return t.length;
        }, this._$splitGraphemes$_ = function(t) {
            for (var s, i = [], e = 0; (s = this._$nextBreak$_(t, e)) < t.length; ) i.push(t.slice(e, s)), 
            e = s;
            return e < t.length && i.push(t.slice(e)), i;
        }, this._$iterateGraphemes$_ = function(i) {
            var e = 0, t = {
                next: function() {
                    var t, s;
                    return (t = this._$nextBreak$_(i, e)) < i.length ? (s = i.slice(e, t), 
                    e = t, {
                        value: s,
                        done: !1
                    }) : e < i.length ? (s = i.slice(e), e = i.length, {
                        value: s,
                        done: !1
                    }) : {
                        value: void 0,
                        done: !0
                    };
                }.bind(this)
            };
            return "undefined" != typeof Symbol && Symbol.iterator && (t[Symbol.iterator] = function() {
                return t;
            }), t;
        }, this._$countGraphemes$_ = function(t) {
            for (var s, i = 0, e = 0; (s = this._$nextBreak$_(t, e)) < t.length; ) e = s, 
            i++;
            return e < t.length && i++, i;
        }, this;
    };
    self._$GraphemeSplitter$_ = t;
}

{
    let a = function(t, s, i) {
        i = i || 0;
        var e = [ 0, 0 ], h = t[1][1] - t[0][1], r = t[0][0] - t[1][0], t = h * t[0][0] + r * t[0][1], n = s[1][1] - s[0][1], o = s[0][0] - s[1][0], s = n * s[0][0] + o * s[0][1], a = h * o - n * r;
        return m(a, 0, i) || (e[0] = (o * t - r * s) / a, e[1] = (h * s - n * t) / a), 
        e;
    }, h = function(t, s, i, e) {
        var h, r = s[0] - t[0], s = s[1] - t[1], n = e[0] - i[0], e = e[1] - i[1];
        return n * s - e * r != 0 && (h = (n * (t[1] - i[1]) + e * (i[0] - t[0])) / (e * r - n * s), 
        0 <= (t = (r * (i[1] - t[1]) + s * (t[0] - i[0])) / (n * s - e * r))) && t <= 1 && 0 <= h && h <= 1;
    }, o = function(t, s, i) {
        return (s[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (s[1] - t[1]);
    }, x = function(t, s, i) {
        return 0 < o(t, s, i);
    }, G = function(t, s, i) {
        return 0 <= o(t, s, i);
    }, T = function(t, s, i) {
        return o(t, s, i) < 0;
    }, _ = function(t, s, i) {
        return o(t, s, i) <= 0;
    }, r = function(t, s, i, e) {
        var h, r, n;
        return e ? (n = D, (r = O)[0] = s[0] - t[0], r[1] = s[1] - t[1], n[0] = i[0] - s[0], 
        n[1] = i[1] - s[1], h = r[0] * n[0] + r[1] * n[1], r = Math.sqrt(r[0] * r[0] + r[1] * r[1]), 
        n = Math.sqrt(n[0] * n[0] + n[1] * n[1]), Math.acos(h / (r * n)) < e) : 0 === o(t, s, i);
    }, I = function(t, s) {
        var i = s[0] - t[0], s = s[1] - t[1];
        return i * i + s * s;
    }, C = function(t, s) {
        var i = t.length;
        return t[s < 0 ? s % i + i : s % i];
    }, n = function(t) {
        t.length = 0;
    }, R = function(t, s, i, e) {
        for (var h = i; h < e; h++) t.push(s[h]);
    }, t = function(t) {
        for (var s = 0, i = t, e = 1; e < t.length; ++e) (i[e][1] < i[s][1] || i[e][1] === i[s][1] && i[e][0] > i[s][0]) && (s = e);
        return !x(C(t, s - 1), C(t, s), C(t, s + 1)) && (l(t), !0);
    }, l = function(t) {
        for (var s = [], i = t.length, e = 0; e !== i; e++) s.push(t.pop());
        for (e = 0; e !== i; e++) t[e] = s[e];
    }, P = function(t, s) {
        return T(C(t, s - 1), C(t, s), C(t, s + 1));
    }, u = function(t, s, i) {
        var e, h = k, r = L;
        if (G(C(t, s + 1), C(t, s), C(t, i)) && _(C(t, s - 1), C(t, s), C(t, i))) return !1;
        for (var n = I(C(t, s), C(t, i)), o = 0; o !== t.length; ++o) if ((o + 1) % t.length !== s && o !== s && G(C(t, s), C(t, i), C(t, o + 1)) && _(C(t, s), C(t, i), C(t, o)) && (h[0] = C(t, s), 
        h[1] = C(t, i), r[0] = C(t, o), r[1] = C(t, o + 1), e = a(h, r), I(C(t, s), e) < n)) return !1;
        return !0;
    }, E = function(t, s, i) {
        for (var e = 0; e !== t.length; ++e) if (e !== s && e !== i && (e + 1) % t.length !== s && (e + 1) % t.length !== i && h(C(t, s), C(t, i), C(t, e), C(t, e + 1))) return !1;
        return !0;
    }, c = function(t, s, i, e) {
        var h = e || [];
        if (n(h), s < i) for (var r = s; r <= i; r++) h.push(t[r]); else {
            for (r = 0; r <= i; r++) h.push(t[r]);
            for (r = s; r < t.length; r++) h.push(t[r]);
        }
        return h;
    }, f = function(t) {
        for (var s = [], i = [], e = [], h = Number.MAX_VALUE, r = 0; r < t.length; ++r) if (P(t, r)) for (var n = 0; n < t.length; ++n) if (u(t, r, n)) {
            for (var i = f(c(t, r, n, e)), o = f(c(t, n, r, e)), a = 0; a < o.length; a++) i.push(o[a]);
            i.length < h && (h = (s = i).length, s.push([ C(t, r), C(t, n) ]));
        }
        return s;
    }, s = function(t) {
        var s = f(t);
        return 0 < s.length ? d(t, s) : [ t ];
    }, d = function(t, s) {
        if (0 === s.length) return [ t ];
        if (s instanceof Array && s.length && s[0] instanceof Array && 2 === s[0].length && s[0][0] instanceof Array) {
            for (var i = [ t ], e = 0; e < s.length; e++) for (var h = s[e], r = 0; r < i.length; r++) {
                var n = i[r], n = d(n, h);
                if (n) {
                    i.splice(r, 1), i.push(n[0], n[1]);
                    break;
                }
            }
            return i;
        }
        return e = t.indexOf((h = s)[0]), r = t.indexOf(h[1]), -1 !== e && -1 !== r && [ c(t, e, r), c(t, r, e) ];
    }, i = function(t) {
        for (var s = t, i = 0; i < s.length - 1; i++) for (var e = 0; e < i - 1; e++) if (h(s[i], s[i + 1], s[e], s[e + 1])) return !1;
        for (i = 1; i < s.length - 2; i++) if (h(s[0], s[s.length - 1], s[i], s[i + 1])) return !1;
        return !0;
    }, A = function(t, s, i, e, h) {
        h = h || 0;
        var r = s[1] - t[1], s = t[0] - s[0], t = r * t[0] + s * t[1], n = e[1] - i[1], e = i[0] - e[0], i = n * i[0] + e * i[1], o = r * e - n * s;
        return m(o, 0, h) ? [ 0, 0 ] : [ (e * t - s * i) / o, (r * i - n * t) / o ];
    }, F = function(t, s, i, e, h, r, n) {
        r = r || 100, n = n || 0, h = h || 25, s = void 0 !== s ? s : [], i = i || [], 
        e = e || [];
        var o = [ 0, 0 ], a = [ 0, 0 ], l = [ 0, 0 ], u = 0, c = 0, f = 0, d = 0, p = 0, m = 0, g = 0, y = [], w = [], S = t, b = t;
        if (!(b.length < 3)) if (r < ++n) console.warn("quickDecomp: max level (" + r + ") reached."); else {
            for (var M = 0; M < t.length; ++M) if (P(S, M)) {
                i.push(S[M]);
                for (var u = c = Number.MAX_VALUE, v = 0; v < t.length; ++v) x(C(S, M - 1), C(S, M), C(S, v)) && _(C(S, M - 1), C(S, M), C(S, v - 1)) && (l = A(C(S, M - 1), C(S, M), C(S, v), C(S, v - 1)), 
                T(C(S, M + 1), C(S, M), l)) && (f = I(S[M], l)) < c && (c = f, a = l, 
                m = v), x(C(S, M + 1), C(S, M), C(S, v + 1)) && _(C(S, M + 1), C(S, M), C(S, v)) && (l = A(C(S, M + 1), C(S, M), C(S, v), C(S, v + 1)), 
                x(C(S, M - 1), C(S, M), l)) && (f = I(S[M], l)) < u && (u = f, o = l, 
                p = v);
                if (m === (p + 1) % t.length) l[0] = (a[0] + o[0]) / 2, l[1] = (a[1] + o[1]) / 2, 
                e.push(l), M < p ? (R(y, S, M, p + 1), y.push(l), w.push(l), 0 !== m && R(w, S, m, S.length), 
                R(w, S, 0, M + 1)) : (0 !== M && R(y, S, M, S.length), R(y, S, 0, p + 1), 
                y.push(l), w.push(l), R(w, S, m, M + 1)); else {
                    if (p < m && (p += t.length), d = Number.MAX_VALUE, p < m) return s;
                    for (v = m; v <= p; ++v) G(C(S, M - 1), C(S, M), C(S, v)) && _(C(S, M + 1), C(S, M), C(S, v)) && (f = I(C(S, M), C(S, v))) < d && E(S, M, v) && (d = f, 
                    g = v % t.length);
                    M < g ? (R(y, S, M, g + 1), 0 !== g && R(w, S, g, b.length), 
                    R(w, S, 0, M + 1)) : (0 !== M && R(y, S, M, b.length), R(y, S, 0, g + 1), 
                    R(w, S, g, M + 1));
                }
                return y.length < w.length ? (F(y, s, i, e, h, r, n), F(w, s, i, e, h, r, n)) : (F(w, s, i, e, h, r, n), 
                F(y, s, i, e, h, r, n)), s;
            }
            s.push(t);
        }
        return s;
    }, e = function(t, s) {
        for (var i = 0, e = t.length - 1; 3 < t.length && 0 <= e; --e) r(C(t, e - 1), C(t, e), C(t, e + 1), s) && (t.splice(e % t.length, 1), 
        i++);
        return i;
    }, p = function(t, s) {
        for (var i = t.length - 1; 1 <= i; --i) for (var e = t[i], h = i - 1; 0 <= h; --h) if (g(e, t[h], s)) {
            t.splice(i, 1);
            continue;
        }
    }, m = function(t, s, i) {
        return i = i || 0, Math.abs(t - s) <= i;
    }, g = function(t, s, i) {
        return m(t[0], s[0], i) && m(t[1], s[1], i);
    };
    a, h, o, x, G, T, _, r, I, C, n, R, l, P, u, E, c, f, d, A, F, m, g, O = [], 
    D = [], k = [], L = [], self._$polyDecomp$_ = {
        _$decomp$_: s,
        _$quickDecomp$_: F,
        _$isSimple$_: i,
        _$removeCollinearPoints$_: e,
        _$removeDuplicatePoints$_: p,
        _$makeCCW$_: t
    };
}

{
    let t = !1, s = !1, i = "dev", e = Symbol("Construct internal API token"), h = 14, r = self._$C3$_ = class {
        constructor() {
            throw TypeError("static class can't be instantiated");
        }
        static _$_GetInternalAPIToken$_() {
            if (h <= 0) throw new Error("cannot obtain internal API token");
            return --h, e;
        }
        static _$SetReady$_() {
            t = !0;
        }
        static _$IsReady$_() {
            return t;
        }
        static _$SetAppStarted$_() {
            s = !0;
        }
        static _$HasAppStarted$_() {
            return s;
        }
        static _$SetBuildMode$_(t) {
            i = t;
        }
        static _$GetBuildMode$_() {
            return i;
        }
        static _$IsReleaseBuild$_() {
            return "final" === i;
        }
    };
    r.isDebug = !1, r._$isDebugDefend$_ = !1, r.hardwareConcurrency = navigator.hardwareConcurrency || 2, 
    self._$C3X$_ = {};
}

{
    const s = self._$C3$_;
    s._$QueryParser$_ = class {
        constructor(t) {
            this._$_queryString$_ = t, this._$_parameters$_ = new Map(), this._$_Parse$_();
        }
        _$_Parse$_() {
            let t = this._$_queryString$_, s = (t = t.startsWith("?") || t.startsWith("#") ? t.substr(1) : t).split("&");
            for (const i of s) this._$_ParseParameter$_(i);
        }
        _$_ParseParameter$_(t) {
            if (t) if (t.includes("=")) {
                const s = t.indexOf("="), i = decodeURIComponent(t.substring(0, s)), e = decodeURIComponent(t.substring(s + 1));
                this._$_parameters$_.set(i, e);
            } else this._$_parameters$_.set(t, null);
        }
        _$LogAll$_() {
            for (const t of this._$_parameters$_) console.log("[QueryParser] Parameter '" + t[0] + "' = " + (null === t[1] ? "null" : "'" + t[1] + "'"));
        }
        _$Has$_(t) {
            return this._$_parameters$_.has(t);
        }
        _$Get$_(t) {
            const s = this._$_parameters$_.get(t);
            return void 0 === s ? null : s;
        }
        _$ClearHash$_() {
            history.replaceState("", document.title, location.pathname + location.search);
        }
        _$Reparse$_(t) {
            this._$_queryString$_ = t, this._$_parameters$_.clear(), this._$_Parse$_();
        }
    }, s._$QueryString$_ = new s._$QueryParser$_(location.search), s._$LocationHashString$_ = new s._$QueryParser$_(location.hash), 
    s._$QueryString$_._$Has$_("perf") && (s._$isPerformanceProfiling$_ = !0), "dev" !== s._$QueryString$_._$Get$_("mode") && s._$SetBuildMode$_("final");
}

{
    let e = function(t) {
        const s = parseFloat(t), i = j.get(s);
        return i || (13 <= s ? "11" : "NT " + t);
    };
    e;
    const a = self._$C3$_, W = "(unknown)", j = (a._$Platform$_ = {
        _$OS$_: W,
        _$OSVersion$_: W,
        _$Browser$_: W,
        _$BrowserVersion$_: W,
        _$BrowserVersionNumber$_: NaN,
        _$BrowserEngine$_: W,
        _$Context$_: "browser",
        _$IsDesktop$_: !0,
        _$IsMobile$_: !1,
        _$IsAppleOS$_: !1,
        _$IsIpadOS$_: !1,
        _$GetDetailedInfo$_: async () => {}
    }, new Map([ [ 5, "2000" ], [ 5.1, "XP" ], [ 5.2, "XP" ], [ 6, "Vista" ], [ 6.1, "7" ], [ 6.2, "8" ], [ 6.3, "8.1" ], [ 10, "10" ] ])), V = navigator.userAgent, U = navigator.userAgentData;
    if (U && 0 < U.brands.length) {
        let s = function(t) {
            let s = "", i = "", e = "", h = "";
            for (const r of t) {
                const n = H.get(r.brand), o = (!s && n && (s = n, i = r.version), 
                z.get(r.brand));
                !e && o && (e = o, h = r.version);
            }
            s || "Chromium" !== e || (a._$Platform$_._$Browser$_ = "Chromium", a._$Platform$_._$BrowserVersion$_ = h), 
            a._$Platform$_._$Browser$_ = s || W, a._$Platform$_._$BrowserVersion$_ = i || W, 
            a._$Platform$_._$BrowserEngine$_ = e || W;
        };
        s, a._$Platform$_._$OS$_ = U.platform, a._$Platform$_._$IsMobile$_ = U.mobile, 
        a._$Platform$_._$IsDesktop$_ = !a._$Platform$_._$IsMobile$_;
        const H = new Map([ [ "Google Chrome", "Chrome" ], [ "Microsoft Edge", "Edge" ], [ "Opera", "Opera" ], [ "Opera GX", "Opera GX" ], [ "Mozilla Firefox", "Firefox" ], [ "Apple Safari", "Safari" ], [ "NW.js", "NW.js" ] ]), z = new Map([ [ "Chromium", "Chromium" ], [ "Gecko", "Gecko" ], [ "WebKit", "WebKit" ] ]);
        s(U.brands);
        let i = !1;
        a._$Platform$_._$GetDetailedInfo$_ = async () => {
            if (!i) try {
                const t = await navigator.userAgentData.getHighEntropyValues([ "platformVersion", "fullVersionList" ]);
                s(t.fullVersionList), "Windows" === a._$Platform$_._$OS$_ ? a._$Platform$_._$OSVersion$_ = e(t.platformVersion) : a._$Platform$_._$OSVersion$_ = t.platformVersion, 
                i = !0;
            } catch (t) {
                console.warn("Failed to get detailed user agent information: ", t);
            }
        };
    } else {
        let t = function(t, s) {
            const i = Array.isArray(t) ? t : [ t ];
            for (const e of i) {
                const h = e.exec(V);
                if (h) {
                    s(h);
                    break;
                }
            }
        };
        t(/windows\s+nt\s+([\d\.]+)/i, t => {
            a._$Platform$_._$OS$_ = "Windows";
            const s = t[1];
            a._$Platform$_._$OSVersion$_ = e(s);
        }), t(/mac\s+os\s+x\s+([\d\._]+)/i, t => {
            a._$Platform$_._$OS$_ = "macOS", a._$Platform$_._$OSVersion$_ = t[1].replace(/_/g, ".");
        }), t(/CrOS/, () => {
            a._$Platform$_._$OS$_ = "Chrome OS";
        }), t(/linux|openbsd|freebsd|netbsd/i, () => {
            a._$Platform$_._$OS$_ = "Linux";
        }), t(/android/i, () => {
            a._$Platform$_._$OS$_ = "Android";
        }), t(/android\s+([\d\.]+)/i, t => {
            a._$Platform$_._$OS$_ = "Android", a._$Platform$_._$OSVersion$_ = t[1];
        }), a._$Platform$_._$OS$_ === W && (t(/(iphone|ipod|ipad)/i, t => {
            a._$Platform$_._$OS$_ = "iOS";
        }), t([ /iphone\s+os\s+([\d\._]+)/i, /ipad[^)]*os\s+([\d\._]+)/i ], t => {
            a._$Platform$_._$OS$_ = "iOS", a._$Platform$_._$OSVersion$_ = t[1].replace(/_/g, ".");
        }));
        const J = /chrome\//i.test(V), q = /chromium\//i.test(V), X = /edg\//i.test(V), Y = /OPR\//.test(V), $ = /nwjs/i.test(V), K = /safari\//i.test(V), Z = /webkit/i.test(V), Q = (X || Y || t(/chrome\/([\d\.]+)/i, t => {
            a._$Platform$_._$Browser$_ = "Chrome", a._$Platform$_._$BrowserVersion$_ = t[1], 
            a._$Platform$_._$BrowserEngine$_ = "Chromium";
        }), t(/edg\/([\d\.]+)/i, t => {
            a._$Platform$_._$Browser$_ = "Edge", a._$Platform$_._$BrowserVersion$_ = t[1], 
            a._$Platform$_._$BrowserEngine$_ = "Chromium";
        }), t(/OPR\/([\d\.]+)/, t => {
            a._$Platform$_._$Browser$_ = "Opera", a._$Platform$_._$BrowserVersion$_ = t[1], 
            a._$Platform$_._$BrowserEngine$_ = "Chromium";
        }), t(/chromium\/([\d\.]+)/i, t => {
            a._$Platform$_._$Browser$_ = "Chromium", a._$Platform$_._$BrowserVersion$_ = t[1], 
            a._$Platform$_._$BrowserEngine$_ = "Chromium";
        }), t(/nwjs\/[0-9.]+/i, t => {
            a._$Platform$_._$Browser$_ = "NW.js", a._$Platform$_._$BrowserVersion$_ = t[1], 
            a._$Platform$_._$BrowserEngine$_ = "Chromium", a._$Platform$_._$Context$_ = "nwjs";
        }), t(/firefox\/([\d\.]+)/i, t => {
            a._$Platform$_._$Browser$_ = "Firefox", a._$Platform$_._$BrowserVersion$_ = t[1], 
            a._$Platform$_._$BrowserEngine$_ = "Gecko";
        }), !K || J || q || X || Y || $ || (a._$Platform$_._$Browser$_ = "Safari", 
        a._$Platform$_._$BrowserEngine$_ = "WebKit", t(/version\/([\d\.]+)/i, t => {
            a._$Platform$_._$BrowserVersion$_ = t[1];
        }), t(/crios\/([\d\.]+)/i, t => {
            a._$Platform$_._$Browser$_ = "Chrome for iOS", a._$Platform$_._$BrowserVersion$_ = t[1];
        }), t(/fxios\/([\d\.]+)/i, t => {
            a._$Platform$_._$Browser$_ = "Firefox for iOS", a._$Platform$_._$BrowserVersion$_ = t[1];
        }), t(/edgios\/([\d\.]+)/i, t => {
            a._$Platform$_._$Browser$_ = "Edge for iOS", a._$Platform$_._$BrowserVersion$_ = t[1];
        })), a._$Platform$_._$BrowserEngine$_ === W && Z && (a._$Platform$_._$BrowserEngine$_ = "WebKit"), 
        "Android" === a._$Platform$_._$OS$_ && "Safari" === a._$Platform$_._$Browser$_ && (a._$Platform$_._$Browser$_ = "Stock"), 
        new Set([ "Windows", "macOS", "Linux", "Chrome OS" ])), tt = Q.has(a._$Platform$_._$OS$_) || "nwjs" === a._$Platform$_._$Context$_;
        a._$Platform$_._$IsDesktop$_ = tt, a._$Platform$_._$IsMobile$_ = !tt;
    }
    "Chrome" === a._$Platform$_._$Browser$_ && "browser" === a._$Platform$_._$Context$_ && /wv\)/.test(V) && (a._$Platform$_._$Context$_ = "webview"), 
    "nwjs" !== a._$Platform$_._$Context$_ && "undefined" != typeof window && (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches || navigator.standalone) && (a._$Platform$_._$Context$_ = "webapp"), 
    a._$Platform$_._$BrowserVersionNumber$_ = parseFloat(a._$Platform$_._$BrowserVersion$_);
    const i = "macOS" === a._$Platform$_._$OS$_ && navigator.maxTouchPoints && 2 < navigator.maxTouchPoints;
    i && (a._$Platform$_._$OS$_ = "iOS", a._$Platform$_._$OSVersion$_ = a._$Platform$_._$BrowserVersion$_, 
    a._$Platform$_._$IsDesktop$_ = !1, a._$Platform$_._$IsMobile$_ = !0, a._$Platform$_._$IsIpadOS$_ = !0), 
    a._$Platform$_._$IsAppleOS$_ = "macOS" === a._$Platform$_._$OS$_ || "iOS" === a._$Platform$_._$OS$_;
}

{
    let n = function(i) {
        return new Promise((t, s) => {
            i.onsuccess = () => t(i.result), i.onerror = () => s(i.error);
        });
    }, o = function(i) {
        return new Promise((t, s) => {
            i.oncomplete = () => t(), i.onerror = () => s(i.error), i.onabort = () => s(i.error);
        });
    }, t = function(t, s) {
        return B(t, s);
    }, s = function(t, s) {
        return B(t, s, !0);
    }, a = function(s) {
        e(s);
        let t = et.get(s);
        return t instanceof Promise || (t = (async i => {
            e(i);
            const t = indexedDB.open(i, st);
            return t.addEventListener("upgradeneeded", t => {
                try {
                    const s = t.target.result;
                    s.createObjectStore(it);
                } catch (t) {
                    console.error("Failed to create objectstore for database " + i, t);
                }
            }), n(t);
        })(s), et.set(s, t), t.catch(t => et.delete(s))), t;
    }, e = function(t) {
        if ("string" != typeof t) throw new TypeError("expected string");
    }, r = function(t, h) {
        const s = t.objectStore(it).openCursor();
        return new Promise(i => {
            const e = [];
            s.onsuccess = t => {
                const s = t.target.result;
                if (s) {
                    switch (h) {
                      case "entries":
                        e.push([ s.key, s.value ]);
                        break;

                      case "keys":
                        e.push(s.key);
                        break;

                      case "values":
                        e.push(s.value);
                    }
                    s.continue();
                } else i(e);
            };
        });
    };
    n, o, t, s, a, e, r;
    const st = 2, it = "keyvaluepairs", et = new Map(), ht = "undefined" != typeof IDBObjectStore && "function" == typeof IDBObjectStore.prototype.getAll, rt = "undefined" != typeof IDBObjectStore && "function" == typeof IDBObjectStore.prototype.getAllKeys;
    async function B(s, i, e = !1, h = !0) {
        const t = await a(s);
        try {
            const r = t.transaction([ it ], e ? "readwrite" : "readonly");
            return i(r);
        } catch (t) {
            if (h && "InvalidStateError" === t.name) return et.delete(s), B(s, i, e, !1);
            throw t;
        }
    }
    class nt {
        constructor(t) {
            e(t), this.name = t;
        }
        async ready() {
            await a(this.name);
        }
        set(h, r) {
            return e(h), s(this.name, async t => {
                const s = t.objectStore(it).put(r, h), i = n(s), e = o(t);
                await Promise.all([ e, i ]);
            });
        }
        get(r) {
            return e(r), t(this.name, async t => {
                const s = t.objectStore(it).get(r), i = n(s), e = o(t), [ , h ] = await Promise.all([ e, i ]);
                return h;
            });
        }
        delete(h) {
            return e(h), s(this.name, async t => {
                const s = t.objectStore(it).delete(h), i = n(s), e = o(t);
                await Promise.all([ e, i ]);
            });
        }
        clear() {
            return s(this.name, async t => {
                const s = t.objectStore(it).clear(), i = n(s), e = o(t);
                await Promise.all([ e, i ]);
            });
        }
        keys() {
            return t(this.name, async t => {
                let s;
                if (rt) {
                    const h = t.objectStore(it).getAllKeys();
                    s = n(h);
                } else s = r(t, "keys");
                const i = o(t), [ , e ] = await Promise.all([ i, s ]);
                return e;
            });
        }
        values() {
            return t(this.name, async t => {
                let s;
                if (ht) {
                    const h = t.objectStore(it).getAll();
                    s = n(h);
                } else s = r(t, "values");
                const i = o(t), [ , e ] = await Promise.all([ i, s ]);
                return e;
            });
        }
        entries() {
            return t(this.name, async t => {
                const s = r(t, "entries"), i = o(t), [ , e ] = await Promise.all([ i, s ]);
                return e;
            });
        }
    }
    self._$KVStorageContainer$_ = nt;
}

{
    let i = function(t) {
        throw new Error(`"${t}" is not implemented`);
    }, e = function(t) {
        if ("function" == typeof t) throw new Error("localforage callback API is not implemented; please use the promise API instead");
    }, h = function(e) {
        return "object" == typeof e ? new Promise(s => {
            const {
                port1: t,
                port2: i
            } = new MessageChannel();
            i.onmessage = t => s(t.data), t.postMessage(e);
        }) : Promise.resolve(e);
    }, r = (i, e, h, self._$KVStorageContainer$_), n = [ /no available storage method found/i, /an attempt was made to break through the security policy of the user agent/i, /the user denied permission to access the database/i, /a mutation operation was attempted on a database that did not allow mutations/i, /idbfactory\.open\(\) called in an invalid security context/i ], o = new WeakMap(), a = !1;
    "undefined" == typeof indexedDB && (a = !0, console.warn("Unable to use local storage because indexedDB is not defined"));
    class ot {
        constructor(t) {
            this._$_inst$_ = t, o.set(this, new Map());
        }
        _$_MaybeSwitchToMemoryFallback$_(t) {
            if (!a) for (const s of n) if (t && s.test(t.message)) {
                console.error("Unable to use local storage, reverting to in-memory store: ", t, t.message), 
                a = !0;
                break;
            }
        }
        async _$_getItemFallback$_(t) {
            const s = o.get(this).get(t), i = await h(s);
            return void 0 === i ? null : i;
        }
        async _$_setItemFallback$_(t, s) {
            s = await h(s), o.get(this).set(t, s);
        }
        _$_removeItemFallback$_(t) {
            o.get(this).delete(t);
        }
        _$_clearFallback$_() {
            o.get(this).clear();
        }
        _$_keysFallback$_() {
            return Array.from(o.get(this).keys());
        }
        _$IsUsingFallback$_() {
            return a;
        }
        async getItem(s, t) {
            if (e(t), a) return this._$_getItemFallback$_(s);
            let i;
            try {
                i = await this._$_inst$_.get(s);
            } catch (t) {
                return this._$_MaybeSwitchToMemoryFallback$_(t), a ? this._$_getItemFallback$_(s) : (console.error(`Error reading '${s}' from storage, returning null: `, t), 
                null);
            }
            return void 0 === i ? null : i;
        }
        async setItem(s, i, t) {
            if (e(t), void 0 === i && (i = null), a) await this._$_setItemFallback$_(s, i); else try {
                await this._$_inst$_.set(s, i);
            } catch (t) {
                if (this._$_MaybeSwitchToMemoryFallback$_(t), !a) throw t;
                await this._$_setItemFallback$_(s, i);
            }
        }
        async removeItem(s, t) {
            if (e(t), a) this._$_removeItemFallback$_(s); else try {
                await this._$_inst$_.delete(s);
            } catch (t) {
                this._$_MaybeSwitchToMemoryFallback$_(t), a ? this._$_removeItemFallback$_(s) : console.error(`Error removing '${s}' from storage: `, t);
            }
        }
        async clear(t) {
            if (e(t), a) this._$_clearFallback$_(); else try {
                await this._$_inst$_.clear();
            } catch (t) {
                this._$_MaybeSwitchToMemoryFallback$_(t), a ? this._$_clearFallback$_() : console.error("Error clearing storage: ", t);
            }
        }
        async keys(t) {
            if (e(t), a) return this._$_keysFallback$_();
            let s = [];
            try {
                s = await this._$_inst$_.keys();
            } catch (t) {
                if (this._$_MaybeSwitchToMemoryFallback$_(t), a) return this._$_keysFallback$_();
                console.error("Error getting storage keys: ", t);
            }
            return s;
        }
        ready(t) {
            return e(t), a ? Promise.resolve(!0) : this._$_inst$_.ready();
        }
        _$createInstance$_(t) {
            if ("object" != typeof t) throw new TypeError("invalid options object");
            const s = t.name;
            if ("string" != typeof s) throw new TypeError("invalid store name");
            const i = new r(s);
            return new ot(i);
        }
        length(t) {
            i("localforage.length()");
        }
        key(t, s) {
            i("localforage.key()");
        }
        iterate(t, s) {
            i("localforage.iterate()");
        }
        _$setDriver$_(t) {
            i("localforage.setDriver()");
        }
        config(t) {
            i("localforage.config()");
        }
        _$defineDriver$_(t) {
            i("localforage.defineDriver()");
        }
        _$driver$_() {
            i("localforage.driver()");
        }
        supports(t) {
            i("localforage.supports()");
        }
        dropInstance() {
            i("localforage.dropInstance()");
        }
        _$disableMemoryMode$_() {
            a = !1;
        }
    }
    self.localforage = new ot(new r("localforage"));
}

{
    const e = self._$C3$_;
    if (e._$Supports$_ = {}, e._$Supports$_._$WebAnimations$_ = (() => {
        try {
            if ("undefined" == typeof document) return !1;
            const t = document.createElement("div");
            if (void 0 === t.animate) return !1;
            const s = t.animate([ {
                opacity: "0"
            }, {
                opacity: "1"
            } ], 1e3);
            return void 0 !== s.reverse;
        } catch (t) {
            return !1;
        }
    })(), e._$Supports$_._$DialogElement$_ = "undefined" != typeof HTMLDialogElement, 
    e._$Supports$_._$RequestIdleCallback$_ = !!self.requestIdleCallback, e._$Supports$_.ImageBitmap = !!self.createImageBitmap, 
    e._$Supports$_.ImageBitmapOptions = !1, e._$Supports$_._$ImageBitmapOptionsResize$_ = !1, 
    e._$Supports$_.ImageBitmap) {
        try {
            self.createImageBitmap(new ImageData(32, 32), {
                premultiplyAlpha: "none"
            }).then(() => {
                e._$Supports$_.ImageBitmapOptions = !0;
            }).catch(() => {
                e._$Supports$_.ImageBitmapOptions = !1;
            });
        } catch (t) {
            e._$Supports$_.ImageBitmapOptions = !1;
        }
        try {
            self.createImageBitmap(new ImageData(32, 32), {
                resizeWidth: 10,
                resizeHeight: 10
            }).then(t => {
                e._$Supports$_._$ImageBitmapOptionsResize$_ = 10 === t.width && 10 === t.height;
            }).catch(() => {
                e._$Supports$_._$ImageBitmapOptionsResize$_ = !1;
            });
        } catch (t) {
            e._$Supports$_._$ImageBitmapOptionsResize$_ = !1;
        }
    }
    if (e._$Supports$_._$ClipboardReadText$_ = !(!navigator.clipboard || !navigator.clipboard.readText), 
    e._$Supports$_._$PermissionsQuery$_ = !(!navigator.permissions || !navigator.permissions.query), 
    e._$Supports$_._$ClipboardPermissionsQuery$_ = !1, e._$Supports$_._$PermissionsQuery$_) {
        const at = {
            name: "clipboard-read"
        };
        navigator.permissions.query(at).then(() => {
            e._$Supports$_._$ClipboardPermissionsQuery$_ = !0;
        }).catch(() => {
            e._$Supports$_._$ClipboardPermissionsQuery$_ = !1;
        });
    }
    e._$Supports$_._$AsyncClipboardApi$_ = !!(navigator.permissions && navigator.clipboard && self.ClipboardItem), 
    e._$Supports$_._$Proxies$_ = "undefined" != typeof Proxy, e._$Supports$_._$DownloadAttribute$_ = (() => {
        if ("undefined" == typeof document) return !1;
        const t = document.createElement("a");
        return void 0 !== t.download;
    })(), e._$Supports$_._$Fetch$_ = "function" == typeof fetch, e._$Supports$_._$PersistentStorage$_ = !!(self.isSecureContext && "Opera" !== e._$Platform$_._$Browser$_ && navigator.storage && navigator.storage.persist), 
    e._$Supports$_._$StorageQuotaEstimate$_ = !!(self.isSecureContext && navigator.storage && navigator.storage.estimate), 
    e._$Supports$_._$Fullscreen$_ = (() => {
        if ("undefined" == typeof document) return !1;
        if ("iOS" === e._$Platform$_._$OS$_) return !1;
        const t = document.documentElement;
        return !!(t.requestFullscreen || t.msRequestFullscreen || t.mozRequestFullScreen || t.webkitRequestFullscreen);
    })(), e._$Supports$_.ImageDecoder = void 0 !== self.ImageDecoder, e._$Supports$_._$WebCodecs$_ = !!self.VideoEncoder, 
    e._$Supports$_._$NativeFileSystemAPI$_ = !!self.showOpenFilePicker, e._$Supports$_._$QueryLocalFonts$_ = !!self.queryLocalFonts, 
    e._$Supports$_.UserActivation = !!navigator.userActivation, e._$Supports$_._$CanvasToBlobWebP$_ = !1, 
    (async () => {
        let s;
        "undefined" == typeof document ? s = new OffscreenCanvas(32, 32) : ((s = document.createElement("canvas")).width = 32, 
        s.height = 32);
        const t = s.getContext("2d");
        t.fillStyle = "blue", t.fillRect(0, 0, 32, 32);
        let i = null;
        try {
            s.convertToBlob ? i = await s.convertToBlob({
                type: "image/webp",
                quality: 1
            }) : s.toBlob && (i = await new Promise(t => s.toBlob(t, "image/webp", 1))), 
            e._$Supports$_._$CanvasToBlobWebP$_ = i && "image/webp" === i.type;
        } catch (t) {
            e._$Supports$_._$CanvasToBlobWebP$_ = !1;
        }
    })();
}

{
    const lt = self._$C3$_;
    if (!String.prototype.trimStart) {
        const ut = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*/;
        String.prototype.trimStart = function() {
            return this.replace(ut, "");
        };
    }
    if (!String.prototype.trimEnd) {
        const ct = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*$/;
        String.prototype.trimEnd = function() {
            return this.replace(ct, "");
        };
    }
    if (String.prototype.replaceAll || (String.prototype.replaceAll = function(t, s) {
        return this.replace(new RegExp(lt._$EscapeRegex$_(t), "g"), s);
    }), Array.prototype.values || (Array.prototype.values = function*() {
        for (const t of this) yield t;
    }), !Array.prototype.flat) {
        let e = function(t, i) {
            return t.reduce((t, s) => (0 < i && Array.isArray(s) ? Array.prototype.push.apply(t, e(s, i - 1)) : t.push(s), 
            t), []);
        };
        e, Array.prototype.flat = function(t = 1) {
            return e(this, t);
        };
    }
    Array.prototype.at || (Array.prototype.at = function(t) {
        if ((t = Math.trunc(t) || 0) < 0 && (t += this.length), !(t < 0 || t >= this.length)) return this[t];
    }), String.prototype.at || (String.prototype.at = function(t) {
        if ((t = Math.trunc(t) || 0) < 0 && (t += this.length), !(t < 0 || t >= this.length)) return this[t];
    }), RegExp.escape || (RegExp.escape = function(t) {
        return String(t).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
    }), Set.prototype._$isSubsetOf$_ || (Set.prototype._$isSubsetOf$_ = function(t) {
        if (!(t instanceof Set)) throw new TypeError("argument must be a Set");
        for (const s of this) if (!t.has(s)) return !1;
        return !0;
    }), navigator.storage && !navigator.storage.estimate && navigator.webkitTemporaryStorage && navigator.webkitTemporaryStorage.queryUsageAndQuota && (navigator.storage.estimate = function() {
        return new Promise((i, t) => navigator.webkitTemporaryStorage.queryUsageAndQuota((t, s) => i({
            usage: t,
            quota: s
        }), t));
    }), void 0 === self.isSecureContext && (self.isSecureContext = "https:" === location.protocol), 
    void 0 === self.globalThis && (self.globalThis = self);
}

{
    let i = function(t) {
        let s = ft._$GetCallStack$_(), i = "Assertion failure: " + t + "\n\nStack trace:\n" + s;
        console.error(i);
    };
    i;
    const ft = self._$C3$_;
    self.assert = function(t, s) {
        t || i(s);
    };
}

{
    const h = self._$C3$_, dt = self._$C3X$_, pt = (h._$IsNumber$_ = function(t) {
        return "number" == typeof t;
    }, h._$IsFiniteNumber$_ = function(t) {
        return h._$IsNumber$_(t) && isFinite(t);
    }, h._$RequireNumber$_ = function(t) {
        if (!h._$IsNumber$_(t)) throw new TypeError("expected number");
    }, h._$RequireOptionalNumber$_ = function(t) {
        h._$IsNullOrUndefined$_(t);
    }, h._$RequireNumberInRange$_ = function(t, s, i) {
        if (!h._$IsNumber$_(t) || isNaN(t) || t < s || i < t) throw new RangeError("number outside of range");
    }, h._$RequireAllNumber$_ = function(...s) {
        for (let t of s);
    }, h._$RequireFiniteNumber$_ = function(t) {
        if (!h._$IsFiniteNumber$_(t)) throw new TypeError("expected finite number");
    }, h._$RequireOptionalFiniteNumber$_ = function(t) {
        h._$IsNullOrUndefined$_(t);
    }, h._$RequireAllFiniteNumber$_ = function(...s) {
        for (let t of s);
    }, h._$IsString$_ = function(t) {
        return "string" == typeof t;
    }, h._$RequireString$_ = function(t) {
        if (!h._$IsString$_(t)) throw new TypeError("expected string");
    }, h._$RequireOptionalString$_ = function(t) {
        h._$IsNullOrUndefined$_(t);
    }, h._$RequireAllString$_ = function(...s) {
        for (let t of s);
    }, h._$IsSimpleObject$_ = function(t) {
        if ("object" != typeof t || null === t) return !1;
        let s = Object.getPrototypeOf(t);
        return s ? s.constructor === Object : null === s;
    }, h._$RequireSimpleObject$_ = function(t) {
        if (!h._$IsSimpleObject$_(t)) throw new TypeError("expected simple object");
    }, h._$RequireOptionalSimpleObject$_ = function(t) {
        if (!h._$IsNullOrUndefined$_(t) && !h._$IsSimpleObject$_(t)) throw new TypeError("expected simple object");
    }, h._$IsObject$_ = function(t) {
        return "object" == typeof t && null !== t && !Array.isArray(t);
    }, h._$RequireObject$_ = function(t) {
        if (!h._$IsObject$_(t)) throw new TypeError("expected object");
    }, h._$RequireOptionalObject$_ = function(t) {
        h._$IsNullOrUndefined$_(t);
    }, h._$RequireAllObject$_ = function(...s) {
        for (let t of s);
    }, h._$IsFileLike$_ = function(t) {
        return h._$WeakIsInstanceOf$_(t, Blob) && "string" == typeof t.name;
    }, h._$RequireFileLike$_ = function(t) {
        if (!h._$IsFileLike$_(t)) throw new TypeError("expected file");
    }, h._$RequireOptionalFileLike$_ = function(t) {
        h._$IsNullOrUndefined$_(t);
    }, h._$IsArray$_ = function(t) {
        return Array.isArray(t);
    }, h._$RequireArray$_ = function(t) {
        if (!h._$IsArray$_(t)) throw new TypeError("expected array");
    }, h._$RequireOptionalArray$_ = function(t) {
        h._$IsNullOrUndefined$_(t);
    }, h._$RequireAllArray$_ = function(...s) {
        for (let t of s);
    }, h._$Is2DArray$_ = function(t) {
        return !(!h._$IsArray$_(t) || t.length && !h._$IsArray$_(t[0]));
    }, h._$Require2DArray$_ = function(s) {
        if (!h._$Is2DArray$_(s)) throw new TypeError("expected 2d array");
        for (let t of s) if (!h._$IsArray$_(t)) throw new TypeError("expected 2d array");
    }, h._$RequireOptional2DArray$_ = function(t) {
        h._$IsNullOrUndefined$_(t);
    }, h._$IsFunction$_ = function(t) {
        return "function" == typeof t;
    }, h._$RequireFunction$_ = function(t, s) {
        if (!h._$IsFunction$_(t)) throw new TypeError("expected function");
        if (!h._$IsNullOrUndefined$_(s) && t !== s) throw new TypeError("expected same function reference");
    }, h._$RequireOptionalFunction$_ = function(t) {
        h._$IsNullOrUndefined$_(t);
    }, h._$RequireAllFunction$_ = function(...s) {
        for (let t of s);
    }, h._$RequireAnyFunction$_ = function(s, ...i) {
        if (!h._$IsFunction$_(s)) throw new TypeError("expected function");
        if (!i.length) throw new Error("missing comparison functions");
        for (let t of i) if (!h._$IsNullOrUndefined$_(t) && s === t) return;
        throw new TypeError("expected same function reference");
    }, h._$RequireOptionalAllFunction$_ = function(...s) {
        if (!h._$IsNullOrUndefined$_(s)) for (let t of s);
    }, h._$IsInstanceOf$_ = function(t, s) {
        return t instanceof s;
    }, h._$IsInstanceOfAny$_ = function(s, ...i) {
        for (let t of i) if (h._$IsInstanceOf$_(s, t)) return !0;
        return !1;
    }, h._$RequireInstanceOf$_ = function(t, s) {
        if (!h._$IsInstanceOf$_(t, s)) throw new TypeError("unexpected type");
    }, h._$RequireOptionalInstanceOf$_ = function(t, s) {
        h._$IsNullOrUndefined$_(t);
    }, h._$RequireAllInstanceOf$_ = function(t, ...s) {
        for (let t of s);
    }, h._$RequireAnyInstanceOf$_ = function(t, ...s) {
        if (!h._$IsInstanceOfAny$_(t, ...s)) throw new TypeError("unexpected type");
    }, h._$RequireAnyOptionalInstanceOf$_ = function(t, ...s) {
        if (!h._$IsNullOrUndefined$_(t) && !h._$IsInstanceOfAny$_(t, ...s)) throw new TypeError("unexpected type");
    }, h._$IsArrayOf$_ = function(s, i) {
        for (let t of s) if (!h._$IsInstanceOf$_(t, i)) return !1;
        return !0;
    }, h._$IsArrayOfFiniteNumbers$_ = function(s) {
        for (let t of s) if (!h._$IsFiniteNumber$_(t)) return !1;
        return !0;
    }, h._$RequireArrayOf$_ = function(s, t) {
        for (let t of s);
    }, h._$RequireOptionalArrayOf$_ = function(s, t) {
        if (!h._$IsNullOrUndefined$_(s)) for (let t of s);
    }, h._$RequireOptionalArrayOfFunctions$_ = function(s, t) {
        if (!h._$IsNullOrUndefined$_(s)) for (let t of s);
    }, h._$RequireArrayOfAny$_ = function(s) {
        for (let t of s);
    }, h._$RequireOptionalArrayOfAny$_ = function(s) {
        if (!h._$IsNullOrUndefined$_(s)) for (let t of s);
    }, h._$IsDOMNode$_ = function(t, s) {
        return !(h._$IsNullOrUndefined$_(t) || !h._$IsString$_(t.nodeName)) && (!s || h._$equalsNoCase$_(t.nodeName, s));
    }, h._$RequireDOMNode$_ = function(t, s) {
        if (h._$IsNullOrUndefined$_(t) || !h._$IsString$_(t.nodeName)) throw new TypeError("expected DOM node");
        if (s && !h._$equalsNoCase$_(t.nodeName, s)) throw new TypeError(`expected DOM '${s}' node`);
    }, h._$RequireOptionalDOMNode$_ = function(t, s) {
        h._$IsNullOrUndefined$_(t);
    }, h._$IsHTMLElement$_ = function(t, s) {
        return !(h._$IsNullOrUndefined$_(t) || !h._$IsString$_(t.tagName)) && (!s || h._$equalsNoCase$_(t.tagName, s));
    }, h._$RequireHTMLElement$_ = function(t, s) {
        if (h._$IsNullOrUndefined$_(t) || !h._$IsString$_(t.tagName)) throw new TypeError("expected HTML element");
        if (s && !h._$equalsNoCase$_(t.tagName, s)) throw new TypeError(`expected HTML '${s}' element`);
    }, h._$RequireOptionalHTMLElement$_ = function(t, s) {
        h._$IsNullOrUndefined$_(t);
    }, h._$IsDrawable$_ = function(t) {
        return h._$IsHTMLElement$_(t, "img") || h._$IsHTMLElement$_(t, "canvas") || h._$IsHTMLElement$_(t, "video") || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap;
    }, h._$RequireDrawable$_ = function(t) {
        if (!h._$IsDrawable$_(t)) throw new TypeError("expected drawable");
    }, h._$RequireOptionalDrawable$_ = function(t) {
        h._$IsNullOrUndefined$_(t);
    }, h._$IsDrawableOrImageData$_ = function(t) {
        return t instanceof ImageData || h._$IsDrawable$_(t);
    }, h._$RequireDrawableOrImageData$_ = function(t) {
        if (!h._$IsDrawableOrImageData$_(t)) throw new TypeError("expected drawable or image data");
    }, h._$RequireOptionalDrawableOrImageData$_ = function(t) {
        if (!h._$IsNullOrUndefined$_(t) && !h._$IsDrawableOrImageData$_(t)) throw new TypeError("expected drawable or image data");
    }, h._$IsStringLike$_ = function(t) {
        return "string" == typeof t || h.HtmlString && t instanceof h.HtmlString || t instanceof h._$BBString$_;
    }, h._$RequireStringLike$_ = function(t) {
        if (!h._$IsStringLike$_(t)) throw new TypeError("expected string-like");
    }, h._$RequireOptionalStringLike$_ = function(t) {
        h._$IsNullOrUndefined$_(t);
    }, h._$RequireAllStringLike$_ = function(...s) {
        for (let t of s);
    }, h._$RequireOverride$_ = function() {
        throw new Error("must be overridden");
    }, h._$NotYetImplemented$_ = function() {
        throw new Error("not yet implemented");
    }, h._$IsDefined$_ = function(t, ...s) {
        let i = t;
        if (void 0 === i) return !1;
        for (let t of s) {
            if (void 0 === i[t]) return !1;
            i = i[t];
        }
        return !0;
    }, h._$IsNullOrUndefined$_ = function(t) {
        return null == t;
    }, h._$AreArrayElementsOfSameType$_ = function(s) {
        let i = s[0].constructor;
        for (let t of s) if (t.constructor !== i) return !1;
        return i;
    }, h._$AreArrayElementsOfType$_ = function(s, i) {
        for (let t of s) if (!(t instanceof i)) return !1;
        return !0;
    }, Object.getPrototypeOf(Uint8Array));
    h._$IsTypedArray$_ = function(t) {
        return h._$IsInstanceOf$_(t, pt);
    }, h._$RequireTypedArray$_ = function(t) {}, h._$WeakRequireTypedArray$_ = function(t) {
        h._$WeakRequireInstanceOf$_(t, pt);
    }, h._$WeakRequireAnyInstanceOf$_ = function(t, ...s) {
        if (!h._$WeakIsAnyInstanceOf$_(t, ...s)) throw new TypeError("unexpected type");
    }, h._$WeakIsAnyInstanceOf$_ = function(t, ...s) {
        for (const i of s) if (h._$WeakIsInstanceOf$_(t, i)) return !0;
        return !1;
    }, h._$WeakRequireInstanceOf$_ = function(t, s) {
        if (!h._$WeakIsInstanceOf$_(t, s)) throw new TypeError("unexpected type");
    }, h._$WeakIsInstanceOf$_ = function(t, s) {
        for (;t = Object.getPrototypeOf(t); ) if (t.constructor.name === s.name) return !0;
        return !1;
    }, dt._$RequireNumber$_ = h._$RequireNumber$_, dt._$RequireOptionalNumber$_ = h._$RequireOptionalNumber$_, 
    dt._$RequireFiniteNumber$_ = h._$RequireFiniteNumber$_, dt._$RequireOptionalFiniteNumber$_ = h._$RequireOptionalFiniteNumber$_, 
    dt._$RequireString$_ = h._$RequireString$_, dt._$RequireOptionalString$_ = h._$RequireOptionalString$_, 
    dt._$RequireObject$_ = h._$RequireObject$_, dt._$RequireOptionalObject$_ = h._$RequireOptionalObject$_, 
    dt._$RequireArray$_ = h._$RequireArray$_, dt._$RequireOptionalArray$_ = h._$RequireOptionalArray$_, 
    dt._$RequireFunction$_ = h._$RequireFunction$_, dt._$RequireOptionalFunction$_ = h._$RequireOptionalFunction$_, 
    dt._$RequireInstanceOf$_ = h._$RequireInstanceOf$_, dt._$RequireOptionalInstanceOf$_ = h._$RequireOptionalInstanceOf$_, 
    dt._$IsNullOrUndefined$_ = h._$IsNullOrUndefined$_;
}

{
    let e = function(t, s) {
        let i = p.getType(t), e = p.getType(s);
        return "null" === i || "null" === e || "undefined" !== i && "undefined" !== e && i === e;
    }, h = function(t) {
        console.warn("[Defence] " + t + " @", p._$GetCallStack$_());
    }, i = function() {
        if (f = -1, 0 < a.size || 0 < l.size) {
            let t = new Set([ ...a.keys() ].map(t => p._$getName$_(t))), s = [ ...t ].join(",");
            console.warn("An object derived from DefendedBase was not protected with debugDefend(). This will disable some checks. See the coding guidelines! Possible affected class names: " + s), 
            a.clear(), l.clear();
        }
    }, r = function(s) {
        let i = new Set();
        for (let t in s) i.add(t);
        return i;
    }, n = function(t, s) {
        let i = r(s), e = d.get(t);
        if (e) {
            let s = [];
            for (let t of e.values()) i.has(t) ? i.delete(t) : s.push(t);
            p._$appendArray$_(s, [ ...i ]), s.length && console.warn(`[Defence] '${p._$getName$_(t)}' constructor creates inconsistent properties: ` + s.join(", "));
        } else d.set(t, i);
    };
    e, h, i, r, n;
    const p = self._$C3$_, mt = new Map();
    p._$ColorLog$_ = function(t, s) {
        console.log("%c" + t, "font-weight: bold; color:" + s);
    }, p._$RafLog$_ = function(t, ...s) {
        mt.has(t) || mt.set(t, -1), -1 === mt.get(t) && mt.set(t, requestAnimationFrame(() => {
            console.log("%c" + t, "font-weight: bold", ...s), mt.set(t, -1);
        }));
    };
    let o, a = (p._$StartMeasure$_ = function(t) {
        performance.mark(t), (o = o || new Map()).has(t) || o.set(t, {
            current: 0,
            total: 0,
            _$average$_: 0,
            _$calls$_: 1,
            toString: function() {
                return `${t} :: current => ${this.current.toPrecision(3)} :: average => ${this._$average$_.toPrecision(3)} :: calls => ` + this._$calls$_;
            }
        });
    }, p._$EndMeasure$_ = function(t) {
        performance.measure("measure-" + t, t);
        const s = performance.getEntriesByName("measure-" + t)[0], i = o.get(t);
        i.current = s.duration, i.total += i.current, i._$average$_ = i.total / i._$calls$_, 
        console.log(i.toString()), i._$calls$_++, performance.clearMarks(t), performance.clearMeasures("measure-" + t);
    }, p._$GetCallStack$_ = function() {
        return new Error().stack;
    }, p._$Debugger$_ = function() {
        debugger;
    }, p.cast = function(t, s) {
        return t && t instanceof s ? t : null;
    }, p._$getName$_ = function(t) {
        return void 0 === t ? "undefined" : null === t ? "null" : "boolean" == typeof t ? "<boolean>" : p._$IsNumber$_(t) ? "<number>" : p._$IsString$_(t) ? "<string>" : p._$IsArray$_(t) ? "<array>" : "symbol" == typeof t ? "<" + t.toString() + ">" : p._$IsFunction$_(t) ? t.name && "Function" !== t.name ? t.name : "<anonymous function>" : "object" == typeof t ? t.constructor && t.constructor.name && "Object" !== t.constructor.name ? t.constructor.name : "<anonymous object>" : "<unknown>";
    }, p.getType = function(t) {
        return null === t ? "null" : Array.isArray(t) ? "array" : typeof t;
    }, p.range = function*(s, i) {
        if (!isFinite(Math.abs(s - i))) throw new Error("Invalid parameters");
        if (i < s) for (let t = s - 1; t >= i; t--) yield t; else for (let t = s; t < i; t++) yield t;
    }, new Map()), l = new Map(), u = new WeakMap(), c = new WeakMap();
    p._$DefendHandler$_ = {};
    const gt = new Set([ "then", "splice" ]);
    p._$DefendHandler$_.get = function(t, s) {
        return s in t || "symbol" == typeof s || gt.has(s) || h(`Accessed missing property '${s}' from defended object '${p._$getName$_(t)}', returning undefined`), 
        c.has(t) && "symbol" != typeof s && !gt.has(s) && h(`Accessed property '${s}' on a released object '${p._$getName$_(t)}'
Object was originally released at: ${c.get(t)})
Call stack at access: `), t[s];
    }, p._$DefendHandler$_.set = function(t, s, i) {
        return s in t || a.has(t) || h(`Set non-existent property '${s}' to '${i}' on defended object '${p._$getName$_(t)}'`), 
        e(t[s], i) || a.has(t) || h(`Set '${p.getType(t[s])}' property '${s}' to type '${p.getType(i)}' on defended object '${p._$getName$_(t)}'`), 
        c.has(t) && h(`Set property '${s}' on a released object '${p._$getName$_(t)}'
Object was originally released at: ${c.get(t)})
Call stack at access: `), t[s] = i, !0;
    }, p._$DefendHandler$_.deleteProperty = function(t, s) {
        throw new ReferenceError(`Cannot delete property '${s}' from defended object '${p._$getName$_(t)}'`);
    }, p._$DefendHandler$_.defineProperty = function(t, s, i) {
        throw new ReferenceError(`Cannot define property '${s}' on defended object '${p._$getName$_(t)}'`);
    }, p._$DefendHandler$_.enumerate = function(t) {
        throw new ReferenceError(`Cannot enumerate defended object '${p._$getName$_(t)}'`);
    };
    let f = -1, d = (p._$DefendedBase$_ = class {
        constructor() {
            if (p._$isDebugDefend$_ && p._$Supports$_._$Proxies$_) {
                let t = Object.create(new.target.prototype), s = new Proxy(t, p._$DefendHandler$_);
                return a.set(t, s), l.set(s, t), u.set(s, t), -1 === f && (f = requestAnimationFrame(i)), 
                s;
            }
        }
    }, p._$debugDefend$_ = function(s) {
        if (p._$isDebugDefend$_ && p._$Supports$_._$Proxies$_ && s instanceof p._$DefendedBase$_) {
            if (l.has(s)) {
                let t = l.get(s);
                l.delete(s), a.delete(t);
            }
            return s;
        }
        return p.isDebug ? Object.seal(s) : s;
    }, p._$New$_ = function(t, ...s) {
        let i;
        try {
            i = new t(...s);
        } catch (t) {
            throw l.clear(), a.clear(), t;
        }
        return p._$isDebugDefend$_ && n(t, i), p._$debugDefend$_(i);
    }, p._$Release$_ = function(t) {
        let s = u.get(t);
        s && c.set(s, p._$GetCallStack$_());
    }, p._$WasReleased$_ = function(t) {
        let s = u.get(t);
        return !!s && !!c.get(s);
    }, new Map());
    p._$PerfMark$_ = class {
        constructor(t) {
            this._$_name$_ = "", t && this.start(t);
        }
        start(t) {
            p._$isPerformanceProfiling$_ && (this._$_name$_ = t, performance.mark(this._$_name$_ + "-Start"));
        }
        end() {
            p._$isPerformanceProfiling$_ && (performance.mark(this._$_name$_ + "-End"), 
            performance.measure(this._$_name$_, this._$_name$_ + "-Start", this._$_name$_ + "-End"));
        }
        next(t) {
            p._$isPerformanceProfiling$_ && (this.end(), this._$_name$_ = t, performance.mark(this._$_name$_ + "-Start"));
        }
    };
}

{
    let i = function(t) {
        return 0 === t && 1 / t < 0;
    };
    i;
    const y = self._$C3$_, yt = 2 * Math.PI, wt = Math.PI / 180, St = 180 / Math.PI, bt = (y.wrap = function(t, s, i) {
        t = Math.floor(t), s = Math.floor(s);
        const e = (i = Math.floor(i)) - s;
        if (0 == e) return i;
        if (t < s) {
            const h = i - (s - t) % e;
            return h === i ? 0 : h;
        }
        return s + (t - s) % e;
    }, y._$mapToRange$_ = function(t, s, i, e, h) {
        const r = i - s;
        if (0 == r && 0 === e) return t;
        const n = h - e;
        return (t - s) * n / r + e;
    }, y.normalize = function(t, s, i) {
        return s - i == 0 ? 1 : (t - s) / (i - s);
    }, y._$clamp$_ = function(t, s, i) {
        return t < s ? s : i < t ? i : t;
    }, y._$clampAngle$_ = function(t) {
        return (t %= yt) < 0 && (t += yt), t;
    }, y._$toRadians$_ = function(t) {
        return t * wt;
    }, y._$toDegrees$_ = function(t) {
        return t * St;
    }, y._$distanceTo$_ = function(t, s, i, e) {
        return Math.hypot(i - t, e - s);
    }, y._$distanceSquared$_ = function(t, s, i, e) {
        const h = i - t, r = e - s;
        return h * h + r * r;
    }, y._$angleTo$_ = function(t, s, i, e) {
        return Math.atan2(e - s, i - t);
    }, y._$angleDiff$_ = function(t, s) {
        if (t === s) return 0;
        let i = Math.sin(t), e = Math.cos(t), h = Math.sin(s), r = Math.cos(s), n = i * h + e * r;
        return 1 <= n ? 0 : n <= -1 ? Math.PI : Math.acos(n);
    }, y._$angleRotate$_ = function(t, s, i) {
        let e = Math.sin(t), h = Math.cos(t), r = Math.sin(s), n = Math.cos(s);
        return Math.acos(e * r + h * n) > i ? 0 < h * r - e * n ? y._$clampAngle$_(t + i) : y._$clampAngle$_(t - i) : y._$clampAngle$_(s);
    }, y._$angleClockwise$_ = function(t, s) {
        let i = Math.sin(t), e = Math.cos(t), h = Math.sin(s), r = Math.cos(s);
        return e * h - i * r <= 0;
    }, y._$angleLerp$_ = function(t, s, i, e = 0) {
        let h = y._$angleDiff$_(t, s), r = yt * e;
        return y._$angleClockwise$_(s, t) ? y._$clampAngle$_(t + (h + r) * i) : y._$clampAngle$_(t - (h + r) * i);
    }, y._$angleLerpClockwise$_ = function(t, s, i, e = 0) {
        const h = y._$angleDiff$_(t, s), r = yt * e;
        return y._$angleClockwise$_(s, t) ? y._$clampAngle$_(t + (h + r) * i) : y._$clampAngle$_(t + (yt - h + r) * i);
    }, y._$angleLerpAntiClockwise$_ = function(t, s, i, e = 0) {
        const h = y._$angleDiff$_(t, s), r = yt * e;
        return y._$angleClockwise$_(s, t) ? y._$clampAngle$_(t - (-yt + h - r) * i) : y._$clampAngle$_(t - (h + r) * i);
    }, y._$angleReflect$_ = function(t, s) {
        const i = y._$angleDiff$_(t, s);
        return y._$angleClockwise$_(t, s) ? y._$clampAngle$_(s - i) : y._$clampAngle$_(s + i);
    }, y._$lerp$_ = function(t, s, i) {
        return t + i * (s - t);
    }, y._$unlerp$_ = function(t, s, i) {
        return t === s ? 0 : (i - t) / (s - t);
    }, y._$relerp$_ = function(t, s, i, e, h) {
        return y._$lerp$_(e, h, y._$unlerp$_(t, s, i));
    }, y._$qarp$_ = function(t, s, i, e) {
        return y._$lerp$_(y._$lerp$_(t, s, e), y._$lerp$_(s, i, e), e);
    }, y._$cubic$_ = function(t, s, i, e, h) {
        return y._$lerp$_(y._$qarp$_(t, s, i, h), y._$qarp$_(s, i, e, h), h);
    }, y._$cosp$_ = function(t, s, i) {
        return (t + s + (t - s) * Math.cos(i * Math.PI)) / 2;
    }, y._$isPOT$_ = function(t) {
        return 0 < t && 0 == (t - 1 & t);
    }, y._$nextHighestPowerOfTwo$_ = function(s) {
        --s;
        for (let t = 1; t < 32; t <<= 1) s |= s >> t;
        return s + 1;
    }, y._$roundToNearestFraction$_ = function(t, s) {
        return Math.round(t * s) / s;
    }, y._$floorToNearestFraction$_ = function(t, s) {
        return Math.floor(t * s) / s;
    }, y._$roundToDp$_ = function(t, s) {
        s = Math.max(Math.floor(s), 0);
        const i = Math.pow(10, s);
        return Math.round(t * i) / i;
    }, y._$countDecimals$_ = function(t) {
        return Math.floor(t) !== t && t.toString().split(".")[1].length || 0;
    }, y.toFixed = function(t, s) {
        let i = t.toFixed(s), e = i.length - 1;
        for (;0 <= e && "0" === i.charAt(e); --e);
        return 0 <= e && "." === i.charAt(e) && --e, e < 0 ? i : i.substr(0, e + 1);
    }, y._$PackRGB$_ = function(t, s, i) {
        return y._$clamp$_(t, 0, 255) | y._$clamp$_(s, 0, 255) << 8 | y._$clamp$_(i, 0, 255) << 16;
    }, 16384), Mt = (y._$PackRGBAEx$_ = function(t, s, i, e) {
        return t = y._$clamp$_(Math.floor(1024 * t), -8192, 8191), s = y._$clamp$_(Math.floor(1024 * s), -8192, 8191), 
        i = y._$clamp$_(Math.floor(1024 * i), -8192, 8191), e = y._$clamp$_(Math.floor(1023 * e), 0, 1023), 
        t < 0 && (t += bt), s < 0 && (s += bt), i < 0 && (i += bt), -(t * bt * bt * 1024 + s * bt * 1024 + 1024 * i + e);
    }, y._$PackRGBEx$_ = function(t, s, i) {
        return y._$PackRGBAEx$_(t, s, i, 1);
    }, y._$GetRValue$_ = function(s) {
        if (0 <= s) return (255 & s) / 255;
        {
            let t = Math.floor(-s / 274877906944);
            return 8191 < t && (t -= bt), t / 1024;
        }
    }, y._$GetGValue$_ = function(s) {
        if (0 <= s) return ((65280 & s) >> 8) / 255;
        {
            let t = Math.floor(-s % 274877906944 / 16777216);
            return 8191 < t && (t -= bt), t / 1024;
        }
    }, y._$GetBValue$_ = function(s) {
        if (0 <= s) return ((16711680 & s) >> 16) / 255;
        {
            let t = Math.floor(-s % 16777216 / 1024);
            return 8191 < t && (t -= bt), t / 1024;
        }
    }, y._$GetAValue$_ = function(t) {
        if (i(t)) return 0;
        if (0 <= t) return 1;
        {
            const s = Math.floor(-t % 1024);
            return s / 1023;
        }
    }, y._$greatestCommonDivisor$_ = function(s, i) {
        for (s = Math.floor(s), i = Math.floor(i); 0 !== i; ) {
            let t = i;
            i = s % i, s = t;
        }
        return s;
    }, [ [ 3, 2 ], [ 4, 3 ], [ 5, 4 ], [ 5, 3 ], [ 6, 5 ], [ 14, 9 ], [ 16, 9 ], [ 16, 10 ], [ 21, 9 ] ]);
    y._$getAspectRatio$_ = function(i, e) {
        if ((i = Math.floor(i)) === (e = Math.floor(e))) return [ 1, 1 ];
        for (let s of Mt) {
            let t = i / s[0] * s[1];
            if (Math.abs(e - t) < 1) return s.slice(0);
            if (t = i / s[1] * s[0], Math.abs(e - t) < 1) return [ s[1], s[0] ];
        }
        let t = y._$greatestCommonDivisor$_(i, e);
        return [ i / t, e / t ];
    }, y._$segmentsIntersect$_ = function(t, s, i, e, h, r, n, o) {
        const a = Math.min(t, i), l = Math.max(t, i), u = Math.min(h, n), c = Math.max(h, n);
        if (l < u || c < a) return !1;
        const f = Math.min(s, e), d = Math.max(s, e), p = Math.min(r, o), m = Math.max(r, o);
        if (d < p || m < f) return !1;
        const g = h - t + n - i, y = r - s + o - e, w = i - t, S = e - s, b = n - h, M = o - r, v = Math.abs(S * b - M * w), x = b * y - M * g;
        if (Math.abs(x) > v) return !1;
        const G = w * y - S * g;
        return Math.abs(G) <= v;
    }, y._$segmentsIntersectPreCalc$_ = function(t, s, i, e, h, r, n, o, a, l, u, c) {
        const f = Math.min(a, u), d = Math.max(a, u);
        if (r < f || d < h) return !1;
        const p = Math.min(l, c), m = Math.max(l, c);
        if (o < p || m < n) return !1;
        const g = a - t + u - i, y = l - s + c - e, w = i - t, S = e - s, b = u - a, M = c - l, v = Math.abs(S * b - M * w), x = b * y - M * g;
        if (Math.abs(x) > v) return !1;
        const G = w * y - S * g;
        return Math.abs(G) <= v;
    }, y._$segmentIntersectsQuad$_ = function(t, s, i, e, h) {
        const r = Math.min(t, i), n = Math.max(t, i), o = Math.min(s, e), a = Math.max(s, e), l = h._$getTlx$_(), u = h._$getTly$_(), c = h._$getTrx$_(), f = h._$getTry$_(), d = h._$getBrx$_(), p = h._$getBry$_(), m = h._$getBlx$_(), g = h._$getBly$_();
        return y._$segmentsIntersectPreCalc$_(t, s, i, e, r, n, o, a, l, u, c, f) || y._$segmentsIntersectPreCalc$_(t, s, i, e, r, n, o, a, c, f, d, p) || y._$segmentsIntersectPreCalc$_(t, s, i, e, r, n, o, a, d, p, m, g) || y._$segmentsIntersectPreCalc$_(t, s, i, e, r, n, o, a, m, g, l, u);
    }, y._$segmentIntersectsAnyN$_ = function(s, i, e, h, r) {
        let n = Math.min(s, e), o = Math.max(s, e), a = Math.min(i, h), l = Math.max(i, h), u = 0;
        for (let t = r.length - 4; u <= t; u += 2) if (y._$segmentsIntersectPreCalc$_(s, i, e, h, n, o, a, l, r[u], r[u + 1], r[u + 2], r[u + 3])) return !0;
        return y._$segmentsIntersectPreCalc$_(s, i, e, h, n, o, a, l, r[u], r[u + 1], r[0], r[1]);
    };
    y._$rayIntersect$_ = function(t, s, i, e, h, r, n, o) {
        const a = i - t, l = e - s, u = n - h, c = o - r, f = a * c - l * u;
        if (0 == f) return 2;
        const d = ((s - e) * (n - t) + a * (o - s)) / f;
        return 0 < d && d < 1 + 1e-6 ? (c * (n - t) + (h - n) * (o - s)) / f : 2;
    }, y._$rayIntersectExtended$_ = function(t, s, i, e, h, r, n, o, a) {
        const l = (n - h) * a, u = (o - r) * a;
        return y._$rayIntersect$_(t, s, i, e, h - l, r - u, n + l, o + u);
    }, y._$isPointInTriangleInclusive$_ = function(t, s, i, e, h, r, n, o) {
        const a = h - i, l = r - e, u = n - i, c = o - e, f = t - i, d = s - e, p = a * a + l * l, m = a * u + l * c, g = a * f + l * d, y = u * u + c * c, w = u * f + c * d, S = 1 / (p * y - m * m), b = (y * g - m * w) * S, M = (p * w - m * g) * S;
        return 0 <= b && 0 <= M && b + M <= 1;
    }, y._$triangleCartesianToBarycentric$_ = function(t, s, i, e, h, r, n, o) {
        const a = h - i, l = r - e, u = n - i, c = o - e, f = t - i, d = s - e, p = a * a + l * l, m = a * u + l * c, g = u * u + c * c, y = f * a + d * l, w = f * u + d * c, S = p * g - m * m, b = (g * y - m * w) / S, M = (p * w - m * y) / S, v = 1 - b - M;
        return [ v, b, M ];
    }, y._$triangleBarycentricToCartesian3d$_ = function(t, s, i, e, h, r, n, o, a, l, u, c) {
        return [ t * e + s * n + i * l, t * h + s * o + i * u, t * r + s * a + i * c ];
    };
}

{
    let l = self._$C3$_, s = null, i = "";
    if ("undefined" != typeof document) {
        const xt = (s = document).querySelector("base");
        !(i = xt && xt.hasAttribute("href") ? xt.getAttribute("href") : "") || (i = i.startsWith("/") ? i.substr(1) : i).endsWith("/") || (i += "/");
    }
    l._$GetBaseHref$_ = function() {
        return i;
    }, l._$GetBaseURL$_ = function() {
        if (!s) return "";
        const t = s.location;
        return l._$GetPathFromURL$_(t.origin + t.pathname) + i;
    }, l._$GetPathFromURL$_ = function(t) {
        if (!t.length) return t;
        if (t.endsWith("/") || t.endsWith("\\")) return t;
        const s = Math.max(t.lastIndexOf("/"), t.lastIndexOf("\\"));
        return -1 === s ? "" : t.substr(0, s + 1);
    }, l._$GetFilenameFromURL$_ = function(t) {
        if (!t.length) return t;
        if (t.endsWith("/") || t.endsWith("\\")) return "";
        const s = Math.max(t.lastIndexOf("/"), t.lastIndexOf("\\"));
        return -1 === s ? t : t.substr(s + 1);
    }, l._$GetFileExtension$_ = function(t) {
        let s = t.lastIndexOf(".");
        return s < 1 ? "" : t.substr(s);
    }, l._$SetFileExtension$_ = function(t, s) {
        const i = t.lastIndexOf(".");
        return -1 === i ? t + "." + s : t.substr(0, i + 1) + s;
    }, l._$GetFileNamePart$_ = function(t) {
        let s = t.lastIndexOf(".");
        return s < 1 ? t : t.substr(0, s);
    }, l._$NormalizeFileSeparator$_ = function(t) {
        return t.replace(/\\/g, "/");
    }, l._$IsFileExtension$_ = function(t, s) {
        const i = t ? l._$GetFileExtension$_(t).slice(1) : "";
        return s === i;
    }, l._$FileNameEquals$_ = function(t, s) {
        let i, e;
        return l._$IsFileLike$_(t) && (i = l._$GetFileNamePart$_(t.name)), l._$IsString$_(t) && (i = l._$GetFileNamePart$_(t)), 
        l._$IsFileLike$_(s) && (e = l._$GetFileNamePart$_(s.name)), l._$IsString$_(s) && (e = l._$GetFileNamePart$_(s)), 
        i === e;
    }, l._$ParseFilePath$_ = function(t) {
        t = l._$NormalizeFileSeparator$_(t);
        let s = /^\w:\//.exec(t), i = (s ? (s = s[0], "/" !== (t = t.slice(3))[0] && (t = "/" + t)) : s = "", 
        (t = 1 < (t = t.replace(/\/{2,}/g, "/")).length && "/" === t.slice(-1) ? t.slice(0, -1) : t).lastIndexOf("/") + 1), e = "", h = t, r, n = "";
        0 < i && (e = t.slice(0, i), h = t.slice(i));
        const o = (r = h).lastIndexOf("."), a = (0 < o && (n = h.slice(o), r = h.slice(0, -n.length)), 
        s + e + h);
        return {
            dir: e,
            _$base$_: h,
            name: r,
            root: s,
            ext: n,
            _$full$_: a
        };
    }, l._$Wait$_ = function(i, e) {
        return new Promise((t, s) => {
            self.setTimeout(t, i, e);
        });
    }, l._$swallowException$_ = function(t) {
        try {
            t();
        } catch (t) {
            l.isDebug && console.warn("Swallowed exception: ", t);
        }
    }, l._$noop$_ = function() {}, l._$equalsNoCase$_ = function(t, s) {
        return "string" == typeof t && "string" == typeof s && (t === s || t.normalize().toLowerCase() === s.normalize().toLowerCase());
    }, l._$equalsCase$_ = function(t, s) {
        return "string" == typeof t && "string" == typeof s && (t === s || t.normalize() === s.normalize());
    }, l._$typedArraySet16$_ = function(t, s, i) {
        t[i++] = s[0], t[i++] = s[1], t[i++] = s[2], t[i++] = s[3], t[i++] = s[4], 
        t[i++] = s[5], t[i++] = s[6], t[i++] = s[7], t[i++] = s[8], t[i++] = s[9], 
        t[i++] = s[10], t[i++] = s[11], t[i++] = s[12], t[i++] = s[13], t[i++] = s[14], 
        t[i] = s[15];
    }, l._$truncateArray$_ = function(t, s) {
        t.length = s;
    }, l._$clearArray$_ = function(t) {
        t && 0 !== t.length && l._$truncateArray$_(t, 0);
    }, l._$clear2DArray$_ = function(i) {
        if (i) {
            for (let s = 0; s < i.length; s++) {
                let t = i[s];
                l._$truncateArray$_(t, 0);
            }
            l._$truncateArray$_(i, 0);
        }
    }, l._$extendArray$_ = function(s, i, e) {
        i |= 0;
        const h = s.length;
        if (!(i <= h)) for (let t = h; t < i; ++t) s.push(e);
    }, l._$resizeArray$_ = function(t, s, i) {
        const e = t.length;
        (s |= 0) < e ? l._$truncateArray$_(t, s) : e < s && l._$extendArray$_(t, s, i);
    }, l._$shallowAssignArray$_ = function(t, s) {
        l._$clearArray$_(t), l._$appendArray$_(t, s);
    }, l._$appendArray$_ = function(i, e) {
        if (e.length < 1e4) i.push(...e); else for (let t = 0, s = e.length; t < s; ++t) i.push(e[t]);
    }, l._$arrayRemove$_ = function(i, e) {
        if (!((e = Math.floor(e)) < 0 || e >= i.length)) {
            let s = i.length - 1;
            for (let t = e; t < s; ++t) i[t] = i[t + 1];
            l._$truncateArray$_(i, s);
        }
    }, l._$arrayFindRemove$_ = function(t, s) {
        let i = t.indexOf(s);
        0 <= i && t.splice(i, 1);
    }, l._$arraysEqual$_ = function(s, i) {
        let e = s.length;
        if (i.length !== e) return !1;
        for (let t = 0; t < e; ++t) if (s[t] !== i[t]) return !1;
        return !0;
    }, l._$arrayFilterOut$_ = function(i, e) {
        let h = [], r = 0;
        for (let s = 0, t = i.length; s < t; ++s) {
            let t = i[s];
            e(t) ? h.push(t) : (i[r] = t, ++r);
        }
        return l._$truncateArray$_(i, r), h;
    }, l._$arrayRemoveAllInSet$_ = function(i, e) {
        let t = i.length, h = 0;
        for (let s = 0, t = i.length; s < t; ++s) {
            let t = i[s];
            e.has(t) || (i[h++] = t);
        }
        return l._$truncateArray$_(i, h), t - h;
    }, l._$isArrayIndexInBounds$_ = function(t, s) {
        return t === Math.floor(t) && 0 <= t && t < s.length;
    }, l._$validateArrayIndex$_ = function(t, s) {
        if (!l._$isArrayIndexInBounds$_(t, s)) throw new RangeError("array index out of bounds");
    }, l._$cloneArray$_ = function(t) {
        return t.slice();
    }, l._$deepCloneArray$_ = function(t, i) {
        let e = [];
        for (let s of t) if (l._$IsObject$_(s)) {
            let t = i(s);
            if (!t) throw new Error("missing clone");
            if (t.constructor !== s.constructor) throw new Error("object is not a clone");
            e.push(t);
        } else l._$IsArray$_(s) ? e.push(l._$deepCloneArray$_(s, i)) : e.push(s);
        return e;
    }, l._$clone2DArray$_ = function(s) {
        let i = [];
        for (let t of s) i.push(t.slice());
        return i;
    }, l._$splitStringAndNormalize$_ = function(t, s = " ") {
        return t ? t.split(s).map(t => t.trim()).filter(t => !!t) : [];
    }, l._$filterSet$_ = function(t, s, i) {
        const e = new Set();
        for (const h of t.values()) s(h) && (i ? e.add(i(h)) : e.add(h));
        return e;
    }, l._$mergeSets$_ = function(t, s) {
        return t.union ? t.union(s) : new Set([ ...t, ...s ]);
    }, l._$mergeSetsInPlace$_ = function(t, s) {
        for (const i of s) t.add(i);
        return t;
    }, l.first = function(s) {
        for (let t of s) return t;
        return null;
    }, l.xor = function(t, s) {
        return !t != !s;
    }, l.compare = function(t, s, i) {
        switch (s) {
          case 0:
            return t === i;

          case 1:
            return t !== i;

          case 2:
            return t < i;

          case 3:
            return t <= i;

          case 4:
            return i < t;

          case 5:
            return i <= t;

          default:
            return !1;
        }
    }, l._$hasAnyOwnProperty$_ = function(s) {
        for (let t in s) if (s.hasOwnProperty(t)) return !0;
        return !1;
    }, l._$PromiseAllWithProgress$_ = function(o, a) {
        return o.length ? new Promise((i, e) => {
            let h = [], r = 0, n = !1;
            for (let s = 0, t = o.length; s < t; ++s) h.push(void 0), o[s].then(t => {
                n || (h[s] = t, ++r === o.length ? i(h) : a(r, o.length));
            }).catch(t => {
                n = !0, e(t);
            });
        }) : Promise.resolve([]);
    };
    let e = [], h = (l._$AddLibraryMemoryCallback$_ = function(t) {
        e.push(t);
    }, l._$GetEstimatedLibraryMemoryUsage$_ = function() {
        let i = 0;
        for (let s of e) {
            let t = s();
            i += t;
        }
        return Math.floor(i);
    }, 1), r = new Map(), n = new MessageChannel();
    n.port2.onmessage = function(t) {
        const s = t.data, i = r.get(s);
        r.delete(s), i && i(performance.now());
    }, l._$RequestUnlimitedAnimationFrame$_ = function(t) {
        const s = h++;
        return r.set(s, t), n.port1.postMessage(s), s;
    }, l._$CancelUnlimitedAnimationFrame$_ = function(t) {
        r.delete(t);
    }, l._$PostTask$_ = l._$RequestUnlimitedAnimationFrame$_, l._$WaitForNextTask$_ = function() {
        return new Promise(t => l._$PostTask$_(t));
    };
    const vt = new Set();
    l._$RequestPostAnimationFrame$_ = function(s) {
        const i = self.requestAnimationFrame(async t => {
            await l._$WaitForNextTask$_(), vt.has(i) && (vt.delete(i), s(t));
        });
        return vt.add(i), i;
    }, l._$CancelPostAnimationFrame$_ = function(t) {
        vt.has(t) && (self.cancelAnimationFrame(t), vt.delete(t));
    };
}

{
    const r = self._$C3$_;
    r._$IsAbsoluteURL$_ = function(t) {
        return /^(?:[a-z\-]+:)?\/\//.test(t) || "data:" === t.substr(0, 5) || "blob:" === t.substr(0, 5);
    }, r._$IsRelativeURL$_ = function(t) {
        return !r._$IsAbsoluteURL$_(t);
    }, r._$ThrowIfNotOk$_ = function(t) {
        if (!t.ok) throw new Error(`fetch '${t.url}' response returned ${t.status} ` + t.statusText);
    }, r._$FetchOk$_ = function(t, s) {
        return fetch(t, s).then(t => (r._$ThrowIfNotOk$_(t), t));
    }, r._$FetchText$_ = function(t) {
        return r._$FetchOk$_(t).then(t => t.text());
    }, r._$FetchJson$_ = function(t) {
        return r._$FetchOk$_(t).then(t => t.json());
    }, r._$FetchBlob$_ = function(t) {
        return r._$FetchOk$_(t).then(t => t.blob());
    }, r._$FetchArrayBuffer$_ = function(t) {
        return r._$FetchOk$_(t).then(t => t.arrayBuffer());
    }, r._$FetchImage$_ = function(e) {
        return new Promise((t, s) => {
            const i = new Image();
            i.onload = () => t(i), i.onerror = t => s(t), i.src = e;
        });
    }, r._$BlobToArrayBuffer$_ = function(e) {
        return "function" == typeof e.arrayBuffer ? e.arrayBuffer() : new Promise((t, s) => {
            const i = new FileReader();
            i.onload = () => t(i.result), i.onerror = () => s(i.error), i.readAsArrayBuffer(e);
        });
    }, r._$BlobToString$_ = function(e) {
        return "function" == typeof e.text ? e.text() : new Promise((t, s) => {
            const i = new FileReader();
            i.onload = () => t(i.result), i.onerror = () => s(i.error), i.readAsText(e);
        });
    }, r._$BlobToJson$_ = function(t) {
        return r._$BlobToString$_(t).then(t => JSON.parse(t));
    }, r._$BlobToImage$_ = async function(t, s) {
        let i = URL.createObjectURL(t);
        try {
            const e = await r._$FetchImage$_(i);
            return URL.revokeObjectURL(i), i = "", s && "function" == typeof e.decode && await e.decode(), 
            e;
        } finally {
            i && URL.revokeObjectURL(i);
        }
    }, r._$CreateCanvas$_ = function(t, s) {
        if ("undefined" == typeof document || "function" != typeof document.createElement) return new OffscreenCanvas(t, s);
        {
            const i = document.createElement("canvas");
            return i.width = t, i.height = s, i;
        }
    }, r._$CanvasToBlob$_ = function(s, i, e) {
        if ("number" != typeof e && (e = 1), i = i || "image/png", e = r._$clamp$_(e, 0, 1), 
        s.convertToBlob) return s.convertToBlob({
            type: i,
            quality: e
        });
        if (s.toBlob) return new Promise(t => s.toBlob(t, i, e));
        throw new Error("could not convert canvas to blob");
    }, r._$DrawableToBlob$_ = function(t, s, i) {
        const e = r._$CreateCanvas$_(t.width, t.height), h = e.getContext("2d");
        return h.drawImage(t, 0, 0), r._$CanvasToBlob$_(e, s, i);
    }, r._$ImageDataToBlob$_ = function(t, s, i) {
        if (r._$Supports$_.ImageBitmapOptions) return createImageBitmap(t, {
            premultiplyAlpha: "none"
        }).then(t => r._$DrawableToBlob$_(t, s, i));
        if (r._$Supports$_.ImageBitmap) return createImageBitmap(t).then(t => r._$DrawableToBlob$_(t, s, i));
        {
            const e = r._$CreateCanvas$_(t.width, t.height), h = e.getContext("2d");
            return h.putImageData(t, 0, 0), r._$CanvasToBlob$_(e, s, i);
        }
    }, r._$CopySet$_ = function(t, s) {
        t.clear();
        for (const i of s) t.add(i);
    }, r._$MapToObject$_ = function(t) {
        const s = Object.create(null);
        for (const [ i, e ] of t.entries()) s[i] = e;
        return s;
    }, r._$ObjectToMap$_ = function(t, s) {
        s.clear();
        for (const [ i, e ] of Object.entries(t)) s.set(i, e);
    }, r._$ToSuperJSON$_ = function s(t) {
        if ("object" != typeof t || null === t) return t;
        if (t instanceof Set) return {
            _c3type_: "set",
            data: [ ...t ].map(t => s(t))
        };
        if (t instanceof Map) return {
            _c3type_: "map",
            data: [ ...t ].map(t => [ t[0], s(t[1]) ])
        };
        {
            const i = Object.create(null);
            for (const [ e, h ] of Object.entries(t)) i[e] = s(h);
            return i;
        }
    }, r._$FromSuperJSON$_ = function s(t) {
        if ("object" == typeof t & null !== t) {
            if ("set" === t._c3type_) return new Set(t.data.map(t => s(t)));
            if ("map" === t._c3type_) return new Map(t.data.map(t => [ t[0], s(t[1]) ]));
            {
                const i = Object.create(null);
                for (const [ e, h ] of Object.entries(t)) i[e] = s(h);
                return i;
            }
        }
        return t;
    }, r._$CSSToCamelCase$_ = function(t) {
        if (t.startsWith("--")) return t;
        let s = "", i = !1, e = 0;
        for (const h of t) "-" === h ? 0 < e && (i = !0) : i ? (s += h.toUpperCase(), 
        i = !1) : s += h, ++e;
        return s;
    }, r._$IsIterator$_ = function(t) {
        return "object" == typeof t && "function" == typeof t.next;
    }, r._$MakeFilledArray$_ = function(s, i) {
        const e = [];
        if ("function" == typeof i) for (let t = 0; t < s; ++t) e.push(i()); else for (let t = 0; t < s; ++t) e.push(i);
        return e;
    };
}

{
    let e = function(t) {
        return 0 === t.length ? "00" : 1 === t.length ? "0" + t : t;
    }, l = function(t, s, i) {
        return i < 0 && (i += 1), 1 < i && --i, i < 1 / 6 ? t + 6 * (s - t) * i : i < .5 ? s : i < 2 / 3 ? t + (s - t) * (2 / 3 - i) * 6 : t;
    };
    e, l;
    const u = self._$C3$_, Gt = /([0-9.]+),([0-9.]+)%?,([0-9.]+)%?/i, Tt = /([0-9.]+),([0-9.]+)%?,([0-9.]+)%?,([0-9.])/i;
    u._$Color$_ = class {
        constructor(t, s, i, e) {
            this._$_r$_ = NaN, this._$_g$_ = NaN, this._$_b$_ = NaN, this._$_a$_ = NaN, 
            this._$_r$_ = 0, this._$_g$_ = 0, this._$_b$_ = 0, this._$_a$_ = 0, 
            t instanceof u._$Color$_ ? this.set(t) : this._$setRgba$_(t || 0, s || 0, i || 0, e || 0);
        }
        _$setRgb$_(t, s, i) {
            return this._$_r$_ = +t, this._$_g$_ = +s, this._$_b$_ = +i, this._$clamp$_(), 
            this;
        }
        _$setRgba$_(t, s, i, e) {
            return this._$_r$_ = +t, this._$_g$_ = +s, this._$_b$_ = +i, this._$_a$_ = +e, 
            this._$clamp$_(), this;
        }
        set(t) {
            return this._$_r$_ = t._$_r$_, this._$_g$_ = t._$_g$_, this._$_b$_ = t._$_b$_, 
            this._$_a$_ = t._$_a$_, this;
        }
        _$copy$_(t) {
            return this.set(t);
        }
        add(t) {
            this._$_r$_ += t._$_r$_, this._$_g$_ += t._$_g$_, this._$_b$_ += t._$_b$_, 
            this._$_a$_ += t._$_a$_, this._$clamp$_();
        }
        _$addRgb$_(t, s, i, e = 0) {
            this._$_r$_ += +t, this._$_g$_ += +s, this._$_b$_ += +i, this._$_a$_ += +e, 
            this._$clamp$_();
        }
        _$diff$_(t) {
            this._$setR$_(Math.max(this._$_r$_, t._$_r$_) - Math.min(this._$_r$_, t._$_r$_)), 
            this._$setG$_(Math.max(this._$_g$_, t._$_g$_) - Math.min(this._$_g$_, t._$_g$_)), 
            this._$setB$_(Math.max(this._$_b$_, t._$_b$_) - Math.min(this._$_b$_, t._$_b$_)), 
            this._$setA$_(Math.max(this._$_a$_, t._$_a$_) - Math.min(this._$_a$_, t._$_a$_)), 
            this._$clamp$_();
        }
        _$copyRgb$_(t) {
            this._$_r$_ = t._$_r$_, this._$_g$_ = t._$_g$_, this._$_b$_ = t._$_b$_;
        }
        _$setR$_(t) {
            this._$_r$_ = u._$clamp$_(+t, 0, 1);
        }
        _$getR$_() {
            return this._$_r$_;
        }
        _$setG$_(t) {
            this._$_g$_ = u._$clamp$_(+t, 0, 1);
        }
        _$getG$_() {
            return this._$_g$_;
        }
        _$setB$_(t) {
            this._$_b$_ = u._$clamp$_(+t, 0, 1);
        }
        _$getB$_() {
            return this._$_b$_;
        }
        _$setA$_(t) {
            this._$_a$_ = u._$clamp$_(+t, 0, 1);
        }
        _$getA$_() {
            return this._$_a$_;
        }
        clone() {
            return u._$New$_(u._$Color$_, this._$_r$_, this._$_g$_, this._$_b$_, this._$_a$_);
        }
        toArray() {
            return [ this._$_r$_, this._$_g$_, this._$_b$_, this._$_a$_ ];
        }
        _$toTypedArray$_() {
            return new Float64Array(this.toArray());
        }
        _$writeToTypedArray$_(t, s) {
            t[s++] = this._$_r$_, t[s++] = this._$_g$_, t[s++] = this._$_b$_, t[s] = this._$_a$_;
        }
        _$writeRGBToTypedArray$_(t, s) {
            t[s++] = this._$_r$_, t[s++] = this._$_g$_, t[s] = this._$_b$_;
        }
        equals(t) {
            return this._$_r$_ === t._$_r$_ && this._$_g$_ === t._$_g$_ && this._$_b$_ === t._$_b$_ && this._$_a$_ === t._$_a$_;
        }
        _$equalsIgnoringAlpha$_(t) {
            return this._$_r$_ === t._$_r$_ && this._$_g$_ === t._$_g$_ && this._$_b$_ === t._$_b$_;
        }
        _$equalsRgb$_(t, s, i) {
            return this._$_r$_ === t && this._$_g$_ === s && this._$_b$_ === i;
        }
        _$equalsRgba$_(t, s, i, e) {
            return this._$_r$_ === t && this._$_g$_ === s && this._$_b$_ === i && this._$_a$_ === e;
        }
        _$equalsF32Array$_(t, s) {
            return t[s] === Math.fround(this._$_r$_) && t[s + 1] === Math.fround(this._$_g$_) && t[s + 2] === Math.fround(this._$_b$_) && t[s + 3] === Math.fround(this._$_a$_);
        }
        _$equalsRGBF32Array$_(t, s) {
            return t[s] === Math.fround(this._$_r$_) && t[s + 1] === Math.fround(this._$_g$_) && t[s + 2] === Math.fround(this._$_b$_);
        }
        multiply(t) {
            this._$_r$_ *= t._$_r$_, this._$_g$_ *= t._$_g$_, this._$_b$_ *= t._$_b$_, 
            this._$_a$_ *= t._$_a$_;
        }
        _$multiplyAlpha$_(t) {
            this._$_r$_ *= t, this._$_g$_ *= t, this._$_b$_ *= t, this._$_a$_ *= t;
        }
        _$premultiply$_() {
            return this._$_r$_ *= this._$_a$_, this._$_g$_ *= this._$_a$_, this._$_b$_ *= this._$_a$_, 
            this;
        }
        _$unpremultiply$_() {
            return this._$_r$_ /= this._$_a$_, this._$_g$_ /= this._$_a$_, this._$_b$_ /= this._$_a$_, 
            this;
        }
        _$clamp$_() {
            return this._$_r$_ = u._$clamp$_(this._$_r$_, 0, 1), this._$_g$_ = u._$clamp$_(this._$_g$_, 0, 1), 
            this._$_b$_ = u._$clamp$_(this._$_b$_, 0, 1), this._$_a$_ = u._$clamp$_(this._$_a$_, 0, 1), 
            this;
        }
        _$setFromRgbValue$_(t) {
            this._$_r$_ = u._$GetRValue$_(t), this._$_g$_ = u._$GetGValue$_(t), 
            this._$_b$_ = u._$GetBValue$_(t), this._$_a$_ = u._$GetAValue$_(t);
        }
        _$getCssRgb$_(t, s, i) {
            const e = u._$IsFiniteNumber$_(t) ? t : this._$getR$_(), h = u._$IsFiniteNumber$_(s) ? s : this._$getG$_(), r = u._$IsFiniteNumber$_(i) ? i : this._$getB$_();
            return `rgb(${100 * e}%, ${100 * h}%, ${100 * r}%)`;
        }
        _$getCssRgba$_(t, s, i, e) {
            const h = u._$IsFiniteNumber$_(t) ? t : this._$getR$_(), r = u._$IsFiniteNumber$_(s) ? s : this._$getG$_(), n = u._$IsFiniteNumber$_(i) ? i : this._$getB$_(), o = u._$IsFiniteNumber$_(e) ? e : this._$getA$_();
            return `rgba(${100 * h}%, ${100 * r}%, ${100 * n}%, ${o})`;
        }
        _$toHexString$_() {
            const t = Math.round(255 * this._$getR$_()), s = Math.round(255 * this._$getG$_()), i = Math.round(255 * this._$getB$_());
            return "#" + e(t.toString(16)) + e(s.toString(16)) + e(i.toString(16));
        }
        _$parseHexString$_(t) {
            if ("string" != typeof t) return !1;
            let s, i, e;
            if (3 === (t = "#" === (t = t.trim()).charAt(0) ? t.substr(1) : t).length) s = parseInt(t[0], 16) / 15, 
            i = parseInt(t[1], 16) / 15, e = parseInt(t[2], 16) / 15; else {
                if (6 !== t.length) return !1;
                s = parseInt(t.substr(0, 2), 16) / 255, i = parseInt(t.substr(2, 2), 16) / 255, 
                e = parseInt(t.substr(4, 2), 16) / 255;
            }
            return isFinite(s) && this._$setR$_(s), isFinite(i) && this._$setG$_(i), 
            isFinite(e) && this._$setB$_(e), this._$setA$_(1), !0;
        }
        _$toCommaSeparatedRgb$_() {
            const t = Math.round(255 * this._$getR$_()), s = Math.round(255 * this._$getG$_()), i = Math.round(255 * this._$getB$_());
            return t + `, ${s}, ` + i;
        }
        _$toRgbArray$_() {
            const t = Math.round(255 * this._$getR$_()), s = Math.round(255 * this._$getG$_()), i = Math.round(255 * this._$getB$_());
            return [ t, s, i ];
        }
        _$parseCommaSeparatedRgb$_(t) {
            if ("string" != typeof t) return !1;
            const s = (t = t.replace(/^rgb\(|\)|%/, "")).split(",");
            if (s.length < 3) return !1;
            const i = parseInt(s[0].trim(), 10) / 255, e = parseInt(s[1].trim(), 10) / 255, h = parseInt(s[2].trim(), 10) / 255;
            return isFinite(i) && this._$setR$_(i), isFinite(e) && this._$setG$_(e), 
            isFinite(h) && this._$setB$_(h), this._$setA$_(1), !0;
        }
        _$parseCommaSeparatedPercentageRgb$_(t) {
            if ("string" != typeof t) return !1;
            const s = (t = t.replace(/^rgb\(|\)|%/, "")).split(",");
            if (s.length < 3) return !1;
            const i = parseInt(s[0].trim(), 10) / 100, e = parseInt(s[1].trim(), 10) / 100, h = parseInt(s[2].trim(), 10) / 100;
            return isFinite(i) && this._$setR$_(i), isFinite(e) && this._$setG$_(e), 
            isFinite(h) && this._$setB$_(h), this._$setA$_(1), !0;
        }
        _$parseCommaSeparatedRgba$_(t) {
            if ("string" != typeof t) return !1;
            const s = (t = t.replace(/^rgba\(|\)|%/, "")).split(",");
            if (s.length < 4) return !1;
            const i = parseInt(s[0].trim(), 10) / 255, e = parseInt(s[1].trim(), 10) / 255, h = parseInt(s[2].trim(), 10) / 255, r = parseFloat(s[3].trim());
            return isFinite(i) && this._$setR$_(i), isFinite(e) && this._$setG$_(e), 
            isFinite(h) && this._$setB$_(h), isFinite(r) && this._$setA$_(r), !0;
        }
        _$parseCommaSeparatedPercentageRgba$_(t) {
            if ("string" != typeof t) return !1;
            const s = (t = t.replace(/^rgba\(|\)|%/, "")).split(",");
            if (s.length < 4) return !1;
            const i = parseInt(s[0].trim(), 10) / 100, e = parseInt(s[1].trim(), 10) / 100, h = parseInt(s[2].trim(), 10) / 100, r = parseFloat(s[3].trim());
            return isFinite(i) && this._$setR$_(i), isFinite(e) && this._$setG$_(e), 
            isFinite(h) && this._$setB$_(h), isFinite(r) && this._$setA$_(r), !0;
        }
        _$parseString$_(t) {
            if ("string" != typeof t) return !1;
            if ((t = t.replace(/\s+/, "")).includes(",")) {
                if (t.startsWith("rgb(")) return t.includes("%") ? this._$parseCommaSeparatedPercentageRgb$_(t) : this._$parseCommaSeparatedRgb$_(t);
                if (t.startsWith("rgba(")) return t.includes("%") ? this._$parseCommaSeparatedPercentageRgba$_(t) : this._$parseCommaSeparatedRgba$_(t);
                if (t.startsWith("hsl(") || t.startsWith("hsla(")) return this._$parseHSLString$_(t);
                {
                    const s = t.split(",");
                    return t.includes("%") ? 3 === s.length ? this._$parseCommaSeparatedPercentageRgb$_(t) : 4 === s.length && this._$parseCommaSeparatedPercentageRgba$_(t) : 3 === s.length ? this._$parseCommaSeparatedRgb$_(t) : 4 === s.length && this._$parseCommaSeparatedRgba$_(t);
                }
            }
            return this._$parseHexString$_(t);
        }
        toJSON() {
            return [ this._$_r$_, this._$_g$_, this._$_b$_, this._$_a$_ ];
        }
        _$setFromHSLA$_(t, s, i, e) {
            let h, r, n;
            if (t %= 360, s = u._$clamp$_(s, 0, 100), i = u._$clamp$_(i, 0, 100), 
            e = u._$clamp$_(e, 0, 1), t /= 360, i /= 100, 0 === (s /= 100)) h = r = n = i; else {
                const o = i < .5 ? i * (1 + s) : i + s - i * s, a = 2 * i - o;
                h = l(a, o, t + 1 / 3), r = l(a, o, t), n = l(a, o, t - 1 / 3);
            }
            return this._$setR$_(h), this._$setG$_(r), this._$setB$_(n), this._$setA$_(e), 
            this;
        }
        _$parseHSLString$_(t) {
            const s = t.replace(/ |hsl|hsla|\(|\)|;/gi, ""), i = Gt.exec(s), e = Tt.exec(s);
            return i && 4 === i.length ? (this._$setFromHSLA$_(+i[1], +i[2], +i[3], 1), 
            !0) : !(!e || 5 !== e.length || (this._$setFromHSLA$_(+i[1], +i[2], +i[3], +i[4]), 
            0));
        }
        _$toHSLAString$_() {
            const t = this._$_r$_, s = this._$_g$_, i = this._$_b$_, e = this._$_a$_, h = u._$Color$_._$GetHue$_(t, s, i), r = u._$Color$_._$GetSaturation$_(t, s, i), n = u._$Color$_._$GetLuminosity$_(t, s, i);
            return `hsla(${h}, ${r}%, ${n}%, ${e})`;
        }
        _$toHSLAArray$_() {
            const t = this._$_r$_, s = this._$_g$_, i = this._$_b$_;
            return [ u._$Color$_._$GetHue$_(t, s, i), u._$Color$_._$GetSaturation$_(t, s, i), u._$Color$_._$GetLuminosity$_(t, s, i), this._$_a$_ ];
        }
        _$setFromJSON$_(t) {
            !Array.isArray(t) || t.length < 3 || (this._$_r$_ = t[0], this._$_g$_ = t[1], 
            this._$_b$_ = t[2], this._$_a$_ = 4 <= t.length ? t[3] : 1);
        }
        set r(t) {
            this._$setR$_(t);
        }
        get r() {
            return this._$getR$_();
        }
        set g(t) {
            this._$setG$_(t);
        }
        get g() {
            return this._$getG$_();
        }
        set b(t) {
            this._$setB$_(t);
        }
        get b() {
            return this._$getB$_();
        }
        set a(t) {
            this._$setA$_(t);
        }
        get a() {
            return this._$getA$_();
        }
        _$setAtIndex$_(t, s) {
            switch (t) {
              case 0:
                this._$setR$_(s);
                break;

              case 1:
                this._$setG$_(s);
                break;

              case 2:
                this._$setB$_(s);
                break;

              case 3:
                this._$setA$_(s);
                break;

              default:
                throw new RangeError("invalid color index");
            }
        }
        _$getAtIndex$_(t) {
            switch (t) {
              case 0:
                return this._$getR$_();

              case 1:
                return this._$getG$_();

              case 2:
                return this._$getB$_();

              case 3:
                return this._$getA$_();

              default:
                throw new RangeError("invalid color index");
            }
        }
        static _$Equals$_(t, s) {
            let i, e;
            if (Array.isArray(t)) (i = new u._$Color$_())._$setFromJSON$_(t); else {
                if (!(t instanceof u._$Color$_)) throw new Error("unexpected type");
                i = t;
            }
            if (Array.isArray(s)) (e = new u._$Color$_())._$setFromJSON$_(s); else {
                if (!(s instanceof u._$Color$_)) throw new Error("unexpected type");
                e = s;
            }
            return i.equals(e);
        }
        static _$DiffChannel$_(t, s) {
            return u._$clamp$_(Math.max(t, s) - Math.min(t, s), 0, 1);
        }
        static _$Diff$_(t, s) {
            const i = new u._$Color$_();
            return i._$setR$_(Math.max(t._$_r$_, s._$_r$_) - Math.min(t._$_r$_, s._$_r$_)), 
            i._$setG$_(Math.max(t._$_g$_, s._$_g$_) - Math.min(t._$_g$_, s._$_g$_)), 
            i._$setB$_(Math.max(t._$_b$_, s._$_b$_) - Math.min(t._$_b$_, s._$_b$_)), 
            i._$setA$_(Math.max(t._$_a$_, s._$_a$_) - Math.min(t._$_a$_, s._$_a$_)), 
            i;
        }
        static _$DiffNoAlpha$_(t, s) {
            const i = new u._$Color$_(0, 0, 0, 1);
            return i._$setR$_(Math.max(t._$_r$_, s._$_r$_) - Math.min(t._$_r$_, s._$_r$_)), 
            i._$setG$_(Math.max(t._$_g$_, s._$_g$_) - Math.min(t._$_g$_, s._$_g$_)), 
            i._$setB$_(Math.max(t._$_b$_, s._$_b$_) - Math.min(t._$_b$_, s._$_b$_)), 
            i;
        }
        static _$GetHue$_(t, s, i) {
            const e = Math.max(t, s, i), h = Math.min(t, s, i);
            if (e === h) return 0;
            let r = 0;
            switch (e) {
              case t:
                r = (s - i) / (e - h) + (s < i ? 6 : 0);
                break;

              case s:
                r = (i - t) / (e - h) + 2;
                break;

              case i:
                r = (t - s) / (e - h) + 4;
            }
            return Math.round(r / 6 * 360);
        }
        static _$GetSaturation$_(t, s, i) {
            const e = Math.max(t, s, i), h = Math.min(t, s, i);
            if (e === h) return 0;
            const r = (e + h) / 2, n = e - h, o = .5 < r ? n / (2 - e - h) : n / (e + h);
            return Math.round(100 * o);
        }
        static _$GetLuminosity$_(t, s, i) {
            const e = Math.max(t, s, i), h = Math.min(t, s, i), r = (e + h) / 2;
            return e ? Math.round(100 * r) : 0;
        }
    }, u._$Color$_._$White$_ = Object.freeze(u._$New$_(u._$Color$_, 1, 1, 1, 1)), 
    u._$Color$_._$Black$_ = Object.freeze(u._$New$_(u._$Color$_, 0, 0, 0, 1)), u._$Color$_._$TransparentBlack$_ = Object.freeze(u._$New$_(u._$Color$_, 0, 0, 0, 0));
}

{
    const _t = self._$C3$_;
    _t._$Vector2$_ = class {
        constructor(t, s) {
            this._$_x$_ = 0, this._$_y$_ = 0, t instanceof _t._$Vector2$_ ? this._$copy$_(t) : this.set(t || 0, s || 0);
        }
        set(t, s) {
            this._$_x$_ = +t, this._$_y$_ = +s;
        }
        _$copy$_(t) {
            this._$_x$_ = t._$_x$_, this._$_y$_ = t._$_y$_;
        }
        equals(t) {
            return this._$_x$_ === t._$_x$_ && this._$_y$_ === t._$_y$_;
        }
        _$equalsValues$_(t, s) {
            return this._$_x$_ === t && this._$_y$_ === s;
        }
        _$equalsF32Array$_(t, s) {
            return t[s] === Math.fround(this._$_x$_) && t[s + 1] === Math.fround(this._$_y$_);
        }
        _$setX$_(t) {
            this._$_x$_ = +t;
        }
        _$getX$_() {
            return this._$_x$_;
        }
        _$setY$_(t) {
            this._$_y$_ = +t;
        }
        _$getY$_() {
            return this._$_y$_;
        }
        toArray() {
            return [ this._$_x$_, this._$_y$_ ];
        }
        _$toTypedArray$_() {
            return new Float64Array(this.toArray());
        }
        _$writeToTypedArray$_(t, s) {
            t[s++] = this._$_x$_, t[s] = this._$_y$_;
        }
        offset(t, s) {
            this._$_x$_ += +t, this._$_y$_ += +s;
        }
        scale(t, s) {
            this._$_x$_ *= t, this._$_y$_ *= s;
        }
        _$divide$_(t, s) {
            this._$_x$_ /= t, this._$_y$_ /= s;
        }
        round() {
            this._$_x$_ = Math.round(this._$_x$_), this._$_y$_ = Math.round(this._$_y$_);
        }
        floor() {
            this._$_x$_ = Math.floor(this._$_x$_), this._$_y$_ = Math.floor(this._$_y$_);
        }
        ceil() {
            this._$_x$_ = Math.ceil(this._$_x$_), this._$_y$_ = Math.ceil(this._$_y$_);
        }
        angle() {
            return _t._$angleTo$_(0, 0, this._$_x$_, this._$_y$_);
        }
        _$lengthSquared$_() {
            return this._$_x$_ * this._$_x$_ + this._$_y$_ * this._$_y$_;
        }
        length() {
            return Math.hypot(this._$_x$_, this._$_y$_);
        }
        _$rotatePrecalc$_(t, s) {
            const i = this._$_x$_ * s - this._$_y$_ * t;
            this._$_y$_ = this._$_y$_ * s + this._$_x$_ * t, this._$_x$_ = i;
        }
        rotate(t) {
            0 !== t && this._$rotatePrecalc$_(Math.sin(t), Math.cos(t));
        }
        _$rotateAbout$_(t, s, i) {
            0 === t || s === this._$_x$_ && i === this._$_y$_ || (this._$_x$_ -= s, 
            this._$_y$_ -= i, this._$rotatePrecalc$_(Math.sin(t), Math.cos(t)), 
            this._$_x$_ += +s, this._$_y$_ += +i);
        }
        move(t, s) {
            0 !== s && (this._$_x$_ += Math.cos(t) * s, this._$_y$_ += Math.sin(t) * s);
        }
        normalize() {
            const t = this.length();
            0 !== t && 1 !== t && (this._$_x$_ /= t, this._$_y$_ /= t);
        }
        _$clamp$_(t, s) {
            this._$_x$_ = _t._$clamp$_(this._$_x$_, t, s), this._$_y$_ = _t._$clamp$_(this._$_y$_, t, s);
        }
        _$dot$_(t) {
            return this._$_x$_ * t._$_x$_ + this._$_y$_ * t._$_y$_;
        }
        reverse() {
            this._$_x$_ = -this._$_x$_, this._$_y$_ = -this._$_y$_;
        }
        _$perp$_() {
            let t = this._$_x$_;
            return this._$_x$_ = this._$_y$_, this._$_y$_ = -t, this;
        }
    };
}

{
    const It = self._$C3$_;
    It.Rect = class {
        constructor(t, s, i, e) {
            this._$_left$_ = NaN, this._$_top$_ = NaN, this._$_right$_ = NaN, this._$_bottom$_ = NaN, 
            this._$_left$_ = 0, this._$_top$_ = 0, this._$_right$_ = 0, this._$_bottom$_ = 0, 
            t instanceof It.Rect ? this._$copy$_(t) : this.set(t || 0, s || 0, i || 0, e || 0);
        }
        set(t, s, i, e) {
            this._$_left$_ = +t, this._$_top$_ = +s, this._$_right$_ = +i, this._$_bottom$_ = +e;
        }
        _$setWH$_(t, s, i, e) {
            s = +s, this._$_left$_ = t = +t, this._$_top$_ = s, this._$_right$_ = t + +i, 
            this._$_bottom$_ = s + +e;
        }
        _$copy$_(t) {
            this._$_left$_ = +t._$_left$_, this._$_top$_ = +t._$_top$_, this._$_right$_ = +t._$_right$_, 
            this._$_bottom$_ = +t._$_bottom$_;
        }
        clone() {
            return new It.Rect(this._$_left$_, this._$_top$_, this._$_right$_, this._$_bottom$_);
        }
        static _$Merge$_(t, s) {
            const i = new It.Rect();
            return i._$setLeft$_(Math.min(t._$_left$_, s._$_left$_)), i._$setTop$_(Math.min(t._$_top$_, s._$_top$_)), 
            i._$setRight$_(Math.max(t._$_right$_, s._$_right$_)), i._$setBottom$_(Math.max(t._$_bottom$_, s._$_bottom$_)), 
            i;
        }
        static _$FromObject$_(t) {
            return new It.Rect(t.left, t.top, t.right, t.bottom);
        }
        equals(t) {
            return this._$_left$_ === t._$_left$_ && this._$_top$_ === t._$_top$_ && this._$_right$_ === t._$_right$_ && this._$_bottom$_ === t._$_bottom$_;
        }
        _$equalsWH$_(t, s, i, e) {
            return this._$_left$_ === t && this._$_top$_ === s && this.width() === i && this.height() === e;
        }
        _$equalsF32Array$_(t, s) {
            return t[s] === Math.fround(this._$_left$_) && t[s + 1] === Math.fround(this._$_top$_) && t[s + 2] === Math.fround(this._$_right$_) && t[s + 3] === Math.fround(this._$_bottom$_);
        }
        _$setLeft$_(t) {
            this._$_left$_ = +t;
        }
        _$getLeft$_() {
            return this._$_left$_;
        }
        _$setTop$_(t) {
            this._$_top$_ = +t;
        }
        _$getTop$_() {
            return this._$_top$_;
        }
        _$setRight$_(t) {
            this._$_right$_ = +t;
        }
        _$getRight$_() {
            return this._$_right$_;
        }
        _$setBottom$_(t) {
            this._$_bottom$_ = +t;
        }
        _$getBottom$_() {
            return this._$_bottom$_;
        }
        toArray() {
            return [ this._$_left$_, this._$_top$_, this._$_right$_, this._$_bottom$_ ];
        }
        _$toTypedArray$_() {
            return new Float64Array(this.toArray());
        }
        _$toDOMRect$_() {
            return new DOMRect(this._$_left$_, this._$_top$_, this.width(), this.height());
        }
        static _$fromDOMRect$_(t) {
            return It._$New$_(It.Rect, t.left, t.top, t.right, t.bottom);
        }
        _$writeToTypedArray$_(t, s) {
            t[s++] = this._$_left$_, t[s++] = this._$_top$_, t[s++] = this._$_right$_, 
            t[s] = this._$_bottom$_;
        }
        _$writeAsQuadToTypedArray$_(t, s) {
            t[s++] = this._$_left$_, t[s++] = this._$_top$_, t[s++] = this._$_right$_, 
            t[s++] = this._$_top$_, t[s++] = this._$_right$_, t[s++] = this._$_bottom$_, 
            t[s++] = this._$_left$_, t[s] = this._$_bottom$_;
        }
        _$writeAsQuadToTypedArray3D$_(t, s, i) {
            t[s++] = this._$_left$_, t[s++] = this._$_top$_, t[s++] = i, t[s++] = this._$_right$_, 
            t[s++] = this._$_top$_, t[s++] = i, t[s++] = this._$_right$_, t[s++] = this._$_bottom$_, 
            t[s++] = i, t[s++] = this._$_left$_, t[s++] = this._$_bottom$_, t[s] = i;
        }
        width() {
            return this._$_right$_ - this._$_left$_;
        }
        height() {
            return this._$_bottom$_ - this._$_top$_;
        }
        _$midX$_() {
            return (this._$_left$_ + this._$_right$_) / 2;
        }
        _$midY$_() {
            return (this._$_top$_ + this._$_bottom$_) / 2;
        }
        offset(t, s) {
            s = +s, this._$_left$_ += t = +t, this._$_top$_ += s, this._$_right$_ += t, 
            this._$_bottom$_ += s;
        }
        offsetLeft(t) {
            this._$_left$_ += +t;
        }
        offsetTop(t) {
            this._$_top$_ += +t;
        }
        _$offsetRight$_(t) {
            this._$_right$_ += +t;
        }
        _$offsetBottom$_(t) {
            this._$_bottom$_ += +t;
        }
        _$toSquare$_(t) {
            if ("x" !== t) throw new Error("invalid axis, only 'x' supported");
            this._$_top$_ < this._$_bottom$_ ? this._$_left$_ < this._$_right$_ ? this._$_bottom$_ = this._$_top$_ + this.width() : this._$_bottom$_ = this._$_top$_ - this.width() : this._$_left$_ < this._$_right$_ ? this._$_bottom$_ = this._$_top$_ - this.width() : this._$_bottom$_ = this._$_top$_ + this.width();
        }
        _$inflate$_(t, s) {
            s = +s, this._$_left$_ -= t = +t, this._$_top$_ -= s, this._$_right$_ += t, 
            this._$_bottom$_ += s;
        }
        _$deflate$_(t, s) {
            s = +s, this._$_left$_ += t = +t, this._$_top$_ += s, this._$_right$_ -= t, 
            this._$_bottom$_ -= s;
        }
        multiply(t, s) {
            this._$_left$_ *= t, this._$_top$_ *= s, this._$_right$_ *= t, this._$_bottom$_ *= s;
        }
        _$divide$_(t, s) {
            this._$_left$_ /= t, this._$_top$_ /= s, this._$_right$_ /= t, this._$_bottom$_ /= s;
        }
        _$mirrorAround$_(t) {
            this._$_left$_ = +t - this._$_left$_, this._$_right$_ = +t - this._$_right$_;
        }
        _$flipAround$_(t) {
            this._$_top$_ = +t - this._$_top$_, this._$_bottom$_ = +t - this._$_bottom$_;
        }
        _$rotate90DegreesAround$_(t, s) {
            const i = this.width(), e = this.height(), h = this._$getLeft$_() + i * t, r = this._$getTop$_() + e * s;
            this._$setWH$_(h - e * s, r - i * t, e, i);
        }
        _$swapLeftRight$_() {
            const t = this._$_left$_;
            this._$_left$_ = this._$_right$_, this._$_right$_ = t;
        }
        _$swapTopBottom$_() {
            const t = this._$_top$_;
            this._$_top$_ = this._$_bottom$_, this._$_bottom$_ = t;
        }
        _$shuntY$_(t) {
            const s = this._$_top$_;
            this._$_top$_ = +t - this._$_bottom$_, this._$_bottom$_ = +t - s;
        }
        round() {
            this._$_left$_ = Math.round(this._$_left$_), this._$_top$_ = Math.round(this._$_top$_), 
            this._$_right$_ = Math.round(this._$_right$_), this._$_bottom$_ = Math.round(this._$_bottom$_);
        }
        _$roundInner$_() {
            this._$_left$_ = Math.ceil(this._$_left$_), this._$_top$_ = Math.ceil(this._$_top$_), 
            this._$_right$_ = Math.floor(this._$_right$_), this._$_bottom$_ = Math.floor(this._$_bottom$_);
        }
        _$roundOuter$_() {
            this._$_left$_ = Math.floor(this._$_left$_), this._$_top$_ = Math.floor(this._$_top$_), 
            this._$_right$_ = Math.ceil(this._$_right$_), this._$_bottom$_ = Math.ceil(this._$_bottom$_);
        }
        floor() {
            this._$_left$_ = Math.floor(this._$_left$_), this._$_top$_ = Math.floor(this._$_top$_), 
            this._$_right$_ = Math.floor(this._$_right$_), this._$_bottom$_ = Math.floor(this._$_bottom$_);
        }
        ceil() {
            this._$_left$_ = Math.ceil(this._$_left$_), this._$_top$_ = Math.ceil(this._$_top$_), 
            this._$_right$_ = Math.ceil(this._$_right$_), this._$_bottom$_ = Math.ceil(this._$_bottom$_);
        }
        _$clamp$_(t, s, i, e) {
            this._$_left$_ = Math.max(this._$_left$_, +t), this._$_top$_ = Math.max(this._$_top$_, +s), 
            this._$_right$_ = Math.min(this._$_right$_, +i), this._$_bottom$_ = Math.min(this._$_bottom$_, +e);
        }
        _$clampBoth$_(t, s, i, e) {
            t = +t, s = +s, i = +i, e = +e, this._$_left$_ = It._$clamp$_(this._$_left$_, t, i), 
            this._$_top$_ = It._$clamp$_(this._$_top$_, s, e), this._$_right$_ = It._$clamp$_(this._$_right$_, t, i), 
            this._$_bottom$_ = It._$clamp$_(this._$_bottom$_, s, e);
        }
        normalize() {
            this._$_left$_ > this._$_right$_ && this._$swapLeftRight$_(), this._$_top$_ > this._$_bottom$_ && this._$swapTopBottom$_();
        }
        _$intersectsRect$_(t) {
            return !(t._$_right$_ < this._$_left$_ || t._$_bottom$_ < this._$_top$_ || t._$_left$_ > this._$_right$_ || t._$_top$_ > this._$_bottom$_);
        }
        _$intersectsRectOffset$_(t, s, i) {
            return !(t._$_right$_ + s < this._$_left$_ || t._$_bottom$_ + i < this._$_top$_ || t._$_left$_ + s > this._$_right$_ || t._$_top$_ + i > this._$_bottom$_);
        }
        _$containsPoint$_(t, s) {
            return t >= this._$_left$_ && t <= this._$_right$_ && s >= this._$_top$_ && s <= this._$_bottom$_;
        }
        _$containsRect$_(t) {
            return t._$_left$_ >= this._$_left$_ && t._$_top$_ >= this._$_top$_ && t._$_right$_ <= this._$_right$_ && t._$_bottom$_ <= this._$_bottom$_;
        }
        _$expandToContain$_(t) {
            t._$_left$_ < this._$_left$_ && (this._$_left$_ = +t._$_left$_), t._$_top$_ < this._$_top$_ && (this._$_top$_ = +t._$_top$_), 
            t._$_right$_ > this._$_right$_ && (this._$_right$_ = +t._$_right$_), 
            t._$_bottom$_ > this._$_bottom$_ && (this._$_bottom$_ = +t._$_bottom$_);
        }
        _$lerpInto$_(t) {
            this._$_left$_ = It._$lerp$_(t._$_left$_, t._$_right$_, this._$_left$_), 
            this._$_top$_ = It._$lerp$_(t._$_top$_, t._$_bottom$_, this._$_top$_), 
            this._$_right$_ = It._$lerp$_(t._$_left$_, t._$_right$_, this._$_right$_), 
            this._$_bottom$_ = It._$lerp$_(t._$_top$_, t._$_bottom$_, this._$_bottom$_);
        }
    };
}

{
    const Ct = self._$C3$_;
    Ct._$Quad$_ = class {
        constructor(t, s, i, e, h, r, n, o) {
            this._$_tlx$_ = NaN, this._$_tly$_ = NaN, this._$_trx$_ = NaN, this._$_try$_ = NaN, 
            this._$_brx$_ = NaN, this._$_bry$_ = NaN, this._$_blx$_ = NaN, this._$_bly$_ = NaN, 
            this._$_tlx$_ = 0, this._$_tly$_ = 0, this._$_trx$_ = 0, this._$_try$_ = 0, 
            this._$_brx$_ = 0, this._$_bry$_ = 0, this._$_blx$_ = 0, this._$_bly$_ = 0, 
            t instanceof Ct._$Quad$_ ? this._$copy$_(t) : this.set(t || 0, s || 0, i || 0, e || 0, h || 0, r || 0, n || 0, o || 0);
        }
        set(t, s, i, e, h, r, n, o) {
            this._$_tlx$_ = +t, this._$_tly$_ = +s, this._$_trx$_ = +i, this._$_try$_ = +e, 
            this._$_brx$_ = +h, this._$_bry$_ = +r, this._$_blx$_ = +n, this._$_bly$_ = +o;
        }
        _$setRect$_(t, s, i, e) {
            this.set(t, s, i, s, i, e, t, e);
        }
        _$copy$_(t) {
            this._$_tlx$_ = t._$_tlx$_, this._$_tly$_ = t._$_tly$_, this._$_trx$_ = t._$_trx$_, 
            this._$_try$_ = t._$_try$_, this._$_brx$_ = t._$_brx$_, this._$_bry$_ = t._$_bry$_, 
            this._$_blx$_ = t._$_blx$_, this._$_bly$_ = t._$_bly$_;
        }
        equals(t) {
            return this._$_tlx$_ === t._$_tlx$_ && this._$_tly$_ === t._$_tly$_ && this._$_trx$_ === t._$_trx$_ && this._$_try$_ === t._$_try$_ && this._$_brx$_ === t._$_brx$_ && this._$_bry$_ === t._$_bry$_ && this._$_blx$_ === t._$_blx$_ && this._$_bly$_ === t._$_bly$_;
        }
        _$setTlx$_(t) {
            this._$_tlx$_ = +t;
        }
        _$getTlx$_() {
            return this._$_tlx$_;
        }
        _$setTly$_(t) {
            this._$_tly$_ = +t;
        }
        _$getTly$_() {
            return this._$_tly$_;
        }
        _$setTrx$_(t) {
            this._$_trx$_ = +t;
        }
        _$getTrx$_() {
            return this._$_trx$_;
        }
        _$setTry$_(t) {
            this._$_try$_ = +t;
        }
        _$getTry$_() {
            return this._$_try$_;
        }
        _$setBrx$_(t) {
            this._$_brx$_ = +t;
        }
        _$getBrx$_() {
            return this._$_brx$_;
        }
        _$setBry$_(t) {
            this._$_bry$_ = +t;
        }
        _$getBry$_() {
            return this._$_bry$_;
        }
        _$setBlx$_(t) {
            this._$_blx$_ = +t;
        }
        _$getBlx$_() {
            return this._$_blx$_;
        }
        _$setBly$_(t) {
            this._$_bly$_ = +t;
        }
        _$getBly$_() {
            return this._$_bly$_;
        }
        _$toDOMQuad$_() {
            return new DOMQuad(new DOMPoint(this._$_tlx$_, this._$_tly$_), new DOMPoint(this._$_trx$_, this._$_try$_), new DOMPoint(this._$_brx$_, this._$_bry$_), new DOMPoint(this._$_blx$_, this._$_bly$_));
        }
        static _$fromDOMQuad$_(t) {
            return Ct._$New$_(Ct._$Quad$_, t.p1.x, t.p1.y, t.p2.x, t.p2.y, t.p3.x, t.p3.y, t.p4.x, t.p4.y);
        }
        toArray() {
            return [ this._$_tlx$_, this._$_tly$_, this._$_trx$_, this._$_try$_, this._$_brx$_, this._$_bry$_, this._$_blx$_, this._$_bly$_ ];
        }
        _$toTypedArray$_() {
            return new Float64Array(this.toArray());
        }
        _$writeToTypedArray$_(t, s) {
            t[s++] = this._$_tlx$_, t[s++] = this._$_tly$_, t[s++] = this._$_trx$_, 
            t[s++] = this._$_try$_, t[s++] = this._$_brx$_, t[s++] = this._$_bry$_, 
            t[s++] = this._$_blx$_, t[s] = this._$_bly$_;
        }
        _$writeToTypedArray3D$_(t, s, i) {
            t[s++] = this._$_tlx$_, t[s++] = this._$_tly$_, t[s++] = i, t[s++] = this._$_trx$_, 
            t[s++] = this._$_try$_, t[s++] = i, t[s++] = this._$_brx$_, t[s++] = this._$_bry$_, 
            t[s++] = i, t[s++] = this._$_blx$_, t[s++] = this._$_bly$_, t[s] = i;
        }
        offset(t, s) {
            s = +s, this._$_tlx$_ += t = +t, this._$_tly$_ += s, this._$_trx$_ += t, 
            this._$_try$_ += s, this._$_brx$_ += t, this._$_bry$_ += s, this._$_blx$_ += t, 
            this._$_bly$_ += s;
        }
        round() {
            this._$_tlx$_ = Math.round(this._$_tlx$_), this._$_tly$_ = Math.round(this._$_tly$_), 
            this._$_trx$_ = Math.round(this._$_trx$_), this._$_try$_ = Math.round(this._$_try$_), 
            this._$_brx$_ = Math.round(this._$_brx$_), this._$_bry$_ = Math.round(this._$_bry$_), 
            this._$_blx$_ = Math.round(this._$_blx$_), this._$_bly$_ = Math.round(this._$_bly$_);
        }
        floor() {
            this._$_tlx$_ = Math.floor(this._$_tlx$_), this._$_tly$_ = Math.floor(this._$_tly$_), 
            this._$_trx$_ = Math.floor(this._$_trx$_), this._$_try$_ = Math.floor(this._$_try$_), 
            this._$_brx$_ = Math.floor(this._$_brx$_), this._$_bry$_ = Math.floor(this._$_bry$_), 
            this._$_blx$_ = Math.floor(this._$_blx$_), this._$_bly$_ = Math.floor(this._$_bly$_);
        }
        ceil() {
            this._$_tlx$_ = Math.ceil(this._$_tlx$_), this._$_tly$_ = Math.ceil(this._$_tly$_), 
            this._$_trx$_ = Math.ceil(this._$_trx$_), this._$_try$_ = Math.ceil(this._$_try$_), 
            this._$_brx$_ = Math.ceil(this._$_brx$_), this._$_bry$_ = Math.ceil(this._$_bry$_), 
            this._$_blx$_ = Math.ceil(this._$_blx$_), this._$_bly$_ = Math.ceil(this._$_bly$_);
        }
        _$setFromRect$_(t) {
            this._$_tlx$_ = t._$_left$_, this._$_tly$_ = t._$_top$_, this._$_trx$_ = t._$_right$_, 
            this._$_try$_ = t._$_top$_, this._$_brx$_ = t._$_right$_, this._$_bry$_ = t._$_bottom$_, 
            this._$_blx$_ = t._$_left$_, this._$_bly$_ = t._$_bottom$_;
        }
        _$setFromRotatedRect$_(t, s) {
            0 === s ? this._$setFromRect$_(t) : this._$setFromRotatedRectPrecalc$_(t, Math.sin(s), Math.cos(s));
        }
        _$setFromRotatedRectPrecalc$_(t, s, i) {
            const e = t._$_left$_ * s, h = t._$_top$_ * s, r = t._$_right$_ * s, n = t._$_bottom$_ * s, o = t._$_left$_ * i, a = t._$_top$_ * i, l = t._$_right$_ * i, u = t._$_bottom$_ * i;
            this._$_tlx$_ = o - h, this._$_tly$_ = a + e, this._$_trx$_ = l - h, 
            this._$_try$_ = a + r, this._$_brx$_ = l - n, this._$_bry$_ = u + r, 
            this._$_blx$_ = o - n, this._$_bly$_ = u + e;
        }
        _$getBoundingBox$_(t) {
            t.set(Math.min(this._$_tlx$_, this._$_trx$_, this._$_brx$_, this._$_blx$_), Math.min(this._$_tly$_, this._$_try$_, this._$_bry$_, this._$_bly$_), Math.max(this._$_tlx$_, this._$_trx$_, this._$_brx$_, this._$_blx$_), Math.max(this._$_tly$_, this._$_try$_, this._$_bry$_, this._$_bly$_));
        }
        _$containsPoint$_(t, s) {
            let i = this._$_trx$_ - this._$_tlx$_, e = this._$_try$_ - this._$_tly$_, h = this._$_brx$_ - this._$_tlx$_, r = this._$_bry$_ - this._$_tly$_, n = t - this._$_tlx$_, o = s - this._$_tly$_, a = i * i + e * e, l = i * h + e * r, u = i * n + e * o, c = h * h + r * r, f = h * n + r * o, d = 1 / (a * c - l * l), p = (c * u - l * f) * d, m = (a * f - l * u) * d;
            return 0 <= p && 0 < m && p + m < 1 || (m = ((a = (i = this._$_blx$_ - this._$_tlx$_) * i + (e = this._$_bly$_ - this._$_tly$_) * e) * f - (l = i * h + e * r) * (u = i * n + e * o)) * (d = 1 / (a * c - l * l)), 
            0 <= (p = (c * u - l * f) * d) && 0 < m && p + m < 1);
        }
        _$midX$_() {
            return (this._$_tlx$_ + this._$_trx$_ + this._$_brx$_ + this._$_blx$_) / 4;
        }
        _$midY$_() {
            return (this._$_tly$_ + this._$_try$_ + this._$_bry$_ + this._$_bly$_) / 4;
        }
        _$intersectsSegment$_(t, s, i, e) {
            return !(!this._$containsPoint$_(t, s) && !this._$containsPoint$_(i, e)) || Ct._$segmentIntersectsQuad$_(t, s, i, e, this);
        }
        _$intersectsQuad$_(t) {
            let s = t._$midX$_(), i = t._$midY$_();
            if (this._$containsPoint$_(s, i)) return !0;
            if (s = this._$midX$_(), i = this._$midY$_(), t._$containsPoint$_(s, i)) return !0;
            const e = this._$_tlx$_, h = this._$_tly$_, r = this._$_trx$_, n = this._$_try$_, o = this._$_brx$_, a = this._$_bry$_, l = this._$_blx$_, u = this._$_bly$_;
            return Ct._$segmentIntersectsQuad$_(e, h, r, n, t) || Ct._$segmentIntersectsQuad$_(r, n, o, a, t) || Ct._$segmentIntersectsQuad$_(o, a, l, u, t) || Ct._$segmentIntersectsQuad$_(l, u, e, h, t);
        }
        _$rotatePointsAnticlockwise$_() {
            const t = this._$_tlx$_, s = this._$_tly$_;
            this._$_tlx$_ = this._$_trx$_, this._$_tly$_ = this._$_try$_, this._$_trx$_ = this._$_brx$_, 
            this._$_try$_ = this._$_bry$_, this._$_brx$_ = this._$_blx$_, this._$_bry$_ = this._$_bly$_, 
            this._$_blx$_ = t, this._$_bly$_ = s;
        }
        _$mirror$_() {
            this._$_swap$_(0, 2), this._$_swap$_(1, 3), this._$_swap$_(6, 4), this._$_swap$_(7, 5);
        }
        _$flip$_() {
            this._$_swap$_(0, 6), this._$_swap$_(1, 7), this._$_swap$_(2, 4), this._$_swap$_(3, 5);
        }
        _$diag$_() {
            this._$_swap$_(2, 6), this._$_swap$_(3, 7);
        }
        _$_swap$_(t, s) {
            const i = this._$_getAtIndex$_(t);
            this._$_setAtIndex$_(t, this._$_getAtIndex$_(s)), this._$_setAtIndex$_(s, i);
        }
        _$_getAtIndex$_(t) {
            switch (t) {
              case 0:
                return this._$_tlx$_;

              case 1:
                return this._$_tly$_;

              case 2:
                return this._$_trx$_;

              case 3:
                return this._$_try$_;

              case 4:
                return this._$_brx$_;

              case 5:
                return this._$_bry$_;

              case 6:
                return this._$_blx$_;

              case 7:
                return this._$_bly$_;

              default:
                throw new RangeError("invalid quad point index");
            }
        }
        _$_setAtIndex$_(t, s) {
            switch (s = +s, t) {
              case 0:
                this._$_tlx$_ = s;
                break;

              case 1:
                this._$_tly$_ = s;
                break;

              case 2:
                this._$_trx$_ = s;
                break;

              case 3:
                this._$_try$_ = s;
                break;

              case 4:
                this._$_brx$_ = s;
                break;

              case 5:
                this._$_bry$_ = s;
                break;

              case 6:
                this._$_blx$_ = s;
                break;

              case 7:
                this._$_bly$_ = s;
                break;

              default:
                throw new RangeError("invalid quad point index");
            }
        }
    };
}

{
    const Rt = self._$C3$_, Pt = [ 0, 0, 1, 0, 1, 1, 0, 1 ], Et = Rt._$New$_(Rt._$Quad$_);
    Rt._$CollisionPoly$_ = class extends Rt._$DefendedBase$_ {
        constructor(t, s = !0) {
            super(), t = t || Pt, this._$_ptsArr$_ = Float64Array.from(t), this._$_bbox$_ = new Rt.Rect(), 
            this._$_isBboxChanged$_ = !0, this._$_enabled$_ = s;
        }
        _$Release$_() {}
        _$pointsArr$_() {
            return this._$_ptsArr$_;
        }
        _$pointCount$_() {
            return this._$_ptsArr$_.length / 2;
        }
        _$setPoints$_(t) {
            this._$_ptsArr$_.length === t.length ? this._$_ptsArr$_.set(t) : this._$_ptsArr$_ = Float64Array.from(t), 
            this._$_isBboxChanged$_ = !0;
        }
        _$setDefaultPoints$_() {
            this._$setPoints$_(Pt);
        }
        _$copy$_(t) {
            this._$setPoints$_(t._$_ptsArr$_);
        }
        _$setBboxChanged$_() {
            this._$_isBboxChanged$_ = !0;
        }
        _$_updateBbox$_() {
            if (this._$_isBboxChanged$_) {
                let i = this._$_ptsArr$_, e = i[0], h = i[1], r = e, n = h;
                for (let t = 0, s = i.length; t < s; t += 2) {
                    const o = i[t], a = i[t + 1];
                    o < e && (e = o), o > r && (r = o), a < h && (h = a), a > n && (n = a);
                }
                this._$_bbox$_.set(e, h, r, n), this._$_isBboxChanged$_ = !1;
            }
        }
        _$setFromRect$_(t, s, i) {
            let e = this._$_ptsArr$_;
            8 !== e.length && (e = new Float64Array(8), this._$_ptsArr$_ = e), e[0] = t._$getLeft$_() - s, 
            e[1] = t._$getTop$_() - i, e[2] = t._$getRight$_() - s, e[3] = t._$getTop$_() - i, 
            e[4] = t._$getRight$_() - s, e[5] = t._$getBottom$_() - i, e[6] = t._$getLeft$_() - s, 
            e[7] = t._$getBottom$_() - i, this._$_bbox$_._$copy$_(t), 0 === s && 0 === i || this._$_bbox$_.offset(-s, -i), 
            this._$_isBboxChanged$_ = !1;
        }
        _$setFromQuad$_(t, s, i) {
            Et._$copy$_(t), Et.offset(s, i), this._$setPoints$_(Et.toArray()), this._$_isBboxChanged$_ = !0;
        }
        transform(t, s, i) {
            let e = 0, h = 1;
            0 !== i && (e = Math.sin(i), h = Math.cos(i)), this._$transformPrecalc$_(t, s, e, h);
        }
        _$transformPrecalc$_(i, e, h, r) {
            const n = this._$_ptsArr$_;
            for (let t = 0, s = n.length; t < s; t += 2) {
                const o = t + 1, a = n[t] * i, l = n[o] * e;
                n[t] = a * r - l * h, n[o] = l * r + a * h;
            }
            this._$_isBboxChanged$_ = !0;
        }
        offset(i, e) {
            const h = this._$_ptsArr$_;
            for (let t = 0, s = h.length; t < s; t += 2) h[t] += i, h[t + 1] += e;
        }
        _$containsPoint$_(i, e) {
            const h = this._$_ptsArr$_;
            if (i === h[0] && e === h[1]) return !0;
            this._$_updateBbox$_();
            let t = this._$_bbox$_, r = t._$getLeft$_() - 110, n = t._$getTop$_() - 101, o = t._$getRight$_() + 131, a = t._$getBottom$_() + 120, l = 0, u = 0, c = 0, f = 0, d = 0, p = 0, m = 0, g = 0, y = (c = r < i ? (l = r, 
            i) : (l = i, r), f = n < e ? (u = n, e) : (u = e, n), m = o < i ? (d = o, 
            i) : (d = i, o), g = a < e ? (p = a, e) : (p = e, a), 0), w = 0;
            for (let t = 0, s = h.length; t < s; t += 2) {
                const S = (t + 2) % s, b = h[t], M = h[t + 1], v = h[S], x = h[1 + S];
                Rt._$segmentsIntersectPreCalc$_(r, n, i, e, l, c, u, f, b, M, v, x) && ++y, 
                Rt._$segmentsIntersectPreCalc$_(o, a, i, e, d, m, p, g, b, M, v, x) && ++w;
            }
            return y % 2 == 1 || w % 2 == 1;
        }
        _$intersectsPoly$_(t, c, f) {
            const d = t._$_ptsArr$_, p = this._$_ptsArr$_;
            if (this._$containsPoint$_(d[0] + c, d[1] + f)) return !0;
            if (t._$containsPoint$_(p[0] - c, p[1] - f)) return !0;
            for (let s = 0, u = p.length; s < u; s += 2) {
                let t = (s + 2) % u, i = p[s], e = p[s + 1], h = p[t], r = p[1 + t], n = 0, o = 0, a = 0, l = 0;
                a = i < h ? (n = i, h) : (n = h, i), l = e < r ? (o = e, r) : (o = r, 
                e);
                for (let t = 0, s = d.length; t < s; t += 2) {
                    const m = (t + 2) % s, g = d[t] + c, y = d[t + 1] + f, w = d[m] + c, S = d[1 + m] + f;
                    if (Rt._$segmentsIntersectPreCalc$_(i, e, h, r, n, a, o, l, g, y, w, S)) return !0;
                }
            }
            return !1;
        }
        _$intersectsSegment$_(i, e, h, r, n, o) {
            if (this._$containsPoint$_(h - i, r - e)) return !0;
            if (this._$containsPoint$_(n - i, o - e)) return !0;
            let a = 0, l = 0, u = 0, c = 0;
            u = h < n ? (a = h, n) : (a = n, h), c = r < o ? (l = r, o) : (l = o, 
            r);
            const f = this._$_ptsArr$_;
            for (let t = 0, s = f.length; t < s; t += 2) {
                const d = (t + 2) % s, p = f[t] + i, m = f[t + 1] + e, g = f[d] + i, y = f[1 + d] + e;
                if (Rt._$segmentsIntersectPreCalc$_(h, r, n, o, a, u, l, c, p, m, g, y)) return !0;
            }
            return !1;
        }
        _$mirror$_(i) {
            const e = this._$_ptsArr$_;
            for (let t = 0, s = e.length; t < s; t += 2) e[t] = 2 * i - e[t];
            this._$_isBboxChanged$_ = !0;
        }
        _$flip$_(i) {
            const e = this._$_ptsArr$_;
            for (let t = 0, s = e.length; t < s; t += 2) {
                const h = t + 1;
                e[h] = 2 * i - e[h];
            }
            this._$_isBboxChanged$_ = !0;
        }
        _$diag$_() {
            const i = this._$_ptsArr$_;
            for (let t = 0, s = i.length; t < s; t += 2) {
                const e = t + 1, h = i[t];
                i[t] = i[e], i[e] = h;
            }
            this._$_isBboxChanged$_ = !0;
        }
        _$GetMidX$_() {
            let i = this._$_ptsArr$_, e = 0;
            for (let t = 0, s = i.length; t < s; t += 2) e += i[t];
            return e / this._$pointCount$_();
        }
        _$GetMidY$_() {
            let i = this._$_ptsArr$_, e = 0;
            for (let t = 0, s = i.length; t < s; t += 2) e += i[t + 1];
            return e / this._$pointCount$_();
        }
        _$GetPointsArray$_() {
            return this._$_ptsArr$_;
        }
        _$GetPointCount$_() {
            return this._$pointCount$_();
        }
        _$IsEnabled$_() {
            return this._$_enabled$_;
        }
    };
}

{
    const At = self._$C3$_;
    At._$PairMap$_ = class extends At._$DefendedBase$_ {
        constructor(t) {
            if (super(), this._$_firstMap$_ = new Map(), t) for (const [ s, i, e ] of t) this.Set(s, i, e);
        }
        _$Release$_() {
            this._$Clear$_(), this._$_firstMap$_ = null;
        }
        _$IsEmpty$_() {
            return 0 === this._$_firstMap$_.size;
        }
        _$Clear$_() {
            const t = this._$_firstMap$_;
            for (const s of t.values()) s.clear();
            t.clear();
        }
        Set(t, s, i) {
            let e = this._$_firstMap$_, h = e.get(t);
            h || (h = new Map(), e.set(t, h)), h.set(s, i);
        }
        _$Get$_(t, s) {
            const i = this._$_firstMap$_.get(t);
            return i && i.get(s);
        }
        _$Has$_(t, s) {
            const i = this._$_firstMap$_.get(t);
            return !!i && i.has(s);
        }
        _$Delete$_(t, s) {
            const i = this._$_firstMap$_, e = i.get(t);
            if (!e) return !1;
            const h = e.delete(s);
            return h && 0 === e.size && i.delete(t), h;
        }
        _$DeleteEither$_(t) {
            const s = this._$_firstMap$_, i = s.get(t);
            i && (i.clear(), s.delete(t));
            for (const [ e, h ] of s.entries()) h.delete(t) && 0 === h.size && s.delete(e);
        }
        _$GetSize$_() {
            let t = 0;
            for (const s of this._$_firstMap$_.values()) t += s.size;
            return t;
        }
        *values() {
            for (const t of this._$_firstMap$_.values()) yield* t.values();
        }
        *_$keyPairs$_() {
            for (const [ t, s ] of this._$_firstMap$_.entries()) for (const i of s.keys()) yield [ t, i ];
        }
        *entries() {
            for (const [ t, s ] of this._$_firstMap$_.entries()) for (const [ i, e ] of s.entries()) yield [ t, i, e ];
        }
    };
}

{
    const Ft = self._$C3$_;
    Ft._$ArraySet$_ = class extends Ft._$DefendedBase$_ {
        constructor() {
            super(), this._$_set$_ = new Set(), this._$_arr$_ = [], this._$_needToRebuildArray$_ = !1;
        }
        _$Release$_() {
            this._$Clear$_();
        }
        _$Clear$_() {
            this._$_set$_.clear(), Ft._$clearArray$_(this._$_arr$_), this._$_needToRebuildArray$_ = !1;
        }
        _$Add$_(t) {
            this._$_set$_.has(t) || (this._$_set$_.add(t), this._$_needToRebuildArray$_) || this._$_arr$_.push(t);
        }
        _$Has$_(t) {
            return this._$_set$_.has(t);
        }
        _$Delete$_(t) {
            this._$_set$_.delete(t) && (this._$_needToRebuildArray$_ = !0);
        }
        _$GetSize$_() {
            return this._$_set$_.size;
        }
        _$IsEmpty$_() {
            return 0 === this._$_set$_.size;
        }
        _$GetArray$_() {
            return this._$_needToRebuildArray$_ && (this._$_RebuildArray$_(), this._$_needToRebuildArray$_ = !1), 
            this._$_arr$_;
        }
        _$_RebuildArray$_() {
            const t = this._$_arr$_;
            Ft._$clearArray$_(t);
            for (const s of this._$_set$_) t.push(s);
        }
    };
}

{
    const Ot = self._$C3$_, Dt = new Map(), kt = new Map(), Lt = new Map(), Bt = new Map(), Nt = new Map(), Wt = new Map(), jt = new Map(), Vt = new Map(), Ut = new Map(), Ht = (Ut.set("linear", "noease"), 
    Ut.set("default", "noease"), [ "default", "noease", "easeinquad", "easeoutquad", "easeinoutquad", "easeincubic", "easeoutcubic", "easeinoutcubic", "easeinquart", "easeoutquart", "easeinoutquart", "easeinquint", "easeoutquint", "easeinoutquint", "easeinsine", "easeoutsine", "easeinoutsine", "easeinexpo", "easeoutexpo", "easeinoutexpo", "easeincirc", "easeoutcirc", "easeinoutcirc", "easeinelastic", "easeoutelastic", "easeinoutelastic", "easeinback", "easeoutback", "easeinoutback", "easeinbounce", "easeoutbounce", "easeinoutbounce" ]), zt = [ "default", "noease", "quad", "cubic", "quart", "quint", "sine", "expo", "circ", "elastic", "back", "bounce" ], Jt = new Map([ [ "linear", "noease" ], [ "in-sine", "easeinsine" ], [ "out-sine", "easeoutsine" ], [ "in-out-sine", "easeinoutsine" ], [ "in-elastic", "easeinelastic" ], [ "out-elastic", "easeoutelastic" ], [ "in-out-elastic", "easeinoutelastic" ], [ "in-back", "easeinback" ], [ "out-back", "easeoutback" ], [ "in-out-back", "easeinoutback" ], [ "in-bounce", "easeinbounce" ], [ "out-bounce", "easeoutbounce" ], [ "in-out-bounce", "easeinoutbounce" ], [ "in-cubic", "easeincubic" ], [ "out-cubic", "easeoutcubic" ], [ "in-out-cubic", "easeinoutcubic" ], [ "in-quadratic", "easeinquad" ], [ "out-quadratic", "easeoutquad" ], [ "in-out-quadratic", "easeinoutquad" ], [ "in-quartic", "easeinquart" ], [ "out-quartic", "easeoutquart" ], [ "in-out-quartic", "easeinoutquart" ], [ "in-quintic", "easeinquint" ], [ "out-quintic", "easeoutquint" ], [ "in-out-quintic", "easeinoutquint" ], [ "in-circular", "easeincirc" ], [ "out-circular", "easeoutcirc" ], [ "in-out-circular", "easeinoutcirc" ], [ "in-exponential", "easeinexpo" ], [ "out-exponential", "easeoutexpo" ], [ "in-out-exponential", "easeinoutexpo" ] ]), qt = (self._$Ease$_ = class ss {
        constructor() {}
        static _$InheritEase$_() {
            return "default";
        }
        static _$DefaultEase$_() {
            return "noease";
        }
        static _$ToInternal$_(t) {
            return Jt.get(t);
        }
        static _$GetEditorEaseNames$_(s, ...i) {
            this._$_CreateEaseMap$_();
            let t, e, h = (e = s ? (Lt.has(s) || Lt.set(s, new Map()), [ ...(t = Lt.get(s)).keys() ].filter(t => !ss._$GetEditorEaseData$_(t, s) || ss._$GetEditorEaseData$_(t, s).transition.IsForAnyPurpose())) : [ ...(t = Nt).keys() ]).sort();
            return [ ...kt.keys() ].concat(h).filter(t => !i.includes(t));
        }
        static _$GetRuntimeEaseNames$_() {
            this._$_CreateEaseMap$_();
            const t = [ ...Nt.keys() ];
            return t.sort(), [ ...kt.keys() ].concat(t);
        }
        static _$GetCustomRuntimeEaseNames$_() {
            this._$_CreateEaseMap$_();
            const t = [ ...Nt.keys() ];
            return t.sort(), t;
        }
        static _$IsPredefinedTranslatedName$_(t) {
            for (const s of Ht) {
                const i = self.lang("ui.bars.timeline.eases." + s);
                if (i === t) return !0;
            }
            for (const e of zt) {
                const h = self.lang("ui.bars.timeline.short-eases." + e);
                if (h === t) return !0;
            }
        }
        static _$IsNamePredefined$_(t) {
            return this._$_CreateEaseMap$_(), [ ...kt.keys() ].includes(t);
        }
        static _$_GetEase$_(t) {
            const s = Ut.get(t);
            return s ? Dt.get(s) : ss._$IsNamePredefined$_(t) ? Dt.get(t) : jt.has(t) ? jt.get(t) : void 0;
        }
        static _$GetBuiltInTransition$_(t) {
            return this._$_CreateEaseMap$_(), Vt.get(t);
        }
        static _$GetEditorEase$_(t, s) {
            this._$_CreateEaseMap$_();
            const i = ss._$_GetEase$_(t);
            if (i) return i;
            if (s) return Lt.get(s).get(t);
            throw new Error("missing ease function");
        }
        static _$GetEditorEaseData$_(t, s) {
            this._$_CreateEaseMap$_();
            const i = Bt.get(s);
            if (i) return i.get(t);
        }
        static _$HasEditorEase$_(t, s) {
            this._$_CreateEaseMap$_();
            const i = ss._$_GetEase$_(t);
            return !!i || !!Lt.get(s).get(t);
        }
        static _$GetRuntimeEase$_(t) {
            this._$_CreateEaseMap$_();
            const s = ss._$_GetEase$_(t);
            return s || Nt.get(t);
        }
        static _$GetRuntimeEaseData$_(t) {
            return this._$_CreateEaseMap$_(), Wt.get(t);
        }
        static _$GetEaseFromIndex$_(t) {
            this._$_CreateEaseMap$_();
            const s = this._$GetRuntimeEaseNames$_();
            return s[t];
        }
        static _$GetIndexForEase$_(t, s) {
            this._$_CreateEaseMap$_();
            const i = this._$GetEditorEaseNames$_(s);
            return i.indexOf(t);
        }
        static _$GetIndexForEaseAtRuntime$_(t) {
            return this._$GetIndexForEase$_(t);
        }
        static _$_CreateEaseMap$_() {
            0 === Dt.size && (this._$_AddPredifinedEase$_("default", () => {}), 
            this._$_AddPredifinedEase$_("noease", [ {
                x: 0,
                y: 0,
                sax: .336,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.336,
                eay: 0,
                se: !1,
                ee: !0
            } ], !0), this._$_AddPredifinedEase$_("easeinsine", [ {
                x: 0,
                y: 0,
                sax: .485,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.038,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeoutsine", [ {
                x: 0,
                y: 0,
                sax: .038,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.485,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinoutsine", [ {
                x: 0,
                y: 0,
                sax: .336,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.336,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinelastic", [ {
                x: 0,
                y: 0,
                sax: .018,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .116,
                y: .002,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .266,
                y: -.005,
                sax: .024,
                say: 0,
                eax: -.021,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .416,
                y: .016,
                sax: .024,
                say: 0,
                eax: -.026,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .566,
                y: -.045,
                sax: .061,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .716,
                y: .132,
                sax: .072,
                say: -.004,
                eax: -.045,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .866,
                y: -.373,
                sax: .06,
                say: 0,
                eax: -.049,
                eay: -.002,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.038,
                eay: -.263,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeoutelastic", [ {
                x: 0,
                y: 0,
                sax: .038,
                say: .263,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .136,
                y: 1.373,
                sax: .049,
                say: .002,
                eax: -.06,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .286,
                y: .868,
                sax: .045,
                say: 0,
                eax: -.072,
                eay: .004,
                se: !0,
                ee: !0
            }, {
                x: .436,
                y: 1.045,
                sax: .025,
                say: 0,
                eax: -.061,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .586,
                y: .984,
                sax: .026,
                say: 0,
                eax: -.024,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .736,
                y: 1.005,
                sax: .021,
                say: 0,
                eax: -.024,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .886,
                y: .998,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.018,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinoutelastic", [ {
                x: 0,
                y: 0,
                sax: .025,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .067,
                y: .001,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .18,
                y: -.005,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .292,
                y: .025,
                sax: .053,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .405,
                y: -.118,
                sax: .069,
                say: 0,
                eax: -.027,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .597,
                y: 1.118,
                sax: .027,
                say: 0,
                eax: -.069,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .71,
                y: .975,
                sax: .025,
                say: 0,
                eax: -.053,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .822,
                y: 1.005,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .935,
                y: .999,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinback", [ {
                x: 0,
                y: 0,
                sax: .35,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.34,
                eay: -1.579,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeoutback", [ {
                x: 0,
                y: 0,
                sax: .34,
                say: 1.579,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.35,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinoutback", [ {
                x: 0,
                y: 0,
                sax: .035,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .242,
                y: -.1,
                sax: .258,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .76,
                y: 1.1,
                sax: .025,
                say: 0,
                eax: -.26,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.035,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinbounce", [ {
                x: 0,
                y: 0,
                sax: .033,
                say: .025,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .092,
                y: 0,
                sax: .026,
                say: .078,
                eax: -.033,
                eay: .025,
                se: !0,
                ee: !0
            }, {
                x: .274,
                y: 0,
                sax: .097,
                say: .319,
                eax: -.026,
                eay: .078,
                se: !0,
                ee: !0
            }, {
                x: .637,
                y: 0,
                sax: .105,
                say: .625,
                eax: -.097,
                eay: .319,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.125,
                eay: -.004,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeoutbounce", [ {
                x: 0,
                y: 0,
                sax: .125,
                say: .004,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .365,
                y: 1,
                sax: .097,
                say: -.319,
                eax: -.105,
                eay: -.625,
                se: !0,
                ee: !0
            }, {
                x: .728,
                y: 1,
                sax: .026,
                say: -.078,
                eax: -.097,
                eay: -.319,
                se: !0,
                ee: !0
            }, {
                x: .91,
                y: 1,
                sax: .033,
                say: -.025,
                eax: -.026,
                eay: -.078,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.033,
                eay: -.025,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinoutbounce", [ {
                x: 0,
                y: 0,
                sax: .01,
                say: .006,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .046,
                y: 0,
                sax: .021,
                say: .038,
                eax: -.01,
                eay: .006,
                se: !0,
                ee: !0
            }, {
                x: .137,
                y: 0,
                sax: .059,
                say: .158,
                eax: -.021,
                eay: .038,
                se: !0,
                ee: !0
            }, {
                x: .319,
                y: 0,
                sax: .117,
                say: .744,
                eax: -.059,
                eay: .158,
                se: !0,
                ee: !0
            }, {
                x: .683,
                y: 1,
                sax: .059,
                say: -.158,
                eax: -.117,
                eay: -.744,
                se: !0,
                ee: !0
            }, {
                x: .865,
                y: 1,
                sax: .021,
                say: -.038,
                eax: -.059,
                eay: -.158,
                se: !0,
                ee: !0
            }, {
                x: .956,
                y: 1,
                sax: .01,
                say: -.006,
                eax: -.021,
                eay: -.038,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.01,
                eay: -.006,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeincubic", [ {
                x: 0,
                y: 0,
                sax: .75,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.138,
                eay: -.321,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeoutcubic", [ {
                x: 0,
                y: 0,
                sax: .138,
                say: .321,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.75,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinoutcubic", [ {
                x: 0,
                y: 0,
                sax: .285,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .5,
                y: .5,
                sax: .081,
                say: .272,
                eax: -.081,
                eay: -.272,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.285,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinquad", [ {
                x: 0,
                y: 0,
                sax: .4,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.178,
                eay: -.392,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeoutquad", [ {
                x: 0,
                y: 0,
                sax: .178,
                say: .392,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.4,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinoutquad", [ {
                x: 0,
                y: 0,
                sax: .25,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .5,
                y: .5,
                sax: .03,
                say: .065,
                eax: -.03,
                eay: -.065,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.25,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinquart", [ {
                x: 0,
                y: 0,
                sax: .25,
                say: 1,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.5,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeoutquart", [ {
                x: 0,
                y: 0,
                sax: .5,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.25,
                eay: -1,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinoutquart", [ {
                x: 0,
                y: 0,
                sax: .765,
                say: .03,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.765,
                eay: -.03,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinquint", [ {
                x: 0,
                y: 0,
                sax: .6,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.2,
                eay: -1,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeoutquint", [ {
                x: 0,
                y: 0,
                sax: .2,
                say: 1,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.6,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinoutquint", [ {
                eax: 0,
                eay: 0,
                ee: !1,
                sax: .84,
                say: 0,
                se: !0,
                x: 0,
                y: 0
            }, {
                eax: -.84,
                eay: 0,
                ee: !0,
                sax: 0,
                say: 0,
                se: !1,
                x: 1,
                y: 1
            } ]), this._$_AddPredifinedEase$_("easeincirc", [ {
                x: 0,
                y: 0,
                sax: .25,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.024,
                eay: -.808,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeoutcirc", [ {
                x: 0,
                y: 0,
                sax: .024,
                say: .808,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.25,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinoutcirc", [ {
                x: 0,
                y: 0,
                sax: .125,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .5,
                y: .5,
                sax: .02,
                say: .428,
                eax: -.02,
                eay: -.428,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.125,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinexpo", [ {
                x: 0,
                y: 0,
                sax: .66,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.14,
                eay: -1,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeoutexpo", [ {
                x: 0,
                y: 0,
                sax: .14,
                say: 1,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.66,
                eay: 0,
                se: !1,
                ee: !0
            } ]), this._$_AddPredifinedEase$_("easeinoutexpo", [ {
                eax: 0,
                eay: 0,
                ee: !1,
                sax: .345,
                say: 0,
                se: !0,
                x: 0,
                y: 0
            }, {
                eax: -.06,
                eay: -.5,
                ee: !0,
                sax: .06,
                say: .5,
                se: !0,
                x: .5,
                y: .5
            }, {
                eax: -.335,
                eay: 0,
                ee: !0,
                sax: 0,
                say: 0,
                se: !1,
                x: 1,
                y: 1
            } ]), this._$_AddPrivateCustomEase$_("cubicbezier", this._$EaseCubicBezier$_), 
            this._$_AddPrivateCustomEase$_("spline", this._$EaseSpline$_));
        }
        static _$_AddPredifinedEase$_(t, s, i = !1) {
            if ("function" == typeof s) ss._$_AddEase$_(t, s, "predefined"); else {
                if (!Ot._$IsArray$_(s)) throw new Error("unexpected arguments");
                if (self.BuiltInTransition) {
                    const h = Ot._$New$_(self.BuiltInTransition, t, i);
                    h.SetFromJson(s), ss._$_AddEase$_(t, (t, s, i, e) => h._$Interpolate$_(t, s, i, e), "predefined"), 
                    Vt.set(t, h);
                } else {
                    const r = Ot._$New$_(Ot._$Transition$_, [ t, s.map(t => [ t.x, t.y, t.sax, t.say, t.eax, t.eay, t.se, t.ee ]) ], !1);
                    r._$MakeLinear$_(i), ss._$_AddEase$_(t, (t, s, i, e) => r._$Interpolate$_(t, s, i, e), "predefined");
                }
            }
        }
        static _$_AddPrivateCustomEase$_(t, s) {
            ss._$_AddEase$_(t, s, "private");
        }
        static _$AddCustomEase$_(t, s, i, e) {
            this._$_CreateEaseMap$_(), ss._$_AddEase$_(t, s, "custom", i, e);
        }
        static _$RemoveCustomEase$_(t, s) {
            if (!this._$IsNamePredefined$_(t) && ![ ...jt.keys() ].includes(t)) {
                const i = Lt.get(s), e = (i && i.delete(t), Bt.get(s));
                e && e.delete(t);
            }
        }
        static _$_AddEase$_(t, s, i, e, h) {
            switch (i) {
              case "predefined":
                Dt.set(t, s), kt.set(t, s);
                break;

              case "custom":
                if (e) {
                    Lt.has(e) || Lt.set(e, new Map()), Bt.has(e) || Bt.set(e, new Map());
                    const r = Lt.get(e), n = (r.set(t, s), Bt.get(e));
                    n.set(t, h);
                } else Nt.set(t, s), Wt.set(t, h);
                break;

              case "private":
                Dt.set(t, s), jt.set(t, s);
                break;

              default:
                throw new Error("unexpected ease mode");
            }
        }
        static _$NoEase$_(t, s, i, e) {
            return 0 === e ? s : i * t / e + s;
        }
        static _$EaseCubicBezier$_(t, s, i, e, h) {
            const r = s, n = 3 * t * (i - s), o = 3 * t ** 2 * (s + e - 2 * i), a = t ** 3 * (h - s + 3 * i - 3 * e);
            return r + n + o + a;
        }
        static _$EaseSpline$_(t, s, i, e, h, r, n, o, a, l) {
            if (e === h && r === n) return t;
            const u = ts(t, s, e, r, o, l), c = Yt(i, h, n, a), f = $t(i, h, n, a), d = Kt(i, h, n, a);
            return Zt(u, c, f, d);
        }
        static _$GetBezierSamples$_(t, s, i, e) {
            const h = [], r = Yt(t, s, i, e), n = $t(t, s, i, e), o = Kt(t, s, i, e);
            for (let t = 0; t < qt; ++t) {
                const a = Zt(t * Xt, r, n, o);
                h.push(a);
            }
            return h;
        }
    }, 11), Xt = 1 / (qt - 1), Yt = (t, s, i, e) => e - 3 * i + 3 * s - t, $t = (t, s, i, e) => 3 * i - 6 * s + 3 * t, Kt = (t, s, i, e) => 3 * (s - t), Zt = (t, s, i, e) => ((s * t + i) * t + e) * t, Qt = (t, s, i, e) => 3 * s * t * t + 2 * i * t + e, ts = (n, t, s, i, e, h) => {
        if (1 == n) return 1;
        let o = 0, r = 1, a = h[r], l = qt - 1;
        qt;
        for (;r != l && a <= n; ) r++, a = h[r], o += Xt;
        r--;
        let u = (n - (a = h[r])) / (h[r + 1] - a), c = o + u * Xt, f = Yt(t, s, i, e), d = $t(t, s, i, e), p = Kt(t, s, i, e), m = Qt(c, f, d, p);
        if (0 === m) return c;
        if (.01 <= m) {
            for (let t = 0; t < 4; ++t) {
                const g = Zt(c, f, d, p) - n, y = Qt(c, f, d, p);
                c -= g / y;
            }
            return c;
        }
        {
            let s = o, i = o + Xt, e = 0, h, r;
            do {
                c = s + (i - s) / 2;
                let t = Zt(c, f, d, p) - n;
                0 < t ? i = c : s = c, h = 1e-7 < Math.abs(t), r = ++e < 10;
            } while (h && r);
            return c;
        }
    };
}

{
    let o = function(t) {
        is._$IsString$_(t);
    };
    o;
    const is = self._$C3$_;
    is._$ProbabilityTable$_ = class {
        constructor(t) {
            this._$_items$_ = [], this._$_name$_ = t || "", this._$_totalWeight$_ = 0;
        }
        _$Release$_() {
            this._$Clear$_(), this._$_items$_ = null;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$Clear$_() {
            is._$clear2DArray$_(this._$_items$_), this._$_totalWeight$_ = 0;
        }
        _$GetTotalWeight$_() {
            return this._$_totalWeight$_;
        }
        _$Sample$_(t = Math.random() * this._$GetTotalWeight$_()) {
            let s = 0;
            for (const [ i, e ] of this._$_items$_) if (t < (s += i)) return e;
            return 0;
        }
        _$AddItem$_(t, s) {
            o(s), this._$_totalWeight$_ += t, this._$_items$_.push([ t, s ]);
        }
        _$RemoveItem$_(s, i) {
            o(i);
            const e = 0 === s;
            for (let t = 0; t < this._$_items$_.length; t++) {
                const h = this._$_items$_[t], r = e || h[0] === s, n = h[1] === i;
                if (r && n) {
                    this._$_items$_.splice(t, 1), this._$_totalWeight$_ -= h[0];
                    break;
                }
            }
        }
        _$asJSON$_() {
            return JSON.stringify(this._$_items$_);
        }
        static _$fromJSON$_(t, s) {
            const i = new is._$ProbabilityTable$_(s), e = JSON.parse(t);
            for (const h of e) {
                const r = h[0], n = h[1];
                i._$AddItem$_(r, n);
            }
            return i;
        }
    };
}

{
    let t = self._$C3$_, i = 0;
    t._$ScreenReaderText$_ = class {
        constructor(t, s) {
            this._$_runtime$_ = t, this._$_text$_ = s, this._$_id$_ = i++, this._$_runtime$_._$PostComponentMessageToDOM$_("runtime", "screen-reader-text", {
                type: "create",
                id: this._$_id$_,
                text: this._$_text$_
            });
        }
        _$Release$_() {
            this._$_runtime$_._$PostComponentMessageToDOM$_("runtime", "screen-reader-text", {
                type: "release",
                id: this._$_id$_
            }), this._$_runtime$_ = null, this._$_text$_ = "", this._$_id$_ = -1;
        }
        _$SetText$_(t) {
            this._$_text$_ !== t && (this._$_text$_ = t, this._$_runtime$_._$PostComponentMessageToDOM$_("runtime", "screen-reader-text", {
                type: "update",
                id: this._$_id$_,
                text: this._$_text$_
            }));
        }
    };
}

{
    const es = self._$C3$_;
    es.Event = class {
        constructor(t, s) {
            this.type = t, this.cancelable = !!s, this.defaultPrevented = !1, this._$propagationStopped$_ = !1, 
            this._$isAsync$_ = !1;
        }
        preventDefault() {
            if (!this.cancelable) throw new Error(`event '${this.type}' is not cancelable`);
            this.defaultPrevented = !0;
        }
        stopPropagation() {
            if (!this.cancelable) throw new Error(`event '${this.type}' cannot be stopped`);
            if (this._$isAsync$_) throw new Error(`cannot stop async event '${this.type}' propagation`);
            this._$propagationStopped$_ = !0;
        }
    };
}

{
    const hs = self._$C3$_;
    hs.Event._$Handler$_ = class extends hs._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_type$_ = t, this._$_captureListeners$_ = [], this._$_captureListenersSet$_ = new Set(), 
            this._$_listeners$_ = [], this._$_listenersSet$_ = new Set(), this._$_fireDepth$_ = 0, 
            this._$_queueModifyListeners$_ = [];
        }
        _$Release$_() {
            0 < this._$_fireDepth$_ || (hs._$clearArray$_(this._$_captureListeners$_), 
            this._$_captureListenersSet$_.clear(), hs._$clearArray$_(this._$_listeners$_), 
            this._$_listenersSet$_.clear(), hs._$clearArray$_(this._$_queueModifyListeners$_), 
            hs._$Release$_(this));
        }
        _$_AddListener$_(t, s) {
            this._$_IsFiring$_() ? this._$_queueModifyListeners$_.push({
                _$op$_: "add",
                _$func$_: t,
                capture: s
            }) : s ? this._$_captureListenersSet$_.has(t) || (this._$_captureListeners$_.push(t), 
            this._$_captureListenersSet$_.add(t)) : this._$_listenersSet$_.has(t) || (this._$_listeners$_.push(t), 
            this._$_listenersSet$_.add(t));
        }
        _$_RemoveListener$_(t, s) {
            this._$_IsFiring$_() ? this._$_queueModifyListeners$_.push({
                _$op$_: "remove",
                _$func$_: t,
                capture: s
            }) : s ? this._$_captureListenersSet$_.has(t) && (this._$_captureListenersSet$_.delete(t), 
            hs._$arrayFindRemove$_(this._$_captureListeners$_, t)) : this._$_listenersSet$_.has(t) && (this._$_listenersSet$_.delete(t), 
            hs._$arrayFindRemove$_(this._$_listeners$_, t));
        }
        _$_IsEmpty$_() {
            return !this._$_captureListeners$_.length && !this._$_listeners$_.length;
        }
        _$_IsFiring$_() {
            return 0 < this._$_fireDepth$_;
        }
        _$_ProcessQueuedListeners$_() {
            const t = new Set(), s = new Set();
            for (const i of this._$_queueModifyListeners$_) if ("add" === i._$op$_) this._$_AddListener$_(i._$func$_, i.capture), 
            (i.capture ? s : t).delete(i._$func$_); else {
                if ("remove" !== i._$op$_) throw new Error("invalid op");
                (i.capture ? (this._$_captureListenersSet$_.delete(i._$func$_), 
                s) : (this._$_listenersSet$_.delete(i._$func$_), t)).add(i._$func$_);
            }
            hs._$arrayRemoveAllInSet$_(this._$_listeners$_, t), hs._$arrayRemoveAllInSet$_(this._$_captureListeners$_, s), 
            hs._$clearArray$_(this._$_queueModifyListeners$_);
        }
        _$_FireCancellable$_(i) {
            this._$_IncreaseFireDepth$_();
            let e = !1;
            for (let t = 0, s = this._$_captureListeners$_.length; t < s; ++t) if (this._$_captureListeners$_[t](i), 
            i._$propagationStopped$_) {
                e = !0;
                break;
            }
            if (!e) for (let t = 0, s = this._$_listeners$_.length; t < s && (this._$_listeners$_[t](i), 
            !i._$propagationStopped$_); ++t);
            return this._$_DecreaseFireDepth$_(), !i.defaultPrevented;
        }
        _$_FireNonCancellable$_(i) {
            this._$_IncreaseFireDepth$_();
            for (let t = 0, s = this._$_captureListeners$_.length; t < s; ++t) this._$_captureListeners$_[t](i);
            for (let t = 0, s = this._$_listeners$_.length; t < s; ++t) this._$_listeners$_[t](i);
            return this._$_DecreaseFireDepth$_(), !0;
        }
        _$_IncreaseFireDepth$_() {
            this._$_fireDepth$_++;
        }
        _$_DecreaseFireDepth$_() {
            this._$_fireDepth$_--, 0 === this._$_fireDepth$_ && 0 < this._$_queueModifyListeners$_.length && this._$_ProcessQueuedListeners$_();
        }
        _$SetDelayRemoveEventsEnabled$_(t) {
            t ? this._$_IncreaseFireDepth$_() : this._$_DecreaseFireDepth$_();
        }
        _$_FireAsync$_(i) {
            let e = [];
            for (let s = 0, t = this._$_captureListeners$_.length; s < t; ++s) {
                let t = this._$_captureListeners$_[s];
                e.push(hs._$Asyncify$_(() => t(i)));
            }
            for (let s = 0, t = this._$_listeners$_.length; s < t; ++s) {
                let t = this._$_listeners$_[s];
                e.push(hs._$Asyncify$_(() => t(i)));
            }
            return Promise.all(e).then(() => !i.defaultPrevented);
        }
        _$_FireAndWait_AsyncOptional$_(i) {
            const e = [];
            this._$_IncreaseFireDepth$_();
            for (let t = 0, s = this._$_captureListeners$_.length; t < s; ++t) {
                const h = this._$_captureListeners$_[t](i);
                h instanceof Promise && e.push(h);
            }
            for (let t = 0, s = this._$_listeners$_.length; t < s; ++t) {
                const r = this._$_listeners$_[t](i);
                r instanceof Promise && e.push(r);
            }
            return this._$_DecreaseFireDepth$_(), e.length ? Promise.all(e).then(() => !i.defaultPrevented) : !i.defaultPrevented;
        }
        async _$_FireAndWaitAsync$_(t) {
            return this._$_FireAndWait_AsyncOptional$_(t);
        }
        async _$_FireAndWaitAsyncSequential$_(i) {
            this._$_IncreaseFireDepth$_();
            for (let t = 0, s = this._$_captureListeners$_.length; t < s; ++t) {
                const e = this._$_captureListeners$_[t](i);
                e instanceof Promise && await e;
            }
            for (let t = 0, s = this._$_listeners$_.length; t < s; ++t) {
                const h = this._$_listeners$_[t](i);
                h instanceof Promise && await h;
            }
            return this._$_DecreaseFireDepth$_(), !i.defaultPrevented;
        }
        *_$_FireAsGenerator$_(i) {
            this._$_IncreaseFireDepth$_();
            for (let t = 0, s = this._$_captureListeners$_.length; t < s; ++t) {
                const e = this._$_captureListeners$_[t](i);
                hs._$IsIterator$_(e) && (yield* e);
            }
            for (let t = 0, s = this._$_listeners$_.length; t < s; ++t) {
                const h = this._$_listeners$_[t](i);
                hs._$IsIterator$_(h) && (yield* h);
            }
            this._$_DecreaseFireDepth$_();
        }
    };
}

{
    const rs = self._$C3$_;
    rs.Event._$Dispatcher$_ = class extends rs._$DefendedBase$_ {
        constructor() {
            super(), this._$_eventHandlers$_ = new Map(), this._$_dispatcherWasReleased$_ = !1;
        }
        _$Release$_() {
            if (this._$_dispatcherWasReleased$_) throw new Error("already released");
            this._$ClearEvents$_(), this._$_dispatcherWasReleased$_ = !0, rs._$Release$_(this);
        }
        _$WasReleased$_() {
            return this._$_dispatcherWasReleased$_;
        }
        _$ClearEvents$_() {
            if (this._$_eventHandlers$_) {
                for (let t of this._$_eventHandlers$_.values()) t._$Release$_();
                this._$_eventHandlers$_.clear();
            }
        }
        _$_GetHandlerByType$_(t, s) {
            let i = this._$_eventHandlers$_.get(t);
            return i || (s ? (i = rs._$New$_(rs.Event._$Handler$_, t), this._$_eventHandlers$_.set(t, i), 
            i) : null);
        }
        _$HasAnyHandlerFor$_(t) {
            return this._$_eventHandlers$_.has(t);
        }
        addEventListener(t, s, i) {
            let e = this._$_GetHandlerByType$_(t, !0);
            e._$_AddListener$_(s, !!i);
        }
        removeEventListener(t, s, i) {
            let e = this._$_GetHandlerByType$_(t, !1);
            e && (e._$_RemoveListener$_(s, !!i), e._$_IsEmpty$_()) && this._$_eventHandlers$_.delete(t);
        }
        dispatchEvent(t) {
            const s = this._$_GetHandlerByType$_(t.type, !1);
            return !s || (t.cancelable ? s._$_FireCancellable$_(t) : s._$_FireNonCancellable$_(t));
        }
        _$dispatchEventAsync$_(t) {
            const s = this._$_GetHandlerByType$_(t.type, !1);
            return s ? (t._$isAsync$_ = !0, s._$_FireAsync$_(t)) : Promise.resolve(!0);
        }
        async _$dispatchEventAndClearAsync$_(t) {
            const s = this._$_GetHandlerByType$_(t.type, !1);
            if (!s) return !0;
            this._$_eventHandlers$_.delete(t.type), t._$isAsync$_ = !0;
            const i = await s._$_FireAsync$_(t);
            return s._$Release$_(), i;
        }
        async _$dispatchEventAndWaitAsync$_(t) {
            const s = this._$_GetHandlerByType$_(t.type, !1);
            return !s || s._$_FireAndWaitAsync$_(t);
        }
        _$dispatchEventAndWait_AsyncOptional$_(t) {
            const s = this._$_GetHandlerByType$_(t.type, !1);
            return !s || s._$_FireAndWait_AsyncOptional$_(t);
        }
        async _$dispatchEventAndWaitAsyncSequential$_(t) {
            const s = this._$_GetHandlerByType$_(t.type, !1);
            return !s || s._$_FireAndWaitAsyncSequential$_(t);
        }
        _$dispatchGeneratorEvent$_(t) {
            const s = this._$_GetHandlerByType$_(t.type, !1);
            if (!s) return null;
            if (t.cancelable) throw new Error("not supported");
            return s._$_FireAsGenerator$_(t);
        }
        _$SetDelayRemoveEventsEnabled$_(t) {
            for (const s of this._$_eventHandlers$_.values()) s._$SetDelayRemoveEventsEnabled$_(t);
        }
    };
}

{
    let r = function(t) {
        c = l && 0 === f ? requestIdleCallback(s, {
            timeout: i
        }) : setTimeout(s, 0 < f ? 1 : t);
    }, s = function(h) {
        if (c = -1, u.length) {
            let i = performance.now(), e = i, t = 0, s;
            for (;n(u.shift()), e = performance.now(), ++t, s = (e - i) / t * 1.1, 
            u.length && (l && 0 === f && void 0 !== h ? s < h.timeRemaining() : e - i + s < o); );
            if (-1 === c && u.length) {
                let t = e - i, s = Math.max(a - t, 4);
                r(s);
            }
        }
    }, n = function(s) {
        let t;
        try {
            t = s._$func$_();
        } catch (t) {
            return void s.reject(t);
        }
        s.resolve(t);
    }, t = (r, s, n, self._$C3$_), o = 12, a = 16, i = 35, l = "undefined" != typeof requestIdleCallback, u = [], c = -1, f = 0, h = t._$QueryString$_._$Has$_("disable-asyncify");
    h && console.warn("[Asyncify] Asyncify has been disabled due to disable-asyncify in the query string. Some work will now be done synchronously."), 
    t._$Asyncify$_ = function(i) {
        let e = null;
        return t.isDebug && (e = t._$GetCallStack$_()), new Promise((t, s) => {
            u.push({
                _$func$_: i,
                resolve: t,
                reject: s,
                stack: e
            }), h ? n(u.pop()) : -1 === c && r(a);
        });
    }, t._$Asyncify$_._$SetHighThroughputMode$_ = function(t) {
        if (t) ++f; else if (--f < 0) throw new Error("already turned off high throughput mode");
    };
}

{
    let t = function() {
        r = -1;
    }, s = function() {
        n = -1, o = -1;
        let i = Date.now();
        for (let s of a) if (s._$_CheckTimeout$_(i)) {
            let t = s._$_GetDeadline$_();
            (-1 === o || t < o) && (o = t);
        } else a.delete(s);
        if (-1 !== o) {
            let t = Math.max(o - i + h, e);
            n = self.setTimeout(s, t);
        }
    }, i = (t, s, self._$C3$_), e = 1e3, h = 100, r = -1, n = (i._$FastGetDateNow$_ = function() {
        return -1 === r && (r = Date.now(), self.setTimeout(t, 16)), r;
    }, -1), o = -1, a = new Set();
    i._$IdleTimeout$_ = class {
        constructor(t, s) {
            this._$_callback$_ = t, this._$_timeout$_ = 1e3 * s, this._$_deadline$_ = 0, 
            this._$_isActive$_ = !1;
        }
        _$Reset$_() {
            let t = i._$FastGetDateNow$_();
            this._$_deadline$_ = t + this._$_timeout$_, this._$_isActive$_ || (a.add(this), 
            this._$_isActive$_ = !0), -1 === n ? (o = this._$_deadline$_, n = self.setTimeout(s, this._$_timeout$_ + h)) : this._$_deadline$_ < o && o > t + e && (self.clearTimeout(n), 
            o = this._$_deadline$_, n = self.setTimeout(s, this._$_timeout$_ + h));
        }
        _$_CheckTimeout$_(t) {
            return !(t >= this._$_deadline$_) || (this._$_callback$_() ? (this._$_deadline$_ = t + this._$_timeout$_, 
            !0) : this._$_isActive$_ = !1);
        }
        _$_GetDeadline$_() {
            return this._$_deadline$_;
        }
        _$Cancel$_() {
            this._$_isActive$_ && (a.delete(this), this._$_isActive$_ = !1, 0 === a.size) && -1 !== n && (self.clearTimeout(n), 
            n = -1, o = -1);
        }
        _$Release$_() {
            this._$Cancel$_(), this._$_callback$_ = null;
        }
    };
}

{
    const ns = self._$C3$_;
    ns._$Disposable$_ = class os {
        constructor(t) {
            this._$_disposed$_ = !1, this._$_disposeAction$_ = t;
        }
        _$Dispose$_() {
            this._$_disposed$_ || (this._$_disposed$_ = !0, this._$_disposeAction$_ && (this._$_disposeAction$_(), 
            this._$_disposeAction$_ = null));
        }
        _$IsDisposed$_() {
            return this._$_disposed$_;
        }
        _$Release$_() {
            this._$Dispose$_();
        }
        static _$Release$_(t) {
            return new os(() => t._$Release$_());
        }
        static _$From$_(s, i, e, h, t) {
            if (null == h) h = !1; else if ("boolean" != typeof h && "object" != typeof h) throw new TypeError("invalid event listener options");
            if (t && (e = e.bind(t)), i.includes(" ")) {
                i = i.split(" ");
                const r = new ns._$CompositeDisposable$_();
                for (let t of i) s.addEventListener(t, e, h), r._$Add$_(ns._$New$_(ns._$Disposable$_, () => s.removeEventListener(t, e, h)));
                return r;
            }
            return s.addEventListener(i, e, h), ns._$New$_(ns._$Disposable$_, () => s.removeEventListener(i, e, h));
        }
    }, ns._$StubDisposable$_ = class extends ns._$Disposable$_ {
        _$SetAction$_(t) {
            this._$_disposeAction$_ = t;
        }
    }, ns._$CompositeDisposable$_ = class extends ns._$Disposable$_ {
        constructor(...s) {
            super(), this._$_disposables$_ = new Set();
            for (let t of s) this._$Add$_(t);
        }
        _$Add$_(...s) {
            if (this._$_disposed$_) throw new Error("already disposed");
            for (let t of s) this._$_disposables$_.add(t);
        }
        _$Remove$_(t) {
            if (this._$_disposed$_) throw new Error("already disposed");
            this._$_disposables$_.delete(t);
        }
        _$RemoveAll$_() {
            if (this._$_disposed$_) throw new Error("already disposed");
            if (this._$_disposables$_) {
                for (let t of this._$_disposables$_) t._$Dispose$_();
                this._$_disposables$_.clear();
            }
        }
        _$IsDisposed$_() {
            return this._$_disposed$_;
        }
        _$Dispose$_() {
            if (this._$_disposed$_) throw new Error("already disposed");
            this._$_disposed$_ = !0;
            for (let t of this._$_disposables$_) t._$Dispose$_();
            this._$_disposables$_.clear(), this._$_disposables$_ = null;
        }
        _$Release$_() {
            this._$Dispose$_();
        }
    };
}

{
    const as = self._$C3$_;
    as._$KahanSum$_ = class extends as._$DefendedBase$_ {
        constructor() {
            super(), this._$_c$_ = 0, this._$_y$_ = 0, this._$_t$_ = 0, this._$_sum$_ = 0;
        }
        _$Add$_(t) {
            this._$_y$_ = (t = +t) - this._$_c$_, this._$_t$_ = this._$_sum$_ + this._$_y$_, 
            this._$_c$_ = this._$_t$_ - this._$_sum$_ - this._$_y$_, this._$_sum$_ = this._$_t$_;
        }
        _$Subtract$_(t) {
            this._$_sum$_ -= +t;
        }
        _$Get$_() {
            return this._$_sum$_;
        }
        _$Reset$_() {
            this._$_c$_ = 0, this._$_y$_ = 0, this._$_t$_ = 0, this._$_sum$_ = 0;
        }
        Set(t) {
            this._$_c$_ = 0, this._$_y$_ = 0, this._$_t$_ = 0, this._$_sum$_ = +t;
        }
        _$Copy$_(t) {
            this._$_c$_ = t._$_c$_, this._$_y$_ = t._$_y$_, this._$_t$_ = t._$_t$_, 
            this._$_sum$_ = t._$_sum$_;
        }
        _$Release$_() {}
    };
}

{
    const ls = self._$C3$_, n = {};
    n._$RBnode$_ = function(t) {
        this._$tree$_ = t, this.right = this._$tree$_._$sentinel$_, this.left = this._$tree$_._$sentinel$_, 
        this.parent = null, this.color = !1, this.key = null;
    }, n._$RedBlackSet$_ = function(t) {
        this.size = 0, this._$sentinel$_ = new n._$RBnode$_(this), this._$sentinel$_.color = !1, 
        this.root = this._$sentinel$_, this.root.parent = this._$sentinel$_, this.compare = t || this._$default_compare$_;
    }, n._$RedBlackSet$_.prototype._$default_compare$_ = function(t, s) {
        return t < s ? -1 : s < t ? 1 : 0;
    }, n._$RedBlackSet$_.prototype.clone = function() {
        var t = new n._$RedBlackSet$_(this.compare);
        return t._$insertAll$_(this), t;
    }, n._$RedBlackSet$_.prototype.clear = function() {
        this.size = 0, this._$sentinel$_ = new n._$RBnode$_(this), this._$sentinel$_.color = !1, 
        this.root = this._$sentinel$_, this.root.parent = this._$sentinel$_;
    }, n._$RedBlackSet$_.prototype._$leftRotate$_ = function(t) {
        var s = t.right;
        t.right = s.left, s.left != this._$sentinel$_ && (s.left.parent = t), s.parent = t.parent, 
        t.parent == this._$sentinel$_ ? this.root = s : t == t.parent.left ? t.parent.left = s : t.parent.right = s, 
        (s.left = t).parent = s;
    }, n._$RedBlackSet$_.prototype._$rightRotate$_ = function(t) {
        var s = t.left;
        t.left = s.right, s.right != this._$sentinel$_ && (s.right.parent = t), 
        s.parent = t.parent, t.parent == this._$sentinel$_ ? this.root = s : t == t.parent.right ? t.parent.right = s : t.parent.left = s, 
        (s.right = t).parent = s;
    }, n._$RedBlackSet$_.prototype._$insert$_ = function(t) {
        if (this.contains(t)) this._$get_$_(t).key = t; else {
            for (var s = new n._$RBnode$_(this), i = (s.key = t, this._$sentinel$_), e = this.root; e != this._$sentinel$_; ) i = e, 
            e = this.compare(s.key, e.key) < 0 ? e.left : e.right;
            (s.parent = i) == this._$sentinel$_ ? this.root = s : this.compare(s.key, i.key) < 0 ? i.left = s : i.right = s, 
            s.left = this._$sentinel$_, s.right = this._$sentinel$_, s.color = !0, 
            this._$insertFixup$_(s), this.size++;
        }
    }, n._$RedBlackSet$_.prototype._$insertFixup$_ = function(t) {
        for (;t != this._$sentinel$_ && t != this.root && 1 == t.parent.color; ) {
            var s;
            t.parent == t.parent.parent.left ? 1 == (s = t.parent.parent.right).color ? (t.parent.color = !1, 
            s.color = !1, t.parent.parent.color = !0, t = t.parent.parent) : (t == t.parent.right && (t = t.parent, 
            this._$leftRotate$_(t)), t.parent.color = !1, t.parent.parent.color = !0, 
            t.parent.parent != this._$sentinel$_ && this._$rightRotate$_(t.parent.parent)) : 1 == (s = t.parent.parent.left).color ? (t.parent.color = !1, 
            s.color = !1, t.parent.parent.color = !0, t = t.parent.parent) : (t == t.parent.left && (t = t.parent, 
            this._$rightRotate$_(t)), t.parent.color = !1, t.parent.parent.color = !0, 
            t.parent.parent != this._$sentinel$_ && this._$leftRotate$_(t.parent.parent));
        }
        this.root.color = !1;
    }, n._$RedBlackSet$_.prototype._$delete_$_ = function(t) {
        var s = t.left == this._$sentinel$_ || t.right == this._$sentinel$_ ? t : this._$successor_$_(t), i = s.left != this._$sentinel$_ ? s.left : s.right;
        i.parent = s.parent, s.parent == this._$sentinel$_ ? this.root = i : s == s.parent.left ? s.parent.left = i : s.parent.right = i, 
        s != t && (t.key = s.key), 0 == s.color && this._$deleteFixup$_(i), this.size--;
    }, n._$RedBlackSet$_.prototype._$deleteFixup$_ = function(t) {
        for (;t != this.root && 0 == t.color; ) {
            var s;
            t = t == t.parent.left ? (1 == (s = t.parent.right).color && (s.color = !1, 
            t.parent.color = !0, this._$leftRotate$_(t.parent), s = t.parent.right), 
            0 == s.left.color && 0 == s.right.color ? (s.color = !0, t.parent) : (0 == s.right.color && (s.left.color = !1, 
            s.color = !0, this._$rightRotate$_(s), s = t.parent.right), s.color = t.parent.color, 
            t.parent.color = !1, s.right.color = !1, this._$leftRotate$_(t.parent), 
            this.root)) : (1 == (s = t.parent.left).color && (s.color = !1, t.parent.color = !0, 
            this._$rightRotate$_(t.parent), s = t.parent.left), 0 == s.right.color && 0 == s.left.color ? (s.color = !0, 
            t.parent) : (0 == s.left.color && (s.right.color = !1, s.color = !0, 
            this._$leftRotate$_(s), s = t.parent.left), s.color = t.parent.color, 
            t.parent.color = !1, s.left.color = !1, this._$rightRotate$_(t.parent), 
            this.root));
        }
        t.color = !1;
    }, n._$RedBlackSet$_.prototype.remove = function(t) {
        var s, t = this._$get_$_(t);
        return t != this._$sentinel$_ ? (s = t.key, this._$delete_$_(t), s) : null;
    }, n._$RedBlackSet$_.prototype._$removeSwapped$_ = function(t, s) {
        this.remove(s);
    }, n._$RedBlackSet$_.prototype.min = function(t) {
        for (;t.left != this._$sentinel$_; ) t = t.left;
        return t;
    }, n._$RedBlackSet$_.prototype.max = function(t) {
        for (;t.right != this._$sentinel$_; ) t = t.right;
        return t;
    }, n._$RedBlackSet$_.prototype._$successor_$_ = function(t) {
        if (t.right != this._$sentinel$_) return this.min(t.right);
        for (var s = t.parent; s != this._$sentinel$_ && t == s.right; ) s = (t = s).parent;
        return s;
    }, n._$RedBlackSet$_.prototype._$predeccessor_$_ = function(t) {
        if (t.left != this._$sentinel$_) return this.max(t.left);
        for (var s = t.parent; s != this._$sentinel$_ && t == s.left; ) s = (t = s).parent;
        return s;
    }, n._$RedBlackSet$_.prototype._$successor$_ = function(t) {
        if (0 < this.size) {
            var s = this._$get_$_(t);
            if (s == this._$sentinel$_) return null;
            if (s.right != this._$sentinel$_) return this.min(s.right).key;
            for (var i = s.parent; i != this._$sentinel$_ && s == i.right; ) i = (s = i).parent;
            return i != this._$sentinel$_ ? i.key : null;
        }
        return null;
    }, n._$RedBlackSet$_.prototype._$predecessor$_ = function(t) {
        if (0 < this.size) {
            var s = this._$get_$_(t);
            if (s == this._$sentinel$_) return null;
            if (s.left != this._$sentinel$_) return this.max(s.left).key;
            for (var i = s.parent; i != this._$sentinel$_ && s == i.left; ) i = (s = i).parent;
            return i != this._$sentinel$_ ? i.key : null;
        }
        return null;
    }, n._$RedBlackSet$_.prototype._$getMin$_ = function() {
        return this.min(this.root).key;
    }, n._$RedBlackSet$_.prototype._$getMax$_ = function() {
        return this.max(this.root).key;
    }, n._$RedBlackSet$_.prototype._$get_$_ = function(t) {
        for (var s = this.root; s != this._$sentinel$_ && 0 != this.compare(s.key, t); ) s = this.compare(t, s.key) < 0 ? s.left : s.right;
        return s;
    }, n._$RedBlackSet$_.prototype.contains = function(t) {
        return null != this._$get_$_(t).key;
    }, n._$RedBlackSet$_.prototype.getValues = function() {
        var s = [];
        return this.forEach(function(t) {
            s.push(t);
        }), s;
    }, n._$RedBlackSet$_.prototype._$insertAll$_ = function(t) {
        if ("array" == n.typeOf(t)) for (var s = 0; s < t.length; s++) this._$insert$_(t[s]); else if ("function" == n.typeOf(t.forEach)) t.forEach(this._$insert$_, this); else if ("function" == n.typeOf(t.getValues)) for (var i = t.getValues(), s = 0; s < i.length; s++) this._$insert$_(i[s]); else if ("object" == n.typeOf(t)) for (var e in t) this._$insert$_(t[e]);
    }, n._$RedBlackSet$_.prototype._$removeAll$_ = function(t) {
        if ("array" == n.typeOf(t)) for (var s = 0; s < t.length; s++) this.remove(t[s]); else if ("function" == n.typeOf(t.forEach)) t.forEach(this._$removeSwapped$_, this); else if ("function" == n.typeOf(t.getValues)) for (var i = t.getValues(), s = 0; s < i.length; s++) this.remove(i[s]); else if ("object" == n.typeOf(t)) for (var e in t) this.remove(t[e]);
    }, n._$RedBlackSet$_.prototype._$containsAll$_ = function(t) {
        if ("array" == n.typeOf(t)) {
            for (var s = 0; s < t.length; s++) if (!this.contains(t[s])) return !1;
            return !0;
        }
        if ("function" == n.typeOf(t.forEach)) return t.every(this.contains, this);
        if ("function" == n.typeOf(t.getValues)) {
            for (var i = t.getValues(), s = 0; s < i.length; s++) if (!this.contains(i[s])) return !1;
            return !0;
        }
        if ("object" == n.typeOf(t)) {
            for (var e in t) if (!this.contains(t[e])) return !1;
            return !0;
        }
    }, n._$RedBlackSet$_.prototype.range = function(t, s) {
        var i = [];
        return this._$traverseFromTo$_(function(t) {
            i.push(t);
        }, t, s), i;
    }, n._$RedBlackSet$_.prototype._$traverse$_ = function(t, s) {
        if (!this._$isEmpty$_()) for (var i = this.min(this.root); i != this._$sentinel$_; ) {
            if (t.call(s, i.key, this)) return;
            i = this._$successor_$_(i);
        }
    }, n._$RedBlackSet$_.prototype._$traverseFrom$_ = function(t, s, i) {
        if (!this._$isEmpty$_()) for (var e = this._$get_$_(s); e != this._$sentinel$_; ) {
            if (t.call(i, e.key, this)) return;
            e = this._$successor_$_(e);
        }
    }, n._$RedBlackSet$_.prototype._$traverseTo$_ = function(t, s, i) {
        if (!this._$isEmpty$_()) for (var e = this.min(this.root), h = this._$get_$_(s); e != h; ) {
            if (t.call(i, e.key, this)) return;
            e = this._$successor_$_(e);
        }
    }, n._$RedBlackSet$_.prototype._$traverseFromTo$_ = function(t, s, i, e) {
        if (!this._$isEmpty$_()) for (var h = this._$get_$_(s), r = this._$get_$_(i); h != r; ) {
            if (t.call(e, h.key, this)) return;
            h = this._$successor_$_(h);
        }
    }, n._$RedBlackSet$_.prototype._$traverseBackwards$_ = function(t, s) {
        if (!this._$isEmpty$_()) for (var i = this.max(this.root); i != this._$sentinel$_; ) {
            if (t.call(s, i.key, this)) return;
            i = this._$predeccessor_$_(i);
        }
    }, n._$RedBlackSet$_.prototype.forEach = function(t, s) {
        if (!this._$isEmpty$_()) for (var i = this.min(this.root); i != this._$sentinel$_; i = this._$successor_$_(i)) t.call(s, i.key, i.key, this);
    }, n._$RedBlackSet$_.prototype.some = function(t, s) {
        if (!this._$isEmpty$_()) for (var i = this.min(this.root); i != this._$sentinel$_; i = this._$successor_$_(i)) if (t.call(s, i.key, i.key, this)) return !0;
        return !1;
    }, n._$RedBlackSet$_.prototype.every = function(t, s) {
        if (this._$isEmpty$_()) return !1;
        for (var i = this.min(this.root); i != this._$sentinel$_; i = this._$successor_$_(i)) if (!t.call(s, i.key, i.key, this)) return !1;
        return !0;
    }, n._$RedBlackSet$_.prototype.map = function(t, s) {
        var i = [];
        if (!this._$isEmpty$_()) for (var e = this.min(this.root); e != this._$sentinel$_; e = this._$successor_$_(e)) i.push(t.call(s, e.key, e.key, this));
        return i;
    }, n._$RedBlackSet$_.prototype.filter = function(t, s) {
        var i = [];
        if (!this._$isEmpty$_()) for (var e = this.min(this.root); e != this._$sentinel$_; e = this._$successor_$_(e)) t.call(s, e.key, e.key, this) && i.push(e.key);
        return i;
    }, n._$RedBlackSet$_.prototype.getCount = function() {
        return this.size;
    }, n._$RedBlackSet$_.prototype._$isEmpty$_ = function() {
        return 0 == this.size;
    }, n._$RedBlackSet$_.prototype._$isSubsetOf$_ = function(t) {
        var s = n.getCount(t);
        if (this.getCount() > s) return !1;
        var i = 0;
        if (this._$isEmpty$_()) return !0;
        for (var e = this.min(this.root); e != this._$sentinel$_; e = this._$successor_$_(e)) n.contains.call(t, t, e.key) && i++;
        return i == this.getCount();
    }, n._$RedBlackSet$_.prototype._$intersection$_ = function(t) {
        var s = new n._$RedBlackSet$_(this.compare);
        if (!this._$isEmpty$_()) for (var i = this.min(this.root); i != this._$sentinel$_; i = this._$successor_$_(i)) t.contains.call(t, i.key, i.key, this) && s._$insert$_(i.key);
        return s;
    }, ls._$RedBlackSet$_ = class extends ls._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_rbSet$_ = new n._$RedBlackSet$_(t), this._$_enableQueue$_ = !1, 
            this._$_queueInsert$_ = new Set(), this._$_queueRemove$_ = new Set();
        }
        _$Add$_(t) {
            this._$_enableQueue$_ ? this._$_rbSet$_.contains(t) ? this._$_queueRemove$_.delete(t) : this._$_queueInsert$_.add(t) : this._$_rbSet$_._$insert$_(t);
        }
        _$Remove$_(t) {
            this._$_enableQueue$_ ? this._$_rbSet$_.contains(t) ? this._$_queueRemove$_.add(t) : this._$_queueInsert$_.delete(t) : this._$_rbSet$_.remove(t);
        }
        _$Has$_(t) {
            return this._$_enableQueue$_ ? !!this._$_queueInsert$_.has(t) || !this._$_queueRemove$_.has(t) && this._$_rbSet$_.contains(t) : this._$_rbSet$_.contains(t);
        }
        _$Clear$_() {
            this._$_rbSet$_.clear(), this._$_queueInsert$_.clear(), this._$_queueRemove$_.clear();
        }
        toArray() {
            if (this._$_enableQueue$_) throw new Error("cannot be used in queueing mode");
            return this._$_rbSet$_.getValues();
        }
        _$GetSize$_() {
            return this._$_rbSet$_.getCount() + this._$_queueInsert$_.size - this._$_queueRemove$_.size;
        }
        _$IsEmpty$_() {
            return 0 === this._$GetSize$_();
        }
        _$Front$_() {
            if (this._$IsEmpty$_()) throw new Error("empty set");
            if (this._$_enableQueue$_) throw new Error("cannot be used in queueing mode");
            const t = this._$_rbSet$_, s = t.min(t.root);
            return s.key;
        }
        _$Shift$_() {
            if (this._$IsEmpty$_()) throw new Error("empty set");
            if (this._$_enableQueue$_) throw new Error("cannot be used in queueing mode");
            const t = this._$Front$_();
            return this._$Remove$_(t), t;
        }
        _$SetQueueingEnabled$_(t) {
            if (this._$_enableQueue$_ !== (t = !!t) && !(this._$_enableQueue$_ = t)) {
                for (const s of this._$_queueRemove$_) this._$_rbSet$_.remove(s);
                this._$_queueRemove$_.clear();
                for (const i of this._$_queueInsert$_) this._$_rbSet$_._$insert$_(i);
                this._$_queueInsert$_.clear();
            }
        }
        _$ForEach$_(t) {
            this._$_rbSet$_.forEach(t);
        }
        *values() {
            if (!this._$IsEmpty$_()) {
                const s = this._$_rbSet$_;
                for (let t = s.min(s.root); t != s._$sentinel$_; t = s._$successor_$_(t)) yield t.key;
            }
        }
        [Symbol.iterator]() {
            return this.values();
        }
    };
}

{
    const us = self._$C3$_;
    us._$PromiseThrottle$_ = class {
        constructor(t = us.hardwareConcurrency) {
            this._$_maxParallel$_ = t, this._$_queue$_ = [], this._$_activeCount$_ = 0;
        }
        _$Add$_(i) {
            return new Promise((t, s) => {
                this._$_queue$_.push({
                    _$func$_: i,
                    resolve: t,
                    reject: s
                }), this._$_MaybeStartNext$_();
            });
        }
        _$_FindInQueue$_(i) {
            for (let t = 0, s = this._$_queue$_.length; t < s; ++t) if (this._$_queue$_[t]._$func$_ === i) return t;
            return -1;
        }
        _$RemoveAndResolve$_(t, s) {
            const i = this._$_FindInQueue$_(t);
            if (-1 === i) throw new Error("cannot find promise to resolve");
            this._$_queue$_[i].resolve(s), this._$_queue$_.splice(i, 1);
        }
        _$RemoveAndReject$_(t, s) {
            const i = this._$_FindInQueue$_(t);
            if (-1 === i) throw new Error("cannot find promise to reject");
            this._$_queue$_[i].reject(s), this._$_queue$_.splice(i, 1);
        }
        async _$_MaybeStartNext$_() {
            if (this._$_queue$_.length && !(this._$_activeCount$_ >= this._$_maxParallel$_)) {
                this._$_activeCount$_++;
                const s = this._$_queue$_.shift();
                try {
                    const t = await s._$func$_();
                    s.resolve(t);
                } catch (t) {
                    s.reject(t);
                }
                this._$_activeCount$_--, this._$_MaybeStartNext$_();
            }
        }
        static async _$Batch$_(t, s) {
            let i = [], e = !1, h = [];
            for (;t--; ) h.push((async () => {
                let t;
                for (;t = s.pop(); ) {
                    if (e) return;
                    try {
                        i.push(await t());
                    } catch (t) {
                        throw e = !0, t;
                    }
                }
            })());
            return await Promise.all(h), i;
        }
    };
}

{
    const cs = self._$C3$_;
    cs._$RateLimiter$_ = class {
        constructor(t, s, i) {
            this._$_callback$_ = t, this._$_interval$_ = s, this._$_intervalOnBattery$_ = i || 2 * s, 
            this._$_timerId$_ = -1, this._$_lastCallTime$_ = -1 / 0, this._$_timerCallFunc$_ = () => this._$_OnTimer$_(), 
            this._$_ignoreReset$_ = !1, this._$_canRunImmediate$_ = !1, this._$_callbackArguments$_ = null;
        }
        _$SetCanRunImmediate$_(t) {
            this._$_canRunImmediate$_ = !!t;
        }
        _$_GetInterval$_() {
            return void 0 !== cs.Battery && cs.Battery.IsOnBatteryPower() ? this._$_intervalOnBattery$_ : this._$_interval$_;
        }
        _$Call$_(...e) {
            if (-1 === this._$_timerId$_) {
                this._$_callbackArguments$_ = e;
                let t = cs._$FastGetDateNow$_(), s = t - this._$_lastCallTime$_, i = this._$_GetInterval$_();
                i <= s && this._$_canRunImmediate$_ ? (this._$_lastCallTime$_ = t, 
                this._$_RunCallback$_()) : this._$_timerId$_ = self.setTimeout(this._$_timerCallFunc$_, Math.max(i - s, 4));
            }
        }
        _$_RunCallback$_() {
            this._$_ignoreReset$_ = !0;
            const t = this._$_callbackArguments$_;
            this._$_callbackArguments$_ = null, t ? this._$_callback$_(...t) : this._$_callback$_(), 
            this._$_ignoreReset$_ = !1;
        }
        _$Reset$_() {
            this._$_ignoreReset$_ || (this._$_CancelTimer$_(), this._$_callbackArguments$_ = null, 
            this._$_lastCallTime$_ = cs._$FastGetDateNow$_());
        }
        _$_OnTimer$_() {
            this._$_timerId$_ = -1, this._$_lastCallTime$_ = cs._$FastGetDateNow$_(), 
            this._$_RunCallback$_();
        }
        _$_CancelTimer$_() {
            -1 !== this._$_timerId$_ && (self.clearTimeout(this._$_timerId$_), this._$_timerId$_ = -1);
        }
        _$Release$_() {
            this._$_CancelTimer$_(), this._$_callback$_ = null, this._$_callbackArguments$_ = null, 
            this._$_timerCallFunc$_ = null;
        }
    };
}

{
    const fs = self._$C3$_;
    fs._$SVGRasterManager$_ = class {
        constructor() {
            this._$_images$_ = new Map(), this._$_allowNpotSurfaces$_ = !1, this._$_getBaseSizeCallback$_ = null, 
            this._$_rasterAtSizeCallback$_ = null, this._$_releaseResultCallback$_ = null, 
            this._$_redrawCallback$_ = null;
        }
        _$SetNpotSurfaceAllowed$_(t) {
            this._$_allowNpotSurfaces$_ = !!t;
        }
        _$IsNpotSurfaceAllowed$_() {
            return this._$_allowNpotSurfaces$_;
        }
        _$SetGetBaseSizeCallback$_(t) {
            this._$_getBaseSizeCallback$_ = t;
        }
        _$GetBaseSize$_(t) {
            if (this._$_getBaseSizeCallback$_) return this._$_getBaseSizeCallback$_(t);
            throw new Error("no get base size callback set");
        }
        _$SetRasterAtSizeCallback$_(t) {
            this._$_rasterAtSizeCallback$_ = t;
        }
        _$RasterAtSize$_(t, s, i, e, h, r) {
            if (this._$_rasterAtSizeCallback$_) return this._$_rasterAtSizeCallback$_(t, s, i, e, h, r);
            throw new Error("no raster at size callback set");
        }
        _$SetReleaseResultCallback$_(t) {
            this._$_releaseResultCallback$_ = t;
        }
        _$ReleaseResult$_(t) {
            if (!this._$_releaseResultCallback$_) throw new Error("no release result callback set");
            this._$_releaseResultCallback$_(t);
        }
        _$SetRedrawCallback$_(t) {
            this._$_redrawCallback$_ = t;
        }
        _$Redraw$_() {
            if (!this._$_redrawCallback$_) throw new Error("no redraw callback set");
            this._$_redrawCallback$_();
        }
        _$AddImage$_(t) {
            let s = this._$_images$_.get(t);
            return s || (s = fs._$New$_(fs._$SVGRasterImage$_, this, t), this._$_images$_.set(t, s)), 
            s._$IncReference$_(), s;
        }
        _$_RemoveImage$_(t) {
            this._$_images$_.delete(t._$GetDataSource$_());
        }
        _$OnTexturesChanged$_() {
            for (const t of this._$_images$_.values()) t._$ReleaseRasterizedResult$_(), 
            t._$ForceRasterAgain$_();
        }
    };
}

{
    const ds = self._$C3$_;
    ds._$SVGRasterImage$_ = class {
        constructor(t, s) {
            this._$_manager$_ = t, this._$_dataSource$_ = s, this._$_refCount$_ = 0, 
            this._$_baseWidth$_ = 0, this._$_baseHeight$_ = 0, this._$_getBaseSizePromise$_ = this._$_manager$_._$GetBaseSize$_(s).then(t => {
                this._$_manager$_ && (this._$_baseWidth$_ = t[0], this._$_baseHeight$_ = t[1], 
                this._$_manager$_._$Redraw$_());
            }).catch(t => {
                console.error("[SVG] Error loading SVG: ", t), this._$_hadError$_ = !0, 
                this._$_manager$_ && this._$_manager$_._$Redraw$_();
            }), this._$_rasterSurfaceWidth$_ = 0, this._$_rasterSurfaceHeight$_ = 0, 
            this._$_rasterImageWidth$_ = 0, this._$_rasterImageHeight$_ = 0, this._$_isRasterizing$_ = !1, 
            this._$_rasterizedResult$_ = null, this._$_forceRaster$_ = !1, this._$_hadError$_ = !1;
        }
        _$Release$_() {
            if (this._$_refCount$_ <= 0) throw new Error("already released");
            this._$_refCount$_--, 0 === this._$_refCount$_ && this._$_Release$_();
        }
        _$ReleaseRasterizedResult$_() {
            this._$_rasterizedResult$_ && (this._$_manager$_._$ReleaseResult$_(this._$_rasterizedResult$_), 
            this._$_rasterizedResult$_ = null);
        }
        _$_Release$_() {
            this._$ReleaseRasterizedResult$_(), this._$_manager$_._$_RemoveImage$_(this), 
            this._$_manager$_ = null;
        }
        _$GetDataSource$_() {
            return this._$_dataSource$_;
        }
        _$IncReference$_() {
            this._$_refCount$_++;
        }
        _$HasReferences$_() {
            return 0 < this._$_refCount$_;
        }
        _$GetRasterizedResult$_() {
            return this._$_rasterizedResult$_;
        }
        _$ForceRasterAgain$_() {
            this._$_forceRaster$_ = !0;
        }
        async _$StartRasterForSize$_(e, h, r) {
            if (0 !== h && 0 !== r && !this._$_hadError$_ && !this._$_isRasterizing$_) {
                let t = ds._$nextHighestPowerOfTwo$_(Math.ceil(h)), s = ds._$nextHighestPowerOfTwo$_(Math.ceil(r)), i = Math.max(t, s);
                if (4096 < i) {
                    const n = 4096 / i;
                    h *= n, r *= n, t = Math.min(Math.ceil(t * n), 4096), s = Math.min(Math.ceil(s * n), 4096);
                }
                if (h < t && r < s) {
                    const o = h / r, a = t / s;
                    r = o < a ? (h = s * o, s) : (h = t) / o;
                }
                if (this._$_manager$_._$IsNpotSurfaceAllowed$_() && (t = Math.ceil(h), 
                s = Math.ceil(r)), !(t <= this._$_rasterSurfaceWidth$_ && s <= this._$_rasterSurfaceHeight$_) || this._$_forceRaster$_) {
                    this._$_isRasterizing$_ = !0, this._$_rasterSurfaceWidth$_ = t, 
                    this._$_rasterSurfaceHeight$_ = s;
                    const l = await this._$_manager$_._$RasterAtSize$_(this._$_dataSource$_, e, this._$_rasterSurfaceWidth$_, this._$_rasterSurfaceHeight$_, h, r);
                    this._$_manager$_ && (this._$ReleaseRasterizedResult$_(), this._$_rasterizedResult$_ = l, 
                    this._$_rasterImageWidth$_ = h, this._$_rasterImageHeight$_ = r, 
                    this._$_isRasterizing$_ = !1, this._$_forceRaster$_ = !1, this._$_manager$_._$Redraw$_());
                }
            }
        }
        _$WhenBaseSizeReady$_() {
            return this._$_getBaseSizePromise$_;
        }
        _$GetBaseWidth$_() {
            return this._$_baseWidth$_;
        }
        _$GetBaseHeight$_() {
            return this._$_baseHeight$_;
        }
        _$GetRasterWidth$_() {
            return this._$_rasterImageWidth$_;
        }
        _$GetRasterHeight$_() {
            return this._$_rasterImageHeight$_;
        }
        _$HadError$_() {
            return this._$_hadError$_;
        }
    };
}

{
    let s = function(t) {
        return ys.get(t);
    };
    s;
    const c = self._$C3$_, ps = (c._$UTF8_BOM$_ = "\ufeff", new Set("0123456789")), ms = (c._$IsNumericChar$_ = function(t) {
        return ps.has(t);
    }, new Set(" \t\n\r\u2028\u2029"));
    c._$IsWhitespaceChar$_ = function(t) {
        return ms.has(t);
    }, c._$FilterWhitespace$_ = function(t) {
        return [ ...t ].filter(t => !c._$IsWhitespaceChar$_(t)).join("");
    }, c._$IsStringAllWhitespace$_ = function(t) {
        for (const s of t) if (!c._$IsWhitespaceChar$_(s)) return !1;
        return !0;
    }, c._$IsCharArrayAllWhitespace$_ = function(t) {
        for (const s of t) if (!c._$IsWhitespaceChar$_(s)) return !1;
        return !0;
    }, c._$IsUnprintableChar$_ = function(t) {
        return 1 === t.length && t.charCodeAt(0) < 32;
    }, c._$FilterUnprintableChars$_ = function(t) {
        return [ ...t ].filter(t => !c._$IsUnprintableChar$_(t)).join("");
    };
    let i = null;
    try {
        i = new RegExp("\\p{P}(?<=[\\u3000-\\u303F\\uFF00-\\uFFEF])", "u");
    } catch (t) {
        console.warn("Unable to detect CJK punctuation: ", t);
    }
    c._$IsCJKPunctuationChar$_ = function(t) {
        return !c._$IsWhitespaceChar$_(t) && i && i.test(t);
    };
    const gs = new Set("0123456789.+-e"), ys = (c._$IsStringNumber$_ = function(s) {
        if (!(s = s.trim()).length) return !1;
        let t = s.charAt(0);
        if ("-" !== t && !ps.has(t)) return !1;
        for (let t of s) if (!gs.has(t)) return !1;
        return !0;
    }, c._$RemoveTrailingDigits$_ = function(s) {
        let i = s.length;
        for (;0 < i; ) {
            let t = s.charAt(i - 1);
            if (!c._$IsNumericChar$_(t)) break;
            --i;
        }
        return s.substr(0, i);
    }, c._$IncrementNumberAtEndOf$_ = function(t) {
        let s = c._$RemoveTrailingDigits$_(t), i = t.substr(s.length);
        return s + (i = i ? (parseInt(i, 10) + 1).toString() : "2");
    }, new Map([ [ "&", "&amp;" ], [ "<", "&lt;" ], [ ">", "&gt;" ], [ '"', "&quot;" ], [ "'", "&#39;" ] ])), ws = /[&<>"']/g, Ss = (c._$EscapeHTML$_ = function(t) {
        return t.replace(ws, s);
    }, c._$EscapeJS$_ = function(t) {
        let s = c._$ReplaceAll$_(t, "\\", "\\\\");
        return s = c._$ReplaceAll$_(s, '"', '\\"'), s = c._$ReplaceAll$_(s, "\t", "\\t"), 
        s = c._$ReplaceAll$_(s, "\r", ""), c._$ReplaceAll$_(s, "\n", "\\n");
    }, c._$EscapeXML$_ = function(t) {
        let s = c._$ReplaceAll$_(t, "&", "&amp;");
        return s = c._$ReplaceAll$_(s, "<", "&lt;"), s = c._$ReplaceAll$_(s, ">", "&gt;"), 
        c._$ReplaceAll$_(s, '"', "&quot;");
    }, /[-[\]{}()*+?.,\\^$|#\s]/g);
    c._$EscapeRegex$_ = function(t) {
        return t.replace(Ss, "\\$&");
    }, c._$CountCharsInString$_ = function(t, s) {
        let i = 0;
        for (const e of t) e === s && ++i;
        return i;
    }, c._$FindAll$_ = function(t, s, i = !1) {
        if (!s) return [];
        i || (t = t.toLowerCase(), s = s.toLowerCase());
        let e = s.length, h = 0, r, n = [];
        for (;-1 < (r = t.indexOf(s, h)); ) n.push(r), h = r + e;
        return n;
    }, c._$ReplaceAll$_ = function(t, s, i) {
        return t.replaceAll(s, () => i);
    }, c._$ReplaceAllCaseInsensitive$_ = function(t, s, i) {
        return t.replace(new RegExp(c._$EscapeRegex$_(s), "gi"), () => i);
    }, c._$SetElementContent$_ = function(t, s) {
        "string" == typeof s ? t.textContent = s : s._$isPlainText$_() ? t.textContent = s.toString() : (t.innerHTML = s._$toHTML$_(), 
        s instanceof c._$BBString$_ && s._$attachLinkHandlers$_(t));
    }, c._$StringLikeEquals$_ = function(t, s) {
        return t instanceof c.HtmlString || t instanceof c._$BBString$_ ? t.equals(s) : s instanceof c.HtmlString || s instanceof c._$BBString$_ ? s.equals(t) : t === s;
    }, c._$StringSubstitute$_ = function(i, ...e) {
        let h = i;
        for (let t = 0, s = e.length; t < s; ++t) {
            const r = `{${t}}`;
            if (!i.includes(r)) throw new Error(`missing placeholder '${r}' in string substitution`);
            h = h.replace(r, e[t].toString());
        }
        return h;
    }, c._$StringSubstituteAllowMissing$_ = function(i, ...e) {
        let h = i, r = -1, n = -1;
        for (let t = 0, s = e.length; t < s; ++t) {
            const o = `{${t}}`;
            i.includes(o) ? (n = t, h = h.replace(o, e[t].toString())) : -1 === r && (r = t);
        }
        if (0 <= r && 0 <= n && r < n) throw new Error(`missing placeholder '${r}' in string substitution`);
        return h;
    }, c._$StringSubstituteMap$_ = function(t, i) {
        let e = t;
        for (let [ t, s ] of Object.entries(i)) e = e.replaceAll(t, s.toString());
        return e;
    }, c._$SortAZ$_ = function(t, s) {
        return s < t ? 1 : t < s ? -1 : 0;
    }, c._$SortAZCaseInsensitive$_ = function(t, s) {
        let i = t.toLowerCase(), e = s.toLowerCase();
        return e < i ? 1 : i < e ? -1 : 0;
    };
    let e = null, h = null;
    self.Intl && self.Intl.Segmenter ? e = new self.Intl.Segmenter() : h = new self._$GraphemeSplitter$_(), 
    c._$SplitGraphemes$_ = function(t) {
        if (e) {
            const s = [];
            for (const i of e.segment(t)) s.push(i.segment);
            return s;
        }
        return h._$splitGraphemes$_(t);
    }, c._$IterateGraphemes$_ = function*(t) {
        if (e) for (const s of e.segment(t)) yield s.segment; else yield* h._$iterateGraphemes$_(t);
    }, c._$CountGraphemes$_ = function(s) {
        if (e) {
            let t = 0;
            for (const i of e.segment(s)) ++t;
            return t;
        }
        return h._$countGraphemes$_(s);
    };
    const bs = 1073741824, Ms = 1024 * bs, vs = {
        _$approximate$_: !(c._$FormatDataSize$_ = function(s, t) {
            let i = "common." + (t ? "dataRates" : "dataSizes") + ".", e = self.langSub;
            if (s < 1024) return e(i + "bytes", s);
            if (s < 1048576) {
                let t = s / 1024;
                return t = t < 10 ? Math.round(10 * t) / 10 : Math.round(t), e(i + "kilobytes", t);
            }
            if (s < bs) {
                let t = s / 1048576;
                return t = t < 10 ? Math.round(10 * t) / 10 : Math.round(t), e(i + "megabytes", t);
            }
            if (s < Ms) {
                let t = s / bs;
                return t = t < 10 ? Math.round(10 * t) / 10 : Math.round(t), e(i + "gigabytes", t);
            }
            {
                let t = s / Ms;
                return t = t < 10 ? Math.round(10 * t) / 10 : Math.round(t), e(i + "terabytes", t);
            }
        }),
        _$days$_: !0,
        _$hours$_: !0,
        _$minutes$_: !0,
        _$seconds$_: !0
    };
    c._$FormatTime$_ = function(t, s) {
        s = Object.assign({}, vs, s), c.Lang.PushContext("common.time");
        const i = [], e = self.lang, h = self.langPluralSub;
        if (s._$days$_) {
            const n = Math.floor(t / 86400);
            0 < n && (t -= 24 * n * 3600, i.push(h(".days", null, n)));
        }
        if (s._$hours$_) {
            const o = Math.floor(t / 3600);
            (0 < o || i.length) && (t -= 3600 * o, i.push(h(".hours", null, o)));
        }
        if (s._$minutes$_) {
            const a = Math.floor(t / 60);
            (0 < a || i.length || !s._$seconds$_) && (t -= 60 * a, i.push(h(".minutes", null, a)));
        }
        if (s._$seconds$_) {
            const l = Math.floor(t % 60);
            i.push(h(".seconds", null, l));
        }
        const r = (s._$approximate$_ ? e(".approx-prefix") : "") + i.join(e(".separator"));
        return c.Lang.PopContext(), r;
    }, c._$ZeroPad$_ = function(t, s) {
        let i = t < 0 ? "-" : "", e = (t = Math.abs(t)).toString(), h = s - e.length;
        for (let t = 0; t < h; ++t) i += "0";
        return i + e;
    }, c._$StringToTitleCase$_ = function(t) {
        return t.toLowerCase().replace(/\b\w/g, t => t.toUpperCase());
    }, c._$CompareVersionStrings$_ = function(t, s) {
        let i = t.split(".").map(t => t.trim()), e = s.split(".").map(t => t.trim());
        c._$resizeArray$_(i, 4, "0"), c._$resizeArray$_(e, 4, "0"), i = i.map(t => parseInt(t, 10)), 
        e = e.map(t => parseInt(t, 10));
        for (let t = 0; t < 4; ++t) {
            const h = i[t] - e[t];
            if (0 != h) return h < 0 ? -1 : 1;
        }
        return 0;
    }, c._$CreateGUID$_ = function() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, t => {
            const s = Math.floor(16 * Math.random()), i = "x" === t ? s : 3 & s | 8;
            return i.toString(16);
        });
    }, c._$StringHammingDistance$_ = function(i, e) {
        if (i.length !== e.length) throw new Error("strings must be same length");
        let h = 0;
        for (let t = 0, s = i.length; t < s; ++t) i.charAt(t) !== e.charAt(t) && ++h;
        return h;
    }, c._$StringLevenshteinDistance$_ = function(t, s) {
        if (0 === t.length) return s.length;
        if (0 === s.length) return t.length;
        let i, e, h, r, n, o;
        for (s.length < t.length && (i = t, t = s, s = i), o = Array(t.length + 1), 
        e = 0; e <= t.length; e++) o[e] = e;
        for (e = 1; e <= s.length; e++) {
            for (r = e, h = 1; h <= t.length; h++) n = s[e - 1] === t[h - 1] ? o[h - 1] : Math.min(o[h - 1] + 1, Math.min(r + 1, o[h] + 1)), 
            o[h - 1] = r, r = n;
            o[t.length] = r;
        }
        return o[t.length];
    };
}

{
    let s = function(t, i, e) {
        const h = o.get(e);
        if (!h) return "class" === e ? i ? "</span>" : `<span class="bbclass${u++}">` : t;
        if ("string" == typeof h) {
            if ("a" === h && 0 === a.length || "abbr" === h && 0 === l.length) return t;
            if ("a" !== h || i) {
                if ("abbr" !== h || i) return "<" + i + h + ">";
                {
                    const r = parseInt(e.substring(3), 10) - 1;
                    if (r < 0 || r >= l.length) throw new Error("invalid bbcode tip substitution");
                    let t = l[r], s = "";
                    if ("string" == typeof t ? s = t : "function" == typeof t && (s = t()), 
                    "string" != typeof s) throw new TypeError("invalid bbcode tip");
                    return `<abbr title="${f._$ReplaceAll$_(s, '"', "&quot;")}">`;
                }
            }
            {
                const s = parseInt(e.substring(1), 10) - 1;
                if (s < 0 || s >= a.length) throw new Error("invalid bbcode link substitution");
                const n = a[s];
                if ("string" == typeof n) return `<a href="${a[s]}">`;
                if ("function" == typeof n) return `<a class="bblink${s}">`;
                throw new TypeError("invalid bbcode link action");
            }
        }
        if (Array.isArray(h)) {
            let t = h[0], s = h[1];
            return i ? "</" + t + ">" : `<${t} class="${s}">`;
        }
    }, f = (s, self._$C3$_), o = new Map([ [ "b", "strong" ], [ "i", "em" ], [ "s", "s" ], [ "u", "u" ], [ "sub", "sub" ], [ "sup", "sup" ], [ "small", "small" ], [ "mark", "mark" ], [ "code", "code" ], [ "a1", "a" ], [ "a2", "a" ], [ "a3", "a" ], [ "a4", "a" ], [ "a5", "a" ], [ "a6", "a" ], [ "a7", "a" ], [ "a8", "a" ], [ "a9", "a" ], [ "tip1", "abbr" ], [ "tip2", "abbr" ], [ "tip3", "abbr" ], [ "tip4", "abbr" ], [ "tip5", "abbr" ], [ "tip6", "abbr" ], [ "tip7", "abbr" ], [ "tip8", "abbr" ], [ "tip9", "abbr" ], [ "bad", [ "span", "bbCodeBad" ] ], [ "good", [ "span", "bbCodeGood" ] ], [ "info", [ "span", "bbCodeInfo" ] ], [ "h1", [ "span", "bbCodeH1" ] ], [ "h2", [ "span", "bbCodeH2" ] ], [ "h3", [ "span", "bbCodeH3" ] ], [ "h4", [ "span", "bbCodeH4" ] ], [ "item", [ "span", "bbCodeItem" ] ] ]), d = new Set([ "icon" ]), i = /\[(\/?)([a-zA-Z0-9]+)\]/g, p = /\[(\/?)([^\[\n]*?)\]/g, a = null, l = null, u = 0, e = /\n/g;
    f._$BBString$_ = class {
        constructor(t, s) {
            if (this._$_bbstr$_ = s && s._$noEscape$_ ? t : f._$EscapeHTML$_(t), 
            this._$_htmlstr$_ = "", this._$_convertLineBreaks$_ = !1, this._$_linkActions$_ = [], 
            this._$_tipList$_ = [], s) {
                if (this._$_convertLineBreaks$_ = !!s.convertLineBreaks, s.links) {
                    if (9 < s.links.length) throw new Error("too many links");
                    this._$_linkActions$_ = s.links;
                }
                if (s.tips) {
                    if (9 < s.tips.length) throw new Error("too many tips");
                    this._$_tipList$_ = s.tips;
                }
            }
            this._$_hasAnyBBtags$_ = this._$_bbstr$_.includes("["), this._$_needsLineBreakConversion$_ = this._$_convertLineBreaks$_ && this._$_bbstr$_.includes("\n"), 
            this._$_isPlain$_ = !this._$_hasAnyBBtags$_ && !this._$_needsLineBreakConversion$_ && !this._$_bbstr$_.includes("&"), 
            this._$_hasParsedFragments$_ = !1, this._$_fragments$_ = [];
        }
        toString() {
            return this._$_bbstr$_;
        }
        valueOf() {
            return this._$_bbstr$_;
        }
        _$isPlainText$_() {
            return this._$_isPlain$_;
        }
        _$toPlainText$_() {
            return this._$_hasAnyBBtags$_ ? this._$_bbstr$_.replace(i, "") : this._$_bbstr$_;
        }
        _$toHTML$_() {
            if (this._$_isPlain$_) return this._$_bbstr$_;
            if (!this._$_htmlstr$_ && this._$_bbstr$_) {
                let t = this._$_bbstr$_;
                this._$_hasAnyBBtags$_ && (u = 0, a = this._$_linkActions$_, l = this._$_tipList$_, 
                t = t.replace(i, s), a = null, l = null), this._$_needsLineBreakConversion$_ && (t = t.replace(e, "<br>")), 
                this._$_htmlstr$_ = t;
            }
            return this._$_htmlstr$_;
        }
        _$attachLinkHandlers$_(i) {
            if (this._$_linkActions$_.length) for (let t = 0, s = this._$_linkActions$_.length; t < s; ++t) {
                const e = this._$_linkActions$_[t];
                if ("function" == typeof e) {
                    const h = i.querySelector(".bblink" + t);
                    if (!h) throw new Error("unable to attach BBString link handler");
                    h.onclick = e;
                }
            }
        }
        equals(t) {
            return t instanceof f.HtmlString ? this._$toHTML$_() === t._$toHTML$_() : t instanceof f._$BBString$_ ? this._$_bbstr$_ === t._$_bbstr$_ : this._$_bbstr$_ === t;
        }
        _$toFragmentList$_() {
            if (!this._$_hasParsedFragments$_) {
                let e = [], t = this._$_bbstr$_, h = [], s = p.lastIndex = 0, i;
                for (;null !== (i = p.exec(t)); ) {
                    const r = i.index;
                    if (!(0 < r && "\\" === t.charAt(r - 1))) {
                        const n = i[0], o = i[1], a = i[2], l = t.substring(s, r);
                        if (s = r + n.length, l && e.push({
                            text: l,
                            _$styles$_: h.slice(0)
                        }), a) if (o) {
                            const u = a.toLowerCase();
                            for (let t = h.length - 1; 0 <= t; --t) if (h[t].tag === u) {
                                h.splice(t, 1);
                                break;
                            }
                        } else {
                            let t = a, s = null, i = a.indexOf("=");
                            if (-1 !== i ? (t = a.substring(0, i).toLowerCase(), 
                            s = a.substring(i + 1)) : t = t.toLowerCase(), d.has(t)) {
                                if ("icon" !== t) throw new Error("unknown self-closing tag " + t);
                                e.push({
                                    icon: s,
                                    _$styles$_: h.slice(0)
                                });
                            } else h.push({
                                tag: t,
                                param: s
                            });
                        }
                    }
                }
                s < t.length && e.push({
                    text: t.substring(s),
                    _$styles$_: h.slice(0)
                });
                for (const c of e) c.text && (c.text = this._$_ProcessBBCodeEscapeSequences$_(c.text));
                this._$_fragments$_ = e.map(t => t.icon ? f._$New$_(f._$IconFragment$_, {
                    icon: t.icon,
                    _$styles$_: t._$styles$_
                }) : f._$New$_(f._$TextFragment$_, {
                    _$chArr$_: f._$SplitGraphemes$_(t.text),
                    _$styles$_: t._$styles$_
                })), this._$_hasParsedFragments$_ = !0;
            }
            return this._$_fragments$_;
        }
        _$_ProcessBBCodeEscapeSequences$_(t) {
            return t = f._$ReplaceAll$_(t, "\\[", "["), f._$ReplaceAll$_(t, "\\\\", "\\");
        }
        static _$StripTags$_(t) {
            return f._$New$_(f._$BBString$_, t, {
                _$noEscape$_: !0
            })._$toPlainText$_();
        }
        static _$StripAnyTags$_(t) {
            return t.replace(p, "");
        }
    };
}

{
    let l = function(t) {
        return "" !== t && "" !== t && w._$IsWhitespaceChar$_(t);
    }, a = function(t) {
        return xs.has(t);
    }, u = function(t) {
        return w._$IsCJKPunctuationChar$_(t) && !a(t);
    }, c = function(t) {
        for (;0 < t.length && l(t.at(-1)); ) t.pop();
    }, y = function(t) {
        return "\n" === t || "\r\n" === t;
    };
    l, a, u, c, y;
    const w = self._$C3$_, xs = new Set("");
    w._$WordWrap$_ = class {
        constructor() {
            this._$_lines$_ = [], this._$_iconSet$_ = null;
        }
        _$GetLines$_() {
            return this._$_lines$_;
        }
        _$GetLineCount$_() {
            return this._$_lines$_.length;
        }
        _$SetIconSet$_(t) {
            this._$_iconSet$_ = t;
        }
        _$_MeasureLine$_(t, s) {
            let i = 0, e = 0, h = 0, r = 0, n = 0;
            for (const o of t) {
                if (-1 === o._$GetWidth$_()) {
                    const a = s(o);
                    o._$SetHeight$_(a.height), o._$SetFontBoundingBoxAscent$_(a.fontBoundingBoxAscent || 0), 
                    o._$SetFontBoundingBoxDescent$_(a.fontBoundingBoxDescent || 0), 
                    o._$SetTopToAlphabeticDistance$_(a._$topToAlphabeticDistance$_ || 0), 
                    o._$IsText$_() ? o._$SetWidth$_(a.width) : o._$IsIcon$_() && o._$CalculateWidthFromHeight$_(this._$_iconSet$_);
                }
                i += o._$GetWidth$_(), e = Math.max(e, o._$GetHeight$_()), h = Math.max(h, o._$GetFontBoundingBoxAscent$_()), 
                r = Math.max(r, o._$GetFontBoundingBoxDescent$_()), n = Math.max(n, o._$GetTopToAlphabeticDistance$_());
            }
            return {
                width: i,
                height: e,
                fontBoundingBoxAscent: h,
                fontBoundingBoxDescent: r,
                _$topToAlphabeticDistance$_: n
            };
        }
        _$_AddLine$_(t, s, i, e, h, r) {
            this._$_lines$_.push(w._$New$_(w._$WordWrap$_._$Line$_, {
                _$fragments$_: t,
                width: s,
                height: i,
                fontBoundingBoxAscent: e,
                fontBoundingBoxDescent: h,
                _$topToAlphabeticDistance$_: r
            }));
        }
        _$WordWrap$_(s, r, n, i, o) {
            if ("string" == typeof s && (s = [ w._$New$_(w._$TextFragment$_, {
                _$chArr$_: w._$SplitGraphemes$_(s)
            }) ]), w._$clearArray$_(this._$_lines$_), !(!s.length || 1 === s.length && s[0]._$IsText$_() && s[0]._$IsEmpty$_() || n < 2)) {
                if (1 === s.length) {
                    const a = s[0];
                    if (a._$IsText$_() && a._$GetLength$_() <= 100 && !a._$HasNewLine$_()) {
                        let {
                            width: t,
                            height: s,
                            fontBoundingBoxAscent: i,
                            fontBoundingBoxDescent: e,
                            _$topToAlphabeticDistance$_: h
                        } = r(a);
                        if (t += o, a._$SetWidth$_(t), a._$SetHeight$_(s), a._$SetFontBoundingBoxAscent$_(i || 0), 
                        a._$SetFontBoundingBoxDescent$_(e || 0), a._$SetTopToAlphabeticDistance$_(h || 0), 
                        t <= n) return void this._$_AddLine$_([ a ], t, s, i, e, h);
                    }
                }
                let t;
                t = "word" === i ? this._$_TokeniseByWord$_(s) : "cjk" === i ? this._$_TokeniseByCJK$_(s) : this._$_TokeniseByChar$_(s), 
                this._$_WrapText$_(t, r, n, o);
            }
        }
        _$_TokeniseByWord$_(t) {
            let s = [], i = [], e = !1;
            for (const h of t) {
                const r = h._$GetStyles$_();
                if (h._$IsIcon$_()) 0 < i.length && s.push(i), s.push([ h ]), i = []; else for (const n of h._$GetCharacterArray$_()) if (y(n)) 0 < i.length && s.push(i), 
                s.push([ w._$New$_(w._$TextFragment$_, {
                    _$chArr$_: [ "\n" ],
                    _$styles$_: r
                }) ]), i = []; else if (0 === i.length) i.push(w._$New$_(w._$TextFragment$_, {
                    _$chArr$_: [ n ],
                    _$styles$_: r
                })), e = l(n); else {
                    const o = l(n);
                    if (o === e) {
                        const a = i.at(-1);
                        a._$GetStyles$_() === r ? a._$_AppendChar$_(n) : i.push(w._$New$_(w._$TextFragment$_, {
                            _$chArr$_: [ n ],
                            _$styles$_: r
                        }));
                    } else s.push(i), i = [ w._$New$_(w._$TextFragment$_, {
                        _$chArr$_: [ n ],
                        _$styles$_: r
                    }) ], e = o;
                }
            }
            return 0 < i.length && s.push(i), s;
        }
        _$_TokeniseByCJK$_(t) {
            let s = [], i = [], e = !1;
            for (const h of t) {
                const r = h._$GetStyles$_();
                if (h._$IsIcon$_()) 0 < i.length && s.push(i), s.push([ h ]), i = []; else for (const n of h._$GetCharacterArray$_()) if (y(n)) 0 < i.length && s.push(i), 
                s.push([ w._$New$_(w._$TextFragment$_, {
                    _$chArr$_: [ "\n" ],
                    _$styles$_: r
                }) ]), i = []; else {
                    if (0 === i.length) i.push(w._$New$_(w._$TextFragment$_, {
                        _$chArr$_: [ n ],
                        _$styles$_: r
                    })); else if (e || u(n)) {
                        const o = i.at(-1);
                        o._$GetStyles$_() === r ? o._$_AppendChar$_(n) : i.push(w._$New$_(w._$TextFragment$_, {
                            _$chArr$_: [ n ],
                            _$styles$_: r
                        }));
                    } else s.push(i), i = [ w._$New$_(w._$TextFragment$_, {
                        _$chArr$_: [ n ],
                        _$styles$_: r
                    }) ];
                    e = a(n);
                }
            }
            return 0 < i.length && s.push(i), s;
        }
        _$_TokeniseByChar$_(t) {
            const s = [];
            for (const i of t) if (i._$IsText$_()) {
                const e = i._$GetCharacterArray$_();
                w._$appendArray$_(s, e.map(t => [ w._$New$_(w._$TextFragment$_, {
                    _$chArr$_: [ t ],
                    _$styles$_: i._$GetStyles$_()
                }) ]));
            } else s.push([ i ]);
            return s;
        }
        _$_CopyLine$_(t) {
            return t.map(t => t._$_Clone$_());
        }
        _$_AddWordToLine$_(s, i) {
            let t = s.length ? s.at(-1) : null, e = 0;
            t && t._$IsText$_() && i[0]._$IsText$_() && i[0]._$GetStyles$_() === t._$GetStyles$_() && (t._$_Append$_(i[0]._$GetCharacterArray$_()), 
            e = 1);
            for (let t = i.length; e < t; ++e) {
                const h = i[e];
                s.push(h._$_Clone$_());
            }
        }
        _$_WrapText$_(t, s, i, e) {
            let h = [], r = 0, n = 0, o = 0, a = 0, l = 0;
            for (const u of t) if (1 === u.length && u[0]._$IsText$_() && 1 === u[0]._$GetLength$_() && y(u[0]._$GetCharacterArray$_()[0])) {
                if (0 === n) {
                    const c = w._$New$_(w._$TextFragment$_, {
                        _$chArr$_: [ " " ],
                        _$styles$_: u[0]._$GetStyles$_()
                    }), f = s(c);
                    n = f.height, o = f.fontBoundingBoxAscent || 0, a = f.fontBoundingBoxDescent || 0, 
                    l = f._$topToAlphabeticDistance$_ || 0;
                }
                this._$_AddLine$_(h, r, n, o, a, l), h = [], r = 0, n = 0, o = 0, 
                a = 0, l = 0;
            } else {
                const d = this._$_CopyLine$_(h), p = (this._$_AddWordToLine$_(d, u), 
                this._$_MeasureLine$_(d, s)), m = p.width;
                if (i <= m) if (0 < h.length && this._$_AddLine$_(h, r, n, o, a, l), 
                h = [], u[0]._$IsText$_() && w._$IsCharArrayAllWhitespace$_(u[0]._$GetCharacterArray$_())) r = 0, 
                n = 0, o = 0, a = 0, l = 0; else {
                    this._$_AddWordToLine$_(h, u);
                    const g = this._$_MeasureLine$_(h, s);
                    r = g.width, n = g.height, o = g.fontBoundingBoxAscent, a = g.fontBoundingBoxDescent, 
                    l = g._$topToAlphabeticDistance$_;
                } else h = d, r = m, n = p.height, o = p.fontBoundingBoxAscent, 
                a = p.fontBoundingBoxDescent, l = p._$topToAlphabeticDistance$_;
            }
            0 < h.length && this._$_AddLine$_(h, r, n, o, a, l), this._$_TrimLinesTrailingWhitespace$_(s, e);
        }
        _$_TrimLinesTrailingWhitespace$_(s, i) {
            for (const e of this._$_lines$_) {
                const h = e._$_GetFragmentsArray$_();
                if (h.length) {
                    let t = h.at(-1);
                    if (t._$IsText$_()) {
                        const r = t._$GetCharacterArray$_(), n = r.slice(0);
                        if (c(n), 0 === n.length) e._$OffsetWidth$_(-t._$GetWidth$_()), 
                        h.pop(); else if (n.length < r.length) {
                            t._$SetCharacterArray$_(n);
                            const o = s(t).width, a = t._$GetWidth$_() - o;
                            t._$SetWidth$_(o), e._$OffsetWidth$_(-a);
                        }
                        0 !== i && 0 < h.length && ((t = h.at(-1))._$OffsetWidth$_(i), 
                        e._$OffsetWidth$_(i));
                    }
                }
            }
        }
        _$Clear$_() {
            w._$clearArray$_(this._$_lines$_);
        }
        _$GetMaxLineWidth$_() {
            return this._$_lines$_.reduce((t, s) => Math.max(t, s._$GetWidth$_()), 0);
        }
        _$GetTotalLineHeight$_() {
            return this._$_lines$_.reduce((t, s) => t + s._$GetHeight$_(), 0);
        }
    };
}

{
    const Gs = self._$C3$_;
    Gs._$WordWrap$_._$Line$_ = class {
        constructor(t) {
            this._$_fragments$_ = t._$fragments$_ || [], this._$_width$_ = t.width || -1, 
            this._$_height$_ = t.height || -1, this._$_fontBoundingBoxAscent$_ = t.fontBoundingBoxAscent || -1, 
            this._$_fontBoundingBoxDescent$_ = t.fontBoundingBoxDescent || -1, this._$_topToAlphabeticDistance$_ = t._$topToAlphabeticDistance$_ || -1, 
            this._$_posX$_ = 0, this._$_posY$_ = 0;
        }
        _$fragments$_() {
            return this._$_fragments$_.values();
        }
        *_$fragmentsReverse$_() {
            const s = this._$_fragments$_;
            for (let t = s.length - 1; 0 <= t; --t) yield s[t];
        }
        _$_GetFragmentsArray$_() {
            return this._$_fragments$_;
        }
        _$OffsetWidth$_(t) {
            this._$_width$_ += t;
        }
        _$GetWidth$_() {
            return this._$_width$_;
        }
        _$GetHeight$_() {
            return this._$_height$_;
        }
        _$GetFoundBoundingBoxAscent$_() {
            return this._$_fontBoundingBoxAscent$_;
        }
        _$GetFontBoundingBoxDescent$_() {
            return this._$_fontBoundingBoxDescent$_;
        }
        _$GetTopToAlphabeticDistance$_() {
            return this._$_topToAlphabeticDistance$_;
        }
        _$SetPosX$_(t) {
            this._$_posX$_ = t;
        }
        _$GetPosX$_() {
            return this._$_posX$_;
        }
        _$SetPosY$_(t) {
            this._$_posY$_ = t;
        }
        _$GetPosY$_() {
            return this._$_posY$_;
        }
    };
}

{
    const Ts = self._$C3$_;
    Ts._$FragmentBase$_ = class {
        constructor(t) {
            this._$_styles$_ = t._$styles$_ || [], this._$_width$_ = t.width || -1, 
            this._$_height$_ = t.height || -1, this._$_fontBoundingBoxAscent$_ = t.fontBoundingBoxAscent || -1, 
            this._$_fontBoundingBoxDescent$_ = t.fontBoundingBoxDescent || -1, this._$_topToAlphabeticDistance$_ = t._$topToAlphabeticDistance$_ || -1, 
            this._$_posX$_ = 0, this._$_posY$_ = 0;
        }
        _$IsText$_() {
            return !1;
        }
        _$IsIcon$_() {
            return !1;
        }
        _$GetStyles$_() {
            return this._$_styles$_;
        }
        _$GetStyleTag$_(s) {
            const i = this._$_styles$_;
            for (let t = i.length - 1; 0 <= t; --t) {
                const e = i[t];
                if (e.tag === s) return e;
            }
            return null;
        }
        _$HasStyleTag$_(t) {
            return !!this._$GetStyleTag$_(t);
        }
        _$GetStyleMap$_() {
            const t = new Map();
            for (const s of this._$_styles$_) t.set(s.tag, s.param);
            return t;
        }
        _$OffsetWidth$_(t) {
            this._$_width$_ += t;
        }
        _$SetWidth$_(t) {
            this._$_width$_ = t;
        }
        _$GetWidth$_() {
            return this._$_width$_;
        }
        _$SetHeight$_(t) {
            this._$_height$_ = t;
        }
        _$GetHeight$_() {
            return this._$_height$_;
        }
        _$SetFontBoundingBoxAscent$_(t) {
            this._$_fontBoundingBoxAscent$_ = t;
        }
        _$GetFontBoundingBoxAscent$_() {
            return this._$_fontBoundingBoxAscent$_;
        }
        _$SetFontBoundingBoxDescent$_(t) {
            this._$_fontBoundingBoxDescent$_ = t;
        }
        _$GetFontBoundingBoxDescent$_() {
            return this._$_fontBoundingBoxDescent$_;
        }
        _$SetTopToAlphabeticDistance$_(t) {
            this._$_topToAlphabeticDistance$_ = t;
        }
        _$GetTopToAlphabeticDistance$_() {
            return this._$_topToAlphabeticDistance$_;
        }
        _$SetPosX$_(t) {
            this._$_posX$_ = t;
        }
        _$GetPosX$_() {
            return this._$_posX$_;
        }
        _$SetPosY$_(t) {
            this._$_posY$_ = t;
        }
        _$GetPosY$_() {
            return this._$_posY$_;
        }
    };
}

{
    const _s = self._$C3$_;
    _s._$TextFragment$_ = class extends _s._$FragmentBase$_ {
        constructor(t) {
            super(t), this._$_chArr$_ = t._$chArr$_;
        }
        _$IsText$_() {
            return !0;
        }
        _$_Append$_(t) {
            _s._$appendArray$_(this._$_chArr$_, t), this._$_width$_ = -1, this._$_height$_ = -1, 
            this._$_fontBoundingBoxAscent$_ = -1, this._$_fontBoundingBoxDescent$_ = -1, 
            this._$_topToAlphabeticDistance$_ = -1;
        }
        _$_AppendChar$_(t) {
            this._$_chArr$_.push(t);
        }
        _$_Clone$_() {
            return _s._$New$_(_s._$TextFragment$_, {
                _$chArr$_: this._$_chArr$_.slice(0),
                _$styles$_: this._$_styles$_,
                width: this._$_width$_,
                height: this._$_height$_,
                fontBoundingBoxAscent: this._$_fontBoundingBoxAscent$_,
                fontBoundingBoxDescent: this._$_fontBoundingBoxDescent$_,
                _$topToAlphabeticDistance$_: this._$_topToAlphabeticDistance$_
            });
        }
        _$GetCharacterArray$_() {
            return this._$_chArr$_;
        }
        _$SetCharacterArray$_(t) {
            this._$_chArr$_ = t;
        }
        _$GetLength$_() {
            return this._$_chArr$_.length;
        }
        _$IsEmpty$_() {
            return 0 === this._$_chArr$_.length;
        }
        _$HasNewLine$_() {
            return this._$_chArr$_.includes("\n");
        }
    };
}

{
    const Is = self._$C3$_;
    Is._$IconFragment$_ = class extends Is._$FragmentBase$_ {
        constructor(t) {
            super(t), this._$_icon$_ = t.icon;
        }
        _$IsIcon$_() {
            return !0;
        }
        _$GetIconParameter$_() {
            return this._$_icon$_;
        }
        _$_Clone$_() {
            return Is._$New$_(Is._$IconFragment$_, {
                icon: this._$_icon$_,
                _$styles$_: this._$_styles$_,
                width: this._$_width$_,
                height: this._$_height$_,
                fontBoundingBoxAscent: this._$_fontBoundingBoxAscent$_,
                fontBoundingBoxDescent: this._$_fontBoundingBoxDescent$_,
                _$topToAlphabeticDistance$_: this._$_topToAlphabeticDistance$_
            });
        }
        _$GetTextIcon$_(t) {
            if (!t) return null;
            let s = Number(this._$_icon$_);
            return String(s) === this._$_icon$_ ? (s = Math.floor(s), t._$GetTextIconByIndex$_(s)) : t._$GetTextIconByTag$_(this._$_icon$_);
        }
        _$CalculateWidthFromHeight$_(t) {
            const s = this._$GetTextIcon$_(t);
            this._$_width$_ = s ? this._$_height$_ * s._$GetWidth$_() / s._$GetHeight$_() : 0;
        }
        _$GetDrawable$_(t) {
            const s = this._$GetTextIcon$_(t);
            return s ? s._$GetDrawable$_() : null;
        }
        _$GetLength$_() {
            return 1;
        }
    };
}

{
    const Cs = self._$C3$_;
    Cs._$TextIconManager$_ = class {
        constructor(t) {
            this._$_iconSets$_ = new Map(), this._$_getIconSetMetaCallback$_ = t._$getIconSetMeta$_, 
            this._$_getIconSetContentCallback$_ = t._$getIconSetContent$_;
        }
        _$Release$_() {
            for (const t of this._$_iconSets$_.values()) t._$Release$_();
            this._$_iconSets$_.clear();
        }
        _$GetIconSet$_(t) {
            let s = this._$_iconSets$_.get(t);
            if (!s) {
                const i = this._$_getIconSetMetaCallback$_(t);
                s = Cs._$New$_(Cs._$TextIconSet$_, this, {
                    source: t,
                    _$iconMeta$_: i
                }), this._$_iconSets$_.set(t, s);
            }
            return s;
        }
        _$HasIconSet$_(t) {
            return this._$_iconSets$_.has(t);
        }
        _$DeleteIconSet$_(t) {
            const s = this._$_iconSets$_.get(t);
            s && s._$Release$_(), this._$_iconSets$_.delete(t);
        }
        async _$_GetIconSetContent$_(t) {
            return this._$_getIconSetContentCallback$_(t);
        }
    };
}

{
    const Rs = self._$C3$_;
    Rs._$TextIconSet$_ = class {
        constructor(t, s) {
            this._$_textIconManager$_ = t, this._$_source$_ = s.source, this._$_iconsArray$_ = [], 
            this._$_iconsByTag$_ = new Map(), this._$_hasStartedLoad$_ = !1, this._$_isLoading$_ = !1, 
            this._$_loadPromise$_ = null;
            const i = s._$iconMeta$_._$icons$_;
            for (let t = 0, s = i.length; t < s; ++t) {
                const e = i[t], h = Rs._$New$_(Rs._$TextIcon$_, this, {
                    index: t,
                    tag: e.tag,
                    source: e.source,
                    width: e.width,
                    height: e.height
                });
                this._$_iconsArray$_.push(h), e.tag && this._$_iconsByTag$_.set(e.tag.toLowerCase(), h);
            }
        }
        _$Release$_() {
            for (const t of this._$_iconsArray$_) t._$Release$_();
            Rs._$clearArray$_(this._$_iconsArray$_), this._$_iconsByTag$_.clear(), 
            this._$_textIconManager$_ = null, this._$_source$_ = null;
        }
        _$HasLoaded$_() {
            return this._$_hasStartedLoad$_;
        }
        _$IsLoading$_() {
            return this._$_isLoading$_;
        }
        _$LoadContent$_() {
            return this._$_loadPromise$_ || (this._$_loadPromise$_ = this._$_DoLoadContent$_()), 
            this._$_loadPromise$_;
        }
        async _$_DoLoadContent$_() {
            if (!this._$_hasStartedLoad$_) {
                this._$_hasStartedLoad$_ = !0, this._$_isLoading$_ = !0;
                const t = await this._$_textIconManager$_._$_GetIconSetContent$_(this._$_source$_);
                if (this._$_textIconManager$_) {
                    const i = t._$icons$_;
                    for (let t = 0, s = Math.min(i.length, this._$_iconsArray$_.length); t < s; ++t) {
                        const e = i[t]._$drawable$_;
                        this._$_iconsArray$_[t]._$_SetDrawable$_(e);
                    }
                    this._$_isLoading$_ = !1;
                }
            }
        }
        _$GetTextIconByIndex$_(t) {
            return (t = Math.floor(t)) < 0 || t >= this._$_iconsArray$_.length ? null : this._$_iconsArray$_[t];
        }
        _$GetTextIconByTag$_(t) {
            return this._$_iconsByTag$_.get(t.toLowerCase()) || null;
        }
    };
}

{
    const Ps = self._$C3$_;
    Ps._$TextIcon$_ = class {
        constructor(t, s) {
            this._$_textIconSet$_ = t, this._$_source$_ = s.source || null, this._$_index$_ = s.index, 
            this._$_tag$_ = s.tag, this._$_width$_ = s.width, this._$_height$_ = s.height, 
            this._$_drawable$_ = null;
        }
        _$Release$_() {
            this._$_width$_ = 0, this._$_height$_ = 0, this._$_textIconSet$_ = null;
        }
        _$GetSource$_() {
            return this._$_source$_;
        }
        _$GetWidth$_() {
            return this._$_width$_;
        }
        _$GetHeight$_() {
            return this._$_height$_;
        }
        _$_SetDrawable$_(t) {
            this._$_drawable$_ = t;
        }
        _$GetDrawable$_() {
            return this._$_drawable$_;
        }
    };
}

{
    let e = function(t, s, i, e) {
        const h = Ds;
        Gh._$subtract$_(Fs, i, s), Gh._$subtract$_(Os, t, s), Gh._$cross$_(h, Fs, Os), 
        Gh.normalize(h, h), e.set(h[0], h[1], h[2], Gh._$dot$_(t, h));
    }, n = function(t, s, i, e, h, r, n) {
        const o = n.x, a = n.y, l = n.z, u = n.w, c = n._$xF$_, f = n._$yF$_, d = n._$zF$_, p = 1 - c, m = 1 - f, g = 1 - d, y = o * t * c + o * e * p + a * s * f + a * h * m + l * i * d + l * r * g;
        if (u <= y) return !0;
        const w = o * e * c + o * t * p + a * h * f + a * s * m + l * r * d + l * i * g;
        return u < w;
    }, h = function(t, s, i, e) {
        const h = e.x, r = e.y, n = e.z, o = e.w, a = h * t + r * s + n * i;
        return o <= a;
    };
    e, n, h;
    const Es = self._$C3$_, As = self._$glMatrix$_, Gh = As._$vec3$_, Vh = As._$vec4$_, xh = As._$mat4$_, Fs = Gh.create(), Os = Gh.create(), Ds = Gh.create(), ks = Vh.create(), Ls = xh.create(), Bs = Gh.create(), Ns = Gh.create(), Ws = Gh.create(), js = Gh.create(), Vs = Gh.create(), Us = Gh.create(), Hs = Gh.create(), zs = Gh.create(), Js = Vh._$fromValues$_(0, 0, 1, 1);
    Es._$Gfx$_ = {
        _$Project$_(t, s, i, e, h, r, n) {
            let o = e[0] * t + e[4] * s + e[8] * i + e[12], a = e[1] * t + e[5] * s + e[9] * i + e[13], l = e[2] * t + e[6] * s + e[10] * i + e[14], u = e[3] * t + e[7] * s + e[11] * i + e[15], c = h[0] * o + h[4] * a + h[8] * l + h[12] * u, f = h[1] * o + h[5] * a + h[9] * l + h[13] * u, d = h[2] * o + h[6] * a + h[10] * l + h[14] * u, p = h[3] * o + h[7] * a + h[11] * l + h[15] * u;
            return 0 != p && (f *= p = 1 / p, d *= p, n[0] = (.5 * (c *= p) + .5) * r[2] + r[0], 
            n[1] = (.5 * f + .5) * r[3] + r[1], n[2] = .5 * (1 + d), !0);
        },
        _$Unproject$_(t, s, i, e, h, r, n) {
            const o = Ls, a = ks;
            return xh.multiply(o, h, e), null !== xh._$invert$_(o, o) && (a[0] = (t - r[0]) / r[2] * 2 - 1, 
            a[1] = (s - r[1]) / r[3] * 2 - 1, a[2] = 2 * i - 1, a[3] = 1, Vh._$transformMat4$_(a, a, o), 
            0 !== a[3]) && (a[3] = 1 / a[3], n[0] = a[0] * a[3], n[1] = a[1] * a[3], 
            n[2] = a[2] * a[3], !0);
        },
        _$UnprojectScreenToWorldZ$_(t, s, i, e, h, r, n) {
            const o = Fs, a = Os;
            if (!Es._$Gfx$_._$Unproject$_(t, s, 0, e, h, r, o)) return !1;
            if (!Es._$Gfx$_._$Unproject$_(t, s, 1, e, h, r, a)) return !1;
            let l = Os, u = (Gh._$subtract$_(l, a, o), Ds), c = (Gh.set(u, 0, 0, 1), 
            -i), f = Gh._$dot$_(u, l), d = 0;
            if (0 === f) {
                const p = Gh._$dot$_(u, o) + c;
                if (0 !== p) return !1;
            } else if ((d = -(Gh._$dot$_(o, u) + c) / f) < 0) return !1;
            return Gh._$scaleAndAdd$_(n, o, l, d), !0;
        }
    };
    class qs {
        constructor() {
            this.x = NaN, this.y = NaN, this.z = NaN, this.w = NaN, this._$xF$_ = NaN, 
            this._$yF$_ = NaN, this._$zF$_ = NaN;
        }
        set(t, s, i, e) {
            this.x = t, this.y = s, this.z = i, this.w = e, this._$xF$_ = 0 < t ? 1 : 0, 
            this._$yF$_ = 0 < s ? 1 : 0, this._$zF$_ = 0 < i ? 1 : 0;
        }
    }
    Es._$Gfx$_._$ViewFrustum$_ = class {
        constructor() {
            this._$_leftP$_ = new qs(), this._$_topP$_ = new qs(), this._$_rightP$_ = new qs(), 
            this._$_bottomP$_ = new qs(), this._$_nearP$_ = new qs(), this._$_farP$_ = new qs();
        }
        _$CalculatePlanes$_(t, s) {
            const i = Js;
            Es._$Gfx$_._$Unproject$_(0, 1, 0, t, s, i, Bs), Es._$Gfx$_._$Unproject$_(1, 1, 0, t, s, i, Ns), 
            Es._$Gfx$_._$Unproject$_(0, 0, 0, t, s, i, Ws), Es._$Gfx$_._$Unproject$_(1, 0, 0, t, s, i, js), 
            Es._$Gfx$_._$Unproject$_(0, 1, 1, t, s, i, Vs), Es._$Gfx$_._$Unproject$_(1, 1, 1, t, s, i, Us), 
            Es._$Gfx$_._$Unproject$_(0, 0, 1, t, s, i, Hs), Es._$Gfx$_._$Unproject$_(1, 0, 1, t, s, i, zs), 
            e(Ws, Bs, Vs, this._$_leftP$_), e(Bs, Ns, Us, this._$_topP$_), e(Ns, js, zs, this._$_rightP$_), 
            e(js, Ws, Hs, this._$_bottomP$_), e(Hs, Vs, Us, this._$_farP$_), e(js, Ns, Bs, this._$_nearP$_);
        }
        _$ContainsAABB$_(t, s, i, e, h, r) {
            return n(t, s, i, e, h, r, this._$_leftP$_) && n(t, s, i, e, h, r, this._$_topP$_) && n(t, s, i, e, h, r, this._$_rightP$_) && n(t, s, i, e, h, r, this._$_bottomP$_) && n(t, s, i, e, h, r, this._$_nearP$_) && n(t, s, i, e, h, r, this._$_farP$_);
        }
        _$IsBehindNearPlane$_(t, s, i) {
            return !h(t, s, i, this._$_nearP$_);
        }
    };
}

{
    const Xs = self._$C3$_, Ys = self._$glMatrix$_, Gh = Ys._$vec3$_, Vh = Ys._$vec4$_, xh = Ys._$mat4$_, $s = xh.create(), Ks = Gh._$fromValues$_(0, 0, 0), Zs = Gh._$fromValues$_(0, 0, 0), Qs = Gh._$fromValues$_(0, 0, 0), ti = Gh._$fromValues$_(0, 1, 0), si = (Vh._$fromValues$_(0, 0, 0, 0), 
    new Xs._$Quad$_()), ii = new Xs.Rect(), ei = new Xs._$Quad$_(0, 0, 1, 0, 1, 1, 0, 1), hi = {
        _$nearZ$_: 1,
        _$farZ$_: 1e4
    }, ri = xh._$fromValues$_(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, .5, 0, 0, 0, .5, 1);
    Xs._$Gfx$_._$RendererBase$_ = class {
        constructor(t) {
            t = Object.assign({}, hi, t), this._$_width$_ = 0, this._$_height$_ = 0, 
            this._$_fovY$_ = Xs._$toRadians$_(45), this._$_tan_fovY_2$_ = Math.tan(this._$_fovY$_ / 2), 
            this._$_matP$_ = xh.create(), this._$_matMV$_ = xh.create(), this._$_zAxisScale$_ = !1, 
            this._$_nearZ$_ = t._$nearZ$_, this._$_farZ$_ = t._$farZ$_, this._$_allShaderPrograms$_ = [], 
            this._$_shaderProgramsByName$_ = new Map(), this._$_spTextureFill$_ = null, 
            this._$_spPoints$_ = null, this._$_spTilemapFill$_ = null, this._$_spTileRandomization$_ = null, 
            this._$_spColorFill$_ = null, this._$_spLinearGradientFill$_ = null, 
            this._$_spPenumbraFill$_ = null, this._$_spHardEllipseFill$_ = null, 
            this._$_spHardEllipseOutline$_ = null, this._$_spSmoothEllipseFill$_ = null, 
            this._$_spSmoothEllipseOutline$_ = null, this._$_spSmoothLineFill$_ = null, 
            this._$_stateGroups$_ = new Map(), this._$_currentStateGroup$_ = null, 
            this._$_blendModeTable$_ = [], this._$_namedBlendModeMap$_ = new Map(), 
            this._$_baseZ$_ = 0, this._$_currentZ$_ = 0, this._$_lineWidth$_ = 1, 
            this._$_lineWidthStack$_ = [ this._$_lineWidth$_ ], this._$_lineCap$_ = 1, 
            this._$_lineCapStack$_ = [ this._$_lineCap$_ ], this._$_lineOffset$_ = .5, 
            this._$_lineOffsetStack$_ = [ this._$_lineOffset$_ ], this._$_frameNumber$_ = 0, 
            this._$_enableMipmaps$_ = !0, this._$_hasMajorPerformanceCaveat$_ = !1;
        }
        _$FillIndexBufferData$_(t) {
            let s = 0, i = t.length, e = 0;
            for (;s < i; ) t[s++] = e, t[s++] = e + 1, t[s++] = e + 2, t[s++] = e, 
            t[s++] = e + 2, t[s++] = e + 3, e += 4;
        }
        _$_ClearState$_() {
            this._$_baseZ$_ = 0, this._$_currentZ$_ = 0, this._$_spTextureFill$_ = null, 
            this._$_spPoints$_ = null, this._$_spTilemapFill$_ = null, this._$_spTileRandomization$_ = null, 
            this._$_spColorFill$_ = null, this._$_spLinearGradientFill$_ = null, 
            this._$_spPenumbraFill$_ = null, this._$_spHardEllipseFill$_ = null, 
            this._$_spHardEllipseOutline$_ = null, this._$_spSmoothEllipseFill$_ = null, 
            this._$_spSmoothEllipseOutline$_ = null, this._$_spSmoothLineFill$_ = null, 
            this._$_ClearAllShaderPrograms$_();
        }
        _$InitState$_() {
            this._$_ClearState$_(), this._$_currentStateGroup$_ = null;
        }
        _$OnDeviceOrContextLost$_() {
            for (const t of this._$_allShaderPrograms$_) t._$Release$_();
            this._$_ClearState$_();
        }
        _$GetWidth$_() {
            return this._$_width$_;
        }
        _$GetHeight$_() {
            return this._$_height$_;
        }
        _$GetDefaultCameraZ$_(t) {
            return this._$IsZAxisScaleNormalized$_() ? 100 : t / (2 * this._$_GetTanFovYDiv2$_());
        }
        _$GetZAxisScaleFactor$_(t) {
            if (this._$IsZAxisScaleNormalized$_()) {
                const s = t / (2 * this._$_GetTanFovYDiv2$_());
                return s / this._$GetDefaultCameraZ$_(t);
            }
            return 1;
        }
        _$SetNearZ$_(t) {
            this._$_nearZ$_ = t;
        }
        _$GetNearZ$_() {
            return this._$_nearZ$_;
        }
        _$SetFarZ$_(t) {
            this._$_farZ$_ = t;
        }
        _$GetFarZ$_() {
            return this._$_farZ$_;
        }
        _$SetFovY$_(t) {
            this._$_fovY$_ = t, this._$_tan_fovY_2$_ = Math.tan(this._$_fovY$_ / 2);
        }
        _$GetFovY$_() {
            return this._$_fovY$_;
        }
        _$_GetTanFovYDiv2$_() {
            return this._$_tan_fovY_2$_;
        }
        _$SetZAxisScaleNormalized$_() {
            this._$_zAxisScale$_ = !1;
        }
        _$SetZAxisScaleRegular$_() {
            this._$_zAxisScale$_ = !0;
        }
        _$IsZAxisScaleNormalized$_() {
            return !this._$_zAxisScale$_;
        }
        _$IsZAxisScaleRegular$_() {
            return this._$_zAxisScale$_;
        }
        _$CalculatePerspectiveMatrix$_(t, s, i = .5, e = .5) {
            const h = this._$GetNearZ$_(), r = this._$GetFarZ$_(), n = this._$GetFovY$_();
            if (.5 === i && .5 === e) this._$IsWebGPU$_() ? xh._$perspectiveZO$_(t, n, s, h, r) : xh.perspective(t, n, s, h, r); else {
                const o = 2 * (i = 1 - i) - 2, a = 2 * i, l = 2 * e - 2, u = 2 * e, c = this._$_GetTanFovYDiv2$_() * h, f = c * s;
                xh._$frustum$_(t, o * f, a * f, l * c, u * c, h, r), this._$IsWebGPU$_() && xh.mul(t, ri, t);
            }
        }
        _$CalculateOrthographicMatrix$_(t, s, i, e = 1) {
            const h = self.devicePixelRatio, r = 2 * this._$GetDefaultCameraZ$_(i) * h * this._$_GetTanFovYDiv2$_() / i, n = s * r / (2 * h * e), o = i * r / (2 * h * e), a = -n, l = n, u = -o, c = o;
            this._$IsWebGPU$_() ? xh._$orthoZO$_(t, a, l, u, c, this._$GetNearZ$_(), this._$GetFarZ$_()) : xh.ortho(t, a, l, u, c, this._$GetNearZ$_(), this._$GetFarZ$_());
        }
        _$CalculateLookAtModelView$_(t, s, i, e, h, r = 1) {
            let n = 1;
            this._$IsZAxisScaleNormalized$_() && (n = 200 * this._$_GetTanFovYDiv2$_() / h);
            const o = Qs, a = (Gh.set(o, n, -n, 1), Ks), l = Zs;
            Gh.multiply(a, s, o), Gh.multiply(l, i, o), xh._$lookAt$_(t, a, l, e || ti), 
            o[2] = r, xh.scale(t, t, o);
        }
        _$CalculateLookAtModelView2$_(t, s, i, e, h, r, n, o) {
            return Gh.set(Ks, t, s, i), Gh.set(Zs, e, h, r), this._$CalculateLookAtModelView$_($s, Ks, Zs, ti, n, o), 
            $s;
        }
        _$_AddShaderProgram$_(t) {
            this._$_allShaderPrograms$_.push(t), this._$_shaderProgramsByName$_.set(t._$GetName$_(), t);
        }
        _$_RemoveShaderProgram$_(t) {
            const s = this._$_allShaderPrograms$_.indexOf(t);
            -1 !== s && this._$_allShaderPrograms$_.splice(s, 1), this._$_shaderProgramsByName$_.delete(t._$GetName$_());
        }
        _$_ClearAllShaderPrograms$_() {
            Xs._$clearArray$_(this._$_allShaderPrograms$_), this._$_shaderProgramsByName$_.clear();
        }
        _$GetShaderProgramByName$_(t) {
            return this._$_shaderProgramsByName$_.get(t) || null;
        }
        _$GetTextureFillShaderProgram$_() {
            return this._$_spTextureFill$_;
        }
        _$SetTextureFillMode$_() {
            this._$SetProgram$_(this._$_spTextureFill$_);
        }
        _$GetPointsRenderingProgram$_() {
            return this._$_spPoints$_;
        }
        _$SetPointsRenderingProgram$_() {
            this._$SetProgram$_(this._$_spPoints$_);
        }
        _$SetTilemapFillMode$_() {
            this._$SetProgram$_(this._$_spTilemapFill$_);
        }
        _$SetTileRandomizationMode$_() {
            this._$SetProgram$_(this._$_spTileRandomization$_);
        }
        _$SetColorFillMode$_() {
            this._$SetProgram$_(this._$_spColorFill$_);
        }
        _$SetLinearGradientFillMode$_() {
            this._$SetProgram$_(this._$_spLinearGradientFill$_);
        }
        _$SetPenumbraFillMode$_() {
            this._$SetProgram$_(this._$_spPenumbraFill$_);
        }
        _$SetHardEllipseFillMode$_() {
            this._$SetProgram$_(this._$_spHardEllipseFill$_);
        }
        _$SetHardEllipseOutlineMode$_() {
            this._$SetProgram$_(this._$_spHardEllipseOutline$_);
        }
        _$SetSmoothEllipseFillMode$_() {
            this._$SetProgram$_(this._$_spSmoothEllipseFill$_);
        }
        _$SetSmoothEllipseOutlineMode$_() {
            this._$SetProgram$_(this._$_spSmoothEllipseOutline$_);
        }
        _$SetSmoothLineFillMode$_() {
            this._$SetProgram$_(this._$_spSmoothLineFill$_);
        }
        _$_SetCurrentStateGroup$_(t) {
            this._$_currentStateGroup$_ = t;
        }
        _$GetCurrentStateGroup$_() {
            return this._$_currentStateGroup$_;
        }
        _$AcquireStateGroup$_(t, s, i, e) {
            let h = Xs._$Gfx$_._$StateGroup$_._$MakeKey$_(t, s, i, e), r = this._$_stateGroups$_.get(h);
            return r || (r = Xs._$New$_(Xs._$Gfx$_._$StateGroup$_, this, t, s, i, e), 
            this._$_stateGroups$_.set(h, r)), r._$AddRef$_(), r;
        }
        _$ReleaseStateGroup$_(t) {
            t._$DecRef$_(), 0 === t._$_GetRefCount$_() && (this._$_currentStateGroup$_ === t && (this._$_currentStateGroup$_ = null), 
            this._$_stateGroups$_.delete(t._$GetKey$_()), t._$Release$_());
        }
        _$_InitBlendModeData$_(t) {
            Xs._$clearArray$_(this._$_blendModeTable$_), this._$_namedBlendModeMap$_.clear();
            let s = 0;
            for (const i of t) {
                const e = i[0], h = i[1], r = i[2];
                this._$_blendModeTable$_.push([ h, r ]), this._$_namedBlendModeMap$_.set(e, {
                    number: s,
                    _$srcBlend$_: h,
                    _$destBlend$_: r
                }), s++;
            }
        }
        _$_GetBlendByIndex$_(t) {
            return this._$_blendModeTable$_[t];
        }
        _$GetSrcBlendByIndex$_(t) {
            return this._$_GetBlendByIndex$_(t)[0];
        }
        _$GetDestBlendByIndex$_(t) {
            return this._$_GetBlendByIndex$_(t)[1];
        }
        _$GetNamedBlend$_(t) {
            const s = this._$_namedBlendModeMap$_.get(t);
            if (void 0 === s) throw new Error("invalid blend name");
            return s;
        }
        _$NamedBlendToNumber$_(t) {
            const s = this._$_namedBlendModeMap$_.get(t);
            if (void 0 === s) throw new Error("invalid blend name");
            return s.number;
        }
        _$SetBaseZ$_(t) {
            this._$_baseZ$_ = t;
        }
        _$GetBaseZ$_() {
            return this._$_baseZ$_;
        }
        _$SetCurrentZ$_(t) {
            this._$_currentZ$_ = t, this._$_currentStateGroup$_ = null;
        }
        _$GetCurrentZ$_() {
            return this._$_currentZ$_;
        }
        _$Line$_(t, s, i, e) {
            const h = Xs._$angleTo$_(t, s, i, e), r = Math.sin(h), n = Math.cos(h), o = .5 * this._$_lineWidth$_, a = r * o, l = n * o, u = this._$_lineCap$_;
            2 === u ? this._$LinePreCalc_LineCap2$_(t, s, 0, i, e, 0, a, l) : 1 === u ? this._$LinePreCalc_LineCap1$_(t, s, 0, i, e, 0, a, l) : this._$LinePreCalc_LineCap0$_(t, s, 0, i, e, 0, a, l);
        }
        _$Line3D$_(t, s, i, e, h, r) {
            const n = Xs._$angleTo$_(t, s, e, h), o = Math.sin(n), a = Math.cos(n), l = .5 * this._$_lineWidth$_, u = o * l, c = a * l, f = this._$_lineCap$_;
            2 === f ? this._$LinePreCalc_LineCap2$_(t, s, i, e, h, r, u, c) : 1 === f ? this._$LinePreCalc_LineCap1$_(t, s, i, e, h, r, u, c) : this._$LinePreCalc_LineCap0$_(t, s, i, e, h, r, u, c);
        }
        _$LinePreCalc_LineCap2$_(t, s, i, e, h, r, n, o) {
            const a = this._$_lineOffset$_, l = t + a - o, u = s + a - n, c = e + a + o, f = h + a + n, d = 2 * o, p = 2 * n, m = l + n, g = u - o, y = l - n + d, w = u + o + p, S = c + n, b = f - o, M = c - n - d, v = f + o - p;
            this._$Quad3D2$_(m, g, i, S, b, r, M, v, r, y, w, i, ei);
        }
        _$LinePreCalc_LineCap1$_(t, s, i, e, h, r, n, o) {
            const a = this._$_lineOffset$_, l = t + a - o, u = s + a - n, c = e + a + o, f = h + a + n, d = l + n, p = u - o, m = l - n, g = u + o, y = c + n, w = f - o, S = c - n, b = f + o;
            this._$Quad3D2$_(d, p, i, y, w, r, S, b, r, m, g, i, ei);
        }
        _$LinePreCalc_LineCap0$_(t, s, i, e, h, r, n, o) {
            const a = this._$_lineOffset$_, l = t + a, u = s + a, c = e + a, f = h + a, d = l + n, p = u - o, m = l - n, g = u + o, y = c + n, w = f - o, S = c - n, b = f + o;
            this._$Quad3D2$_(d, p, i, y, w, r, S, b, r, m, g, i, ei);
        }
        _$TexturedLine$_(t, s, i, e, h, r) {
            const n = Xs._$angleTo$_(t, s, i, e), o = Math.sin(n), a = Math.cos(n), l = .5 * this._$_lineWidth$_, u = o * l, c = a * l, f = this._$_lineCap$_;
            2 === f ? this._$TexturedLinePreCalc_LineCap2$_(t, s, i, e, u, c, h, r) : 1 === f ? this._$TexturedLinePreCalc_LineCap1$_(t, s, i, e, u, c, h, r) : this._$TexturedLinePreCalc_LineCap0$_(t, s, i, e, u, c, h, r);
        }
        _$TexturedLinePreCalc_LineCap2$_(t, s, i, e, h, r, n, o) {
            const a = this._$_lineOffset$_, l = t + a - r, u = s + a - h, c = i + a + r, f = e + a + h, d = 2 * r, p = 2 * h, m = l + h, g = u - r, y = l - h + d, w = u + r + p, S = c + h, b = f - r, M = c - h - d, v = f + r - p;
            si.set(m, g, S, b, M, v, y, w), ii.set(n, 0, o, 0), this._$Quad3$_(si, ii);
        }
        _$TexturedLinePreCalc_LineCap1$_(t, s, i, e, h, r, n, o) {
            const a = this._$_lineOffset$_, l = t + a - r, u = s + a - h, c = i + a + r, f = e + a + h, d = l + h, p = u - r, m = l - h, g = u + r, y = c + h, w = f - r, S = c - h, b = f + r;
            si.set(d, p, y, w, S, b, m, g), ii.set(n, 0, o, 0), this._$Quad3$_(si, ii);
        }
        _$TexturedLinePreCalc_LineCap0$_(t, s, i, e, h, r, n, o) {
            const a = this._$_lineOffset$_, l = t + a, u = s + a, c = i + a, f = e + a, d = l + h, p = u - r, m = l - h, g = u + r, y = c + h, w = f - r, S = c - h, b = f + r;
            si.set(d, p, y, w, S, b, m, g), ii.set(n, 0, o, 0), this._$Quad3$_(si, ii);
        }
        _$LineRect$_(t, s, i, e) {
            const h = .5 * this._$_lineWidth$_, r = this._$_lineCap$_;
            2 === r ? this._$_LineRectPreCalc_LineCap2$_(t, s, i, e, h) : 1 === r ? this._$_LineRectPreCalc_LineCap1$_(t, s, i, e, h) : this._$_LineRectPreCalc_LineCap0$_(t, s, i, e, h);
        }
        _$_LineRectPreCalc_LineCap2$_(t, s, i, e, h) {
            this._$LinePreCalc_LineCap2$_(t, s, 0, i, s, 0, 0, h), this._$LinePreCalc_LineCap2$_(i, s, 0, i, e, 0, h, 0), 
            this._$LinePreCalc_LineCap2$_(i, e, 0, t, e, 0, 0, -h), this._$LinePreCalc_LineCap2$_(t, e, 0, t, s, 0, -h, 0);
        }
        _$_LineRectPreCalc_LineCap1$_(t, s, i, e, h) {
            this._$LinePreCalc_LineCap1$_(t, s, 0, i, s, 0, 0, h), this._$LinePreCalc_LineCap1$_(i, s, 0, i, e, 0, h, 0), 
            this._$LinePreCalc_LineCap1$_(i, e, 0, t, e, 0, 0, -h), this._$LinePreCalc_LineCap1$_(t, e, 0, t, s, 0, -h, 0);
        }
        _$_LineRectPreCalc_LineCap0$_(t, s, i, e, h) {
            this._$LinePreCalc_LineCap0$_(t, s, 0, i, s, 0, 0, h), this._$LinePreCalc_LineCap0$_(i, s, 0, i, e, 0, h, 0), 
            this._$LinePreCalc_LineCap0$_(i, e, 0, t, e, 0, 0, -h), this._$LinePreCalc_LineCap0$_(t, e, 0, t, s, 0, -h, 0);
        }
        _$LineRect2$_(t) {
            this._$LineRect$_(t._$getLeft$_(), t._$getTop$_(), t._$getRight$_(), t._$getBottom$_());
        }
        _$LineQuad$_(t) {
            const s = Xs._$angleTo$_(t._$getTlx$_(), t._$getTly$_(), t._$getTrx$_(), t._$getTry$_()), i = Math.sin(s), e = Math.cos(s), h = .5 * this._$_lineWidth$_, r = i * h, n = e * h, o = this._$_lineCap$_;
            2 === o ? this._$_LineQuadPreCalc_LineCap2$_(t, r, n) : 1 === o ? this._$_LineQuadPreCalc_LineCap1$_(t, r, n) : this._$_LineQuadPreCalc_LineCap0$_(t, r, n);
        }
        _$_LineQuadPreCalc_LineCap2$_(t, s, i) {
            this._$LinePreCalc_LineCap2$_(t._$getTlx$_(), t._$getTly$_(), 0, t._$getTrx$_(), t._$getTry$_(), 0, s, i), 
            this._$LinePreCalc_LineCap2$_(t._$getTrx$_(), t._$getTry$_(), 0, t._$getBrx$_(), t._$getBry$_(), 0, i, -s), 
            this._$LinePreCalc_LineCap2$_(t._$getBrx$_(), t._$getBry$_(), 0, t._$getBlx$_(), t._$getBly$_(), 0, -s, -i), 
            this._$LinePreCalc_LineCap2$_(t._$getBlx$_(), t._$getBly$_(), 0, t._$getTlx$_(), t._$getTly$_(), 0, -i, s);
        }
        _$_LineQuadPreCalc_LineCap1$_(t, s, i) {
            this._$LinePreCalc_LineCap1$_(t._$getTlx$_(), t._$getTly$_(), 0, t._$getTrx$_(), t._$getTry$_(), 0, s, i), 
            this._$LinePreCalc_LineCap1$_(t._$getTrx$_(), t._$getTry$_(), 0, t._$getBrx$_(), t._$getBry$_(), 0, i, -s), 
            this._$LinePreCalc_LineCap1$_(t._$getBrx$_(), t._$getBry$_(), 0, t._$getBlx$_(), t._$getBly$_(), 0, -s, -i), 
            this._$LinePreCalc_LineCap1$_(t._$getBlx$_(), t._$getBly$_(), 0, t._$getTlx$_(), t._$getTly$_(), 0, -i, s);
        }
        _$_LineQuadPreCalc_LineCap0$_(t, s, i) {
            this._$LinePreCalc_LineCap0$_(t._$getTlx$_(), t._$getTly$_(), 0, t._$getTrx$_(), t._$getTry$_(), 0, s, i), 
            this._$LinePreCalc_LineCap0$_(t._$getTrx$_(), t._$getTry$_(), 0, t._$getBrx$_(), t._$getBry$_(), 0, i, -s), 
            this._$LinePreCalc_LineCap0$_(t._$getBrx$_(), t._$getBry$_(), 0, t._$getBlx$_(), t._$getBly$_(), 0, -s, -i), 
            this._$LinePreCalc_LineCap0$_(t._$getBlx$_(), t._$getBly$_(), 0, t._$getTlx$_(), t._$getTly$_(), 0, -i, s);
        }
        _$SetLineWidth$_(t) {
            this._$_lineWidth$_ = t, this._$_lineWidthStack$_[this._$_lineWidthStack$_.length - 1] = t;
        }
        _$GetLineWidth$_() {
            return this._$_lineWidth$_;
        }
        _$PushLineWidth$_(t) {
            if (100 <= this._$_lineWidthStack$_.length) throw new Error("pushed too many line widths - check push/pop pairs");
            this._$_lineWidthStack$_.push(t), this._$_lineWidth$_ = t;
        }
        _$PopLineWidth$_() {
            if (this._$_lineWidthStack$_.length <= 1) throw new Error("cannot pop last line width - check push/pop pairs");
            this._$_lineWidthStack$_.pop(), this._$_lineWidth$_ = this._$_lineWidthStack$_.at(-1);
        }
        _$SetLineCapButt$_() {
            this._$_lineCap$_ = 0, this._$_lineCapStack$_[this._$_lineCapStack$_.length - 1] = 0;
        }
        _$SetLineCapSquare$_() {
            this._$_lineCap$_ = 1, this._$_lineCapStack$_[this._$_lineCapStack$_.length - 1] = 0;
        }
        _$SetLineCapZag$_() {
            this._$_lineCap$_ = 2, this._$_lineCapStack$_[this._$_lineCapStack$_.length - 1] = 0;
        }
        _$PushLineCap$_(t) {
            if ("butt" === t) this._$PushLineCapButt$_(); else if ("square" === t) this._$PushLineCapSquare$_(); else {
                if ("zag" !== t) throw new Error("invalid line cap");
                this._$PushLineCapZag$_();
            }
        }
        _$PushLineCapButt$_() {
            if (100 <= this._$_lineCapStack$_.length) throw new Error("pushed too many line caps - check push/pop pairs");
            this._$_lineCapStack$_.push(0), this._$_lineCap$_ = 0;
        }
        _$PushLineCapSquare$_() {
            if (100 <= this._$_lineCapStack$_.length) throw new Error("pushed too many line caps - check push/pop pairs");
            this._$_lineCapStack$_.push(1), this._$_lineCap$_ = 1;
        }
        _$PushLineCapZag$_() {
            if (100 <= this._$_lineCapStack$_.length) throw new Error("pushed too many line caps - check push/pop pairs");
            this._$_lineCapStack$_.push(2), this._$_lineCap$_ = 2;
        }
        _$PopLineCap$_() {
            if (this._$_lineCapStack$_.length <= 1) throw new Error("cannot pop last line cap - check push/pop pairs");
            this._$_lineCapStack$_.pop(), this._$_lineCap$_ = this._$_lineCapStack$_.at(-1);
        }
        _$SetLineOffset$_(t) {
            this._$_lineOffset$_ = t, this._$_lineOffsetStack$_[this._$_lineOffsetStack$_.length - 1] = t;
        }
        _$GetLineOffset$_() {
            return this._$_lineOffset$_;
        }
        _$PushLineOffset$_(t) {
            if (100 <= this._$_lineOffsetStack$_.length) throw new Error("pushed too many line offsets - check push/pop pairs");
            this._$_lineOffsetStack$_.push(t), this._$_lineOffset$_ = t;
        }
        _$PopLineOffset$_() {
            if (this._$_lineOffsetStack$_.length <= 1) throw new Error("cannot pop last line offset - check push/pop pairs");
            this._$_lineOffsetStack$_.pop(), this._$_lineOffset$_ = this._$_lineOffsetStack$_.at(-1);
        }
        _$ConvexPoly$_(s) {
            const t = s.length / 2;
            if (t < 3) throw new Error("need at least 3 points");
            const i = t - 2, e = i - 1, h = s[0], r = s[1];
            for (let t = 0; t < i; t += 2) {
                const n = 2 * t, o = s[2 + n], a = s[3 + n], l = s[4 + n], u = s[5 + n];
                if (t === e) this._$Quad2$_(h, r, o, a, l, u, l, u); else {
                    const c = s[6 + n], f = s[7 + n];
                    this._$Quad2$_(h, r, o, a, l, u, c, f);
                }
            }
        }
        _$GetNumVertexComponents$_() {
            return 3;
        }
        _$Finish$_() {
            this._$EndBatch$_(!0), this._$_frameNumber$_++;
        }
        _$GetFrameNumber$_() {
            return this._$_frameNumber$_;
        }
        _$IncrementFrameNumber$_() {
            this._$_frameNumber$_++;
        }
        _$SetMipmapsEnabled$_(t) {
            this._$_enableMipmaps$_ = !!t;
        }
        _$AreMipmapsEnabled$_() {
            return this._$_enableMipmaps$_;
        }
        _$SetHasMajorPerformanceCaveat$_(t) {
            this._$_hasMajorPerformanceCaveat$_ = !!t;
        }
        _$HasMajorPerformanceCaveat$_() {
            return this._$_hasMajorPerformanceCaveat$_;
        }
        _$IsWebGL$_() {
            return !1;
        }
        _$IsWebGPU$_() {
            return !1;
        }
        _$GetEstimatedBackBufferMemoryUsage$_() {}
        _$GetEstimatedRenderBufferMemoryUsage$_() {}
        _$GetEstimatedTextureMemoryUsage$_() {}
        _$GetEstimatedTotalMemoryUsage$_() {
            return this._$GetEstimatedBackBufferMemoryUsage$_() + this._$GetEstimatedRenderBufferMemoryUsage$_() + this._$GetEstimatedTextureMemoryUsage$_();
        }
        _$CreateRendererText$_() {
            return Xs._$New$_(Xs._$Gfx$_._$RendererText$_, this);
        }
    };
}

{
    const ni = self._$C3$_;
    ni._$Gfx$_._$ShaderProgramBase$_ = class {
        constructor(t, s) {
            this._$_name$_ = s.name, this._$_renderer$_ = t, this._$_extendBoxHorizontal$_ = s.extendBoxHorizontal || 0, 
            this._$_extendBoxVertical$_ = s.extendBoxVertical || 0, this._$_crossSampling$_ = !!s.crossSampling, 
            this._$_mustPreDraw$_ = !!s.mustPreDraw, this._$_preservesOpaqueness$_ = !!s.preservesOpaqueness, 
            this._$_supports3dDirectRendering$_ = !!s.supports3dDirectRendering, 
            this._$_animated$_ = !!s.animated, this._$_blendsBackground$_ = !!s.blendsBackground, 
            this._$_usesDepth$_ = !!s.usesDepth, this._$_usesAnySrcRectOrPixelSize$_ = !1, 
            this._$_needsPostDrawOrExtendBox$_ = this._$_crossSampling$_ || this._$_blendsBackground$_ || 0 !== this._$_extendBoxHorizontal$_ || 0 !== this._$_extendBoxVertical$_;
        }
        _$Release$_() {
            this._$_renderer$_ = null;
        }
        _$GetRenderer$_() {
            return this._$_renderer$_;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$ExtendsBox$_() {
            return 0 !== this._$_extendBoxHorizontal$_ || 0 !== this._$_extendBoxVertical$_;
        }
        _$GetBoxExtendHorizontal$_() {
            return this._$_extendBoxHorizontal$_;
        }
        _$GetBoxExtendVertical$_() {
            return this._$_extendBoxVertical$_;
        }
        _$UsesCrossSampling$_() {
            return this._$_crossSampling$_;
        }
        _$MustPreDraw$_() {
            return this._$_mustPreDraw$_;
        }
        _$PreservesOpaqueness$_() {
            return this._$_preservesOpaqueness$_;
        }
        _$Supports3DDirectRendering$_() {
            return this._$_supports3dDirectRendering$_;
        }
        _$IsAnimated$_() {
            return this._$_animated$_;
        }
        _$BlendsBackground$_() {
            return this._$_blendsBackground$_;
        }
        _$UsesDepth$_() {
            return this._$_usesDepth$_;
        }
        _$UsesAnySrcRectOrPixelSize$_() {
            return this._$_usesAnySrcRectOrPixelSize$_;
        }
        _$NeedsPostDrawOrExtendsBox$_() {
            return this._$_needsPostDrawOrExtendBox$_;
        }
        _$UsesIsSrcTexRotated$_() {
            return !1;
        }
    };
}

{
    const oi = self._$C3$_;
    oi._$Gfx$_._$StateGroup$_ = class {
        constructor(t, s, i, e, h) {
            this._$_renderer$_ = t, this._$_refCount$_ = 0, this._$_shaderProgram$_ = null, 
            this._$_shaderProgramName$_ = "", this._$_blendMode$_ = i, this._$_color$_ = oi._$New$_(oi._$Color$_), 
            this._$_color$_.set(e), this._$_zElevation$_ = h, "string" == typeof s ? this._$_shaderProgramName$_ = s : (this._$_shaderProgram$_ = s, 
            this._$_shaderProgramName$_ = this._$_shaderProgram$_._$GetName$_());
        }
        _$Release$_() {
            if (0 < this._$_refCount$_) throw new Error("releasing state group still in use");
            this._$_renderer$_ = null, this._$_shaderProgram$_ = null, this._$_shaderProgramName$_ = "";
        }
        _$Apply$_() {
            const t = this._$_renderer$_;
            t._$SetProgram$_(this._$_shaderProgram$_), t._$SetBlendMode$_(this._$_blendMode$_), 
            t._$SetColor$_(this._$_color$_), t._$SetCurrentZ$_(this._$_zElevation$_), 
            t._$_SetCurrentStateGroup$_(this);
        }
        _$GetKey$_() {
            return oi._$Gfx$_._$StateGroup$_._$MakeKey$_(this._$_shaderProgramName$_, this._$_blendMode$_, this._$_color$_, this._$_zElevation$_);
        }
        _$AddRef$_() {
            ++this._$_refCount$_;
        }
        _$DecRef$_() {
            --this._$_refCount$_;
        }
        _$_GetRefCount$_() {
            return this._$_refCount$_;
        }
        _$OnContextLost$_() {
            this._$_shaderProgram$_ = null;
        }
        _$OnContextRestored$_(t) {
            if (this._$_shaderProgram$_ = t._$GetShaderProgramByName$_(this._$_shaderProgramName$_), 
            !this._$_shaderProgram$_) throw new Error("failed to restore shader program");
        }
        static _$MakeKey$_(t, s, i, e) {
            const h = "string" == typeof t ? t : t._$GetName$_();
            return h + "," + s + "," + i._$getR$_() + "," + i._$getG$_() + "," + i._$getB$_() + "," + i._$getA$_() + "," + e;
        }
    };
}

{
    let e = function(t, s, i) {
        const e = i._$getTlx$_(), h = i._$getTly$_(), r = i._$getTrx$_() - e, n = i._$getTry$_() - h, o = i._$getBlx$_() - e, a = i._$getBly$_() - h, l = r * t, u = n * t, c = o * s, f = a * s;
        return [ e + l + c, h + u + f ];
    };
    e;
    const _ = self._$C3$_, ai = _._$New$_(_._$Quad$_);
    _._$Gfx$_._$MeshPoint$_ = class {
        constructor(t, s, i) {
            this._$_mesh$_ = t, this._$_col$_ = s, this._$_row$_ = i, this._$_x$_ = NaN, 
            this._$_y$_ = NaN, this._$_zElevation$_ = NaN, this._$_u$_ = NaN, this._$_v$_ = NaN, 
            this._$_x$_ = 0, this._$_y$_ = 0, this._$_zElevation$_ = 0, this._$_u$_ = 0, 
            this._$_v$_ = 0;
        }
        _$_Init$_(t, s, i, e) {
            this._$_x$_ = t, this._$_y$_ = s, this._$_u$_ = i, this._$_v$_ = e;
        }
        _$GetX$_() {
            return this._$_x$_;
        }
        _$SetX$_(t) {
            this._$_x$_ !== t && (this._$_x$_ = t, this._$_mesh$_._$_SetPointsChanged$_());
        }
        _$GetY$_() {
            return this._$_y$_;
        }
        _$SetY$_(t) {
            this._$_y$_ !== t && (this._$_y$_ = t, this._$_mesh$_._$_SetPointsChanged$_());
        }
        _$GetZElevation$_() {
            return this._$_zElevation$_;
        }
        _$SetZElevation$_(t) {
            this._$_zElevation$_ !== t && (this._$_zElevation$_ = Math.max(t, 0), 
            this._$_mesh$_._$_SetPointsChanged$_());
        }
        _$GetU$_() {
            return this._$_u$_;
        }
        _$SetU$_(t) {
            this._$_u$_ = t;
        }
        _$GetV$_() {
            return this._$_v$_;
        }
        _$SetV$_(t) {
            this._$_v$_ = t;
        }
        _$_Interpolate_TexRect$_(t, s, i) {
            [ this._$_x$_, this._$_y$_ ] = e(t._$_x$_, t._$_y$_, s), this._$_zElevation$_ = t._$_zElevation$_, 
            this._$_u$_ = _._$lerp$_(i._$getLeft$_(), i._$getRight$_(), t._$_u$_), 
            this._$_v$_ = _._$lerp$_(i._$getTop$_(), i._$getBottom$_(), t._$_v$_);
        }
        _$_Interpolate_TexQuad$_(t, s, i) {
            [ this._$_x$_, this._$_y$_ ] = e(t._$_x$_, t._$_y$_, s), this._$_zElevation$_ = t._$_zElevation$_, 
            [ this._$_u$_, this._$_v$_ ] = e(t._$_u$_, t._$_v$_, i);
        }
        _$SaveToJson$_() {
            return {
                x: this._$GetX$_(),
                y: this._$GetY$_(),
                z: this._$GetZElevation$_(),
                u: this._$GetU$_(),
                v: this._$GetV$_()
            };
        }
        _$LoadFromJson$_(t) {
            this._$SetX$_(t.x), this._$SetY$_(t.y), t.hasOwnProperty("z") && this._$SetZElevation$_(t.z), 
            this._$SetU$_(t.u), this._$SetV$_(t.v);
        }
        _$GetMesh$_() {
            return this._$_mesh$_;
        }
        _$GetColumn$_() {
            return this._$_col$_;
        }
        _$GetRow$_() {
            return this._$_row$_;
        }
    }, _._$Gfx$_._$Mesh$_ = class {
        constructor(i, t, s) {
            if (i < 2 || t < 2) throw new Error("invalid mesh size");
            this._$_hsize$_ = i, this._$_vsize$_ = t, this._$_owner$_ = s || null, 
            this._$_pts$_ = [], this._$_minX$_ = 0, this._$_minY$_ = 0, this._$_maxX$_ = 1, 
            this._$_maxY$_ = 1, this._$_maxZ$_ = 0, this._$_pointsChanged$_ = !1;
            const e = i - 1, h = t - 1;
            for (let s = 0; s < t; ++s) {
                const r = [];
                for (let t = 0; t < i; ++t) {
                    const n = _._$New$_(_._$Gfx$_._$MeshPoint$_, this, t, s), o = t / e, a = s / h;
                    n._$_Init$_(o, a, o, a), r.push(n);
                }
                this._$_pts$_.push(r);
            }
        }
        _$Release$_() {
            _._$clearArray$_(this._$_pts$_);
        }
        _$GetHSize$_() {
            return this._$_hsize$_;
        }
        _$GetVSize$_() {
            return this._$_vsize$_;
        }
        _$GetOwner$_() {
            return this._$_owner$_;
        }
        _$_GetPoints$_() {
            return this._$_pts$_;
        }
        _$_SetPointsChanged$_() {
            this._$_pointsChanged$_ = !0;
        }
        _$_MaybeComputeBounds$_() {
            if (this._$_pointsChanged$_) {
                let t = 1 / 0, s = 1 / 0, i = -1 / 0, e = -1 / 0, h = 0;
                for (const r of this._$_pts$_) for (const n of r) {
                    const o = n._$GetX$_(), a = n._$GetY$_();
                    t = Math.min(t, o), s = Math.min(s, a), i = Math.max(i, o), 
                    e = Math.max(e, a), h = Math.max(h, n._$GetZElevation$_());
                }
                this._$_minX$_ = t, this._$_minY$_ = s, this._$_maxX$_ = i, this._$_maxY$_ = e, 
                this._$_maxZ$_ = h, this._$_pointsChanged$_ = !1;
            }
        }
        _$GetMinX$_() {
            return this._$_MaybeComputeBounds$_(), this._$_minX$_;
        }
        _$GetMinY$_() {
            return this._$_MaybeComputeBounds$_(), this._$_minY$_;
        }
        _$GetMaxX$_() {
            return this._$_MaybeComputeBounds$_(), this._$_maxX$_;
        }
        _$GetMaxY$_() {
            return this._$_MaybeComputeBounds$_(), this._$_maxY$_;
        }
        _$GetMaxZ$_() {
            return this._$_MaybeComputeBounds$_(), this._$_maxZ$_;
        }
        _$HasAnyZElevation$_() {
            return 0 < this._$GetMaxZ$_();
        }
        _$GetMeshPointAt$_(t, s) {
            return t = Math.floor(t), s = Math.floor(s), t < 0 || t >= this._$_hsize$_ || s < 0 || s >= this._$_vsize$_ ? null : this._$_pts$_[s][t];
        }
        _$CalculateTransformedMesh$_(t, i, e) {
            const h = e instanceof _.Rect;
            if (t._$GetHSize$_() !== this._$GetHSize$_() || t._$GetVSize$_() !== this._$GetVSize$_()) throw new Error("source mesh wrong size");
            const r = t._$_pts$_, n = this._$_pts$_;
            for (let t = 0, s = n.length; t < s; ++t) {
                const o = r[t], a = n[t];
                for (let t = 0, s = a.length; t < s; ++t) {
                    const l = o[t], u = a[t];
                    h ? u._$_Interpolate_TexRect$_(l, i, e) : u._$_Interpolate_TexQuad$_(l, i, e);
                }
            }
        }
        _$Draw$_(r) {
            let n = this._$_pts$_, o = n[0];
            for (let t = 1, s = n.length; t < s; ++t) {
                let i = n[t], e = o[0], h = i[0];
                for (let t = 1, s = i.length; t < s; ++t) {
                    const a = o[t], l = i[t];
                    ai.set(e._$GetU$_(), e._$GetV$_(), a._$GetU$_(), a._$GetV$_(), l._$GetU$_(), l._$GetV$_(), h._$GetU$_(), h._$GetV$_()), 
                    r._$Quad3D2$_(e._$GetX$_(), e._$GetY$_(), e._$GetZElevation$_(), a._$GetX$_(), a._$GetY$_(), a._$GetZElevation$_(), l._$GetX$_(), l._$GetY$_(), l._$GetZElevation$_(), h._$GetX$_(), h._$GetY$_(), h._$GetZElevation$_(), ai), 
                    e = a, h = l;
                }
                o = i;
            }
        }
        _$Outline$_(o, a) {
            a = a || ((t, s, i) => [ t, s, i ]);
            let t = this._$_pts$_, l = t[0];
            for (let r = 1, n = t.length; r < n; ++r) {
                let i = t[r], e = l[0], h = i[0];
                for (let t = 1, s = i.length; t < s; ++t) {
                    const u = l[t], c = i[t], [ f, d, p ] = a(e._$GetX$_(), e._$GetY$_(), e._$GetZElevation$_()), [ m, g, y ] = a(u._$GetX$_(), u._$GetY$_(), u._$GetZElevation$_()), [ w, S, b ] = a(c._$GetX$_(), c._$GetY$_(), c._$GetZElevation$_()), [ M, v, x ] = a(h._$GetX$_(), h._$GetY$_(), h._$GetZElevation$_());
                    o._$Line3D$_(f, d, p, m, g, y), o._$Line3D$_(f, d, p, w, S, b), 
                    o._$Line3D$_(f, d, p, M, v, x), t === s - 1 && o._$Line3D$_(m, g, y, w, S, b), 
                    r === n - 1 && o._$Line3D$_(M, v, x, w, S, b), e = u, h = c;
                }
                l = i;
            }
        }
        _$InsertPolyMeshVertices$_(t) {
            let i = .99999999, e = t._$pointsArr$_(), h = [], r = this._$GetHSize$_() - 1, n = this._$GetVSize$_() - 1, o = 1 / r, a = 1 / n, l = r - 1, u = n - 1, c = e[0], f = e[1], d = _._$clamp$_(Math.floor(c * r), 0, l), p = _._$clamp$_(Math.floor(f * n), 0, u), m = !0, g = 0, y = 0, w = 0, S = -1, b = () => {
                c = _._$clamp$_(_._$lerp$_(c, g, w), 0, 1), f = _._$clamp$_(_._$lerp$_(f, y, w), 0, 1), 
                h.push(c, f);
            };
            for (let t = 0, s = e.length; t < s; t += 2) {
                c = e[t], f = e[t + 1], h.push(c, f), d = _._$clamp$_(Math.floor(c * r), 0, l), 
                p = _._$clamp$_(Math.floor(f * n), 0, u);
                const M = (t + 2) % s;
                for (g = e[M], y = e[1 + M], S = -1; ;) {
                    if (1e6 < h.length) throw new Error("Too many mesh poly points");
                    const v = d * o, x = p * a, G = (d + 1) * o, T = (p + 1) * a;
                    if (m = _._$isPointInTriangleInclusive$_(c, f, v, x, G, x, G, T), 
                    0 !== S && 0 <= (w = _._$rayIntersectExtended$_(c, f, g, y, v, x, G, T, -.001)) && w <= i) b(), 
                    m = !m, S = 0; else if (0 < p && 2 !== S && 0 <= (w = _._$rayIntersectExtended$_(c, f, g, y, v, x, G, x, .001)) && w <= i) b(), 
                    p--, m = !1, S = 4; else if (d < l && 3 !== S && 0 <= (w = _._$rayIntersectExtended$_(c, f, g, y, G, x, G, T, .001)) && w <= i) b(), 
                    d++, m = !1, S = 1; else if (0 < d && 1 !== S && 0 <= (w = _._$rayIntersectExtended$_(c, f, g, y, v, x, v, T, .001)) && w <= i) b(), 
                    d--, m = !0, S = 3; else {
                        if (!(p < u && 4 !== S && 0 <= (w = _._$rayIntersectExtended$_(c, f, g, y, v, T, G, T, .001)) && w <= i)) break;
                        b(), p++, m = !0, S = 2;
                    }
                }
            }
            return _._$New$_(_._$CollisionPoly$_, h);
        }
        _$TransformCollisionPoly$_(t, s) {
            const i = this._$_TransformPolyPoints$_(t);
            this._$_SimplifyPoly$_(i), s._$setPoints$_(i);
        }
        _$_TransformPolyPoints$_(t) {
            const i = [], e = t._$pointsArr$_();
            for (let t = 0, s = e.length; t < s; t += 2) {
                const h = e[t], r = e[t + 1], [ n, o ] = this._$TransformPoint$_(h, r);
                i.push(n, o);
            }
            return i;
        }
        _$TransformPoint$_(t, s) {
            const i = this._$GetHSize$_() - 1, e = this._$GetVSize$_() - 1, h = 1 / i, r = 1 / e, n = _._$clamp$_(Math.floor(t * i), 0, i - 1), o = _._$clamp$_(Math.floor(s * e), 0, e - 1), a = n * h, l = o * r, u = (n + 1) * h, c = (o + 1) * r, f = this._$GetMeshPointAt$_(n, o), d = this._$GetMeshPointAt$_(n + 1, o + 1), p = _._$isPointInTriangleInclusive$_(t, s, a, l, u, l, u, c), m = p ? a + h : a, g = p ? l : l + r, y = this._$GetMeshPointAt$_(n + (p ? 1 : 0), o + (p ? 0 : 1)), [ w, S, b ] = _._$triangleCartesianToBarycentric$_(t, s, a, l, m, g, u, c);
            return _._$triangleBarycentricToCartesian3d$_(w, S, b, f._$GetX$_(), f._$GetY$_(), f._$GetZElevation$_(), y._$GetX$_(), y._$GetY$_(), y._$GetZElevation$_(), d._$GetX$_(), d._$GetY$_(), d._$GetZElevation$_());
        }
        _$_SimplifyPoly$_(i) {
            let e = [], h = i[0], r = i[1], n = h - i.at(-2), o = r - i.at(-1);
            for (let t = 0, s = i.length; t < s; t += 2) {
                const a = (t + 2) % s, l = i[a], u = i[1 + a], c = l - h, f = u - r, d = Math.abs(c) < 1e-7 && Math.abs(n) < 1e-7 && Math.sign(f) === Math.sign(o), p = Math.abs(f) < 1e-7 && Math.abs(o) < 1e-7 && Math.sign(c) === Math.sign(n);
                (!d && !p && .001 < Math.abs(c / n - f / o) || 0 == c && 0 == f) && e.push(h, r), 
                h = l, r = u, n = c, o = f;
            }
            6 <= e.length && e.length < i.length && _._$shallowAssignArray$_(i, e);
        }
        _$SaveToJson$_() {
            return {
                cols: this._$GetHSize$_(),
                rows: this._$GetVSize$_(),
                points: this._$_pts$_.map(t => t.map(t => t._$SaveToJson$_()))
            };
        }
        _$LoadFromJson$_(t) {
            const i = this._$GetHSize$_(), e = this._$GetVSize$_();
            if (t.cols !== i || t.rows !== e) throw new Error("mesh data wrong size");
            const h = t.points;
            for (let s = 0; s < e; ++s) {
                const r = h[s];
                for (let t = 0; t < i; ++t) {
                    const n = this._$GetMeshPointAt$_(t, s);
                    n._$LoadFromJson$_(r[t]);
                }
            }
        }
    };
}

{
    let d = function(t, s) {
        let i, e, h, r;
        switch (t) {
          case "rgba8":
            i = s.RGBA8, e = s.RGBA, h = s.RGBA, r = s.UNSIGNED_BYTE;
            break;

          case "rgb8":
            i = s.RGB8, e = s.RGB, h = s.RGB, r = s.UNSIGNED_BYTE;
            break;

          case "rgba4":
            i = s.RGBA4, e = s.RGBA, h = s.RGBA, r = s.UNSIGNED_SHORT_4_4_4_4;
            break;

          case "rgb5_a1":
            i = s.RGB5_A1, e = s.RGBA, h = s.RGBA, r = s.UNSIGNED_SHORT_5_5_5_1;
            break;

          case "rgb565":
            i = s.RGB565, e = s.RGB, h = s.RGB, r = s.UNSIGNED_SHORT_5_6_5;
            break;

          default:
            throw new Error("invalid pixel format");
        }
        return {
            _$sizedinternalformat$_: i,
            _$internalformat$_: e,
            format: h,
            type: r
        };
    };
    d;
    const li = self._$C3$_, ui = new Set([ "rgba8", "rgb8", "rgba4", "rgb5_a1", "rgb565" ]), ci = new Set([ "nearest", "bilinear", "trilinear" ]), fi = new Set([ "default", "low", "high" ]), di = new Set([ "clamp-to-edge", "repeat", "mirror-repeat" ]), pi = {
        _$wrapX$_: "clamp-to-edge",
        _$wrapY$_: "clamp-to-edge",
        _$sampling$_: "trilinear",
        _$anisotropy$_: 0,
        _$pixelFormat$_: "rgba8",
        _$mipMap$_: !0,
        _$mipMapQuality$_: "default",
        premultiplyAlpha: !0,
        _$isSvg$_: !1,
        width: -1,
        height: -1
    }, mi = {
        premultiplyAlpha: !0,
        flipY: !1
    }, gi = new Set();
    li._$Gfx$_._$WebGLRendererTexture$_ = class {
        constructor(t) {
            this._$_renderer$_ = t, this._$_texture$_ = null, this._$_width$_ = 0, 
            this._$_height$_ = 0, this._$_isStatic$_ = !0, this._$_wrapX$_ = "clamp-to-edge", 
            this._$_wrapY$_ = "clamp-to-edge", this._$_sampling$_ = "trilinear", 
            this._$_anisotropy$_ = 0, this._$_pixelFormat$_ = "rgba8", this._$_isMipMapped$_ = !1, 
            this._$_mipMapQuality$_ = "default", this._$_refCount$_ = 0;
        }
        _$_CreateStatic$_(s, t) {
            if (!("undefined" != typeof HTMLImageElement && s instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && s instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && s instanceof ImageBitmap || "undefined" != typeof OffscreenCanvas && s instanceof OffscreenCanvas || s instanceof ImageData || s instanceof ArrayBuffer || null === s)) throw new Error("invalid texture source");
            if (t = Object.assign({}, pi, t), this._$_texture$_) throw new Error("already created texture");
            if (this._$_wrapX$_ = t._$wrapX$_, this._$_wrapY$_ = t._$wrapY$_, this._$_sampling$_ = t._$sampling$_, 
            this._$_anisotropy$_ = t._$anisotropy$_, this._$_pixelFormat$_ = t._$pixelFormat$_, 
            this._$_isMipMapped$_ = !!t._$mipMap$_ && this._$_renderer$_._$AreMipmapsEnabled$_(), 
            this._$_mipMapQuality$_ = t._$mipMapQuality$_, !di.has(this._$_wrapX$_) || !di.has(this._$_wrapY$_)) throw new Error("invalid wrap mode");
            if (!ci.has(this._$_sampling$_)) throw new Error("invalid sampling");
            if (!ui.has(this._$_pixelFormat$_)) throw new Error("invalid pixel format");
            if (!fi.has(this._$_mipMapQuality$_)) throw new Error("invalid mipmap quality");
            if (this._$_isStatic$_ = !0, s instanceof ArrayBuffer || null === s || t._$isSvg$_) {
                if (this._$_width$_ = t.width, this._$_height$_ = t.height, s instanceof ArrayBuffer && s.byteLength !== this._$_width$_ * this._$_height$_ * 4) throw new Error("ArrayBuffer wrong size");
            } else this._$_width$_ = s.width, this._$_height$_ = s.height;
            if (this._$_width$_ <= 0 || this._$_height$_ <= 0) throw new Error("invalid texture data size");
            if (t._$isSvg$_) {
                const o = li._$CreateCanvas$_(this._$_width$_, this._$_height$_), a = o.getContext("2d");
                a.drawImage(s, 0, 0, this._$_width$_, this._$_height$_), s = o;
            }
            const i = li._$isPOT$_(this._$_width$_) && li._$isPOT$_(this._$_height$_), e = this._$_renderer$_._$GetMaxTextureSize$_();
            if (this._$_width$_ > e || this._$_height$_ > e) throw new Error("texture data exceeds maximum texture size");
            const h = this._$_renderer$_._$GetContext$_(), r = this._$_renderer$_._$GetWebGLVersionNumber$_(), n = (this._$_texture$_ = h.createTexture(), 
            h.bindTexture(h.TEXTURE_2D, this._$_texture$_), h.pixelStorei(h.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), 
            h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL, !1), d(this._$_pixelFormat$_, h));
            if (this._$_renderer$_._$SupportsNPOTTextures$_() || i || !this._$_IsTiled$_()) if (2 <= r) {
                let t;
                t = this._$_isMipMapped$_ ? Math.floor(Math.log2(Math.max(this._$_width$_, this._$_height$_)) + 1) : 1, 
                h.texStorage2D(h.TEXTURE_2D, t, n._$sizedinternalformat$_, this._$_width$_, this._$_height$_), 
                s instanceof ArrayBuffer ? h.texSubImage2D(h.TEXTURE_2D, 0, 0, 0, this._$_width$_, this._$_height$_, n.format, n.type, new Uint8Array(s)) : null !== s && h.texSubImage2D(h.TEXTURE_2D, 0, 0, 0, n.format, n.type, s);
            } else s instanceof ArrayBuffer ? h.texImage2D(h.TEXTURE_2D, 0, n._$internalformat$_, this._$_width$_, this._$_height$_, 0, n.format, n.type, new Uint8Array(s)) : null === s ? h.texImage2D(h.TEXTURE_2D, 0, n._$internalformat$_, this._$_width$_, this._$_height$_, 0, n.format, n.type, null) : h.texImage2D(h.TEXTURE_2D, 0, n._$internalformat$_, n.format, n.type, s); else {
                if (null === s) throw new Error("cannot pass null data when creating a NPOT tiled texture without NPOT support");
                if ((s = s instanceof ArrayBuffer ? new ImageData(new Uint8ClampedArray(s), this._$_width$_, this._$_height$_) : s) instanceof ImageData) {
                    const c = li._$CreateCanvas$_(this._$_width$_, this._$_height$_), f = c.getContext("2d");
                    f.putImageData(s, 0, 0), s = c;
                }
                const l = li._$CreateCanvas$_(li._$nextHighestPowerOfTwo$_(this._$_width$_), li._$nextHighestPowerOfTwo$_(this._$_height$_)), u = l.getContext("2d");
                u.imageSmoothingEnabled = "nearest" !== this._$_sampling$_, u.drawImage(s, 0, 0, this._$_width$_, this._$_height$_, 0, 0, l.width, l.height), 
                h.texImage2D(h.TEXTURE_2D, 0, n._$internalformat$_, n.format, n.type, l);
            }
            null !== s && this._$_SetTextureParameters$_(h), h.bindTexture(h.TEXTURE_2D, null), 
            this._$_renderer$_._$_ResetLastTexture$_(), this._$_refCount$_ = 1, 
            gi.add(this);
        }
        _$_CreateDynamic$_(t, s, i) {
            if (i = Object.assign({}, pi, i), this._$_texture$_) throw new Error("already created texture");
            if (this._$_wrapX$_ = i._$wrapX$_, this._$_wrapY$_ = i._$wrapY$_, this._$_sampling$_ = i._$sampling$_, 
            this._$_pixelFormat$_ = i._$pixelFormat$_, this._$_isMipMapped$_ = !!i._$mipMap$_ && this._$_renderer$_._$AreMipmapsEnabled$_(), 
            this._$_mipMapQuality$_ = i._$mipMapQuality$_, !di.has(this._$_wrapX$_) || !di.has(this._$_wrapY$_)) throw new Error("invalid wrap mode");
            if (!ci.has(this._$_sampling$_)) throw new Error("invalid sampling");
            if (!ui.has(this._$_pixelFormat$_)) throw new Error("invalid pixel format");
            if (!fi.has(this._$_mipMapQuality$_)) throw new Error("invalid mipmap quality");
            this._$_isStatic$_ = !1, this._$_width$_ = Math.floor(t), this._$_height$_ = Math.floor(s);
            const e = li._$isPOT$_(this._$_width$_) && li._$isPOT$_(this._$_height$_), h = this._$_renderer$_._$GetMaxTextureSize$_();
            if (this._$_width$_ <= 0 || this._$_height$_ <= 0) throw new Error("invalid texture size");
            if (this._$_width$_ > h || this._$_height$_ > h) throw new Error("texture exceeds maximum texture size");
            if (!this._$_renderer$_._$SupportsNPOTTextures$_() && this._$_IsTiled$_() && !e) throw new Error("non-power-of-two tiled textures not supported");
            const r = this._$_renderer$_._$GetContext$_(), n = this._$_renderer$_._$GetWebGLVersionNumber$_(), o = (this._$_texture$_ = r.createTexture(), 
            r.bindTexture(r.TEXTURE_2D, this._$_texture$_), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), 
            r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, !1), d(this._$_pixelFormat$_, r)), a = 2 <= n ? o._$sizedinternalformat$_ : o._$internalformat$_;
            r.texImage2D(r.TEXTURE_2D, 0, a, this._$_width$_, this._$_height$_, 0, o.format, o.type, null), 
            this._$_SetTextureParameters$_(r), r.bindTexture(r.TEXTURE_2D, null), 
            this._$_renderer$_._$_ResetLastTexture$_(), this._$_refCount$_ = 1, 
            gi.add(this);
        }
        _$_GetMipMapHint$_(t) {
            if ("default" === this._$_mipMapQuality$_) return this._$_isStatic$_ ? t.NICEST : t.FASTEST;
            if ("low" === this._$_mipMapQuality$_) return t.FASTEST;
            if ("high" === this._$_mipMapQuality$_) return t.NICEST;
            throw new Error("invalid mipmap quality");
        }
        _$_IsTiled$_() {
            return "clamp-to-edge" !== this._$_wrapX$_ || "clamp-to-edge" !== this._$_wrapY$_;
        }
        _$_GetTextureWrapMode$_(t, s) {
            if ("clamp-to-edge" === s) return t.CLAMP_TO_EDGE;
            if ("repeat" === s) return t.REPEAT;
            if ("mirror-repeat" === s) return t.MIRRORED_REPEAT;
            throw new Error("invalid wrap mode");
        }
        _$_SetTextureParameters$_(t) {
            const s = li._$isPOT$_(this._$_width$_) && li._$isPOT$_(this._$_height$_);
            if (t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, this._$_GetTextureWrapMode$_(t, this._$_wrapX$_)), 
            t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, this._$_GetTextureWrapMode$_(t, this._$_wrapY$_)), 
            "nearest" === this._$_sampling$_) t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), 
            t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), this._$_isMipMapped$_ = !1; else if (t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), 
            (s || this._$_renderer$_._$SupportsNPOTTextures$_()) && this._$_isMipMapped$_) {
                t.hint(t.GENERATE_MIPMAP_HINT, this._$_GetMipMapHint$_(t)), t.generateMipmap(t.TEXTURE_2D);
                const e = "trilinear" === this._$_sampling$_ && !this._$_renderer$_._$HasMajorPerformanceCaveat$_();
                t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, e ? t.LINEAR_MIPMAP_LINEAR : t.LINEAR_MIPMAP_NEAREST);
            } else t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), 
            this._$_isMipMapped$_ = !1;
            const i = this._$_renderer$_._$_GetAnisotropicExtension$_();
            i && 0 < this._$_anisotropy$_ && "nearest" !== this._$_sampling$_ && t.texParameterf(t.TEXTURE_2D, i.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(this._$_anisotropy$_, this._$_renderer$_._$_GetMaxAnisotropy$_()));
        }
        _$_Update$_(t, s) {
            if (!("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLVideoElement && t instanceof HTMLVideoElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas || t instanceof ImageData)) throw new Error("invalid texture source");
            if (!this._$_texture$_ || this._$_refCount$_ <= 0) throw new Error("texture not created");
            if (this._$_isStatic$_) throw new Error("cannot update static texture");
            s = Object.assign({}, mi, s);
            const i = t.width || t.videoWidth, e = t.height || t.videoHeight, h = this._$_renderer$_._$GetWebGLVersionNumber$_(), r = this._$_renderer$_._$GetContext$_(), n = (r.bindTexture(r.TEXTURE_2D, this._$_texture$_), 
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s.premultiplyAlpha), 
            r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, !!s.flipY), d(this._$_pixelFormat$_, r)), o = 2 <= h ? n._$sizedinternalformat$_ : n._$internalformat$_;
            try {
                if (this._$_width$_ === i && this._$_height$_ === e) {
                    const a = li._$isPOT$_(this._$_width$_) && li._$isPOT$_(this._$_height$_);
                    r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, n.format, n.type, t), 
                    (a || this._$_renderer$_._$SupportsNPOTTextures$_()) && this._$_isMipMapped$_ && (r.hint(r.GENERATE_MIPMAP_HINT, this._$_GetMipMapHint$_(r)), 
                    r.generateMipmap(r.TEXTURE_2D));
                } else {
                    this._$_width$_ = i, this._$_height$_ = e;
                    const l = li._$isPOT$_(this._$_width$_) && li._$isPOT$_(this._$_height$_);
                    if (!this._$_renderer$_._$SupportsNPOTTextures$_() && this._$_IsTiled$_() && !l) throw new Error("non-power-of-two tiled textures not supported");
                    r.texImage2D(r.TEXTURE_2D, 0, o, n.format, n.type, t), (l || this._$_renderer$_._$SupportsNPOTTextures$_()) && this._$_isMipMapped$_ && (r.hint(r.GENERATE_MIPMAP_HINT, this._$_GetMipMapHint$_(r)), 
                    r.generateMipmap(r.TEXTURE_2D));
                }
            } catch (t) {
                console.error("Error updating WebGL texture: ", t);
            }
            r.bindTexture(r.TEXTURE_2D, null), this._$_renderer$_._$_ResetLastTexture$_();
        }
        _$_Delete$_() {
            if (0 < this._$_refCount$_) throw new Error("texture still has references");
            if (!this._$_texture$_) throw new Error("already deleted texture");
            gi.delete(this);
            const t = this._$_renderer$_._$GetContext$_();
            t.deleteTexture(this._$_texture$_), this._$_texture$_ = null;
        }
        _$IsValid$_() {
            return !!this._$_texture$_;
        }
        _$_GetTexture$_() {
            return this._$_texture$_;
        }
        _$GetRenderer$_() {
            return this._$_renderer$_;
        }
        _$AddReference$_() {
            this._$_refCount$_++;
        }
        _$SubtractReference$_() {
            if (this._$_refCount$_ <= 0) throw new Error("no more references");
            this._$_refCount$_--;
        }
        _$GetReferenceCount$_() {
            return this._$_refCount$_;
        }
        _$GetWidth$_() {
            return this._$_width$_;
        }
        _$GetHeight$_() {
            return this._$_height$_;
        }
        _$IsStatic$_() {
            return this._$_isStatic$_;
        }
        _$GetEstimatedMemoryUsage$_() {
            let t = this._$_width$_ * this._$_height$_;
            switch (this._$_pixelFormat$_) {
              case "rgba8":
                t *= 4;
                break;

              case "rgb8":
                t *= 3;
                break;

              case "rgba4":
              case "rgb5_a1":
              case "rgb565":
                t *= 2;
            }
            return this._$_isMipMapped$_ && (t += Math.floor(t / 3)), t;
        }
        static _$OnContextLost$_() {
            gi.clear();
        }
        static _$allTextures$_() {
            return gi.values();
        }
    };
}

{
    const yi = self._$C3$_, wi = self._$glMatrix$_, Gh = wi._$vec3$_, xh = wi._$mat4$_, Si = new Set([ "nearest", "bilinear", "trilinear" ]), bi = {
        _$sampling$_: "trilinear",
        alpha: !0,
        depth: !1,
        _$isSampled$_: !0,
        _$isDefaultSize$_: !0,
        _$multisampling$_: 0
    }, Mi = new Set();
    yi._$Gfx$_._$WebGLRenderTarget$_ = class {
        constructor(t) {
            this._$_renderer$_ = t, this._$_frameBuffer$_ = null, this._$_frameBufferNoDepth$_ = null, 
            this._$_texture$_ = null, this._$_renderBuffer$_ = null, this._$_width$_ = 0, 
            this._$_height$_ = 0, this._$_isDefaultSize$_ = !0, this._$_sampling$_ = "trilinear", 
            this._$_alpha$_ = !0, this._$_depth$_ = !1, this._$_isSampled$_ = !0, 
            this._$_multisampling$_ = 0, this._$_projectionMatrix$_ = xh.create(), 
            this._$_lastFov$_ = 0, this._$_lastNearZ$_ = 0, this._$_lastFarZ$_ = 0;
        }
        _$_Create$_(t, s, i) {
            i = Object.assign({}, bi, i);
            const e = this._$_renderer$_._$GetWebGLVersionNumber$_();
            if (this._$_texture$_ || this._$_renderBuffer$_) throw new Error("already created render target");
            if (this._$_sampling$_ = i._$sampling$_, this._$_alpha$_ = !!i.alpha, 
            this._$_depth$_ = !!i.depth, this._$_isSampled$_ = !!i._$isSampled$_, 
            this._$_isDefaultSize$_ = !!i._$isDefaultSize$_, this._$_multisampling$_ = i._$multisampling$_, 
            !Si.has(this._$_sampling$_)) throw new Error("invalid sampling");
            if (0 < this._$_multisampling$_ && (e < 2 || this._$_isSampled$_)) throw new Error("invalid use of multisampling");
            if (e < 2 && (this._$_isSampled$_ = !0), this._$_width$_ = t, this._$_height$_ = s, 
            this._$_width$_ <= 0 || this._$_height$_ <= 0) throw new Error("invalid render target size");
            this._$_CalculateProjection$_();
            const h = this._$_renderer$_._$GetContext$_();
            if (this._$_frameBuffer$_ = h.createFramebuffer(), this._$_depth$_ && (this._$_frameBufferNoDepth$_ = h.createFramebuffer()), 
            this._$_isSampled$_) {
                this._$_texture$_ = this._$_renderer$_._$CreateDynamicTexture$_(this._$_width$_, this._$_height$_, {
                    _$sampling$_: this._$_sampling$_,
                    _$pixelFormat$_: this._$_alpha$_ ? "rgba8" : "rgb8",
                    _$mipMap$_: !1
                });
                const n = this._$_texture$_._$_GetTexture$_();
                h.bindFramebuffer(h.FRAMEBUFFER, this._$_frameBuffer$_), h.framebufferTexture2D(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.TEXTURE_2D, n, 0), 
                this._$_depth$_ && (h.bindFramebuffer(h.FRAMEBUFFER, this._$_frameBufferNoDepth$_), 
                h.framebufferTexture2D(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.TEXTURE_2D, n, 0));
            } else {
                this._$_renderBuffer$_ = h.createRenderbuffer(), h.bindRenderbuffer(h.RENDERBUFFER, this._$_renderBuffer$_);
                const o = this._$_alpha$_ ? h.RGBA8 : h.RGB8;
                if (0 < this._$_multisampling$_) {
                    const a = h.getInternalformatParameter(h.RENDERBUFFER, o, h.SAMPLES);
                    if (a && a[0]) {
                        const l = a[0];
                        this._$_multisampling$_ > l && (this._$_multisampling$_ = l);
                    } else this._$_multisampling$_ = 0;
                }
                0 === this._$_multisampling$_ ? h.renderbufferStorage(h.RENDERBUFFER, o, this._$_width$_, this._$_height$_) : h.renderbufferStorageMultisample(h.RENDERBUFFER, this._$_multisampling$_, o, this._$_width$_, this._$_height$_), 
                h.bindFramebuffer(h.FRAMEBUFFER, this._$_frameBuffer$_), h.framebufferRenderbuffer(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.RENDERBUFFER, this._$_renderBuffer$_), 
                this._$_depth$_ && (h.bindFramebuffer(h.FRAMEBUFFER, this._$_frameBufferNoDepth$_), 
                h.framebufferRenderbuffer(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.RENDERBUFFER, this._$_renderBuffer$_)), 
                h.bindRenderbuffer(h.RENDERBUFFER, null);
            }
            const r = this._$_renderer$_._$_GetDepthBuffer$_();
            this._$_depth$_ && r && (h.bindFramebuffer(h.FRAMEBUFFER, this._$_frameBuffer$_), 
            this._$_renderer$_._$_CanSampleDepth$_() ? h.framebufferTexture2D(h.FRAMEBUFFER, h.DEPTH_STENCIL_ATTACHMENT, h.TEXTURE_2D, r, 0) : h.framebufferRenderbuffer(h.FRAMEBUFFER, h.DEPTH_STENCIL_ATTACHMENT, h.RENDERBUFFER, r)), 
            h.bindFramebuffer(h.FRAMEBUFFER, null), Mi.add(this);
        }
        _$_Resize$_(t, s) {
            if (this._$_width$_ !== t || this._$_height$_ !== s) {
                this._$_width$_ = t, this._$_height$_ = s, this._$_CalculateProjection$_();
                const i = this._$_renderer$_._$GetContext$_(), e = (i.bindFramebuffer(i.FRAMEBUFFER, this._$_frameBuffer$_), 
                this._$_texture$_ ? this._$_texture$_._$_Update$_(new ImageData(this._$_width$_, this._$_height$_)) : (i.bindRenderbuffer(i.RENDERBUFFER, this._$_renderBuffer$_), 
                i.renderbufferStorage(i.RENDERBUFFER, this._$_alpha$_ ? i.RGBA8 : i.RGB8, this._$_width$_, this._$_height$_), 
                i.bindRenderbuffer(i.RENDERBUFFER, null)), this._$_renderer$_._$_GetDepthBuffer$_());
                this._$_depth$_ && e && (this._$_renderer$_._$_CanSampleDepth$_() ? i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, e, 0) : i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, e)), 
                i.bindFramebuffer(i.FRAMEBUFFER, null);
            }
        }
        _$_Delete$_() {
            if (!this._$_texture$_ && !this._$_renderBuffer$_) throw new Error("already deleted render target");
            Mi.delete(this);
            const t = this._$_renderer$_._$GetContext$_(), s = (this._$_texture$_ ? (t.bindFramebuffer(t.FRAMEBUFFER, this._$_frameBuffer$_), 
            t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0), 
            this._$_depth$_ && (t.bindFramebuffer(t.FRAMEBUFFER, this._$_frameBufferNoDepth$_), 
            t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0)), 
            this._$_renderer$_._$DeleteTexture$_(this._$_texture$_), this._$_texture$_ = null) : this._$_renderBuffer$_ && (t.bindFramebuffer(t.FRAMEBUFFER, this._$_frameBuffer$_), 
            t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, null), 
            this._$_depth$_ && (t.bindFramebuffer(t.FRAMEBUFFER, this._$_frameBufferNoDepth$_), 
            t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, null)), 
            t.deleteRenderbuffer(this._$_renderBuffer$_), this._$_renderBuffer$_ = null), 
            t.bindFramebuffer(t.FRAMEBUFFER, null), 2 <= this._$_renderer$_._$GetWebGLVersionNumber$_() && (t.bindFramebuffer(t.READ_FRAMEBUFFER, null), 
            t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null)), t.deleteFramebuffer(this._$_frameBuffer$_), 
            this._$_depth$_ && t.deleteFramebuffer(this._$_frameBufferNoDepth$_), 
            this._$_renderer$_._$GetBatchState$_());
            s._$currentFramebuffer$_ = null, this._$_frameBuffer$_ = s._$currentFramebufferNoDepth$_ = null;
        }
        _$_CalculateProjection$_() {
            this._$_renderer$_._$CalculatePerspectiveMatrix$_(this._$_projectionMatrix$_, this._$_width$_ / this._$_height$_), 
            this._$_lastFov$_ = this._$_renderer$_._$GetFovY$_(), this._$_lastNearZ$_ = this._$_renderer$_._$GetNearZ$_(), 
            this._$_lastFarZ$_ = this._$_renderer$_._$GetFarZ$_();
        }
        _$_GetFramebuffer$_() {
            return this._$_frameBuffer$_;
        }
        _$_GetFramebufferNoDepth$_() {
            return this._$_frameBufferNoDepth$_;
        }
        _$GetRenderer$_() {
            return this._$_renderer$_;
        }
        _$GetTexture$_() {
            return this._$_texture$_;
        }
        _$GetProjectionMatrix$_() {
            return this._$_renderer$_._$GetFovY$_() === this._$_lastFov$_ && this._$_renderer$_._$GetNearZ$_() === this._$_lastNearZ$_ && this._$_renderer$_._$GetFarZ$_() === this._$_lastFarZ$_ || this._$_CalculateProjection$_(), 
            this._$_projectionMatrix$_;
        }
        _$IsLinearSampling$_() {
            return "nearest" !== this._$_sampling$_;
        }
        _$HasAlpha$_() {
            return this._$_alpha$_;
        }
        _$IsSampled$_() {
            return this._$_isSampled$_;
        }
        _$HasDepthBuffer$_() {
            return this._$_depth$_;
        }
        _$GetWidth$_() {
            return this._$_width$_;
        }
        _$GetHeight$_() {
            return this._$_height$_;
        }
        _$IsDefaultSize$_() {
            return this._$_isDefaultSize$_;
        }
        _$GetMultisampling$_() {
            return this._$_multisampling$_;
        }
        _$GetOptions$_() {
            const t = {
                _$sampling$_: this._$_sampling$_,
                alpha: this._$_alpha$_,
                _$isSampled$_: this._$_isSampled$_
            };
            return this._$_isDefaultSize$_ || (t.width = this._$_width$_, t.height = this._$_height$_), 
            t;
        }
        _$IsCompatibleWithOptions$_(t) {
            return "nearest" !== (t = Object.assign({}, bi, t))._$sampling$_ === this._$IsLinearSampling$_() && !!t.alpha === this._$HasAlpha$_() && !!t.depth === this._$HasDepthBuffer$_() && !(2 <= this._$_renderer$_._$GetWebGLVersionNumber$_() && !!t._$isSampled$_ !== this._$IsSampled$_()) && ("number" == typeof t.width || "number" == typeof t.height ? !this._$IsDefaultSize$_() && this._$GetWidth$_() === Math.floor(t.width) && this._$GetHeight$_() === Math.floor(t.height) : this._$IsDefaultSize$_());
        }
        _$_GetWebGLTexture$_() {
            return this._$_texture$_ ? this._$_texture$_._$_GetTexture$_() : null;
        }
        _$GetEstimatedMemoryUsage$_() {
            return this._$_texture$_ ? this._$_texture$_._$GetEstimatedMemoryUsage$_() : this._$_width$_ * this._$_height$_ * (this._$_alpha$_ ? 4 : 3);
        }
        static async _$DebugReadPixelsToBlob$_(t, s) {
            const i = await t._$ReadBackRenderTargetToImageData$_(s, !0);
            return yi._$ImageDataToBlob$_(i);
        }
        static _$OnContextLost$_() {
            Mi.clear();
        }
        static _$allRenderTargets$_() {
            return Mi.values();
        }
        static _$ResizeAll$_(t, s) {
            for (const i of Mi) i._$IsDefaultSize$_() && i._$_Resize$_(t, s);
        }
    };
}

{
    const m = self._$C3$_, vi = self._$glMatrix$_, Gh = vi._$vec3$_, xh = vi._$mat4$_, xi = new Set([ "aPos", "aTex", "aPoints", "matP", "matMV", "samplerFront", "samplerBack", "samplerDepth", "destStart", "destEnd", "srcStart", "srcEnd", "srcOriginStart", "srcOriginEnd", "pixelSize", "seconds", "devicePixelRatio", "layerScale", "layerAngle", "layoutStart", "layoutEnd", "color", "color2_", "pointTexStart", "pointTexEnd", "zElevation", "tileSize", "tileSpacing", "outlineThickness", "zNear", "zFar" ]);
    m._$Gfx$_._$WebGLShaderProgram$_ = class extends m._$Gfx$_._$ShaderProgramBase$_ {
        static async _$Compile$_(t, s) {
            const i = t._$GetContext$_(), e = s.src, h = s._$vertexSrc$_, r = s.name, n = i.createShader(i.FRAGMENT_SHADER), o = (i.shaderSource(n, e), 
            i.compileShader(n), i.createShader(i.VERTEX_SHADER)), a = (i.shaderSource(o, h), 
            i.compileShader(o), i.createProgram()), l = (i.attachShader(a, n), i.attachShader(a, o), 
            i.bindAttribLocation(a, 0, "aPos"), i.bindAttribLocation(a, 1, "aTex"), 
            i.bindAttribLocation(a, 2, "aPoints"), i.linkProgram(a), t._$_GetParallelShaderCompileExtension$_());
            if (l ? await t._$_WaitForObjectReady$_(() => i.getProgramParameter(a, l.COMPLETION_STATUS_KHR)) : await m._$Wait$_(5), 
            !i.getShaderParameter(n, i.COMPILE_STATUS)) {
                const c = i.getShaderInfoLog(n);
                throw i.deleteShader(n), i.deleteShader(o), i.deleteProgram(a), 
                new Error("Error compiling fragment shader: " + c);
            }
            if (!i.getShaderParameter(o, i.COMPILE_STATUS)) {
                const f = i.getShaderInfoLog(o);
                throw i.deleteShader(n), i.deleteShader(o), i.deleteProgram(a), 
                new Error("Error compiling vertex shader: " + f);
            }
            if (!i.getProgramParameter(a, i.LINK_STATUS)) {
                const d = i.getProgramInfoLog(a);
                throw i.deleteShader(n), i.deleteShader(o), i.deleteProgram(a), 
                new Error("Error linking shader program: " + d);
            }
            const u = m._$FilterUnprintableChars$_(i.getProgramInfoLog(a) || "").trim();
            return u && !m._$IsStringAllWhitespace$_(u) && console.info(`[WebGL] Shader program '${r}' compilation log: `, u), 
            i.deleteShader(n), i.deleteShader(o), a;
        }
        static async _$Create$_(t, s) {
            const i = await m._$Gfx$_._$WebGLShaderProgram$_._$Compile$_(t, s);
            return new m._$Gfx$_._$WebGLShaderProgram$_(t, i, s);
        }
        constructor(t, s, i) {
            super(t, i);
            const e = t._$GetContext$_(), h = t._$GetBatchState$_(), r = (t._$EndBatch$_(), 
            e.useProgram(s), this._$_gl$_ = e, this._$_shaderProgram$_ = s, this._$_isDeviceTransform$_ = "<default-device-transform>" === i.name, 
            e.getAttribLocation(s, "aPos")), n = e.getAttribLocation(s, "aTex"), o = (this._$_locAPoints$_ = e.getAttribLocation(s, "aPoints"), 
            -1 !== r && (e.bindBuffer(e.ARRAY_BUFFER, t._$_vertexBuffer$_), e.vertexAttribPointer(r, t._$GetNumVertexComponents$_(), e.FLOAT, !1, 0, 0), 
            e.enableVertexAttribArray(r)), -1 !== n && (e.bindBuffer(e.ARRAY_BUFFER, t._$_texcoordBuffer$_), 
            e.vertexAttribPointer(n, 2, e.FLOAT, !1, 0, 0), e.enableVertexAttribArray(n)), 
            -1 !== this._$_locAPoints$_ && (e.bindBuffer(e.ARRAY_BUFFER, t._$_pointBuffer$_), 
            e.vertexAttribPointer(this._$_locAPoints$_, 4, e.FLOAT, !1, 0, 0), e.enableVertexAttribArray(this._$_locAPoints$_)), 
            e.bindBuffer(e.ARRAY_BUFFER, null), this._$_uMatP$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "matP", "mat4"), 
            this._$_uMatMV$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "matMV", "mat4"), 
            this._$_uColor$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "color", "vec4"), 
            this._$_uSamplerFront$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "samplerFront", "sampler"), 
            this._$_uPointTexStart$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "pointTexStart", "vec2"), 
            this._$_uPointTexEnd$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "pointTexEnd", "vec2"), 
            this._$_uZElevation$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "zElevation", "float"), 
            this._$_uTileSize$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "tileSize", "vec2"), 
            this._$_uTileSpacing$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "tileSpacing", "vec2"), 
            this._$_uColor2$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "color2_", "vec4"), 
            this._$_uOutlineThickness$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "outlineThickness", "float"), 
            this._$_uSamplerBack$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "samplerBack", "sampler"), 
            this._$_uSamplerDepth$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "samplerDepth", "sampler"), 
            this._$_uDestStart$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "destStart", "vec2"), 
            this._$_uDestEnd$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "destEnd", "vec2"), 
            this._$_uSrcStart$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "srcStart", "vec2"), 
            this._$_uSrcEnd$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "srcEnd", "vec2"), 
            this._$_uSrcOriginStart$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "srcOriginStart", "vec2"), 
            this._$_uSrcOriginEnd$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "srcOriginEnd", "vec2"), 
            this._$_uPixelSize$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "pixelSize", "vec2"), 
            this._$_uSeconds$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "seconds", "float"), 
            this._$_uDevicePixelRatio$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "devicePixelRatio", "float"), 
            this._$_uLayerScale$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "layerScale", "float"), 
            this._$_uLayerAngle$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "layerAngle", "float"), 
            this._$_uLayoutStart$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "layoutStart", "vec2"), 
            this._$_uLayoutEnd$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "layoutEnd", "vec2"), 
            this._$_uZNear$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "zNear", "float"), 
            this._$_uZFar$_ = new m._$Gfx$_._$WebGLShaderUniform$_(this, "zFar", "float"), 
            this._$_hasAnyOptionalUniforms$_ = !!(this._$_uPixelSize$_._$IsUsed$_() || this._$_uSeconds$_._$IsUsed$_() || this._$_uSamplerBack$_._$IsUsed$_() || this._$_uDestStart$_._$IsUsed$_() || this._$_uDestEnd$_._$IsUsed$_() || this._$_uSrcStart$_._$IsUsed$_() || this._$_uSrcEnd$_._$IsUsed$_() || this._$_uSrcOriginStart$_._$IsUsed$_() || this._$_uSrcOriginEnd$_._$IsUsed$_() || this._$_uDevicePixelRatio$_._$IsUsed$_() || this._$_uLayerScale$_._$IsUsed$_() || this._$_uLayerAngle$_._$IsUsed$_() || this._$_uLayoutStart$_._$IsUsed$_() || this._$_uLayoutEnd$_._$IsUsed$_()), 
            i.parameters || []);
            this._$_uCustomParameters$_ = [], this._$_usesAnySrcRectOrPixelSize$_ = this._$_uPixelSize$_._$IsUsed$_() || this._$_uSrcStart$_._$IsUsed$_() || this._$_uSrcEnd$_._$IsUsed$_() || this._$_uSrcOriginStart$_._$IsUsed$_() || this._$_uSrcOriginEnd$_._$IsUsed$_(), 
            this._$_hasCurrentMatP$_ = !1, this._$_hasCurrentMatMV$_ = !1, this._$_uColor$_._$Init4f$_(1, 1, 1, 1), 
            this._$_uColor2$_._$Init4f$_(1, 1, 1, 1), this._$_uSamplerFront$_._$Init1i$_(0), 
            this._$_uSamplerBack$_._$Init1i$_(1), this._$_uSamplerDepth$_._$Init1i$_(2), 
            this._$_uPointTexStart$_._$Init2f$_(0, 0), this._$_uPointTexEnd$_._$Init2f$_(1, 1), 
            this._$_uZElevation$_._$Init1f$_(0), this._$_uTileSize$_._$Init2f$_(0, 0), 
            this._$_uTileSpacing$_._$Init2f$_(0, 0), this._$_uDestStart$_._$Init2f$_(0, 0), 
            this._$_uDestEnd$_._$Init2f$_(1, 1), this._$_uSrcStart$_._$Init2f$_(0, 0), 
            this._$_uSrcEnd$_._$Init2f$_(0, 0), this._$_uSrcOriginStart$_._$Init2f$_(0, 0), 
            this._$_uSrcOriginEnd$_._$Init2f$_(0, 0), this._$_uPixelSize$_._$Init2f$_(0, 0), 
            this._$_uDevicePixelRatio$_._$Init1f$_(1), this._$_uZNear$_._$Init1f$_(t._$GetNearZ$_()), 
            this._$_uZFar$_._$Init1f$_(t._$GetFarZ$_()), this._$_uLayerScale$_._$Init1f$_(1), 
            this._$_uLayerAngle$_._$Init1f$_(0), this._$_uSeconds$_._$Init1f$_(0), 
            this._$_uLayoutStart$_._$Init2f$_(0, 0), this._$_uLayoutEnd$_._$Init2f$_(0, 0), 
            this._$_uOutlineThickness$_._$Init1f$_(1);
            for (const l of o) {
                const u = l[0], c = l[2], f = new m._$Gfx$_._$WebGLShaderUniform$_(this, u, c);
                "color" === c ? f._$Init3f$_(0, 0, 0) : f._$Init1f$_(0), this._$_uCustomParameters$_.push(f);
            }
            this._$_isDeviceTransform$_ ? this._$_UpdateDeviceTransformUniforms$_(h._$currentMatP$_) : (this._$UpdateMatP$_(h._$currentMatP$_, !0), 
            this._$UpdateMatMV$_(h._$currentMV$_, !0));
            const a = h._$currentShader$_;
            e.useProgram(a ? a._$_shaderProgram$_ : null);
        }
        _$Release$_() {
            this._$_gl$_.deleteProgram(this._$_shaderProgram$_), this._$_shaderProgram$_ = null, 
            this._$_renderer$_._$_RemoveShaderProgram$_(this), this._$_gl$_ = null, 
            super._$Release$_();
        }
        _$GetWebGLContext$_() {
            return this._$_gl$_;
        }
        _$GetShaderProgram$_() {
            return this._$_shaderProgram$_;
        }
        _$GetParameterCount$_() {
            return this._$_uCustomParameters$_.length;
        }
        _$GetParameterType$_(t) {
            return t < 0 || t >= this._$_uCustomParameters$_.length ? null : this._$_uCustomParameters$_[t]._$GetType$_();
        }
        _$AreCustomParametersAlreadySetInBatch$_(i) {
            for (let t = 0, s = i.length; t < s; ++t) if (!this._$_uCustomParameters$_[t]._$IsSetToCustomInBatch$_(i[t])) return !1;
            return !0;
        }
        _$SetCustomParametersInBatch$_(i) {
            for (let t = 0, s = i.length; t < s; ++t) this._$_uCustomParameters$_[t]._$SetBatchValueCustom$_(i[t]);
        }
        _$AreOptionalUniformsAlreadySetInBatch$_(t, s, i, e, h, r, n, o, a, l) {
            return !this._$_uSamplerBack$_._$IsUsed$_() && !(this._$_uPixelSize$_._$IsUsed$_() && !this._$_uPixelSize$_._$IsSetTo2InBatch$_(h, r) || this._$_uDestStart$_._$IsUsed$_() && !this._$_uDestStart$_._$IsSetTo2InBatch$_(t._$getLeft$_(), t._$getTop$_()) || this._$_uDestEnd$_._$IsUsed$_() && !this._$_uDestEnd$_._$IsSetTo2InBatch$_(t._$getRight$_(), t._$getBottom$_()) || this._$_uDevicePixelRatio$_._$IsUsed$_() && !this._$_uDevicePixelRatio$_._$IsSetTo1InBatch$_(n) || this._$_uLayerScale$_._$IsUsed$_() && !this._$_uLayerScale$_._$IsSetTo1InBatch$_(o) || this._$_uLayerAngle$_._$IsUsed$_() && !this._$_uLayerAngle$_._$IsSetTo1InBatch$_(a) || this._$_uSrcStart$_._$IsUsed$_() && !this._$_uSrcStart$_._$IsSetTo2InBatch$_(s._$getLeft$_(), s._$getTop$_()) || this._$_uSrcEnd$_._$IsUsed$_() && !this._$_uSrcEnd$_._$IsSetTo2InBatch$_(s._$getRight$_(), s._$getBottom$_()) || this._$_uSrcOriginStart$_._$IsUsed$_() && !this._$_uSrcOriginStart$_._$IsSetTo2InBatch$_(i._$getLeft$_(), i._$getTop$_()) || this._$_uSrcOriginEnd$_._$IsUsed$_() && !this._$_uSrcOriginEnd$_._$IsSetTo2InBatch$_(i._$getRight$_(), i._$getBottom$_()) || this._$_uLayoutStart$_._$IsUsed$_() && !this._$_uLayoutStart$_._$IsSetTo2InBatch$_(e._$getLeft$_(), e._$getTop$_()) || this._$_uLayoutEnd$_._$IsUsed$_() && !this._$_uLayoutEnd$_._$IsSetTo2InBatch$_(e._$getTop$_(), e._$getBottom$_()) || this._$_uSeconds$_._$IsUsed$_() && !this._$_uSeconds$_._$IsSetTo1InBatch$_(l));
        }
        _$SetOptionalUniformsInBatch$_(t, s, i, e, h, r, n, o, a, l) {
            this._$_uSamplerBack$_._$IsUsed$_() || (this._$_uPixelSize$_._$IsUsed$_() && this._$_uPixelSize$_._$SetBatch2$_(h, r), 
            this._$_uDestStart$_._$IsUsed$_() && this._$_uDestStart$_._$SetBatch2$_(t._$getLeft$_(), t._$getTop$_()), 
            this._$_uDestEnd$_._$IsUsed$_() && this._$_uDestEnd$_._$SetBatch2$_(t._$getRight$_(), t._$getBottom$_()), 
            this._$_uDevicePixelRatio$_._$IsUsed$_() && this._$_uDevicePixelRatio$_._$SetBatch1$_(n), 
            this._$_uLayerScale$_._$IsUsed$_() && this._$_uLayerScale$_._$SetBatch1$_(o), 
            this._$_uLayerAngle$_._$IsUsed$_() && this._$_uLayerAngle$_._$SetBatch1$_(a), 
            this._$_uSrcStart$_._$IsUsed$_() && this._$_uSrcStart$_._$SetBatch2$_(s._$getLeft$_(), s._$getTop$_()), 
            this._$_uSrcEnd$_._$IsUsed$_() && this._$_uSrcEnd$_._$SetBatch2$_(s._$getRight$_(), s._$getBottom$_()), 
            this._$_uSrcOriginStart$_._$IsUsed$_() && this._$_uSrcOriginStart$_._$SetBatch2$_(i._$getLeft$_(), i._$getTop$_()), 
            this._$_uSrcOriginEnd$_._$IsUsed$_() && this._$_uSrcOriginEnd$_._$SetBatch2$_(i._$getRight$_(), i._$getBottom$_()), 
            this._$_uLayoutStart$_._$IsUsed$_() && this._$_uLayoutStart$_._$SetBatch2$_(e._$getLeft$_(), e._$getTop$_()), 
            this._$_uLayoutEnd$_._$IsUsed$_() && this._$_uLayoutEnd$_._$SetBatch2$_(e._$getTop$_(), e._$getBottom$_()), 
            this._$_uSeconds$_._$IsUsed$_() && this._$_uSeconds$_._$SetBatch1$_(l));
        }
        _$UpdateMatP$_(t, s) {
            this._$_hasCurrentMatP$_ && !s || this._$_isDeviceTransform$_ || (this._$_uMatP$_._$IsUsed$_() && this._$_uMatP$_._$UpdateMatrix4fv$_(t), 
            this._$_hasCurrentMatP$_ = !0);
        }
        _$SetMatPStale$_() {
            this._$_hasCurrentMatP$_ = !1;
        }
        _$UpdateMatMV$_(t, s) {
            this._$_hasCurrentMatMV$_ && !s || this._$_isDeviceTransform$_ || (this._$_uMatMV$_._$IsUsed$_() && this._$_uMatMV$_._$UpdateMatrix4fv$_(t), 
            this._$_hasCurrentMatMV$_ = !0);
        }
        _$SetMatMVStale$_() {
            this._$_hasCurrentMatMV$_ = !1;
        }
        _$_UpdateDeviceTransformUniforms$_(t) {
            if (!this._$_isDeviceTransform$_) throw new Error("not device transform shader");
            this._$_uMatP$_._$UpdateMatrix4fv$_(t);
            const s = this._$_renderer$_, i = s._$GetWidth$_() / 2, e = s._$GetHeight$_() / 2, h = s._$CalculateLookAtModelView2$_(i, e, s._$GetDefaultCameraZ$_(s._$GetHeight$_()), i, e, 0, s._$GetHeight$_());
            this._$_uMatMV$_._$UpdateMatrix4fv$_(h);
        }
        _$UpdateColor$_(t) {
            this._$_uColor$_._$IsUsed$_() && this._$_uColor$_._$Update4f$_(t[0], t[1], t[2], t[3]);
        }
        static _$GetReservedUniformNames$_() {
            return xi;
        }
        static _$GetDefaultVertexShaderSource$_(t) {
            const s = t ? "highmedp" : "mediump";
            return [ "#ifdef GL_FRAGMENT_PRECISION_HIGH", "#define highmedp highp", "#else", "#define highmedp mediump", "#endif", "attribute highp vec3 aPos;", `attribute ${s} vec2 aTex;`, `varying ${s} vec2 vTex;`, "uniform highp mat4 matP;", "uniform highp mat4 matMV;", "void main(void) {", `	gl_Position = matP * matMV * vec4(aPos, 1.0);`, `	vTex = aTex;`, "}" ].join("\n");
        }
        static _$GetDefaultVertexShaderSource_WebGL2$_(t) {
            const s = t ? "highp" : "mediump";
            return [ "#version 300 es", "in highp vec3 aPos;", `in ${s} vec2 aTex;`, `out ${s} vec2 vTex;`, "uniform highp mat4 matP;", "uniform highp mat4 matMV;", "void main(void) {", `	gl_Position = matP * matMV * vec4(aPos, 1.0);`, `	vTex = aTex;`, "}" ].join("\n");
        }
        static _$GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth$_() {
            return [ "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "\tgl_FragColor = texture2D(samplerFront, vTex) * color;", "}" ].join("\n");
        }
        static _$GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT$_() {
            return [ "#extension GL_EXT_frag_depth : enable", "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "\tgl_FragColor = texture2D(samplerFront, vTex) * color;", "\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}" ].join("\n");
        }
        static _$GetTextureFillFragmentShaderSource_WebGL2$_() {
            return [ "#version 300 es", "in mediump vec2 vTex;", "out lowp vec4 outColor;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "\toutColor = texture(samplerFront, vTex) * color;", "\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}" ].join("\n");
        }
        static _$GetTilemapFragmentShaderSource_WebGL1_NoFragDepth$_() {
            return [ "#ifdef GL_FRAGMENT_PRECISION_HIGH", "#define highmedp highp", "#else", "#define highmedp mediump", "#endif", "varying highmedp vec2 vTex;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "uniform highmedp vec2 srcStart;", "uniform highmedp vec2 pixelSize;", "uniform highmedp vec2 tileSize;", "uniform highmedp vec2 tileSpacing;", "void main(void) {", "\thighmedp vec2 tile = floor(vTex);", "\thighmedp vec2 tex = fract(vTex);", "\thighmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "\thighmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "\thighmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;", "}" ].join("\n");
        }
        static _$GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT$_() {
            return [ "#extension GL_EXT_frag_depth : enable", "#ifdef GL_FRAGMENT_PRECISION_HIGH", "#define highmedp highp", "#else", "#define highmedp mediump", "#endif", "varying highmedp vec2 vTex;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "uniform highmedp vec2 srcStart;", "uniform highmedp vec2 pixelSize;", "uniform highmedp vec2 tileSize;", "uniform highmedp vec2 tileSpacing;", "void main(void) {", "\thighmedp vec2 tile = floor(vTex);", "\thighmedp vec2 tex = fract(vTex);", "\thighmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "\thighmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "\thighmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;", "\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}" ].join("\n");
        }
        static _$GetTilemapFragmentShaderSource_WebGL2$_() {
            return [ "#version 300 es", "in highp vec2 vTex;", "out lowp vec4 outColor;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "uniform highp vec2 srcStart;", "uniform highp vec2 pixelSize;", "uniform highp vec2 tileSize;", "uniform highp vec2 tileSpacing;", "void main(void) {", "\thighp vec2 tile = floor(vTex);", "\thighp vec2 tex = fract(vTex);", "\thighp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "\thighp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "\thighp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "\toutColor = texture(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;", "\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}" ].join("\n");
        }
        static _$GetTileRandomizationFragmentShaderSource$_(t, s, i) {
            let e = "";
            return 2 <= t ? e = "#version 300 es\n" : (s && (e = "#extension GL_EXT_frag_depth : enable\n"), 
            i && (e += "#extension GL_EXT_shader_texture_lod : enable\n#extension GL_OES_standard_derivatives : enable\n")), 
            e + `
#ifdef GL_FRAGMENT_PRECISION_HIGH
#define highmedp highp
#else
#define highmedp mediump
#endif
precision highmedp float;
${2 <= t ? "in" : "varying"} vec2 vTex;
${2 <= t ? "out lowp vec4 outColor;" : ""}
uniform lowp vec4 color;
uniform lowp sampler2D samplerFront;
uniform vec2 pixelSize;

uniform vec2 tileSize;
uniform vec2 tileSpacing;
uniform float outlineThickness;

const float PI = 3.1415926;

lowp vec4 cospVec4(lowp vec4 a, lowp vec4 b, float x)
{
	return (a + b + (a - b) * cos(x * PI)) / 2.0;
}

vec3 randVec3(vec2 seed)
{
	return vec3(fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(12.9898,78.233))) * 43758.5453),
				fract(sin(dot(seed.yx + vec2(0.1, 0.1), vec2(12.9898,-78.233))) * 43758.5453),
				fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(-12.9898,-78.233))) * 43758.5453));
}

lowp vec4 sampleTile(vec2 tile, vec2 uv, vec2 ddx, vec2 ddy)
{
	vec2 posRandom = tileSize;
	float angleRandom = outlineThickness;
	
	vec3 rand = (randVec3(floor(tile + 0.5)) - 0.5) * 2.0;
	
	float angle = angleRandom * rand.z * PI;
	float sin_a = sin(angle);
	float cos_a = cos(angle);
	float aspect = pixelSize.x / pixelSize.y;

	vec2 mid = tile + vec2(0.5, 0.5);
	vec2 dp = uv - mid;
	dp.x /= aspect;
	vec2 r = vec2(dp.x * cos_a - dp.y * sin_a,
				  dp.y * cos_a + dp.x * sin_a);
	r.x *= aspect;

	vec2 p = mid + r + (posRandom * rand.xy / 2.0);
	
	${2 <= t ? "return textureGrad(samplerFront, p, ddx, ddy);" : ""}
	${t < 2 && i ? "return texture2DGradEXT(samplerFront, p, ddx, ddy);" : ""}
	${t < 2 && !i ? "return texture2D(samplerFront, p);" : ""}
}

void main(void) {
	
	${t < 2 ? "lowp vec4 outColor;" : ""}
	
	float blendMarginX = tileSpacing.x;
	float blendMarginY = tileSpacing.y;
	
	vec2 tile = floor(vTex);
	vec2 tex = fract(vTex);
	vec2 ddx = ${2 <= t || i ? "dFdx(vTex)" : "vec2(0.0, 0.0)"};
	vec2 ddy = ${2 <= t || i ? "dFdy(vTex)" : "vec2(0.0, 0.0)"};
	
	vec4 curTile = sampleTile(tile, vTex, ddx, ddy);
	
	bool inLeftMargin = (tex.x < blendMarginX);
	bool inRightMargin = (tex.x > 1.0 - blendMarginX);
	bool inTopMargin = (tex.y < blendMarginY);
	bool inBottomMargin = (tex.y > 1.0 - blendMarginY);
	
	if (inLeftMargin)
	{
		lowp vec4 leftTile = sampleTile(tile + vec2(-1.0, 0.0), vTex, ddx, ddy);
		float leftMix = (tex.x / (blendMarginX * 2.0)) + 0.5;
		lowp vec4 leftMixedTile = cospVec4(leftTile, curTile, leftMix);
		
		if (inTopMargin)
		{
			lowp vec4 topTile =     sampleTile(tile + vec2(0.0,  -1.0), vTex, ddx, ddy);
			lowp vec4 topLeftTile = sampleTile(tile + vec2(-1.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topLeftMixedTile = cospVec4(topLeftTile, topTile, leftMix);
			
			outColor = cospVec4(topLeftMixedTile, leftMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
		}
		else if (inBottomMargin)
		{
			lowp vec4 bottomTile =     sampleTile(tile + vec2(0.0,  1.0), vTex, ddx, ddy);
			lowp vec4 bottomLeftTile = sampleTile(tile + vec2(-1.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomLeftMixedTile = cospVec4(bottomLeftTile, bottomTile, leftMix);
			
			outColor = cospVec4(leftMixedTile, bottomLeftMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
		}
		else
		{
			outColor = leftMixedTile;
		}
	}
	else if (inRightMargin)
	{
		lowp vec4 rightTile = sampleTile(tile + vec2(1.0, 0.0), vTex, ddx, ddy);
		float rightMix = (tex.x - (1.0 - blendMarginX)) / (blendMarginX * 2.0);
		lowp vec4 rightMixedTile = cospVec4(curTile, rightTile, rightMix);
		
		if (inTopMargin)
		{
			lowp vec4 topTile =      sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topRightTile = sampleTile(tile + vec2(1.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topRightMixedTile = cospVec4(topTile, topRightTile, rightMix);
			
			outColor = cospVec4(topRightMixedTile, rightMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
		}
		else if (inBottomMargin)
		{
			lowp vec4 bottomTile =      sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomRightTile = sampleTile(tile + vec2(1.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomRightMixedTile = cospVec4(bottomTile, bottomRightTile, rightMix);
			
			outColor = cospVec4(rightMixedTile, bottomRightMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
		}
		else
		{
			outColor = rightMixedTile;
		}
	}
	else if (inTopMargin)
	{
		lowp vec4 topTile = sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);
		outColor = cospVec4(topTile, curTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
	}
	else if (inBottomMargin)
	{
		lowp vec4 bottomTile = sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);
		outColor = cospVec4(curTile, bottomTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
	}
	else
	{
		outColor = curTile;
	}
	
	outColor *= color;
	${t < 2 ? "gl_FragColor = outColor;" : ""}
	${2 <= t ? "gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}
	${t < 2 && s ? "gl_FragDepthEXT = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}
}
`;
        }
        static _$GetPointVertexShaderSource_WebGL1$_() {
            return [ "attribute vec4 aPoints;", "varying float pointOpacity;", "uniform float zElevation;", "uniform mat4 matP;", "uniform mat4 matMV;", "void main(void) {", "\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);", "\tgl_PointSize = aPoints.z;", "\tpointOpacity = aPoints.w;", "}" ].join("\n");
        }
        static _$GetPointVertexShaderSource_WebGL2$_() {
            return [ "#version 300 es", "in vec4 aPoints;", "out float pointOpacity;", "uniform float zElevation;", "uniform mat4 matP;", "uniform mat4 matMV;", "void main(void) {", "\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);", "\tgl_PointSize = aPoints.z;", "\tpointOpacity = aPoints.w;", "}" ].join("\n");
        }
        static _$GetPointFragmentShaderSource_WebGL1_NoFragDepth$_() {
            return [ "uniform lowp sampler2D samplerFront;", "varying lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "void main(void) {", "\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "\tgl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "}" ].join("\n");
        }
        static _$GetPointFragmentShaderSource_WebGL1_FragDepthEXT$_() {
            return [ "#extension GL_EXT_frag_depth : enable", "uniform lowp sampler2D samplerFront;", "varying lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "void main(void) {", "\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "\tgl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}" ].join("\n");
        }
        static _$GetPointFragmentShaderSource_WebGL2$_() {
            return [ "#version 300 es", "uniform lowp sampler2D samplerFront;", "in lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "out lowp vec4 outColor;", "void main(void) {", "\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "\toutColor = texture(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}" ].join("\n");
        }
        static _$GetColorFillFragmentShaderSource$_() {
            return [ "uniform lowp vec4 color;", "void main(void) {", "\tgl_FragColor = color;", "}" ].join("\n");
        }
        static _$GetLinearGradientFillFragmentShaderSource$_() {
            return [ "precision lowp float;", "varying mediump vec2 vTex;", "uniform vec4 color;", "uniform vec4 color2_;", "vec3 fromLinear(vec3 linearRGB)", "{", "\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));", "\tvec3 higher = vec3(1.055) * pow(abs(linearRGB), vec3(1.0/2.4)) - vec3(0.055);", "\tvec3 lower = linearRGB * vec3(12.92);", "\treturn mix(higher, lower, vec3(cutoff));", "}", "vec3 toLinear(vec3 sRGB)", "{", "\tbvec3 cutoff = lessThan(sRGB, vec3(0.04045));", "\tvec3 higher = pow(abs((sRGB + vec3(0.055))/vec3(1.055)), vec3(2.4));", "\tvec3 lower = sRGB/vec3(12.92);", "\treturn mix(higher, lower, vec3(cutoff));", "}", "void main(void) {", "\tvec3 linearGrad = mix(toLinear(color.rgb), toLinear(color2_.rgb), vTex.x);", "\tfloat a = mix(color.a, color2_.a, vTex.x);", "\tgl_FragColor = vec4(fromLinear(linearGrad) * a, a);", "}" ].join("\n");
        }
        static _$GetPenumbraFillFragmentShaderSource$_() {
            return [ "#ifdef GL_FRAGMENT_PRECISION_HIGH", "#define highmedp highp", "#else", "#define highmedp mediump", "#endif", "precision lowp float;", "varying highmedp vec2 vTex;", "uniform vec4 color;", "void main(void) {", `	highmedp float grad = vTex.x / (1.0 - vTex.y);`, `	gl_FragColor = color * (1.0 - (cos(grad * 3.141592653589793) + 1.0) / 2.0);`, "}" ].join("\n");
        }
        static _$GetSmoothLineFillFragmentShaderSource$_() {
            return [ "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "void main(void) {", "\tlowp float f = 1.0 - abs(vTex.y - 0.5) * 2.0;", "\tgl_FragColor = color * f;", "}" ].join("\n");
        }
        static _$GetHardEllipseFillFragmentShaderSource$_() {
            return [ "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "void main(void) {", "\tmediump vec2 diff = vTex - vec2(0.5, 0.5);", "\tmediump vec2 diffSq = diff * diff;", "\tmediump float f = step(diffSq.x + diffSq.y, 0.25);", "\tgl_FragColor = color * f;", "}" ].join("\n");
        }
        static _$GetHardEllipseOutlineFragmentShaderSource$_() {
            return [ "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform mediump vec2 pixelSize;", "uniform mediump float outlineThickness;", "void main(void) {", "\tmediump vec2 diff = vTex - vec2(0.5, 0.5);", "\tmediump vec2 diffSq = diff * diff;", "\tmediump float distSq = diffSq.x + diffSq.y;", "\tmediump vec2 norm = normalize(diff);", "\tmediump vec2 halfNorm = norm * 0.5;", "\tmediump float innerF = step(distSq, 0.25);", "\tmediump vec2 innerEdge = halfNorm - pixelSize * norm * outlineThickness;", "\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;", "\tmediump float outerF = step(innerEdgeSq.x + innerEdgeSq.y, distSq);", "\tgl_FragColor = color * innerF * outerF;", "}" ].join("\n");
        }
        static _$GetSmoothEllipseFillFragmentShaderSource$_() {
            return [ "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform mediump vec2 pixelSize;", "void main(void) {", "\tmediump vec2 diff = vTex - vec2(0.5, 0.5);", "\tmediump vec2 diffSq = diff * diff;", "\tmediump vec2 norm = normalize(diff);", "\tmediump vec2 halfNorm = norm * 0.5;", "\tmediump vec2 halfNormSq = halfNorm * halfNorm;", "\tmediump vec2 innerEdge = halfNorm - pixelSize * norm;", "\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;", "\tmediump float f = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);", "\tgl_FragColor = color * f;", "}" ].join("\n");
        }
        static _$GetSmoothEllipseOutlineFragmentShaderSource$_() {
            return [ "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform mediump vec2 pixelSize;", "uniform mediump float outlineThickness;", "void main(void) {", "\tmediump vec2 diff = vTex - vec2(0.5, 0.5);", "\tmediump vec2 diffSq = diff * diff;", "\tmediump float distSq = diffSq.x + diffSq.y;", "\tmediump vec2 norm = normalize(diff);", "\tmediump vec2 halfNorm = norm * 0.5;", "\tmediump vec2 halfNormSq = halfNorm * halfNorm;", "\tmediump vec2 pxNorm = pixelSize * norm;", "\tmediump vec2 innerEdge1 = halfNorm - pxNorm;", "\tmediump vec2 innerEdge1Sq = innerEdge1 * innerEdge1;", "\tmediump float innerF = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);", "\tmediump vec2 innerEdge2 = halfNorm - pxNorm * outlineThickness;", "\tmediump vec2 innerEdge2Sq = innerEdge2 * innerEdge2;", "\tmediump vec2 innerEdge3 = halfNorm - pxNorm * (outlineThickness + 1.0);", "\tmediump vec2 innerEdge3Sq = innerEdge3 * innerEdge3;", "\tmediump float outerF = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);", "\tgl_FragColor = color * innerF * outerF;", "}" ].join("\n");
        }
    };
}

{
    const Gi = self._$C3$_, Ti = self._$glMatrix$_, xh = Ti._$mat4$_, _i = new Map([ [ "float", 1 ], [ "percent", 1 ], [ "sampler", 1 ], [ "vec2", 2 ], [ "vec3", 3 ], [ "color", 3 ], [ "vec4", 4 ], [ "mat4", 16 ] ]);
    Gi._$Gfx$_._$WebGLShaderUniform$_ = class {
        constructor(t, s, i) {
            if (!_i.has(i)) throw new Error("invalid uniform type");
            this._$_owner$_ = t, this._$_gl$_ = this._$_owner$_._$GetWebGLContext$_(), 
            this._$_name$_ = s, this._$_type$_ = i, this._$_isColorType$_ = "color" === this._$_type$_, 
            this._$_location$_ = this._$_gl$_.getUniformLocation(this._$_owner$_._$GetShaderProgram$_(), s), 
            this._$_isUsed$_ = !!this._$_location$_;
            const e = _i.get(i);
            this._$_lastValue$_ = new Float32Array(e), this._$_lastBatchValue$_ = new Float32Array(e);
        }
        _$Release$_() {
            this._$_owner$_ = null, this._$_gl$_ = null, this._$_location$_ = null;
        }
        _$IsUsed$_() {
            return this._$_isUsed$_;
        }
        _$GetType$_() {
            return this._$_type$_;
        }
        _$IsColorType$_() {
            return this._$_isColorType$_;
        }
        _$Init1f$_(t) {
            this._$IsUsed$_() && (this._$_lastValue$_[0] = t, this._$_lastBatchValue$_.set(this._$_lastValue$_), 
            this._$_gl$_.uniform1f(this._$_location$_, t));
        }
        _$Init1i$_(t) {
            this._$IsUsed$_() && (this._$_lastValue$_[0] = t, this._$_lastBatchValue$_.set(this._$_lastValue$_), 
            this._$_gl$_.uniform1i(this._$_location$_, t));
        }
        _$Init2f$_(t, s) {
            this._$IsUsed$_() && (this._$_lastValue$_[0] = t, this._$_lastValue$_[1] = s, 
            this._$_lastBatchValue$_.set(this._$_lastValue$_), this._$_gl$_.uniform2f(this._$_location$_, t, s));
        }
        _$Init3f$_(t, s, i) {
            this._$IsUsed$_() && (this._$_lastValue$_[0] = t, this._$_lastValue$_[1] = s, 
            this._$_lastValue$_[2] = i, this._$_lastBatchValue$_.set(this._$_lastValue$_), 
            this._$_gl$_.uniform3f(this._$_location$_, t, s, i));
        }
        _$Init4f$_(t, s, i, e) {
            this._$IsUsed$_() && (this._$_lastValue$_[0] = t, this._$_lastValue$_[1] = s, 
            this._$_lastValue$_[2] = i, this._$_lastValue$_[3] = e, this._$_lastBatchValue$_.set(this._$_lastValue$_), 
            this._$_gl$_.uniform4f(this._$_location$_, t, s, i, e));
        }
        _$Update1f$_(t) {
            t = Math.fround(t);
            const s = this._$_lastValue$_;
            s[0] !== t && (s[0] = t, this._$_gl$_.uniform1f(this._$_location$_, t));
        }
        _$Update1i$_(t) {
            const s = this._$_lastValue$_;
            s[0] !== t && this._$_gl$_.uniform1i(this._$_location$_, s[0] = t);
        }
        _$Update2f$_(t, s) {
            t = Math.fround(t), s = Math.fround(s);
            const i = this._$_lastValue$_;
            i[0] === t && i[1] === s || (i[0] = t, i[1] = s, this._$_gl$_.uniform2f(this._$_location$_, t, s));
        }
        _$Update3f$_(t, s, i) {
            t = Math.fround(t), s = Math.fround(s), i = Math.fround(i);
            const e = this._$_lastValue$_;
            e[0] === t && e[1] === s && e[2] === i || (e[0] = t, e[1] = s, e[2] = i, 
            this._$_gl$_.uniform3f(this._$_location$_, t, s, i));
        }
        _$Update4f$_(t, s, i, e) {
            t = Math.fround(t), s = Math.fround(s), i = Math.fround(i), e = Math.fround(e);
            const h = this._$_lastValue$_;
            h[0] === t && h[1] === s && h[2] === i && h[3] === e || (h[0] = t, h[1] = s, 
            h[2] = i, h[3] = e, this._$_gl$_.uniform4f(this._$_location$_, t, s, i, e));
        }
        _$UpdateMatrix4fv$_(t) {
            const s = this._$_lastValue$_;
            xh._$exactEquals$_(s, t) || (Gi._$typedArraySet16$_(s, t, 0), this._$_gl$_.uniformMatrix4fv(this._$_location$_, !1, t));
        }
        _$IsSetToCustomInBatch$_(t) {
            const s = this._$_lastBatchValue$_;
            return this._$IsColorType$_() ? s[0] === Math.fround(t._$getR$_()) && s[1] === Math.fround(t._$getG$_()) && s[2] === Math.fround(t._$getB$_()) : s[0] === Math.fround(t);
        }
        _$SetBatchValueCustom$_(t) {
            const s = this._$_lastBatchValue$_;
            this._$IsColorType$_() ? (s[0] = t._$getR$_(), s[1] = t._$getG$_(), 
            s[2] = t._$getB$_()) : s[0] = t;
        }
        _$IsSetTo1InBatch$_(t) {
            return this._$_lastBatchValue$_[0] === Math.fround(t);
        }
        _$IsSetTo2InBatch$_(t, s) {
            const i = this._$_lastBatchValue$_;
            return i[0] === Math.fround(t) && i[1] === Math.fround(s);
        }
        _$SetBatch1$_(t) {
            this._$_lastBatchValue$_[0] = t;
        }
        _$SetBatch2$_(t, s) {
            const i = this._$_lastBatchValue$_;
            i[0] = t, i[1] = s;
        }
    };
}

{
    const Ii = self._$C3$_, Ci = self._$glMatrix$_, Vh = Ci._$vec4$_, xh = Ci._$mat4$_;
    Ii._$Gfx$_._$BatchState$_ = class {
        constructor(t) {
            this.renderer = t, this._$currentMV$_ = xh.create(), this._$currentMatP$_ = xh.create(), 
            this._$currentFramebuffer$_ = null, this._$currentFramebufferNoDepth$_ = null, 
            this._$isDepthSamplingEnabled$_ = !1, this._$currentColor$_ = Vh._$fromValues$_(1, 1, 1, 1), 
            this._$currentShader$_ = null, this._$pointTexCoords$_ = new Ii.Rect(), 
            this.clearColor = Ii._$New$_(Ii._$Color$_, 0, 0, 0, 0);
        }
    }, Ii._$Gfx$_._$WebGLBatchJob$_ = class {
        constructor(t) {
            const s = new ArrayBuffer(96);
            this._$_type$_ = 0, this._$_batchState$_ = t, this._$_gl$_ = t.renderer._$GetContext$_(), 
            this._$_startIndex$_ = 0, this._$_indexCount$_ = 0, this._$_texParam$_ = null, 
            this._$_mat4param$_ = new Float32Array(s, 0, 16), this._$_colorParam$_ = new Float32Array(s, 64, 4), 
            this._$_srcOriginRect$_ = new Float32Array(s, 80, 4), this._$_shaderParams$_ = [];
        }
        _$InitQuad$_(t, s) {
            this._$_type$_ = 1, this._$_startIndex$_ = t, this._$_indexCount$_ = s;
        }
        _$DoQuad$_() {
            const t = this._$_gl$_;
            t.drawElements(t.TRIANGLES, this._$_indexCount$_, t.UNSIGNED_SHORT, this._$_startIndex$_);
        }
        _$InitSetTexture$_(t) {
            this._$_type$_ = 2, this._$_texParam$_ = t;
        }
        _$DoSetTexture$_() {
            const t = this._$_gl$_, s = this._$_texParam$_;
            t.bindTexture(t.TEXTURE_2D, s ? s._$_GetTexture$_() : null);
        }
        _$InitSetColor$_(t) {
            this._$_type$_ = 3, t._$writeToTypedArray$_(this._$_colorParam$_, 0);
        }
        _$DoSetColor$_() {
            const t = this._$_colorParam$_, s = this._$_batchState$_;
            Vh._$copy$_(s._$currentColor$_, t), s._$currentShader$_._$UpdateColor$_(t);
        }
        _$InitSetGradientColor$_(t) {
            this._$_type$_ = 21, t._$writeToTypedArray$_(this._$_colorParam$_, 0);
        }
        _$DoSetGradientColor$_() {
            const t = this._$_colorParam$_, s = this._$_batchState$_._$currentShader$_;
            s._$_uColor2$_._$IsUsed$_() && s._$_uColor2$_._$Update4f$_(t[0], t[1], t[2], t[3]);
        }
        _$InitSetBlend$_(t, s) {
            this._$_type$_ = 4, this._$_startIndex$_ = t, this._$_indexCount$_ = s;
        }
        _$DoSetBlend$_() {
            this._$_gl$_.blendFunc(this._$_startIndex$_, this._$_indexCount$_);
        }
        _$InitSetViewport$_(t, s, i, e) {
            this._$_type$_ = 5;
            const h = this._$_colorParam$_;
            h[0] = t, h[1] = s, h[2] = i, h[3] = e;
        }
        _$DoSetViewport$_() {
            const t = this._$_colorParam$_;
            this._$_gl$_.viewport(t[0], t[1], t[2], t[3]);
        }
        _$InitSetProjection$_(t) {
            this._$_type$_ = 6, xh._$copy$_(this._$_mat4param$_, t);
        }
        _$DoSetProjection$_() {
            const t = this._$_batchState$_, i = t.renderer._$_allShaderPrograms$_, e = t._$currentShader$_, h = this._$_mat4param$_;
            for (let t = 0, s = i.length; t < s; ++t) {
                const r = i[t];
                r === e ? r._$UpdateMatP$_(h, !0) : r._$SetMatPStale$_();
            }
            xh._$copy$_(t._$currentMatP$_, h);
        }
        _$InitSetModelView$_(t) {
            this._$_type$_ = 7, xh._$copy$_(this._$_mat4param$_, t);
        }
        _$DoSetModelView$_() {
            const t = this._$_batchState$_, i = t.renderer._$_allShaderPrograms$_, e = t._$currentShader$_, h = this._$_mat4param$_;
            for (let t = 0, s = i.length; t < s; ++t) {
                const r = i[t];
                r === e ? r._$UpdateMatMV$_(h, !0) : r._$SetMatMVStale$_();
            }
            xh._$copy$_(t._$currentMV$_, h);
        }
        _$InitSetRenderTarget$_(t) {
            this._$_type$_ = 8, this._$_texParam$_ = t;
        }
        _$DoSetRenderTarget$_() {
            const t = this._$_gl$_, s = this._$_texParam$_, i = this._$_batchState$_;
            s ? (i._$currentFramebuffer$_ = s._$_GetFramebuffer$_(), i._$currentFramebufferNoDepth$_ = s._$_GetFramebufferNoDepth$_(), 
            i._$isDepthSamplingEnabled$_ && i._$currentFramebufferNoDepth$_ ? t.bindFramebuffer(t.FRAMEBUFFER, i._$currentFramebufferNoDepth$_) : t.bindFramebuffer(t.FRAMEBUFFER, i._$currentFramebuffer$_)) : (i._$currentFramebuffer$_ = null, 
            i._$currentFramebufferNoDepth$_ = null, t.bindFramebuffer(t.FRAMEBUFFER, null));
        }
        _$InitClearSurface$_(t) {
            this._$_type$_ = 9, t._$writeToTypedArray$_(this._$_mat4param$_, 0);
        }
        _$InitClearSurface2$_(t, s, i, e) {
            this._$_type$_ = 9;
            const h = this._$_mat4param$_;
            h[0] = t, h[1] = s, h[2] = i, h[3] = e;
        }
        _$DoClearSurface$_() {
            const t = this._$_gl$_, s = this._$_mat4param$_, i = this._$_batchState$_, e = i.clearColor, h = s[0], r = s[1], n = s[2], o = s[3];
            e._$equalsRgba$_(h, r, n, o) || (t.clearColor(h, r, n, o), e._$setRgba$_(h, r, n, o)), 
            t.clear(t.COLOR_BUFFER_BIT);
        }
        _$InitSetPointTexCoords$_(t) {
            this._$_type$_ = 15, t._$writeToTypedArray$_(this._$_mat4param$_, 0);
        }
        _$DoSetPointTextureCoords$_() {
            const t = this._$_mat4param$_;
            this._$_batchState$_._$pointTexCoords$_.set(t[0], t[1], t[2], t[3]);
        }
        _$InitPoints$_(t, s) {
            this._$_type$_ = 10, this._$_startIndex$_ = t, this._$_indexCount$_ = 1, 
            this._$_mat4param$_[0] = s;
        }
        _$DoPoints$_() {
            const t = this._$_gl$_, s = this._$_batchState$_, i = s.renderer, e = i._$_spPoints$_, h = (t.useProgram(e._$_shaderProgram$_), 
            e._$UpdateMatP$_(s._$currentMatP$_, !1), e._$UpdateMatMV$_(s._$currentMV$_, !1), 
            s._$pointTexCoords$_), r = (e._$_uPointTexStart$_._$IsUsed$_() && e._$_uPointTexStart$_._$Update2f$_(h._$getLeft$_(), h._$getTop$_()), 
            e._$_uPointTexEnd$_._$IsUsed$_() && e._$_uPointTexEnd$_._$Update2f$_(h._$getRight$_(), h._$getBottom$_()), 
            this._$_mat4param$_[0]);
            if (e._$_uZElevation$_._$IsUsed$_() && e._$_uZElevation$_._$Update1f$_(r), 
            e._$_uColor$_._$IsUsed$_()) {
                const n = s._$currentColor$_;
                e._$_uColor$_._$Update4f$_(n[0], n[1], n[2], n[3]);
            }
            t.drawArrays(t.POINTS, this._$_startIndex$_ / 4, this._$_indexCount$_), 
            t.useProgram(s._$currentShader$_._$_shaderProgram$_);
        }
        _$InitSetProgram$_(t) {
            this._$_type$_ = 11, this._$_texParam$_ = t;
        }
        _$DoSetProgram$_() {
            const t = this._$_gl$_, s = this._$_batchState$_, i = this._$_texParam$_;
            if (s._$currentShader$_ = i, t.useProgram(i._$_shaderProgram$_), i._$UpdateMatP$_(s._$currentMatP$_, !1), 
            i._$UpdateMatMV$_(s._$currentMV$_, !1), i._$_uColor$_._$IsUsed$_()) {
                const e = s._$currentColor$_;
                i._$_uColor$_._$Update4f$_(e[0], e[1], e[2], e[3]);
            }
        }
        _$InitSetProgramParameters$_() {
            this._$_type$_ = 12;
        }
        _$DoSetProgramParameters$_() {
            const t = this._$_batchState$_._$currentShader$_, s = this._$_gl$_, i = this._$_mat4param$_, e = this._$_colorParam$_, h = this._$_srcOriginRect$_;
            if (t._$_uSamplerBack$_._$IsUsed$_()) {
                const r = this._$_batchState$_.renderer, n = this._$_texParam$_;
                r._$_lastTexture1$_ !== n && (s.activeTexture(s.TEXTURE1), s.bindTexture(s.TEXTURE_2D, n ? n._$_GetTexture$_() : null), 
                r._$_lastTexture1$_ = n, s.activeTexture(s.TEXTURE0));
            }
            t._$_uPixelSize$_._$IsUsed$_() && t._$_uPixelSize$_._$Update2f$_(i[0], i[1]), 
            t._$_uDestStart$_._$IsUsed$_() && t._$_uDestStart$_._$Update2f$_(i[2], i[3]), 
            t._$_uDestEnd$_._$IsUsed$_() && t._$_uDestEnd$_._$Update2f$_(i[4], i[5]), 
            t._$_uDevicePixelRatio$_._$IsUsed$_() && t._$_uDevicePixelRatio$_._$Update1f$_(this._$_indexCount$_), 
            t._$_uLayerScale$_._$IsUsed$_() && t._$_uLayerScale$_._$Update1f$_(i[6]), 
            t._$_uLayerAngle$_._$IsUsed$_() && t._$_uLayerAngle$_._$Update1f$_(i[7]), 
            t._$_uSrcStart$_._$IsUsed$_() && t._$_uSrcStart$_._$Update2f$_(i[12], i[13]), 
            t._$_uSrcEnd$_._$IsUsed$_() && t._$_uSrcEnd$_._$Update2f$_(i[14], i[15]), 
            t._$_uSrcOriginStart$_._$IsUsed$_() && t._$_uSrcOriginStart$_._$Update2f$_(h[0], h[1]), 
            t._$_uSrcOriginEnd$_._$IsUsed$_() && t._$_uSrcOriginEnd$_._$Update2f$_(h[2], h[3]), 
            t._$_uLayoutStart$_._$IsUsed$_() && t._$_uLayoutStart$_._$Update2f$_(e[0], e[1]), 
            t._$_uLayoutEnd$_._$IsUsed$_() && t._$_uLayoutEnd$_._$Update2f$_(e[2], e[3]), 
            t._$_uSeconds$_._$IsUsed$_() && t._$_uSeconds$_._$Update1f$_(this._$_startIndex$_);
        }
        _$InitSetProgramCustomParameters$_() {
            this._$_type$_ = 13;
        }
        _$DoSetProgramCustomParameters$_() {
            const t = this._$_batchState$_._$currentShader$_, i = t._$_uCustomParameters$_, e = this._$_shaderParams$_;
            for (let t = 0, s = i.length; t < s; ++t) {
                const h = i[t], r = e[t];
                h._$IsColorType$_() ? h._$Update3f$_(r._$getR$_(), r._$getG$_(), r._$getB$_()) : h._$Update1f$_(r);
            }
        }
        _$InitInvalidateFramebuffer$_(t) {
            this._$_type$_ = 14, this._$_texParam$_ = t;
        }
        _$DoInvalidateFramebuffer$_() {
            const t = this._$_gl$_, s = this._$_texParam$_, i = this._$_batchState$_._$currentFramebuffer$_;
            s !== i && t.bindFramebuffer(t.FRAMEBUFFER, s), t.invalidateFramebuffer(t.FRAMEBUFFER, [ t.COLOR_ATTACHMENT0 ]), 
            s !== i && t.bindFramebuffer(t.FRAMEBUFFER, i);
        }
        _$InitBlitFramebuffer$_(t, s, i) {
            this._$_type$_ = 17;
            const e = this._$_mat4param$_, h = this._$_batchState$_.renderer, r = (e[0] = t._$GetWidth$_(), 
            e[1] = t._$GetHeight$_(), e[2] = (s || h)._$GetWidth$_(), e[3] = (s || h)._$GetHeight$_(), 
            e[4] = t._$IsLinearSampling$_() ? 1 : 0, e[5] = "stretch" === i, this._$_shaderParams$_);
            Ii._$clearArray$_(r), r.push(t._$_GetFramebuffer$_()), r.push(s ? s._$_GetFramebuffer$_() : null);
        }
        _$DoBlitFramebuffer$_() {
            const t = this._$_mat4param$_, s = this._$_shaderParams$_, i = this._$_gl$_, e = t[0], h = t[1], r = t[2], n = t[3], o = 0 !== t[4], a = 0 !== t[5], l = s[0], u = s[1];
            if (i.bindFramebuffer(i.READ_FRAMEBUFFER, l), i.bindFramebuffer(i.DRAW_FRAMEBUFFER, u), 
            a) i.blitFramebuffer(0, 0, e, h, 0, 0, r, n, i.COLOR_BUFFER_BIT, o ? i.LINEAR : i.NEAREST); else {
                const c = Math.min(e, r), f = Math.min(h, n), d = Math.max(h - n, 0), p = Math.max(n - h, 0);
                i.blitFramebuffer(0, d, c, f + d, 0, p, c, f + p, i.COLOR_BUFFER_BIT, i.NEAREST);
            }
        }
        _$InitStartQuery$_(t) {
            this._$_type$_ = 18, this._$_texParam$_ = t;
        }
        _$DoStartQuery$_() {
            this._$_texParam$_._$BeginTimeElapsed$_(), this._$_texParam$_ = null;
        }
        _$InitEndQuery$_(t) {
            this._$_type$_ = 19, this._$_texParam$_ = t;
        }
        _$DoEndQuery$_() {
            this._$_texParam$_._$EndTimeElapsed$_(), this._$_texParam$_ = null;
        }
        _$InitSetEllipseParams$_(t, s, i) {
            this._$_type$_ = 20;
            const e = this._$_mat4param$_;
            e[0] = t, e[1] = s, e[2] = i;
        }
        _$DoSetEllipseParams$_() {
            const t = this._$_batchState$_._$currentShader$_, s = this._$_mat4param$_;
            t._$_uPixelSize$_._$IsUsed$_() && t._$_uPixelSize$_._$Update2f$_(s[0], s[1]), 
            t._$_uOutlineThickness$_._$IsUsed$_() && t._$_uOutlineThickness$_._$Update1f$_(s[2]);
        }
        _$InitSetTilemapInfo$_(t, s, i, e, h, r, n) {
            this._$_type$_ = 16;
            const o = this._$_mat4param$_;
            t._$writeToTypedArray$_(o, 0), o[4] = 1 / s, o[5] = 1 / i, o[6] = e / s, 
            o[7] = h / i, o[8] = r / s, o[9] = n / i;
        }
        _$DoSetTilemapInfo$_() {
            const t = this._$_batchState$_._$currentShader$_, s = this._$_mat4param$_;
            t._$_uSrcStart$_._$IsUsed$_() && t._$_uSrcStart$_._$Update2f$_(s[0], s[1]), 
            t._$_uPixelSize$_._$IsUsed$_() && t._$_uPixelSize$_._$Update2f$_(s[4], s[5]), 
            t._$_uTileSize$_._$IsUsed$_() && t._$_uTileSize$_._$Update2f$_(s[6], s[7]), 
            t._$_uTileSpacing$_._$IsUsed$_() && t._$_uTileSpacing$_._$Update2f$_(s[8], s[9]);
        }
        _$InitSetTileRandomizationInfo$_(t, s, i, e, h, r, n) {
            this._$_type$_ = 29;
            const o = this._$_mat4param$_;
            o[0] = 1 / t, o[1] = 1 / s, o[2] = i, o[3] = e, o[4] = h, o[5] = r, 
            o[6] = n;
        }
        _$DoSetTileRandomizationInfo$_() {
            const t = this._$_batchState$_._$currentShader$_, s = this._$_mat4param$_;
            t._$_uPixelSize$_._$IsUsed$_() && t._$_uPixelSize$_._$Update2f$_(s[0], s[1]), 
            t._$_uTileSize$_._$IsUsed$_() && t._$_uTileSize$_._$Update2f$_(s[2], s[3]), 
            t._$_uOutlineThickness$_._$IsUsed$_() && t._$_uOutlineThickness$_._$Update1f$_(s[4]), 
            t._$_uTileSpacing$_._$IsUsed$_() && t._$_uTileSpacing$_._$Update2f$_(s[5], s[6]);
        }
        _$InitClearDepth$_(t) {
            this._$_type$_ = 22, this._$_startIndex$_ = t ? 1 : 0;
        }
        _$DoClearDepth$_() {
            const t = this._$_gl$_, s = 0 !== this._$_startIndex$_;
            s || t.depthMask(!0), t.clear(t.DEPTH_BUFFER_BIT), s || t.depthMask(!1);
        }
        _$InitSetDepthEnabled$_(t) {
            this._$_type$_ = 23, this._$_startIndex$_ = t ? 1 : 0;
        }
        _$DoSetDepthEnabled$_() {
            const t = this._$_gl$_;
            0 === this._$_startIndex$_ ? (t.disable(t.DEPTH_TEST), t.depthMask(!1)) : (t.enable(t.DEPTH_TEST), 
            t.depthMask(!0));
        }
        _$InitSetDepthSamplingEnabled$_(t) {
            this._$_type$_ = 24, this._$_startIndex$_ = t ? 1 : 0;
        }
        _$DoSetDepthSamplingEnabled$_() {
            const t = this._$_gl$_, s = this._$_batchState$_, i = s.renderer, e = 0 !== this._$_startIndex$_;
            s._$isDepthSamplingEnabled$_ = e, t.activeTexture(t.TEXTURE2), e ? (s._$currentFramebufferNoDepth$_ && t.bindFramebuffer(t.FRAMEBUFFER, s._$currentFramebufferNoDepth$_), 
            t.bindTexture(t.TEXTURE_2D, i._$_GetDepthBuffer$_())) : (t.bindTexture(t.TEXTURE_2D, null), 
            s._$currentFramebufferNoDepth$_ && t.bindFramebuffer(t.FRAMEBUFFER, s._$currentFramebuffer$_)), 
            t.activeTexture(t.TEXTURE0);
        }
        _$InitCoplanarStartStencilPass$_() {
            this._$_type$_ = 25;
        }
        _$DoCoplanarStartStencilPass$_() {
            const t = this._$_gl$_;
            t.clear(t.STENCIL_BUFFER_BIT), t.enable(t.STENCIL_TEST), t.stencilFunc(t.ALWAYS, 1, 1), 
            t.stencilOp(t.KEEP, t.KEEP, t.REPLACE), t.colorMask(!1, !1, !1, !1);
        }
        _$InitCoplanarStartColorPass$_() {
            this._$_type$_ = 26;
        }
        _$DoCoplanarStartColorPass$_() {
            const t = this._$_gl$_;
            t.colorMask(!0, !0, !0, !0), t.stencilFunc(t.EQUAL, 1, 1), t.stencilOp(t.KEEP, t.KEEP, t.KEEP);
        }
        _$InitCoplanarRestore$_() {
            this._$_type$_ = 27;
        }
        _$DoCoplanarRestore$_() {
            const t = this._$_gl$_;
            t.disable(t.STENCIL_TEST);
        }
        _$InitSetScissor$_(t, s, i, e, h) {
            this._$_type$_ = 28, this._$_startIndex$_ = t ? 1 : 0;
            const r = this._$_mat4param$_;
            r[0] = s, r[1] = i, r[2] = e, r[3] = h;
        }
        _$DoSetScissor$_() {
            const t = this._$_gl$_, s = this._$_mat4param$_;
            1 === this._$_startIndex$_ ? (t.enable(t.SCISSOR_TEST), t.scissor(s[0], s[1], s[2], s[3])) : t.disable(t.SCISSOR_TEST);
        }
        _$Run$_() {
            switch (this._$_type$_) {
              case 1:
                return void this._$DoQuad$_();

              case 2:
                return void this._$DoSetTexture$_();

              case 3:
                return void this._$DoSetColor$_();

              case 4:
                return void this._$DoSetBlend$_();

              case 5:
                return void this._$DoSetViewport$_();

              case 6:
                return void this._$DoSetProjection$_();

              case 7:
                return void this._$DoSetModelView$_();

              case 8:
                return void this._$DoSetRenderTarget$_();

              case 9:
                return void this._$DoClearSurface$_();

              case 10:
                return void this._$DoPoints$_();

              case 11:
                return void this._$DoSetProgram$_();

              case 12:
                return void this._$DoSetProgramParameters$_();

              case 13:
                return void this._$DoSetProgramCustomParameters$_();

              case 14:
                return void this._$DoInvalidateFramebuffer$_();

              case 15:
                return void this._$DoSetPointTextureCoords$_();

              case 16:
                return void this._$DoSetTilemapInfo$_();

              case 17:
                return void this._$DoBlitFramebuffer$_();

              case 18:
                return void this._$DoStartQuery$_();

              case 19:
                return void this._$DoEndQuery$_();

              case 20:
                return void this._$DoSetEllipseParams$_();

              case 21:
                return void this._$DoSetGradientColor$_();

              case 22:
                return void this._$DoClearDepth$_();

              case 23:
                return void this._$DoSetDepthEnabled$_();

              case 24:
                return void this._$DoSetDepthSamplingEnabled$_();

              case 25:
                return void this._$DoCoplanarStartStencilPass$_();

              case 26:
                return void this._$DoCoplanarStartColorPass$_();

              case 27:
                return void this._$DoCoplanarRestore$_();

              case 28:
                return void this._$DoSetScissor$_();

              case 29:
                return void this._$DoSetTileRandomizationInfo$_();
            }
        }
    };
}

{
    let I = function(t, s, i, e, h, r) {
        s ? t.strokeRect(i, e, h, r) : t.fillRect(i, e, h, r);
    }, t = function(t) {
        return t * (4 / 3);
    }, o = function(t, s) {
        t = t.trim();
        const i = parseFloat(t);
        return isFinite(i) ? t.endsWith("%") ? s * i / 100 : i : 0;
    };
    I, t, o;
    const Ri = self._$C3$_, Pi = new Set([ "serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong" ]), Ei = {
        timeout: 60
    }, Ai = new Ri._$Color$_(0, 0, 0, 1), Fi = new Set([ "left", "center", "right" ]), Oi = new Set([ "top", "center", "bottom" ]), Di = new Set([ "word", "cjk", "character" ]), ki = new Set([ "ltr", "rtl" ]), Li = new Set();
    Ri.FontManager && Ri.FontManager.addEventListener("fontload", t => {
        const s = t.font._$GetName$_();
        for (const i of Li) (i._$IsBBCodeEnabled$_() || Ri._$equalsNoCase$_(i._$GetFontName$_(), s)) && i._$_SetWordWrapChanged$_();
    });
    let s = !1, i = !1;
    Ri._$Gfx$_._$RendererText$_ = class {
        constructor(t, s) {
            s = Object.assign({}, Ei, s), this._$_renderer$_ = t, this._$_fontName$_ = "Arial", 
            this._$_fontSize$_ = 16, this._$_fontSizeScale$_ = 1, this._$_lineHeight$_ = 0, 
            this._$_isBold$_ = !1, this._$_isItalic$_ = !1, this._$_colorStr$_ = "black", 
            this._$_isBBcodeEnabled$_ = !1, this._$_iconSet$_ = null, this._$_iconSmoothing$_ = !0, 
            this._$onloadfont$_ = null, this._$_alreadyLoadedFonts$_ = new Set(), 
            this._$_horizontalAlign$_ = "left", this._$_verticalAlign$_ = "top", 
            this._$_text$_ = "", this._$_bbString$_ = null, this._$_wrappedText$_ = Ri._$New$_(Ri._$WordWrap$_), 
            this._$_wrapMode$_ = "word", this._$_textDirection$_ = "ltr", this._$_wordWrapChanged$_ = !1, 
            this._$_textLayoutChanged$_ = !1, this._$_drawChanged$_ = !1, this._$_drawMaxCharCount$_ = -1, 
            this._$_drawCharCount$_ = 0, this._$_cssWidth$_ = 0, this._$_cssHeight$_ = 0, 
            this._$_width$_ = 0, this._$_height$_ = 0, this._$_zoom$_ = 1, this._$_textCanvas$_ = null, 
            this._$_textContext$_ = null, this._$_measureContext$_ = null, this._$_measureContextTop$_ = null, 
            this._$_lastCanvasWidth$_ = -1, this._$_lastCanvasHeight$_ = -1, this._$_lastTextCanvasFont$_ = "", 
            this._$_lastMeasureCanvasFont$_ = "", this._$_lastTextCanvasFillStyle$_ = "", 
            this._$_lastTextCanvasOpacity$_ = 1, this._$_lastTextCanvasLineWidth$_ = 1, 
            this._$_measureTextCallback$_ = t => this._$_MeasureText$_(t), this._$_texture$_ = null, 
            this._$_rcTex$_ = new Ri.Rect(), this._$_scaleFactor$_ = 1, this._$_textureTimeout$_ = new Ri._$IdleTimeout$_(() => {
                this._$ReleaseTexture$_(), this._$_SetTextCanvasSize$_(8, 8);
            }, s.timeout), this._$ontextureupdate$_ = null, this._$_wasReleased$_ = !1, 
            Li.add(this);
        }
        _$Release$_() {
            this._$onloadfont$_ = null, this._$_alreadyLoadedFonts$_.clear(), this._$_iconSet$_ = null, 
            this._$_bbString$_ = null, this._$_textCanvas$_ = null, this._$_textContext$_ = null, 
            this._$_measureContext$_ = null, this._$_measureContextTop$_ = null, 
            this._$_measureTextCallback$_ = null, this._$_textureTimeout$_._$Release$_(), 
            this._$ontextureupdate$_ = null, this._$ReleaseTexture$_(), this._$_wrappedText$_._$Clear$_(), 
            this._$_wrappedText$_ = null, this._$_renderer$_ = null, this._$_wasReleased$_ = !0, 
            Li.delete(this);
        }
        _$_SetDrawChanged$_() {
            this._$_drawChanged$_ = !0;
        }
        _$_SetTextLayoutChanged$_() {
            this._$_SetDrawChanged$_(), this._$_textLayoutChanged$_ = !0;
        }
        _$_SetWordWrapChanged$_() {
            this._$_SetTextLayoutChanged$_(), this._$_wordWrapChanged$_ = !0;
        }
        _$SetBBCodeEnabled$_(t) {
            if (this._$_isBBcodeEnabled$_ !== (t = !!t)) {
                this._$_isBBcodeEnabled$_ = t;
                const s = this._$_isBBcodeEnabled$_ ? "alphabetic" : "top";
                this._$_textContext$_ && (this._$_textContext$_.textBaseline = s), 
                this._$_measureContext$_ && (this._$_measureContext$_.textBaseline = s), 
                this._$_SetWordWrapChanged$_();
            }
        }
        _$IsBBCodeEnabled$_() {
            return this._$_isBBcodeEnabled$_;
        }
        _$SetIconSet$_(t) {
            this._$_iconSet$_ !== t && (this._$_iconSet$_ = t, this._$_wrappedText$_._$SetIconSet$_(t), 
            this._$_iconSet$_ && this._$_iconSet$_._$IsLoading$_() && this._$_iconSet$_._$LoadContent$_().then(() => this._$_SetDrawChanged$_()), 
            this._$_SetWordWrapChanged$_());
        }
        _$SetIconSmoothing$_(t) {
            this._$_iconSmoothing$_ !== (t = !!t) && (this._$_iconSmoothing$_ = t, 
            this._$_SetDrawChanged$_());
        }
        _$SetFontName$_(t) {
            this._$_fontName$_ !== (t = t || "serif") && (this._$_fontName$_ = t, 
            this._$_SetWordWrapChanged$_());
        }
        _$GetFontName$_() {
            return this._$_fontName$_;
        }
        _$SetFontSize$_(t) {
            this._$_fontSize$_ !== (t = t < .1 ? .1 : t) && (this._$_fontSize$_ = t, 
            this._$_SetWordWrapChanged$_());
        }
        _$GetFontSize$_() {
            return this._$_fontSize$_;
        }
        _$SetFontSizeScale$_(t) {
            this._$_fontSizeScale$_ !== t && (this._$_fontSizeScale$_ = t, this._$_SetWordWrapChanged$_());
        }
        _$SetLineHeight$_(t) {
            this._$_lineHeight$_ !== t && (this._$_lineHeight$_ = t, this._$_SetTextLayoutChanged$_());
        }
        _$GetLineHeight$_() {
            return this._$_lineHeight$_;
        }
        _$SetBold$_(t) {
            this._$_isBold$_ !== (t = !!t) && (this._$_isBold$_ = t, this._$_SetWordWrapChanged$_());
        }
        _$IsBold$_() {
            return this._$_isBold$_;
        }
        _$SetItalic$_(t) {
            this._$_isItalic$_ !== (t = !!t) && (this._$_isItalic$_ = t, this._$_SetWordWrapChanged$_());
        }
        _$IsItalic$_() {
            return this._$_isItalic$_;
        }
        _$SetDrawMaxCharacterCount$_(t) {
            t = Math.floor(t), this._$_drawMaxCharCount$_ !== t && (this._$_drawMaxCharCount$_ = t, 
            this._$_SetDrawChanged$_());
        }
        _$GetDrawMaxCharacterCount$_() {
            return this._$_drawMaxCharCount$_;
        }
        _$_GetFontString$_(t, s) {
            let i = [];
            (this._$_isBold$_ || s._$HasStyleTag$_("b")) && i.push("bold"), (this._$_isItalic$_ || s._$HasStyleTag$_("i")) && i.push("italic");
            const e = s._$GetStyleTag$_("size"), h = (e ? parseFloat(e.param) : this._$_fontSize$_) * this._$_fontSizeScale$_;
            i.push(t ? h + "pt" : h * this._$GetDrawScale$_() + "pt");
            let r = this._$_fontName$_, n = s._$GetStyleTag$_("font");
            return n && n.param && (r = n.param, this._$onloadfont$_) && !this._$_alreadyLoadedFonts$_.has(r) && (this._$onloadfont$_(r), 
            this._$_alreadyLoadedFonts$_.add(r)), r && (Pi.has(r) ? i.push(r) : i.push('"' + r + '"')), 
            i.join(" ");
        }
        _$SetColor$_(t) {
            t instanceof Ri._$Color$_ && (t = t._$getCssRgb$_()), this._$_colorStr$_ !== t && (this._$_colorStr$_ = t, 
            this._$_SetDrawChanged$_());
        }
        _$SetColorRgb$_(t, s, i) {
            Ai._$setRgb$_(t, s, i), this._$SetColor$_(Ai);
        }
        _$SetHorizontalAlignment$_(t) {
            if (!Fi.has(t)) throw new Error("invalid horizontal alignment");
            this._$_horizontalAlign$_ !== t && (this._$_horizontalAlign$_ = t, this._$_SetTextLayoutChanged$_());
        }
        _$GetHorizontalAlignment$_() {
            return this._$_horizontalAlign$_;
        }
        _$SetVerticalAlignment$_(t) {
            if (!Oi.has(t)) throw new Error("invalid vertical alignment");
            this._$_verticalAlign$_ !== t && (this._$_verticalAlign$_ = t, this._$_SetTextLayoutChanged$_());
        }
        _$GetVerticalAlignment$_() {
            return this._$_verticalAlign$_;
        }
        _$SetWordWrapMode$_(t) {
            if (!Di.has(t)) throw new Error("invalid word wrap mode");
            this._$_wrapMode$_ !== t && (this._$_wrapMode$_ = t, this._$_SetWordWrapChanged$_());
        }
        _$GetWordWrapMode$_() {
            return this._$_wrapMode$_;
        }
        _$SetTextDirection$_(t) {
            if (!ki.has(t)) throw new Error("invalid text direction");
            this._$_textDirection$_ !== t && (this._$_textDirection$_ = t, this._$_textContext$_ && (this._$_textContext$_.direction = this._$_textDirection$_), 
            this._$_measureContext$_ && (this._$_measureContext$_.direction = this._$_textDirection$_), 
            this._$_SetWordWrapChanged$_());
        }
        _$GetTextDirection$_() {
            return this._$_textDirection$_;
        }
        _$SetText$_(t) {
            this._$_text$_ !== t && (this._$_text$_ = t, this._$_SetWordWrapChanged$_());
        }
        _$GetText$_() {
            return this._$_text$_;
        }
        _$GetDrawScale$_() {
            return this._$_scaleFactor$_ * this._$_zoom$_ * self.devicePixelRatio;
        }
        _$SetSize$_(r, n, o) {
            if (void 0 === o && (o = 1), !(r <= 0 || this._$_cssWidth$_ === r && this._$_cssHeight$_ === n && this._$_zoom$_ === o)) {
                let t = this._$_cssWidth$_, s = (this._$_cssWidth$_ = r, this._$_cssHeight$_ = n, 
                this._$_zoom$_ = o, self.devicePixelRatio), i = (this._$_width$_ = this._$_cssWidth$_ * this._$_zoom$_ * s, 
                this._$_height$_ = this._$_cssHeight$_ * this._$_zoom$_ * s, Math.max(this._$_width$_, this._$_height$_)), e = Math.min(this._$_renderer$_._$GetMaxTextureSize$_(), 4096), h = 1;
                e < i && (h = e / i, this._$_width$_ = Math.min(this._$_width$_ * h, e), 
                this._$_height$_ = Math.min(this._$_height$_ * h, e)), this._$_scaleFactor$_ = h, 
                this._$_cssWidth$_ !== t ? this._$_SetWordWrapChanged$_() : this._$_SetTextLayoutChanged$_();
            }
        }
        _$GetWidth$_() {
            return this._$_width$_;
        }
        _$GetHeight$_() {
            return this._$_height$_;
        }
        _$GetZoom$_() {
            return this._$_zoom$_;
        }
        _$GetTextWidth$_() {
            return this._$_UpdateTextMeasurements$_(), this._$_wrappedText$_._$GetMaxLineWidth$_();
        }
        _$GetTextHeight$_() {
            return this._$_UpdateTextMeasurements$_(), this._$_wrappedText$_._$GetTotalLineHeight$_() + this._$_wrappedText$_._$GetLineCount$_() * (this._$_lineHeight$_ + 4) - this._$_lineHeight$_;
        }
        _$GetLengthInGraphemes$_() {
            this._$_UpdateTextMeasurements$_();
            let t = 0;
            for (const s of this._$_wrappedText$_._$GetLines$_()) for (const i of s._$fragments$_()) t += i._$GetLength$_();
            return t;
        }
        _$GetTexture$_() {
            return this._$_textureTimeout$_._$Reset$_(), this._$_MaybeUpdate$_(), 
            this._$_texture$_;
        }
        _$HitTestFragment$_(t, s) {
            this._$_UpdateTextMeasurements$_();
            const i = this._$GetDrawScale$_(), e = this._$_wrappedText$_._$GetLines$_();
            for (const h of e) {
                const r = h._$GetFontBoundingBoxDescent$_() * i;
                if (s >= h._$GetPosY$_() - h._$GetHeight$_() * i + r && s < h._$GetPosY$_() + r) for (const n of h._$fragments$_()) if (t >= n._$GetPosX$_() && t < n._$GetPosX$_() + n._$GetWidth$_() * i) return n;
            }
            return null;
        }
        *_$fragmentsWithTag$_(t) {
            this._$_UpdateTextMeasurements$_();
            const s = this._$_wrappedText$_._$GetLines$_();
            for (const i of s) for (const e of i._$fragments$_()) {
                const h = e._$GetStyleTag$_("tag");
                h && Ri._$equalsNoCase$_(h.param, t) && (yield e);
            }
        }
        _$FindFragmentWithTag$_(t, s) {
            for (const i of this._$fragmentsWithTag$_(t)) {
                if (0 === s) return i;
                --s;
            }
            return null;
        }
        _$CountFragmentsWithTag$_(t) {
            let s = 0;
            for (const i of this._$fragmentsWithTag$_(t)) ++s;
            return s;
        }
        _$_MaybeUpdate$_() {
            this._$_texture$_ && !this._$_drawChanged$_ && !this._$_textLayoutChanged$_ && !this._$_wordWrapChanged$_ || this._$_wasReleased$_ || this._$_width$_ <= 0 || this._$_height$_ <= 0 || (this._$_drawChanged$_ = !1, 
            this._$_DoUpdate$_());
        }
        _$_DoUpdate$_() {
            this._$_wasReleased$_ || (this._$_UpdateTextMeasurements$_(), this._$_SetTextCanvasSize$_(Math.max(Ri._$nextHighestPowerOfTwo$_(Math.ceil(this._$_width$_)), 128), Math.max(Ri._$nextHighestPowerOfTwo$_(Math.ceil(this._$_height$_)), 64)), 
            this._$_DrawTextToCanvas$_(), this._$_UpdateTexture$_(), this._$_textureTimeout$_._$Reset$_());
        }
        _$_SetTextCanvasSize$_(t, s) {
            this._$_textCanvas$_ || (this._$_textCanvas$_ = Ri._$CreateCanvas$_(16, 16));
            let i = !1;
            this._$_lastCanvasWidth$_ === t && this._$_lastCanvasHeight$_ === s || (this._$_lastCanvasWidth$_ = t, 
            this._$_lastCanvasHeight$_ = s, this._$_textCanvas$_.width = t, this._$_textCanvas$_.height = s, 
            i = !0), this._$_textContext$_ || (this._$_textContext$_ = this._$_textCanvas$_.getContext("2d"), 
            i = !0), i ? (this._$_textContext$_.textBaseline = this._$_isBBcodeEnabled$_ ? "alphabetic" : "top", 
            this._$_textContext$_.direction = this._$_textDirection$_, this._$_textContext$_.font = this._$_lastTextCanvasFont$_, 
            this._$_textContext$_.fillStyle = this._$_lastTextCanvasFillStyle$_, 
            this._$_textContext$_.strokeStyle = this._$_lastTextCanvasFillStyle$_, 
            this._$_textContext$_.globalAlpha = this._$_lastTextCanvasOpacity$_, 
            this._$_textContext$_.lineWidth = this._$_lastTextCanvasLineWidth$_) : this._$_textContext$_.clearRect(0, 0, t, s);
        }
        _$_MaybeCreateMeasureContext$_() {
            this._$_measureContext$_ || (this._$_measureContext$_ = Ri._$CreateCanvas$_(16, 16).getContext("2d"), 
            this._$_measureContextTop$_ = Ri._$CreateCanvas$_(16, 16).getContext("2d"), 
            this._$_measureContext$_.textBaseline = this._$_isBBcodeEnabled$_ ? "alphabetic" : "top", 
            this._$_measureContextTop$_.textBaseline = "top", this._$_measureContext$_.direction = this._$_textDirection$_, 
            this._$_measureContextTop$_.direction = this._$_textDirection$_);
        }
        _$_SetMeasureFontString$_(t) {
            this._$_lastMeasureCanvasFont$_ !== t && (this._$_lastMeasureCanvasFont$_ = t, 
            this._$_measureContext$_.font = t, this._$_measureContextTop$_.font = t);
        }
        _$_SupportsFontBoundingBoxMeasurements$_() {
            if (!s) {
                s = !0, this._$_MaybeCreateMeasureContext$_();
                const t = this._$_measureContext$_.measureText("test");
                i = "number" == typeof t.fontBoundingBoxAscent && "number" == typeof t.fontBoundingBoxDescent;
            }
            return i;
        }
        _$_UpdateTextMeasurements$_() {
            this._$_UpdateWordWrap$_(), this._$_UpdateTextLayout$_();
        }
        _$_UpdateWordWrap$_() {
            this._$_wordWrapChanged$_ && (this._$_MaybeCreateMeasureContext$_(), 
            !this._$_isBBcodeEnabled$_ || this._$_bbString$_ && this._$_bbString$_.toString() === this._$_text$_ || (this._$_bbString$_ = new Ri._$BBString$_(this._$_text$_, {
                _$noEscape$_: !0
            })), this._$_wrappedText$_._$WordWrap$_(this._$_isBBcodeEnabled$_ ? this._$_bbString$_._$toFragmentList$_() : this._$_text$_, this._$_measureTextCallback$_, this._$_cssWidth$_, this._$_wrapMode$_, 0), 
            this._$_wordWrapChanged$_ = !1);
        }
        _$_UpdateTextLayout$_() {
            this._$_textLayoutChanged$_ && (this._$_LayoutText$_(), this._$_textLayoutChanged$_ = !1);
        }
        _$_MeasureText$_(t) {
            let s = t._$IsText$_() ? t._$GetCharacterArray$_().join("") : " ", i = (this._$_SetMeasureFontString$_(this._$_GetFontString$_(!0, t)), 
            t._$GetStyleTag$_("size")), e = (i ? parseFloat(i.param) : this._$_fontSize$_) * this._$_fontSizeScale$_, h = this._$_measureContext$_.measureText(s), r = 0;
            if (this._$_isBBcodeEnabled$_ && this._$_SupportsFontBoundingBoxMeasurements$_()) {
                const n = this._$_measureContextTop$_.measureText(s);
                r = h.fontBoundingBoxAscent - n.fontBoundingBoxAscent;
            }
            return {
                width: h.width,
                height: 4 / 3 * e,
                fontBoundingBoxAscent: h.fontBoundingBoxAscent || 0,
                fontBoundingBoxDescent: h.fontBoundingBoxDescent || 0,
                _$topToAlphabeticDistance$_: r
            };
        }
        _$_SetDrawFontString$_(t) {
            this._$_lastTextCanvasFont$_ !== t && (this._$_lastTextCanvasFont$_ = t, 
            this._$_textContext$_.font = t);
        }
        _$_SetDrawCanvasColor$_(t) {
            this._$_lastTextCanvasFillStyle$_ !== t && (this._$_lastTextCanvasFillStyle$_ = t, 
            this._$_textContext$_.fillStyle = t, this._$_textContext$_.strokeStyle = t);
        }
        _$_SetDrawCanvasOpacity$_(t) {
            this._$_lastTextCanvasOpacity$_ !== t && (this._$_lastTextCanvasOpacity$_ = t, 
            this._$_textContext$_.globalAlpha = t);
        }
        _$_SetDrawCanvasLineWith$_(t) {
            this._$_lastTextCanvasLineWidth$_ !== t && (this._$_lastTextCanvasLineWidth$_ = t, 
            this._$_textContext$_.lineWidth = t);
        }
        _$_LayoutText$_() {
            let e = this._$GetDrawScale$_(), h = (4 + this._$_lineHeight$_) * e, r = 0, n = this._$_wrappedText$_._$GetLines$_();
            if (0 !== n.length) {
                for (const s of n) {
                    s._$SetPosX$_(NaN), s._$SetPosY$_(NaN);
                    for (const o of s._$fragments$_()) o._$SetPosX$_(NaN), o._$SetPosY$_(NaN);
                }
                let t = this._$_isBBcodeEnabled$_ && this._$_SupportsFontBoundingBoxMeasurements$_(), i = n[0]._$GetHeight$_() * e;
                if ("center" === this._$_verticalAlign$_) {
                    const a = n.reduce((t, s) => t + s._$GetHeight$_() * e + h, 0) - h;
                    r = Math.max(this._$_height$_ / 2 - a / 2, 0), t && (i = n[0]._$GetTopToAlphabeticDistance$_() * e);
                } else if ("bottom" === this._$_verticalAlign$_) {
                    const l = n.reduce((t, s) => t + s._$GetHeight$_() * e + h, 0) - this._$_lineHeight$_ * e, u = t ? n.at(-1)._$GetFontBoundingBoxDescent$_() * e : 0;
                    r = this._$_height$_ - l - u - 2;
                }
                for (let t = 0, s = n.length; t < s; ++t) {
                    const c = n[t], f = c._$GetHeight$_() * e, d = r;
                    if (this._$_isBBcodeEnabled$_) {
                        if (r += 0 === t ? i : f, 0 < t && r > this._$_height$_ - 4 * e) break;
                    } else if (0 < t && r >= this._$_height$_ - f) break;
                    0 <= d && this._$_LayoutTextLine$_(c, r, e), this._$_isBBcodeEnabled$_ || (r += f), 
                    r += h;
                }
            }
        }
        _$_LayoutTextLine$_(t, s, i) {
            let e = 0;
            "center" === this._$_horizontalAlign$_ ? e = (this._$_width$_ - t._$GetWidth$_() * i) / 2 : "right" === this._$_horizontalAlign$_ && (e = this._$_width$_ - t._$GetWidth$_() * i), 
            t._$SetPosX$_(e), t._$SetPosY$_(s);
            for (const h of "ltr" === this._$_textDirection$_ ? t._$fragments$_() : t._$fragmentsReverse$_()) this._$_LayoutFragment$_(h, e, s, i), 
            e += h._$GetWidth$_() * i;
        }
        _$_LayoutFragment$_(t, s, i, e) {
            const h = t._$GetStyleTag$_("offsetx"), r = (s += h ? o(h.param, t._$GetHeight$_()) * e : 0, 
            t._$GetStyleTag$_("offsety"));
            if (i += r ? o(r.param, t._$GetHeight$_()) * e : 0, t._$IsIcon$_()) {
                const n = t._$GetStyleTag$_("iconoffsety");
                i += n ? o(n.param, t._$GetHeight$_()) * e : .2 * t._$GetHeight$_() * e;
            }
            t._$SetPosX$_(s), t._$SetPosY$_(i);
        }
        _$_DrawTextToCanvas$_() {
            this._$_textContext$_.imageSmoothingEnabled = this._$_iconSmoothing$_, 
            this._$_textContext$_.imageSmoothingQuality = "high", this._$_drawCharCount$_ = 0;
            const t = this._$GetDrawScale$_(), s = this._$_wrappedText$_._$GetLines$_();
            for (const i of s) this._$_DrawTextLine$_(i, t);
        }
        _$_DrawTextLine$_(t, s) {
            const i = t._$GetPosX$_(), e = t._$GetPosY$_();
            if (Number.isFinite(i) && Number.isFinite(e)) for (const h of "ltr" === this._$_textDirection$_ ? t._$fragments$_() : t._$fragmentsReverse$_()) this._$_DrawFragment$_(h, s, t._$GetHeight$_());
        }
        _$_DrawFragment$_(n, o, a) {
            const l = this._$_textContext$_, u = n._$GetPosX$_(), c = n._$GetPosY$_();
            if (Number.isFinite(u) && Number.isFinite(c)) {
                let t = a / 16, s = n._$GetWidth$_() * o, i = n._$GetHeight$_() * o, e = n._$GetHeight$_() / 16, h = (4 + this._$_lineHeight$_) * o, r = n._$IsText$_() ? n._$GetCharacterArray$_() : null;
                if (-1 !== this._$_drawMaxCharCount$_) {
                    if (this._$_drawCharCount$_ >= this._$_drawMaxCharCount$_) return;
                    n._$IsText$_() && this._$_drawCharCount$_ + r.length > this._$_drawMaxCharCount$_ && (r = r.slice(0, this._$_drawMaxCharCount$_ - this._$_drawCharCount$_), 
                    s = this._$_MeasureText$_(n).width * o), this._$_drawCharCount$_ += n._$GetLength$_();
                }
                const f = n._$GetStyleTag$_("background"), d = n._$HasStyleTag$_("u"), p = n._$HasStyleTag$_("s");
                if ((!n._$IsText$_() || !Ri._$IsCharArrayAllWhitespace$_(r) || f || d || p) && !n._$HasStyleTag$_("hide")) {
                    const m = n._$GetStyleTag$_("color"), g = n._$GetStyleTag$_("opacity"), y = (this._$_SetDrawCanvasOpacity$_(g ? parseFloat(g.param) / 100 : 1), 
                    f && (this._$_SetDrawCanvasColor$_(f.param), l.fillRect(u, c - i, s, i + h)), 
                    n._$GetStyleTag$_("linethickness")), w = y ? parseFloat(y.param) : 1, S = n._$HasStyleTag$_("stroke");
                    if (S && this._$_SetDrawCanvasLineWith$_(.5 * e * w * this._$GetDrawScale$_()), 
                    n._$IsText$_()) {
                        const b = r.join("");
                        if (this._$_SetDrawFontString$_(this._$_GetFontString$_(!1, n)), 
                        !S) {
                            this._$_SetDrawCanvasLineWith$_(.5 * e * w * this._$GetDrawScale$_());
                            const M = n._$GetStyleTag$_("outlineback");
                            M && (this._$_SetDrawCanvasColor$_(M.param), this._$_FillOrStrokeText$_(!0, b, u, c, s));
                        }
                        if (this._$_SetDrawCanvasColor$_(m ? m.param : this._$_colorStr$_), 
                        this._$_FillOrStrokeText$_(S, b, u, c, s), !S) {
                            this._$_SetDrawCanvasLineWith$_(.5 * e * w * this._$GetDrawScale$_());
                            const v = n._$GetStyleTag$_("outline");
                            v && (this._$_SetDrawCanvasColor$_(v.param), this._$_FillOrStrokeText$_(!0, b, u, c, s));
                        }
                    } else if (n._$IsIcon$_() && 0 < n._$GetWidth$_()) {
                        const x = n._$GetDrawable$_(this._$_iconSet$_);
                        x && l.drawImage(x, u, c - i, s, i);
                    }
                    if (this._$_SetDrawCanvasColor$_(m ? m.param : this._$_colorStr$_), 
                    d && I(l, S, u, c + o * t, s, o * t * w), p) {
                        const G = c - i / 4, T = o * e, _ = G + T / 2;
                        l.fillRect(u, _ - T * w / 2, s, T * w);
                    }
                }
            }
        }
        _$_FillOrStrokeText$_(t, s, i, e, h) {
            "rtl" === this._$_textDirection$_ && (i += h), t ? "Gecko" === Ri._$Platform$_._$BrowserEngine$_ ? this._$_textContext$_.strokeText(s, i, e, h) : this._$_textContext$_.strokeText(s, i, e) : "Gecko" === Ri._$Platform$_._$BrowserEngine$_ ? this._$_textContext$_.fillText(s, i, e, h) : this._$_textContext$_.fillText(s, i, e);
        }
        _$_UpdateTexture$_() {
            this._$_renderer$_._$IsContextLost$_() || (this._$_texture$_ || (this._$_texture$_ = this._$_renderer$_._$CreateDynamicTexture$_(this._$_textCanvas$_.width, this._$_textCanvas$_.height, {
                _$mipMap$_: !0,
                _$mipMapQuality$_: "high"
            })), this._$_renderer$_._$UpdateTexture$_(this._$_textCanvas$_, this._$_texture$_), 
            this._$_rcTex$_.set(0, 0, this._$_width$_ / this._$_texture$_._$GetWidth$_(), this._$_height$_ / this._$_texture$_._$GetHeight$_()), 
            this._$ontextureupdate$_ && this._$ontextureupdate$_());
        }
        _$GetTexRect$_() {
            return this._$_rcTex$_;
        }
        _$ReleaseTexture$_() {
            this._$_texture$_ && (this._$_renderer$_._$IsContextLost$_() || this._$_renderer$_._$DeleteTexture$_(this._$_texture$_), 
            this._$_texture$_ = null);
        }
        static _$OnContextLost$_() {
            for (const t of Li) t._$ReleaseTexture$_();
        }
        static _$GetAll$_() {
            return Li.values();
        }
    };
}

{
    const Bi = self._$C3$_;
    class Ni {
        constructor(t) {
            this._$_gl$_ = t._$GetContext$_(), this._$_version$_ = t._$GetWebGLVersionNumber$_(), 
            this._$_timerExt$_ = t._$_GetDisjointTimerQueryExtension$_(), this._$_query$_ = null, 
            this._$_isActive$_ = !1, this._$_hasResult$_ = !1, this._$_result$_ = 0, 
            1 === this._$_version$_ ? this._$_query$_ = this._$_timerExt$_.createQueryEXT() : this._$_query$_ = this._$_gl$_.createQuery();
        }
        _$Release$_() {
            this._$_DeleteQueryObject$_(), this._$_gl$_ = null, this._$_timerExt$_ = null, 
            this._$_hasResult$_ = !1;
        }
        _$_DeleteQueryObject$_() {
            this._$_query$_ && (1 === this._$_version$_ ? this._$_timerExt$_.deleteQueryEXT(this._$_query$_) : this._$_gl$_.deleteQuery(this._$_query$_), 
            this._$_query$_ = null);
        }
        _$BeginTimeElapsed$_() {
            if (this._$_isActive$_) throw new Error("query already active");
            1 === this._$_version$_ ? this._$_timerExt$_.beginQueryEXT(this._$_timerExt$_.TIME_ELAPSED_EXT, this._$_query$_) : this._$_gl$_.beginQuery(this._$_timerExt$_.TIME_ELAPSED_EXT, this._$_query$_), 
            this._$_isActive$_ = !0;
        }
        _$EndTimeElapsed$_() {
            if (!this._$_isActive$_) throw new Error("query not active");
            1 === this._$_version$_ ? this._$_timerExt$_.endQueryEXT(this._$_timerExt$_.TIME_ELAPSED_EXT) : this._$_gl$_.endQuery(this._$_timerExt$_.TIME_ELAPSED_EXT), 
            this._$_isActive$_ = !1;
        }
        _$CheckForResult$_() {
            if (this._$_query$_ && !this._$_hasResult$_ && !this._$_isActive$_) {
                let t = !1;
                t = 1 === this._$_version$_ ? this._$_timerExt$_.getQueryObjectEXT(this._$_query$_, this._$_timerExt$_.QUERY_RESULT_AVAILABLE_EXT) : this._$_gl$_.getQueryParameter(this._$_query$_, this._$_gl$_.QUERY_RESULT_AVAILABLE);
                const s = this._$_gl$_.getParameter(this._$_timerExt$_.GPU_DISJOINT_EXT);
                t && !s && (1 === this._$_version$_ ? this._$_result$_ = this._$_timerExt$_.getQueryObjectEXT(this._$_query$_, this._$_timerExt$_.QUERY_RESULT_EXT) : this._$_result$_ = this._$_gl$_.getQueryParameter(this._$_query$_, this._$_gl$_.QUERY_RESULT), 
                this._$_result$_ /= 1e9, this._$_hasResult$_ = !0), (t || s) && this._$_DeleteQueryObject$_();
            }
        }
        _$HasResult$_() {
            return this._$_hasResult$_;
        }
        _$GetResult$_() {
            if (this._$_hasResult$_) return this._$_result$_;
            throw new Error("no result available");
        }
    }
    Bi._$Gfx$_._$WebGLTimeElapsedQuery$_ = class {
        constructor(t) {
            this._$_renderer$_ = t, this._$_frameNumber$_ = t._$GetFrameNumber$_(), 
            this._$_isActive$_ = !1, this._$_parentQuery$_ = null, this._$_isNested$_ = !1, 
            this._$_realQuery$_ = null, this._$_queries$_ = [];
        }
        _$Release$_() {
            for (const t of this._$_queries$_) t instanceof Ni && t._$Release$_();
            Bi._$clearArray$_(this._$_queries$_), this._$_parentQuery$_ = null, 
            this._$_realQuery$_ = null, this._$_renderer$_ = null;
        }
        _$BeginTimeElapsed$_() {
            if (this._$_isActive$_) throw new Error("query already active");
            const t = this._$_renderer$_._$_GetTimeQueryStack$_();
            0 < t.length ? (this._$_isNested$_ = !0, this._$_parentQuery$_ = t.at(-1), 
            this._$_parentQuery$_._$_EndReal$_(), this._$_parentQuery$_._$_queries$_.push(this)) : (this._$_isNested$_ = !1, 
            this._$_parentQuery$_ = null), this._$_isActive$_ = !0, t.push(this), 
            this._$_StartReal$_();
        }
        _$EndTimeElapsed$_() {
            if (!this._$_isActive$_) throw new Error("query not active");
            const t = this._$_renderer$_._$_GetTimeQueryStack$_().pop();
            if (t !== this) throw new Error("can only end most nested query");
            this._$_isActive$_ = !1, this._$_EndReal$_(), this._$_parentQuery$_ && (this._$_parentQuery$_._$_StartReal$_(), 
            this._$_parentQuery$_ = null);
        }
        _$_StartReal$_() {
            this._$_realQuery$_ = Bi._$New$_(Ni, this._$_renderer$_), this._$_queries$_.push(this._$_realQuery$_), 
            this._$_realQuery$_._$BeginTimeElapsed$_();
        }
        _$_EndReal$_() {
            this._$_realQuery$_._$EndTimeElapsed$_(), this._$_realQuery$_ = null;
        }
        _$CheckForResult$_() {
            for (const t of this._$_queries$_) t._$CheckForResult$_();
        }
        _$IsNested$_() {
            return this._$_isNested$_;
        }
        _$HasResult$_() {
            return this._$_queries$_.every(t => t._$HasResult$_());
        }
        _$GetResult$_() {
            return this._$_queries$_.reduce((t, s) => t + s._$GetResult$_(), 0);
        }
        _$GetFrameNumber$_() {
            return this._$_frameNumber$_;
        }
    };
}

{
    const Wi = self._$C3$_;
    Wi._$Gfx$_._$WebGLQueryResultBuffer$_ = class {
        constructor(t, s = 1e3) {
            this._$_renderer$_ = t, this._$_maxQueries$_ = s, this._$_buffer$_ = [], 
            this._$_renderer$_._$_AddQueryResultBuffer$_(this);
        }
        _$Release$_() {
            this._$Clear$_(), this._$_renderer$_._$_RemoveQueryResultBuffer$_(this), 
            this._$_renderer$_ = null;
        }
        _$Clear$_() {
            for (const t of this._$_buffer$_) t._$Release$_();
            Wi._$clearArray$_(this._$_buffer$_);
        }
        _$AddTimeElapsedQuery$_() {
            const t = new Wi._$Gfx$_._$WebGLTimeElapsedQuery$_(this._$_renderer$_);
            if (this._$_buffer$_.push(t), this._$_buffer$_.length > this._$_maxQueries$_) {
                const s = this._$_buffer$_.shift();
                s._$Release$_();
            }
            return t;
        }
        _$CheckForResults$_(t) {
            for (const s of this._$_buffer$_) {
                if (s._$GetFrameNumber$_() >= t) return;
                if (s._$IsNested$_()) return;
                s._$CheckForResult$_();
            }
        }
        _$GetFrameRangeResultSum$_(t, s) {
            if (s <= t) return NaN;
            let i = 0;
            for (const e of this._$_buffer$_) {
                if (e._$GetFrameNumber$_() >= s) break;
                if (!(e._$GetFrameNumber$_() < t)) {
                    if (!e._$HasResult$_()) return NaN;
                    i += e._$GetResult$_();
                }
            }
            return i;
        }
        _$DeleteAllBeforeFrameNumber$_(i) {
            for (let t = 0, s = this._$_buffer$_.length; t < s; ++t) {
                const e = this._$_buffer$_[t];
                if (!(e._$GetFrameNumber$_() < i)) return void (0 < t && this._$_buffer$_.splice(0, t));
                e._$Release$_();
            }
        }
    };
}

{
    let i = function() {
        h = -1;
        for (const t of e) t._$checkFunc$_() && (t.resolve(), e.delete(t));
        0 < e.size && (h = self.requestAnimationFrame(i));
    }, b = (i, self._$C3$_), t = self._$glMatrix$_, M = (t._$vec3$_, t._$vec4$_), y = t._$mat4$_, r = {
        powerPreference: "default",
        _$enableGpuProfiling$_: !0,
        alpha: !1,
        depth: !1,
        _$canSampleDepth$_: !1,
        _$maxWebGLVersion$_: 2,
        failIfMajorPerformanceCaveat: !1
    }, n = new Set([ "default", "low-power", "high-performance" ]), c = new b._$Quad$_(0, 0, 1, 0, 1, 1, 0, 1), w = y.create(), S = y.create(), v = new b._$Quad$_(), x = new b.Rect(), G = null, e = (b.isDebug && (self._$debug_lose_webgl_context$_ = function() {
        G ? G.loseContext() : console.warn("WEBGL_lose_context not supported");
    }, self._$debug_restore_webgl_context$_ = function() {
        G ? G.restoreContext() : console.warn("WEBGL_lose_context not supported");
    }), new Set()), h = -1;
    b._$Gfx$_._$WebGLRenderer$_ = class extends b._$Gfx$_._$RendererBase$_ {
        constructor(t, s) {
            if (super(s), s = Object.assign({}, r, s), !n.has(s.powerPreference)) throw new Error("invalid power preference");
            let i = {
                alpha: !!s.alpha,
                depth: !1,
                antialias: !1,
                powerPreference: s.powerPreference,
                failIfMajorPerformanceCaveat: !!s.failIfMajorPerformanceCaveat
            }, e = null, h = 0;
            if (2 <= s._$maxWebGLVersion$_ && (e = t.getContext("webgl2", i), h = 2), 
            e || (e = t.getContext("webgl", i), h = 1), !e) throw new Error("renderer-unavailable (could not get WebGL context)");
            this._$_gl$_ = e, this._$_attribs$_ = e.getContextAttributes(), this._$_versionString$_ = e.getParameter(e.VERSION), 
            this._$_version$_ = h, this._$_viewport$_ = M.create(), this._$_didChangeTransform$_ = !1, 
            this._$_bbProjectionMatrix$_ = y.create(), this._$_usesDepthBuffer$_ = !!s.depth, 
            this._$_canSampleDepth$_ = !(!s.depth || !s._$canSampleDepth$_), this._$_isDepthEnabled$_ = this._$_usesDepthBuffer$_, 
            this._$_isDepthSamplingEnabled$_ = !1, this._$_depthBuffer$_ = null, 
            this._$_isAutoSizeDepthBuffer$_ = !0, this._$_depthBufferWidth$_ = 0, 
            this._$_depthBufferHeight$_ = 0, this._$_vertexBuffer$_ = null, this._$_texcoordBuffer$_ = null, 
            this._$_indexBuffer$_ = null, this._$_pointBuffer$_ = null, this._$_vertexData$_ = new Float32Array(8e3 * this._$GetNumVertexComponents$_()), 
            this._$_indexData$_ = new Uint16Array(12e3), this._$_texcoordData$_ = new Float32Array(16e3), 
            this._$_pointData$_ = new Float32Array(32e3), this._$_vertexPtr$_ = 0, 
            this._$_texPtr$_ = 0, this._$_pointPtr$_ = 0, this._$_lastVertexPtr$_ = 0, 
            this._$_lastProgram$_ = null, this._$_spDeviceTransformTextureFill$_ = null, 
            this._$_batch$_ = [], this._$_batchPtr$_ = 0, this._$_topOfBatch$_ = 0, 
            this._$_currentRenderTarget$_ = null, this._$_lastPointZ$_ = 0, this._$_batchState$_ = b._$New$_(b._$Gfx$_._$BatchState$_, this), 
            this._$_lastColor$_ = b._$New$_(b._$Color$_, 1, 1, 1, 1), this._$_lastTexture0$_ = null, 
            this._$_lastTexture1$_ = null, this._$_lastSrcBlend$_ = 0, this._$_lastDestBlend$_ = 0, 
            this._$_lastPointTexCoords$_ = new b.Rect(), this._$_lastScissorRect$_ = b._$New$_(b.Rect, 0, 0, -1, -1), 
            this._$_coplanarMode$_ = 0, this._$_maxTextureSize$_ = -1, this._$_minPointSize$_ = 0, 
            this._$_maxPointSize$_ = 0, this._$_highpPrecision$_ = 0, this._$_unmaskedVendor$_ = "(unavailable)", 
            this._$_unmaskedRenderer$_ = "(unavailable)", this._$_extensions$_ = [], 
            this._$_isInitialisingAfterContextRestored$_ = !1, this._$_parallelShaderCompileExt$_ = null, 
            this._$_anisotropicExt$_ = null, this._$_depthTextureExt$_ = null, this._$_fragDepthExt$_ = null, 
            this._$_stdDerivativesExt$_ = null, this._$_textureLodExt$_ = null, 
            this._$_maxAnisotropy$_ = 0, this._$_isGpuProfilingEnabled$_ = !!s._$enableGpuProfiling$_, 
            this._$_timerExt$_ = null, this._$_allQueryResultBuffers$_ = new Set(), 
            this._$_timeQueryStack$_ = [], this._$FillIndexBufferData$_(this._$_indexData$_);
        }
        _$IsWebGL$_() {
            return !0;
        }
        async _$InitState$_() {
            super._$InitState$_();
            const t = this._$_gl$_, s = this._$GetNumVertexComponents$_(), i = (this._$_lastColor$_._$setRgba$_(1, 1, 1, 1), 
            this._$_lastTexture0$_ = null, this._$_lastTexture1$_ = null, this._$_vertexPtr$_ = 0, 
            this._$_pointPtr$_ = 0, this._$_lastVertexPtr$_ = 8e3 * s - 4 * s, b._$clearArray$_(this._$_batch$_), 
            this._$_batchPtr$_ = 0, this._$_topOfBatch$_ = 0, this._$_lastProgram$_ = null, 
            this._$_currentRenderTarget$_ = null, this._$_lastPointTexCoords$_.set(0, 0, 1, 1), 
            this._$_lastPointZ$_ = 0, this._$_batchState$_), e = (i._$currentShader$_ = null, 
            i._$currentFramebuffer$_ = null, i._$currentFramebufferNoDepth$_ = null, 
            M.set(i._$currentColor$_, 1, 1, 1, 1), i.clearColor._$setRgba$_(0, 0, 0, 0), 
            i._$pointTexCoords$_.set(0, 0, 1, 1), t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT), 
            t.enable(t.BLEND), t.blendFunc(t.ONE, t.ONE_MINUS_SRC_ALPHA), this._$_lastSrcBlend$_ = t.ONE, 
            this._$_lastDestBlend$_ = t.ONE_MINUS_SRC_ALPHA, this._$_InitBlendModes$_(t), 
            t.disable(t.CULL_FACE), t.disable(t.STENCIL_TEST), t.disable(t.DITHER), 
            this._$_usesDepthBuffer$_ ? (t.enable(t.DEPTH_TEST), t.depthMask(!0), 
            t.depthFunc(t.LEQUAL)) : (t.disable(t.DEPTH_TEST), t.depthMask(!1)), 
            this._$_isDepthEnabled$_ = this._$_usesDepthBuffer$_, this._$_isDepthSamplingEnabled$_ = !1, 
            this._$_pointBuffer$_ = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._$_pointBuffer$_), 
            t.bufferData(t.ARRAY_BUFFER, this._$_pointData$_.byteLength, t.DYNAMIC_DRAW), 
            this._$_vertexBuffer$_ = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._$_vertexBuffer$_), 
            t.bufferData(t.ARRAY_BUFFER, this._$_vertexData$_.byteLength, t.DYNAMIC_DRAW), 
            this._$_texcoordBuffer$_ = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._$_texcoordBuffer$_), 
            t.bufferData(t.ARRAY_BUFFER, this._$_texcoordData$_.byteLength, t.DYNAMIC_DRAW), 
            this._$_indexBuffer$_ = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._$_indexBuffer$_), 
            t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._$_indexData$_, t.STATIC_DRAW), 
            t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, null), this._$_maxTextureSize$_ = t.getParameter(t.MAX_TEXTURE_SIZE), 
            t.getParameter(t.ALIASED_POINT_SIZE_RANGE)), h = (this._$_minPointSize$_ = e[0], 
            this._$_maxPointSize$_ = e[1], t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT)), r = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT), n = (this._$_highpPrecision$_ = h && r ? Math.min(h.precision, r.precision) : 0, 
            2048 < this._$_maxPointSize$_ && (this._$_maxPointSize$_ = 2048), this._$_extensions$_ = t.getSupportedExtensions(), 
            t.getExtension("WEBGL_debug_renderer_info"));
            if (n && (this._$_unmaskedVendor$_ = t.getParameter(n.UNMASKED_VENDOR_WEBGL), 
            this._$_unmaskedRenderer$_ = t.getParameter(n.UNMASKED_RENDERER_WEBGL)), 
            this._$_parallelShaderCompileExt$_ = t.getExtension("KHR_parallel_shader_compile"), 
            b.isDebug && (G = t.getExtension("WEBGL_lose_context")), this._$_isGpuProfilingEnabled$_ && (1 === this._$GetWebGLVersionNumber$_() ? this._$_timerExt$_ = t.getExtension("EXT_disjoint_timer_query") : this._$_timerExt$_ = t.getExtension("EXT_disjoint_timer_query_webgl2") || t.getExtension("EXT_disjoint_timer_query")), 
            this._$_anisotropicExt$_ = t.getExtension("EXT_texture_filter_anisotropic"), 
            this._$_anisotropicExt$_ ? this._$_maxAnisotropy$_ = t.getParameter(this._$_anisotropicExt$_.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : this._$_maxAnisotropy$_ = 0, 
            this._$GetWebGLVersionNumber$_() < 2 && this._$_usesDepthBuffer$_ && this._$_canSampleDepth$_ && (this._$_depthTextureExt$_ = t.getExtension("WEBGL_depth_texture"), 
            !this._$_depthTextureExt$_)) throw new Error("no depth texture support");
            this._$GetWebGLVersionNumber$_() < 2 && (this._$_fragDepthExt$_ = t.getExtension("EXT_frag_depth"), 
            this._$_stdDerivativesExt$_ = t.getExtension("OES_standard_derivatives"), 
            this._$_textureLodExt$_ = t.getExtension("EXT_shader_texture_lod"));
            let o = b._$Gfx$_._$WebGLShaderProgram$_, a = o._$GetDefaultVertexShaderSource$_(!1), l = o._$GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth$_(), u = a, c = o._$GetPointFragmentShaderSource_WebGL1_NoFragDepth$_(), f = o._$GetPointVertexShaderSource_WebGL1$_(), d = o._$GetTilemapFragmentShaderSource_WebGL1_NoFragDepth$_(), p = o._$GetDefaultVertexShaderSource$_(!0), m = !1;
            this._$_usesDepthBuffer$_ && (this._$GetWebGLVersionNumber$_() < 2 ? this._$_fragDepthExt$_ && (l = o._$GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT$_(), 
            c = o._$GetPointFragmentShaderSource_WebGL1_FragDepthEXT$_(), d = o._$GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT$_(), 
            m = !0) : (u = o._$GetDefaultVertexShaderSource_WebGL2$_(), l = o._$GetTextureFillFragmentShaderSource_WebGL2$_(), 
            c = o._$GetPointFragmentShaderSource_WebGL2$_(), f = o._$GetPointVertexShaderSource_WebGL2$_(), 
            d = o._$GetTilemapFragmentShaderSource_WebGL2$_(), p = o._$GetDefaultVertexShaderSource_WebGL2$_(!0)));
            const g = o._$GetTileRandomizationFragmentShaderSource$_(this._$GetWebGLVersionNumber$_(), m, this._$_stdDerivativesExt$_ && this._$_textureLodExt$_), y = 2 <= this._$GetWebGLVersionNumber$_() ? o._$GetDefaultVertexShaderSource_WebGL2$_() : a, w = [ [ l, u, "<default>" ], [ l, u, "<default-device-transform>" ], [ c, f, "<point>" ], [ o._$GetColorFillFragmentShaderSource$_(), a, "<fill>" ], [ o._$GetLinearGradientFillFragmentShaderSource$_(), a, "<lineargradient>" ], [ o._$GetPenumbraFillFragmentShaderSource$_(), a, "<penumbra>" ], [ o._$GetHardEllipseFillFragmentShaderSource$_(), a, "<hardellipse>" ], [ o._$GetHardEllipseOutlineFragmentShaderSource$_(), a, "<hardellipseoutline>" ], [ o._$GetSmoothEllipseFillFragmentShaderSource$_(), a, "<smoothellipse>" ], [ o._$GetSmoothEllipseOutlineFragmentShaderSource$_(), a, "<smoothellipseoutline>" ], [ o._$GetSmoothLineFillFragmentShaderSource$_(), a, "<smoothline>" ], [ d, p, "<tilemap>" ], [ g, y, "<tilerandomization>" ] ], S = await Promise.all(w.map(t => this._$CreateShaderProgram$_({
                src: t[0],
                _$vertexSrc$_: t[1],
                name: t[2]
            })));
            this._$_spTextureFill$_ = S[0], this._$_spDeviceTransformTextureFill$_ = S[1], 
            this._$_spPoints$_ = S[2], this._$_spColorFill$_ = S[3], this._$_spLinearGradientFill$_ = S[4], 
            this._$_spPenumbraFill$_ = S[5], this._$_spHardEllipseFill$_ = S[6], 
            this._$_spHardEllipseOutline$_ = S[7], this._$_spSmoothEllipseFill$_ = S[8], 
            this._$_spSmoothEllipseOutline$_ = S[9], this._$_spSmoothLineFill$_ = S[10], 
            this._$_spTilemapFill$_ = S[11], this._$_spTileRandomization$_ = S[12], 
            this._$SetTextureFillMode$_();
        }
        async _$CreateShaderProgram$_(t) {
            const s = await b._$Gfx$_._$WebGLShaderProgram$_._$Create$_(this, t);
            return this._$_AddShaderProgram$_(s), s;
        }
        _$ResetLastProgram$_() {
            this._$_lastProgram$_ = null;
        }
        _$SetSize$_(t, s, i) {
            if (this._$_width$_ !== t || this._$_height$_ !== s || i) {
                this._$EndBatch$_();
                const e = this._$_gl$_, h = this._$_batchState$_;
                this._$_width$_ = t, this._$_height$_ = s, this._$_SetViewport$_(0, 0, t, s), 
                this._$CalculatePerspectiveMatrix$_(this._$_bbProjectionMatrix$_, t / s), 
                this._$SetProjectionMatrix$_(this._$_bbProjectionMatrix$_), this._$_spDeviceTransformTextureFill$_ && (e.useProgram(this._$_spDeviceTransformTextureFill$_._$GetShaderProgram$_()), 
                this._$_spDeviceTransformTextureFill$_._$_UpdateDeviceTransformUniforms$_(this._$_matP$_), 
                this._$_lastProgram$_ = this._$_spDeviceTransformTextureFill$_, 
                this._$_batchState$_._$currentShader$_ = this._$_spDeviceTransformTextureFill$_), 
                e.bindTexture(e.TEXTURE_2D, null), e.activeTexture(e.TEXTURE1), 
                e.bindTexture(e.TEXTURE_2D, null), e.activeTexture(e.TEXTURE0), 
                this._$_lastTexture0$_ = null, this._$_lastTexture1$_ = null, this._$_usesDepthBuffer$_ && this._$_isAutoSizeDepthBuffer$_ && this._$_SetDepthBufferSize$_(this._$_width$_, this._$_height$_), 
                this._$_currentRenderTarget$_ && this._$_currentRenderTarget$_._$_Resize$_(this._$_width$_, this._$_height$_), 
                e.bindFramebuffer(e.FRAMEBUFFER, null), this._$_currentRenderTarget$_ = null, 
                h._$currentFramebuffer$_ = null, h._$currentFramebufferNoDepth$_ = null;
            }
        }
        _$_SetDepthBufferSize$_(t, s) {
            const i = this._$_gl$_;
            this._$_depthBuffer$_ && this._$_depthBufferWidth$_ === t && this._$_depthBufferHeight$_ === s || (this._$_canSampleDepth$_ ? (this._$_depthBuffer$_ && i.deleteTexture(this._$_depthBuffer$_), 
            this._$_depthBuffer$_ = i.createTexture(), i.bindTexture(i.TEXTURE_2D, this._$_depthBuffer$_), 
            i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.NEAREST), 
            i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), 
            2 <= this._$GetWebGLVersionNumber$_() ? i.texImage2D(i.TEXTURE_2D, 0, i.DEPTH24_STENCIL8, t, s, 0, i.DEPTH_STENCIL, i.UNSIGNED_INT_24_8, null) : this._$_depthTextureExt$_ && i.texImage2D(i.TEXTURE_2D, 0, i.DEPTH_STENCIL, t, s, 0, i.DEPTH_STENCIL, this._$_depthTextureExt$_.UNSIGNED_INT_24_8_WEBGL, null), 
            i.bindTexture(i.TEXTURE_2D, null)) : (this._$_depthBuffer$_ && i.deleteRenderbuffer(this._$_depthBuffer$_), 
            this._$_depthBuffer$_ = i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, this._$_depthBuffer$_), 
            i.renderbufferStorage(i.RENDERBUFFER, 2 <= this._$_version$_ ? i.DEPTH24_STENCIL8 : i.DEPTH_STENCIL, t, s), 
            i.bindRenderbuffer(i.RENDERBUFFER, null)), this._$_depthBufferWidth$_ = t, 
            this._$_depthBufferHeight$_ = s);
        }
        _$SetFixedSizeDepthBuffer$_(t, s) {
            this._$_usesDepthBuffer$_ && (this._$_isAutoSizeDepthBuffer$_ = !1, 
            this._$_SetDepthBufferSize$_(t, s));
        }
        _$SetAutoSizeDepthBuffer$_() {
            this._$_usesDepthBuffer$_ && (this._$_isAutoSizeDepthBuffer$_ = !0, 
            this._$_SetDepthBufferSize$_(this._$_width$_, this._$_height$_));
        }
        _$_SetViewport$_(t, s, i, e) {
            const h = this._$_viewport$_;
            if (h[0] !== t || h[1] !== s || h[2] !== i || h[3] !== e) {
                const r = this._$PushBatch$_();
                r._$InitSetViewport$_(t, s, i, e), M.set(h, t, s, i, e), this._$_topOfBatch$_ = 0;
            }
        }
        _$SetFovY$_(t) {
            super._$SetFovY$_(t), this._$CalculatePerspectiveMatrix$_(this._$_bbProjectionMatrix$_, this._$_width$_ / this._$_height$_);
        }
        _$SetNearZ$_(t) {
            super._$SetNearZ$_(t), this._$CalculatePerspectiveMatrix$_(this._$_bbProjectionMatrix$_, this._$_width$_ / this._$_height$_);
        }
        _$SetFarZ$_(t) {
            super._$SetFarZ$_(t), this._$CalculatePerspectiveMatrix$_(this._$_bbProjectionMatrix$_, this._$_width$_ / this._$_height$_);
        }
        _$SetProjectionMatrix$_(t) {
            if (!y._$exactEquals$_(this._$_matP$_, t)) {
                const s = this._$PushBatch$_();
                s._$InitSetProjection$_(t), y._$copy$_(this._$_matP$_, t), this._$_topOfBatch$_ = 0, 
                this._$_didChangeTransform$_ = !0;
            }
        }
        _$SetDefaultRenderTargetProjectionState$_() {
            let t, s, i, e = this._$_currentRenderTarget$_;
            i = (null === e ? (t = this._$_bbProjectionMatrix$_, s = this._$GetWidth$_(), 
            this) : (t = e._$GetProjectionMatrix$_(), s = e._$GetWidth$_(), e))._$GetHeight$_(), 
            this._$SetProjectionMatrix$_(t), this._$_SetViewport$_(0, 0, s, i);
        }
        _$SetModelViewMatrix$_(t) {
            if (!y._$exactEquals$_(this._$_matMV$_, t)) {
                const s = this._$PushBatch$_();
                s._$InitSetModelView$_(t), y._$copy$_(this._$_matMV$_, t), this._$_topOfBatch$_ = 0, 
                this._$_didChangeTransform$_ = !0;
            }
        }
        _$ResetDidChangeTransformFlag$_() {
            this._$_didChangeTransform$_ = !1;
        }
        _$DidChangeTransform$_() {
            return this._$_didChangeTransform$_;
        }
        _$GetBatchState$_() {
            return this._$_batchState$_;
        }
        _$PushBatch$_() {
            const t = this._$_batch$_;
            return this._$_batchPtr$_ === t.length && t.push(new b._$Gfx$_._$WebGLBatchJob$_(this._$_batchState$_)), 
            t[this._$_batchPtr$_++];
        }
        _$EndBatch$_() {
            0 === this._$_batchPtr$_ || this._$IsContextLost$_() || (this._$_WriteBuffers$_(), 
            this._$_ExecuteBatch$_(), this._$_batchPtr$_ = 0, this._$_vertexPtr$_ = 0, 
            this._$_texPtr$_ = 0, this._$_pointPtr$_ = 0, this._$_topOfBatch$_ = 0);
        }
        _$_WriteBuffers$_() {
            const t = this._$_gl$_;
            0 < this._$_pointPtr$_ && (t.bindBuffer(t.ARRAY_BUFFER, this._$_pointBuffer$_), 
            t.bufferSubData(t.ARRAY_BUFFER, 0, this._$_pointData$_.subarray(0, this._$_pointPtr$_))), 
            0 < this._$_vertexPtr$_ && (t.bindBuffer(t.ARRAY_BUFFER, this._$_vertexBuffer$_), 
            t.bufferSubData(t.ARRAY_BUFFER, 0, this._$_vertexData$_.subarray(0, this._$_vertexPtr$_)), 
            t.bindBuffer(t.ARRAY_BUFFER, this._$_texcoordBuffer$_), t.bufferSubData(t.ARRAY_BUFFER, 0, this._$_texcoordData$_.subarray(0, this._$_texPtr$_)));
        }
        _$_ExecuteBatch$_() {
            const i = this._$_batch$_;
            for (let t = 0, s = this._$_batchPtr$_; t < s; ++t) i[t]._$Run$_();
        }
        _$GetOpacity$_() {
            return this._$_lastColor$_._$getA$_();
        }
        _$SetColorRgba$_(t, s, i, e) {
            const h = this._$_lastColor$_;
            if (!h._$equalsRgba$_(t, s, i, e)) {
                h._$setRgba$_(t, s, i, e);
                const r = this._$PushBatch$_();
                r._$InitSetColor$_(h), this._$_topOfBatch$_ = 0, this._$_currentStateGroup$_ = null;
            }
        }
        _$SetOpacity$_(t) {
            const s = this._$_lastColor$_;
            if (s._$getA$_() !== t) {
                s._$setA$_(t);
                const i = this._$PushBatch$_();
                i._$InitSetColor$_(s), this._$_topOfBatch$_ = 0, this._$_currentStateGroup$_ = null;
            }
        }
        _$SetColor$_(t) {
            const s = this._$_lastColor$_;
            if (!s.equals(t)) {
                s.set(t);
                const i = this._$PushBatch$_();
                i._$InitSetColor$_(s), this._$_topOfBatch$_ = 0, this._$_currentStateGroup$_ = null;
            }
        }
        _$ResetColor$_() {
            this._$SetColorRgba$_(1, 1, 1, 1);
        }
        _$GetColor$_() {
            return this._$_lastColor$_;
        }
        _$SetTexture$_(t) {
            if (t !== this._$_lastTexture0$_) {
                const s = this._$PushBatch$_();
                s._$InitSetTexture$_(t), this._$_lastTexture0$_ = t, this._$_topOfBatch$_ = 0;
            }
        }
        _$_ResetLastTexture$_() {
            this._$_lastTexture0$_ = null;
        }
        _$SetBlendMode$_(t) {
            const s = this._$_GetBlendByIndex$_(t);
            this._$_SetBlend$_(s[0], s[1]);
        }
        _$SetNamedBlendMode$_(t) {
            const s = this._$GetNamedBlend$_(t);
            this._$_SetBlend$_(s._$srcBlend$_, s._$destBlend$_);
        }
        _$_SetBlend$_(t, s) {
            if (t !== this._$_lastSrcBlend$_ || s !== this._$_lastDestBlend$_) {
                const i = this._$PushBatch$_();
                i._$InitSetBlend$_(t, s), this._$_lastSrcBlend$_ = t, this._$_lastDestBlend$_ = s, 
                this._$_topOfBatch$_ = 0, this._$_currentStateGroup$_ = null;
            }
        }
        _$IsPremultipliedAlphaBlend$_() {
            return this._$_lastSrcBlend$_ === this._$_gl$_.ONE && this._$_lastDestBlend$_ === this._$_gl$_.ONE_MINUS_SRC_ALPHA;
        }
        _$SetAlphaBlend$_() {
            this._$_SetBlend$_(this._$_gl$_.ONE, this._$_gl$_.ONE_MINUS_SRC_ALPHA);
        }
        _$SetNoPremultiplyAlphaBlend$_() {
            this._$_SetBlend$_(this._$_gl$_.SRC_ALPHA, this._$_gl$_.ONE_MINUS_SRC_ALPHA);
        }
        _$SetCopyBlend$_() {
            this._$_SetBlend$_(this._$_gl$_.ONE, this._$_gl$_.ZERO);
        }
        Rect(t) {
            this._$Rect2$_(t._$getLeft$_(), t._$getTop$_(), t._$getRight$_(), t._$getBottom$_());
        }
        _$Rect2$_(t, s, i, e) {
            this._$Quad2$_(t, s, i, s, i, e, t, e);
        }
        _$_ExtendQuadBatch$_() {
            let t = this._$_vertexPtr$_;
            if (t >= this._$_lastVertexPtr$_ && (this._$EndBatch$_(), t = 0), 1 === this._$_topOfBatch$_) this._$_batch$_[this._$_batchPtr$_ - 1]._$_indexCount$_ += 6; else {
                const s = this._$PushBatch$_();
                s._$InitQuad$_(t, 6), this._$_topOfBatch$_ = 1;
            }
        }
        _$_WriteQuadToVertexBuffer$_(t) {
            t._$writeToTypedArray3D$_(this._$_vertexData$_, this._$_vertexPtr$_, this._$_baseZ$_ + this._$_currentZ$_), 
            this._$_vertexPtr$_ += 12;
        }
        _$Quad$_(t) {
            this._$_ExtendQuadBatch$_(), this._$_WriteQuadToVertexBuffer$_(t), c._$writeToTypedArray$_(this._$_texcoordData$_, this._$_texPtr$_), 
            this._$_texPtr$_ += 8;
        }
        _$Quad2$_(t, s, i, e, h, r, n, o) {
            this._$_ExtendQuadBatch$_();
            let a = this._$_vertexData$_, l = this._$_vertexPtr$_, u = this._$_baseZ$_ + this._$_currentZ$_;
            a[l++] = t, a[l++] = s, a[l++] = u, a[l++] = i, a[l++] = e, a[l++] = u, 
            a[l++] = h, a[l++] = r, a[l++] = u, a[l++] = n, a[l++] = o, a[l++] = u, 
            this._$_vertexPtr$_ = l, c._$writeToTypedArray$_(this._$_texcoordData$_, this._$_texPtr$_), 
            this._$_texPtr$_ += 8;
        }
        _$Quad3$_(t, s) {
            this._$_ExtendQuadBatch$_(), this._$_WriteQuadToVertexBuffer$_(t), s._$writeAsQuadToTypedArray$_(this._$_texcoordData$_, this._$_texPtr$_), 
            this._$_texPtr$_ += 8;
        }
        _$Quad4$_(t, s) {
            this._$_ExtendQuadBatch$_(), this._$_WriteQuadToVertexBuffer$_(t), s._$writeToTypedArray$_(this._$_texcoordData$_, this._$_texPtr$_), 
            this._$_texPtr$_ += 8;
        }
        _$Quad3D$_(t, s, i, e, h, r, n, o, a, l, u, c, f) {
            this._$_ExtendQuadBatch$_();
            let d = this._$_vertexData$_, p = this._$_vertexPtr$_, m = this._$_baseZ$_ + this._$_currentZ$_;
            d[p++] = t, d[p++] = s, d[p++] = m + i, d[p++] = e, d[p++] = h, d[p++] = m + r, 
            d[p++] = n, d[p++] = o, d[p++] = m + a, d[p++] = l, d[p++] = u, d[p++] = m + c, 
            this._$_vertexPtr$_ = p, f._$writeAsQuadToTypedArray$_(this._$_texcoordData$_, this._$_texPtr$_), 
            this._$_texPtr$_ += 8;
        }
        _$Quad3D2$_(t, s, i, e, h, r, n, o, a, l, u, c, f) {
            this._$_ExtendQuadBatch$_();
            let d = this._$_vertexData$_, p = this._$_vertexPtr$_, m = this._$_baseZ$_ + this._$_currentZ$_;
            d[p++] = t, d[p++] = s, d[p++] = m + i, d[p++] = e, d[p++] = h, d[p++] = m + r, 
            d[p++] = n, d[p++] = o, d[p++] = m + a, d[p++] = l, d[p++] = u, d[p++] = m + c, 
            this._$_vertexPtr$_ = p, f._$writeToTypedArray$_(this._$_texcoordData$_, this._$_texPtr$_), 
            this._$_texPtr$_ += 8;
        }
        _$DrawMesh$_(e, h, r) {
            const n = this._$_vertexData$_, o = this._$_texcoordData$_;
            if (r.length % 3 != 0) throw new Error("invalid index buffer length");
            for (let i = 0, t = r.length; i < t; ) {
                const a = r[i++], l = r[i++], u = r[i++], c = 3 * a, f = 3 * l, d = 3 * u, p = 2 * a, m = 2 * l, g = 2 * u;
                this._$_ExtendQuadBatch$_();
                let t = this._$_vertexPtr$_, s = this._$_texPtr$_;
                n[t++] = e[0 + c], n[t++] = e[1 + c], n[t++] = e[2 + c], n[t++] = e[0 + f], 
                n[t++] = e[1 + f], n[t++] = e[2 + f], n[t++] = e[0 + d], n[t++] = e[1 + d], 
                n[t++] = e[2 + d], n[t++] = e[0 + d], n[t++] = e[1 + d], n[t++] = e[2 + d], 
                o[s++] = h[0 + p], o[s++] = h[1 + p], o[s++] = h[0 + m], o[s++] = h[1 + m], 
                o[s++] = h[0 + g], o[s++] = h[1 + g], o[s++] = h[0 + g], o[s++] = h[1 + g], 
                this._$_vertexPtr$_ = t, this._$_texPtr$_ = s;
            }
        }
        _$FullscreenQuad$_(t, s) {
            this._$SetCurrentZ$_(0), y._$copy$_(w, this._$_matP$_), y._$copy$_(S, this._$_matMV$_), 
            this._$SetDefaultRenderTargetProjectionState$_();
            const [ i, e ] = this._$GetRenderTargetSize$_(this._$_currentRenderTarget$_), h = this._$CalculateLookAtModelView2$_(0, 0, this._$GetDefaultCameraZ$_(e), 0, 0, 0, e);
            if (this._$SetModelViewMatrix$_(h), "crop" === t && this._$_currentRenderTarget$_ && s) {
                const r = this._$_width$_ / 2, n = this._$_height$_ / 2, o = s._$GetWidth$_(), a = s._$GetHeight$_(), l = this._$_currentRenderTarget$_._$GetWidth$_(), u = this._$_currentRenderTarget$_._$GetHeight$_(), c = Math.min(l, o), f = Math.min(u, a), d = Math.max(a - u, 0), p = Math.max(u - a, 0);
                x.set(-r, n - p, -r + c, n - f - p), v._$setFromRect$_(x), x.set(0, d, c, f + d), 
                x._$divide$_(o, a), this._$Quad3$_(v, x);
            } else {
                const m = i / 2, g = e / 2;
                this._$Rect2$_(-m, g, m, -g);
            }
            this._$SetProjectionMatrix$_(w), this._$SetModelViewMatrix$_(S);
        }
        _$StartRenderingPoints$_(t) {
            if (!this._$_lastPointTexCoords$_.equals(t)) {
                this._$_lastPointTexCoords$_._$copy$_(t);
                const s = this._$PushBatch$_();
                s._$InitSetPointTexCoords$_(t), this._$_topOfBatch$_ = 0;
            }
        }
        _$FinishRenderingPoints$_() {}
        _$Point$_(t, s, i, e) {
            7996 <= this._$_pointPtr$_ && this._$EndBatch$_();
            let h = this._$_pointPtr$_, r = this._$_baseZ$_ + this._$_currentZ$_;
            if (2 === this._$_topOfBatch$_ && this._$_lastPointZ$_ === r) this._$_batch$_[this._$_batchPtr$_ - 1]._$_indexCount$_++; else {
                const o = this._$PushBatch$_();
                o._$InitPoints$_(h, r), this._$_topOfBatch$_ = 2, this._$_lastPointZ$_ = r;
            }
            const n = this._$_pointData$_;
            n[h++] = t, n[h++] = s, n[h++] = i, n[h++] = e, this._$_pointPtr$_ = h;
        }
        _$SetProgram$_(t) {
            if (this._$_lastProgram$_ !== t) {
                const s = this._$PushBatch$_();
                s._$InitSetProgram$_(t), this._$_lastProgram$_ = t, this._$_topOfBatch$_ = 0, 
                this._$_currentStateGroup$_ = null;
            }
        }
        _$GetProgram$_() {
            return this._$_lastProgram$_;
        }
        _$SetDeviceTransformTextureFillMode$_() {
            this._$SetProgram$_(this._$_spDeviceTransformTextureFill$_);
        }
        _$SetGradientColor$_(t) {
            const s = this._$PushBatch$_();
            s._$InitSetGradientColor$_(t), this._$_topOfBatch$_ = 0;
        }
        _$SetEllipseParams$_(t, s, i = 1) {
            const e = this._$PushBatch$_();
            e._$InitSetEllipseParams$_(t, s, i), this._$_topOfBatch$_ = 0;
        }
        _$SetTilemapInfo$_(t, s, i, e, h, r, n) {
            if (this._$_lastProgram$_ !== this._$_spTilemapFill$_) throw new Error("must set tilemap fill mode first");
            const o = this._$PushBatch$_();
            o._$InitSetTilemapInfo$_(t, s, i, e, h, r, n), this._$_topOfBatch$_ = 0;
        }
        _$SetTileRandomizationInfo$_(t, s, i, e, h, r, n) {
            if (this._$_lastProgram$_ !== this._$_spTileRandomization$_) throw new Error("must set tile randomization mode first");
            const o = this._$PushBatch$_();
            o._$InitSetTileRandomizationInfo$_(t, s, i, e, h, r, n), this._$_topOfBatch$_ = 0;
        }
        _$SetProgramParameters$_(t, s, i, e, h, r, n, o, a, l, u) {
            const c = this._$_lastProgram$_;
            if (u %= 10800, c._$_hasAnyOptionalUniforms$_ && !c._$AreOptionalUniformsAlreadySetInBatch$_(s, i, e, h, r, n, o, a, l, u)) {
                const f = this._$PushBatch$_(), d = (f._$InitSetProgramParameters$_(), 
                c._$SetOptionalUniformsInBatch$_(s, i, e, h, r, n, o, a, l, u), 
                f._$_mat4param$_), p = (d[0] = r, d[1] = n, s._$writeToTypedArray$_(d, 2), 
                d[6] = a, d[7] = l, i._$writeToTypedArray$_(d, 12), f._$_colorParam$_), m = (h._$writeToTypedArray$_(p, 0), 
                p[1]);
                p[1] = p[3], p[3] = m, e._$writeToTypedArray$_(f._$_srcOriginRect$_, 0), 
                f._$_startIndex$_ = u, f._$_indexCount$_ = o, c._$_uSamplerBack$_._$IsUsed$_() ? f._$_texParam$_ = t ? t._$GetTexture$_() : null : f._$_texParam$_ = null, 
                this._$_topOfBatch$_ = 0;
            }
        }
        _$SetProgramCustomParameters$_(t) {
            const s = this._$_lastProgram$_;
            if (0 !== t.length && !s._$AreCustomParametersAlreadySetInBatch$_(t)) {
                const i = this._$PushBatch$_();
                i._$InitSetProgramCustomParameters$_(), s._$SetCustomParametersInBatch$_(t), 
                b._$shallowAssignArray$_(i._$_shaderParams$_, t), this._$_topOfBatch$_ = 0;
            }
        }
        _$ClearRgba$_(t, s, i, e) {
            const h = this._$PushBatch$_();
            h._$InitClearSurface2$_(t, s, i, e), this._$_topOfBatch$_ = 0;
        }
        _$Clear$_(t) {
            const s = this._$PushBatch$_();
            s._$InitClearSurface$_(t), this._$_topOfBatch$_ = 0;
        }
        _$Start$_() {}
        _$Finish$_() {
            super._$Finish$_(), this._$_gl$_.flush();
        }
        _$ClearDepth$_() {
            if (this._$_usesDepthBuffer$_ && this._$_currentRenderTarget$_ && this._$_currentRenderTarget$_._$HasDepthBuffer$_()) {
                const t = this._$PushBatch$_();
                t._$InitClearDepth$_(this._$_isDepthEnabled$_), this._$_topOfBatch$_ = 0;
            }
        }
        _$SetDepthEnabled$_(t) {
            if (this._$_isDepthEnabled$_ !== (t = !!t) && this._$_usesDepthBuffer$_) {
                this._$_isDepthEnabled$_ = t;
                const s = this._$PushBatch$_();
                s._$InitSetDepthEnabled$_(t), this._$_topOfBatch$_ = 0;
            }
        }
        _$IsDepthEnabled$_() {
            return this._$_isDepthEnabled$_;
        }
        _$_GetDepthBuffer$_() {
            return this._$_depthBuffer$_;
        }
        _$_CanSampleDepth$_() {
            return this._$_canSampleDepth$_;
        }
        _$SetDepthSamplingEnabled$_(t) {
            if (t = !!t, this._$_canSampleDepth$_ && this._$_isDepthSamplingEnabled$_ !== t) {
                if (t && this._$IsDepthEnabled$_()) throw new Error("depth still enabled");
                this._$_isDepthSamplingEnabled$_ = t;
                const s = this._$PushBatch$_();
                s._$InitSetDepthSamplingEnabled$_(t), this._$_topOfBatch$_ = 0;
            }
        }
        _$SetScissorRect$_(t, s, i, e, h = 0) {
            if (t = Math.floor(t), s = Math.floor(s), i = Math.floor(i), e = Math.floor(e), 
            !this._$_lastScissorRect$_._$equalsWH$_(t, s, i, e)) {
                this._$_lastScissorRect$_._$setWH$_(t, s, i, e);
                const r = h || this._$GetRenderTargetSize$_(this._$GetRenderTarget$_())[1], n = (s = r - s - e, 
                this._$PushBatch$_());
                n._$InitSetScissor$_(!0, t, s, i, e), this._$_topOfBatch$_ = 0;
            }
        }
        _$RemoveScissorRect$_() {
            if (-1 !== this._$_lastScissorRect$_._$getRight$_()) {
                this._$_lastScissorRect$_.set(0, 0, -1, -1);
                const t = this._$PushBatch$_();
                t._$InitSetScissor$_(!1, 0, 0, 0, 0), this._$_topOfBatch$_ = 0;
            }
        }
        _$CheckForQueryResults$_() {
            for (const t of this._$_allQueryResultBuffers$_) t._$CheckForResults$_(this._$_frameNumber$_);
        }
        _$IsContextLost$_() {
            return !this._$_gl$_ || this._$_gl$_.isContextLost() || this._$_isInitialisingAfterContextRestored$_;
        }
        _$OnContextLost$_() {
            super._$OnDeviceOrContextLost$_(), b._$Gfx$_._$WebGLRendererTexture$_._$OnContextLost$_(), 
            b._$Gfx$_._$WebGLRenderTarget$_._$OnContextLost$_(), b._$Gfx$_._$RendererText$_._$OnContextLost$_();
            for (const t of this._$_allQueryResultBuffers$_) t._$Clear$_();
            this._$_extensions$_ = [], this._$_timerExt$_ = null, this._$_parallelShaderCompileExt$_ = null, 
            this._$_anisotropicExt$_ = null, this._$_depthTextureExt$_ = null, this._$_fragDepthExt$_ = null, 
            this._$_stdDerivativesExt$_ = null, this._$_textureLodExt$_ = null, 
            this._$_maxAnisotropy$_ = 0, this._$_unmaskedVendor$_ = "(unavailable)", 
            this._$_unmaskedRenderer$_ = "(unavailable)", this._$_lastProgram$_ = null, 
            this._$_spDeviceTransformTextureFill$_ = null, this._$_depthBuffer$_ = null;
            for (const s of this._$_stateGroups$_.values()) s._$OnContextLost$_();
        }
        async _$OnContextRestored$_() {
            this._$_isInitialisingAfterContextRestored$_ = !0, await this._$InitState$_(), 
            this._$_isInitialisingAfterContextRestored$_ = !1;
            for (const t of this._$_stateGroups$_.values()) t._$OnContextRestored$_(this);
            this._$SetSize$_(this._$_width$_, this._$_height$_, !0);
        }
        _$CreateStaticTexture$_(t, s) {
            if (this._$IsContextLost$_()) throw new Error("context lost");
            this._$EndBatch$_();
            const i = b._$New$_(b._$Gfx$_._$WebGLRendererTexture$_, this);
            return i._$_CreateStatic$_(t, s), i;
        }
        async _$CreateStaticTextureAsync$_(e, h) {
            if (this._$IsContextLost$_()) throw new Error("context lost");
            if (h = Object.assign({}, h), b._$Supports$_.ImageBitmapOptions) {
                let t = await createImageBitmap(e, {
                    premultiplyAlpha: "premultiply"
                }), s = h._$wrapX$_ && "clamp-to-edge" !== h._$wrapX$_ || h._$wrapY$_ && "clamp-to-edge" !== h._$wrapY$_, i = b._$isPOT$_(t.width) && b._$isPOT$_(t.height);
                return this._$SupportsNPOTTextures$_() || i || !s ? h.premultiplyAlpha = !1 : b._$Supports$_._$ImageBitmapOptionsResize$_ ? (t = await createImageBitmap(e, {
                    premultiplyAlpha: "premultiply",
                    resizeWidth: b._$nextHighestPowerOfTwo$_(t.width),
                    resizeHeight: b._$nextHighestPowerOfTwo$_(t.height)
                }), h.premultiplyAlpha = !1) : t = await createImageBitmap(e, {
                    premultiplyAlpha: "none"
                }), b._$Asyncify$_(() => this._$CreateStaticTexture$_(t, h));
            }
            if (e instanceof Blob) {
                if ("undefined" == typeof Image) throw new Error("texture upload variant not supported in worker");
                const t = await b._$BlobToImage$_(e);
                e = t;
            }
            return b._$Asyncify$_(() => this._$CreateStaticTexture$_(e, h));
        }
        _$CreateDynamicTexture$_(t, s, i) {
            this._$EndBatch$_();
            const e = b._$New$_(b._$Gfx$_._$WebGLRendererTexture$_, this);
            return e._$_CreateDynamic$_(t, s, i), e;
        }
        _$UpdateTexture$_(t, s, i) {
            this._$EndBatch$_(), s._$_Update$_(t, i);
        }
        _$DeleteTexture$_(t) {
            t && (t._$SubtractReference$_(), 0 < t._$GetReferenceCount$_() || (this._$EndBatch$_(), 
            t === this._$_lastTexture0$_ && (this._$_gl$_.bindTexture(this._$_gl$_.TEXTURE_2D, null), 
            this._$_lastTexture0$_ = null), t === this._$_lastTexture1$_ && (this._$_gl$_.activeTexture(this._$_gl$_.TEXTURE1), 
            this._$_gl$_.bindTexture(this._$_gl$_.TEXTURE_2D, null), this._$_gl$_.activeTexture(this._$_gl$_.TEXTURE0), 
            this._$_lastTexture1$_ = null), t._$_Delete$_()));
        }
        _$CreateRenderTarget$_(t) {
            let s = this._$_width$_, i = this._$_height$_, e = !0;
            if (t && ("number" == typeof t.width && (s = Math.floor(t.width), e = !1), 
            "number" == typeof t.height) && (i = Math.floor(t.height), e = !1), 
            s <= 0 || i <= 0) throw new Error("invalid size");
            this._$EndBatch$_();
            const h = b._$New$_(b._$Gfx$_._$WebGLRenderTarget$_, this);
            return h._$_Create$_(s, i, Object.assign({
                _$isDefaultSize$_: e
            }, t)), this._$_currentRenderTarget$_ = null, this._$_batchState$_._$currentFramebuffer$_ = null, 
            this._$_batchState$_._$currentFramebufferNoDepth$_ = null, h;
        }
        _$SetRenderTarget$_(t, s = !0) {
            if (t !== this._$_currentRenderTarget$_) {
                t && t._$IsDefaultSize$_() && t._$_Resize$_(this._$_width$_, this._$_height$_);
                const i = this._$PushBatch$_();
                i._$InitSetRenderTarget$_(t), this._$_currentRenderTarget$_ = t, 
                this._$_topOfBatch$_ = 0, s && this._$SetDefaultRenderTargetProjectionState$_();
            }
        }
        _$GetRenderTarget$_() {
            return this._$_currentRenderTarget$_;
        }
        _$GetRenderTargetSize$_(t) {
            return t ? [ t._$GetWidth$_(), t._$GetHeight$_() ] : [ this._$_width$_, this._$_height$_ ];
        }
        _$CopyRenderTarget$_(t, s = "stretch") {
            if (this._$_version$_ < 2 || this._$_currentRenderTarget$_ && 0 < this._$_currentRenderTarget$_._$GetMultisampling$_()) this._$SetCopyBlend$_(), 
            this._$ResetColor$_(), this._$DrawRenderTarget$_(t, s); else {
                const i = this._$PushBatch$_();
                i._$InitBlitFramebuffer$_(t, this._$_currentRenderTarget$_, s), 
                this._$_topOfBatch$_ = 0;
            }
        }
        _$DrawRenderTarget$_(t, s = "stretch") {
            const i = t._$GetTexture$_();
            if (!i) throw new Error("not a texture-backed render target");
            this._$SetTexture$_(i), this._$FullscreenQuad$_(s, i);
        }
        _$InvalidateRenderTarget$_(t) {
            if (!(this._$_version$_ < 2)) {
                const s = this._$PushBatch$_();
                s._$InitInvalidateFramebuffer$_(t._$_GetFramebuffer$_()), this._$_topOfBatch$_ = 0;
            }
        }
        _$DeleteRenderTarget$_(t) {
            this._$SetRenderTarget$_(null), this._$EndBatch$_();
            const s = t._$GetTexture$_();
            s === this._$_lastTexture0$_ && (this._$_gl$_.bindTexture(this._$_gl$_.TEXTURE_2D, null), 
            this._$_lastTexture0$_ = null), s === this._$_lastTexture1$_ && (this._$_gl$_.activeTexture(this._$_gl$_.TEXTURE1), 
            this._$_gl$_.bindTexture(this._$_gl$_.TEXTURE_2D, null), this._$_gl$_.activeTexture(this._$_gl$_.TEXTURE0), 
            this._$_lastTexture1$_ = null), t._$_Delete$_();
        }
        async _$ReadBackRenderTargetToImageData$_(t, s, i) {
            this._$EndBatch$_();
            let e = this._$_currentRenderTarget$_, h, r, n, o = (n = t ? (h = t._$GetWidth$_(), 
            r = t._$GetHeight$_(), t._$_GetFramebuffer$_()) : (h = this._$GetWidth$_(), 
            r = this._$GetHeight$_(), null), 0), a = 0, l = h, u = r;
            if (i) {
                o = b._$clamp$_(Math.floor(i._$getLeft$_()), 0, h - 1), a = b._$clamp$_(Math.floor(i._$getTop$_()), 0, r - 1);
                let t = i.width(), s = (t = 0 === t ? h - o : b._$clamp$_(Math.floor(t), 0, h - o), 
                i.height());
                s = 0 === s ? r - a : b._$clamp$_(Math.floor(s), 0, r - a), l = t, 
                u = s, a = r - (a + u);
            }
            let c = this._$_gl$_, f = (c.bindFramebuffer(c.FRAMEBUFFER, n), () => {
                c.bindFramebuffer(c.FRAMEBUFFER, null), this._$_currentRenderTarget$_ = null, 
                this._$_batchState$_._$currentFramebuffer$_ = null, this._$_batchState$_._$currentFramebufferNoDepth$_ = null, 
                this._$SetRenderTarget$_(e);
            }), d;
            if (!s && 2 <= this._$GetWebGLVersionNumber$_()) {
                c.bindFramebuffer(c.READ_FRAMEBUFFER, n);
                const p = c.createBuffer(), m = l * u * 4, g = c.PIXEL_PACK_BUFFER, y = (c.bindBuffer(g, p), 
                c.bufferData(g, m, c.STREAM_READ), c.readPixels(o, a, l, u, c.RGBA, c.UNSIGNED_BYTE, 0), 
                c.bindFramebuffer(c.READ_FRAMEBUFFER, null), c.bindBuffer(g, null), 
                f(), c.fenceSync(c.SYNC_GPU_COMMANDS_COMPLETE, 0));
                await this._$_WaitForObjectReady$_(() => c.getSyncParameter(y, c.SYNC_STATUS) === c.SIGNALED), 
                c.deleteSync(y), d = new ImageData(l, u), c.bindBuffer(g, p), c.getBufferSubData(g, 0, new Uint8Array(d.data.buffer), 0, m), 
                c.bindBuffer(g, null), c.deleteBuffer(p);
            } else d = new ImageData(l, u), c.readPixels(o, a, l, u, c.RGBA, c.UNSIGNED_BYTE, new Uint8Array(d.data.buffer)), 
            f();
            return d;
        }
        _$CoplanarStartStencilPass$_() {
            this._$SetDepthEnabled$_(!0);
            const t = this._$PushBatch$_();
            t._$InitCoplanarStartStencilPass$_(), this._$_topOfBatch$_ = 0, this._$_coplanarMode$_ = 1;
        }
        _$CoplanarStartColorPass$_() {
            this._$SetDepthEnabled$_(!1);
            const t = this._$PushBatch$_();
            t._$InitCoplanarStartColorPass$_(), this._$_topOfBatch$_ = 0, this._$_coplanarMode$_ = 2;
        }
        _$IsCoplanarColorPass$_() {
            return 2 === this._$_coplanarMode$_;
        }
        _$CoplanarRestoreStandardRendering$_() {
            this._$SetDepthEnabled$_(!0);
            const t = this._$PushBatch$_();
            t._$InitCoplanarRestore$_(), this._$_topOfBatch$_ = 0, this._$_coplanarMode$_ = 0;
        }
        _$StartQuery$_(t) {
            if (this._$SupportsGPUProfiling$_()) {
                const s = this._$PushBatch$_();
                s._$InitStartQuery$_(t), this._$_topOfBatch$_ = 0;
            }
        }
        _$EndQuery$_(t) {
            if (this._$SupportsGPUProfiling$_()) {
                const s = this._$PushBatch$_();
                s._$InitEndQuery$_(t), this._$_topOfBatch$_ = 0;
            }
        }
        _$_WaitForObjectReady$_(s) {
            const t = new Promise(t => e.add({
                resolve: t,
                _$checkFunc$_: s
            }));
            return -1 === h && (h = self.requestAnimationFrame(i)), t;
        }
        _$GetEstimatedBackBufferMemoryUsage$_() {
            return this._$_width$_ * this._$_height$_ * (this._$_attribs$_.alpha ? 4 : 3);
        }
        _$GetEstimatedRenderBufferMemoryUsage$_() {
            let t = 0;
            for (const s of b._$Gfx$_._$WebGLRenderTarget$_._$allRenderTargets$_()) s._$GetTexture$_() || (t += s._$GetEstimatedMemoryUsage$_());
            return t;
        }
        _$GetEstimatedTextureMemoryUsage$_() {
            let t = 0;
            for (const s of b._$Gfx$_._$WebGLRendererTexture$_._$allTextures$_()) t += s._$GetEstimatedMemoryUsage$_();
            return t;
        }
        _$GetWebGLVersionString$_() {
            return this._$_versionString$_;
        }
        _$GetWebGLVersionNumber$_() {
            return this._$_version$_;
        }
        _$GetDisplayName$_() {
            return "webgl" + this._$GetWebGLVersionNumber$_();
        }
        _$SupportsNPOTTextures$_() {
            return 2 <= this._$GetWebGLVersionNumber$_();
        }
        _$GetMaxTextureSize$_() {
            return this._$_maxTextureSize$_;
        }
        _$GetMinPointSize$_() {
            return this._$_minPointSize$_;
        }
        _$GetMaxPointSize$_() {
            return this._$_maxPointSize$_;
        }
        _$SupportsHighP$_() {
            return 0 !== this._$_highpPrecision$_;
        }
        _$GetHighPPrecision$_() {
            return this._$_highpPrecision$_;
        }
        _$GetUnmaskedVendor$_() {
            return this._$_unmaskedVendor$_;
        }
        _$GetUnmaskedRenderer$_() {
            return this._$_unmaskedRenderer$_;
        }
        _$GetWebGLExtensionsAnalyticsString$_() {
            if (2 <= this._$GetWebGLVersionNumber$_()) return "webgl2";
            {
                const t = [];
                return this._$_fragDepthExt$_ && t.push("EXT_frag_depth"), this._$_stdDerivativesExt$_ && t.push("OES_standard_derivatives"), 
                this._$_textureLodExt$_ && t.push("EXT_shader_texture_lod"), 0 < t.length ? "webgl1:" + t.join(",") : "webgl1:none";
            }
        }
        _$GetExtensions$_() {
            return this._$_extensions$_;
        }
        _$SupportsGPUProfiling$_() {
            return !!this._$_timerExt$_;
        }
        _$_GetDisjointTimerQueryExtension$_() {
            return this._$_timerExt$_;
        }
        _$_GetParallelShaderCompileExtension$_() {
            return this._$_parallelShaderCompileExt$_;
        }
        _$_GetAnisotropicExtension$_() {
            return this._$_anisotropicExt$_;
        }
        _$_GetMaxAnisotropy$_() {
            return this._$_maxAnisotropy$_;
        }
        _$_AddQueryResultBuffer$_(t) {
            this._$_allQueryResultBuffers$_.add(t);
        }
        _$_RemoveQueryResultBuffer$_(t) {
            this._$_allQueryResultBuffers$_.delete(t);
        }
        _$_GetTimeQueryStack$_() {
            return this._$_timeQueryStack$_;
        }
        _$GetContext$_() {
            return this._$_gl$_;
        }
        _$_InitBlendModes$_(t) {
            this._$_InitBlendModeData$_([ [ "normal", t.ONE, t.ONE_MINUS_SRC_ALPHA ], [ "additive", t.ONE, t.ONE ], [ "xor", t.ONE, t.ONE_MINUS_SRC_ALPHA ], [ "copy", t.ONE, t.ZERO ], [ "destination-over", t.ONE_MINUS_DST_ALPHA, t.ONE ], [ "source-in", t.DST_ALPHA, t.ZERO ], [ "destination-in", t.ZERO, t.SRC_ALPHA ], [ "source-out", t.ONE_MINUS_DST_ALPHA, t.ZERO ], [ "destination-out", t.ZERO, t.ONE_MINUS_SRC_ALPHA ], [ "source-atop", t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA ], [ "destination-atop", t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA ] ]);
        }
        _$CreateWebGLText$_() {
            return this._$CreateRendererText$_();
        }
    };
}

{
    const ji = self._$C3$_, Vi = {
        _$getDrawSize$_: null,
        _$getRenderTarget$_: null,
        _$releaseRenderTarget$_: null,
        getTime: null,
        _$redraw$_: null
    };
    ji._$Gfx$_._$EffectChainManager$_ = class {
        constructor(t) {
            t = Object.assign({}, Vi, t), this._$_cbGetDrawSize$_ = t._$getDrawSize$_, 
            this._$_cbGetRenderTarget$_ = t._$getRenderTarget$_, this._$_cbReleaseRenderTarget$_ = t._$releaseRenderTarget$_, 
            this._$_cbGetTime$_ = t.getTime, this._$_cbRedraw$_ = t._$redraw$_, 
            this._$_webgpuBackTexture$_ = null, this._$_allEffectChains$_ = new Set();
        }
        _$_AddEffectChain$_(t) {
            this._$_allEffectChains$_.add(t);
        }
        _$_RemoveEffectChain$_(t) {
            this._$_allEffectChains$_.delete(t);
        }
        _$OnContextLost$_() {
            this._$_webgpuBackTexture$_ = null;
            for (const t of this._$_allEffectChains$_) t._$OnContextLost$_();
        }
        _$GetDrawSize$_(t) {
            return this._$_cbGetDrawSize$_ ? this._$_cbGetDrawSize$_(t) : [ t._$GetWidth$_(), t._$GetHeight$_() ];
        }
        _$GetRenderTarget$_(t) {
            return this._$_cbGetRenderTarget$_(t);
        }
        _$ReleaseRenderTarget$_(t, s) {
            this._$_cbReleaseRenderTarget$_(t, s);
        }
        _$GetTime$_() {
            return this._$_cbGetTime$_();
        }
        _$Redraw$_(t) {
            this._$_cbRedraw$_(t);
        }
        _$_GetWebGPUBackTexture$_(t, s, i) {
            return s = Math.floor(s), i = Math.floor(i), !this._$_webgpuBackTexture$_ || this._$_webgpuBackTexture$_._$GetWidth$_() === s && this._$_webgpuBackTexture$_._$GetHeight$_() === i || (t._$DeleteTexture$_(this._$_webgpuBackTexture$_), 
            this._$_webgpuBackTexture$_ = null), null === this._$_webgpuBackTexture$_ && (this._$_webgpuBackTexture$_ = t._$CreateStaticTexture$_(null, {
                width: s,
                height: i,
                _$sampling$_: "nearest",
                _$mipMap$_: !1
            })), this._$_webgpuBackTexture$_;
        }
    };
}

{
    const o = self._$C3$_, Ui = self._$glMatrix$_, xh = Ui._$mat4$_, Hi = o._$New$_(o.Rect), zi = o._$New$_(o.Rect), Ji = o._$New$_(o.Rect), qi = o._$New$_(o.Rect), Xi = xh.create(), Yi = xh.create(), $i = {
        _$drawContent$_: null,
        _$getSourceTextureInfo$_: null,
        _$getShaderParameters$_: null,
        _$invalidateRenderTargets$_: !1
    }, Ki = {
        _$indexMap$_: null,
        _$forcePreDraw$_: !1,
        _$forcePostDraw$_: !1,
        _$is3D$_: !1,
        _$isSourceTextureRotated$_: !1,
        _$isRotatedOrNegativeSizeInstance$_: !1,
        _$useFullSurface$_: !1
    };
    o._$Gfx$_._$EffectChain$_ = class {
        constructor(t, s) {
            s = Object.assign({}, $i, s), this._$_manager$_ = t, this._$_cbDrawContent$_ = s._$drawContent$_, 
            this._$_cbGetSourceTextureInfo$_ = s._$getSourceTextureInfo$_, this._$_cbGetShaderParameters$_ = s._$getShaderParameters$_, 
            this._$_cbDrawContentHook$_ = null, this._$_shaderProgramList$_ = [], 
            this._$_shaderProgramIndices$_ = [], this._$_steps$_ = [], this._$_needsRebuild$_ = !1, 
            this._$_blendMode$_ = 0, this._$_isAnyShaderAnimated$_ = !1, this._$_isAnyShaderDepthSampling$_ = !1, 
            this._$_isAnyShaderBackgroundBlending$_ = !1, this._$_isAnyShaderCrossSampling$_ = !1, 
            this._$_isAnyIsSrcTexRotated$_ = !1, this._$_useCopyTextureBackgroundSampling$_ = !1, 
            this._$_didChangeTransform$_ = !1, this._$_depthEnabledAtStart$_ = !1, 
            this._$_coplanarColorPassAtStart$_ = !1, this._$_canUseFastPath$_ = !1, 
            this._$_useFullSurface$_ = !1, this._$_isSourceTextureRotated$_ = !1, 
            this._$_numTempSurfacesRequired$_ = 0, this._$_renderTargets$_ = [ null, null, null ], 
            this._$_invalidateRenderTargets$_ = !!s._$invalidateRenderTargets$_, 
            this._$_boxExtendHorizontal$_ = 0, this._$_boxExtendVertical$_ = 0, 
            this._$_drawWidth$_ = 0, this._$_drawHeight$_ = 0, this._$_contentObject$_ = null, 
            this._$_contextObject$_ = null, this._$_layoutRect$_ = o._$New$_(o.Rect), 
            this._$_drawSurfaceRect$_ = o._$New$_(o.Rect), this._$_rcTexOriginal$_ = o._$New$_(o.Rect), 
            this._$_rcTexBounce$_ = o._$New$_(o.Rect), this._$_rcTexDest$_ = o._$New$_(o.Rect), 
            this._$_devicePixelRatio$_ = 1, this._$_layerScale$_ = 1, this._$_layerAngle$_ = 0, 
            this._$_time$_ = 0, this._$_destRenderTarget$_ = null, this._$_backTex$_ = null, 
            this._$_compositOffX$_ = 0, this._$_compositOffY$_ = 0, this._$_updateOwnProjection$_ = !1, 
            this._$_projectionMatrix$_ = xh.create(), this._$_modelViewMatrix$_ = xh.create(), 
            this._$_manager$_._$_AddEffectChain$_(this);
        }
        _$Release$_() {
            this._$_manager$_._$_RemoveEffectChain$_(this), o._$clearArray$_(this._$_steps$_), 
            o._$clearArray$_(this._$_shaderProgramList$_), o._$clearArray$_(this._$_shaderProgramIndices$_), 
            this._$_contentObject$_ = null, this._$_contextObject$_ = null, this._$_cbDrawContent$_ = null, 
            this._$_cbGetSourceTextureInfo$_ = null, this._$_cbGetShaderParameters$_ = null;
        }
        _$OnContextLost$_() {
            this._$_needsRebuild$_ = !0, o._$clearArray$_(this._$_steps$_), o._$clearArray$_(this._$_shaderProgramList$_), 
            o._$clearArray$_(this._$_shaderProgramIndices$_);
        }
        _$NeedsRebuild$_() {
            return this._$_needsRebuild$_;
        }
        _$BuildSteps$_(h, t) {
            if (t = Object.assign({}, Ki, t), o._$clearArray$_(this._$_steps$_), 
            this._$_boxExtendHorizontal$_ = 0, this._$_boxExtendVertical$_ = 0, 
            this._$_isAnyShaderAnimated$_ = !1, this._$_isAnyShaderDepthSampling$_ = !1, 
            this._$_isAnyShaderBackgroundBlending$_ = !1, this._$_isAnyShaderCrossSampling$_ = !1, 
            this._$_isAnyIsSrcTexRotated$_ = !1, this._$_useCopyTextureBackgroundSampling$_ = !1, 
            this._$_numTempSurfacesRequired$_ = 0, this._$_isSourceTextureRotated$_ = !!t._$isSourceTextureRotated$_, 
            this._$_useFullSurface$_ = !!t._$useFullSurface$_, this._$_needsRebuild$_ = !1, 
            o._$shallowAssignArray$_(this._$_shaderProgramList$_, h), 0 !== h.length) {
                if (t._$indexMap$_) {
                    if (t._$indexMap$_.length !== h.length) throw new Error("incorrect indexMap length");
                    o._$shallowAssignArray$_(this._$_shaderProgramIndices$_, t._$indexMap$_);
                } else {
                    o._$clearArray$_(this._$_shaderProgramIndices$_);
                    for (let t = 0, s = h.length; t < s; ++t) this._$_shaderProgramIndices$_.push(t);
                }
                for (const s of h) this._$_boxExtendHorizontal$_ += s._$GetBoxExtendHorizontal$_(), 
                this._$_boxExtendVertical$_ += s._$GetBoxExtendVertical$_(), s._$IsAnimated$_() && (this._$_isAnyShaderAnimated$_ = !0), 
                s._$UsesDepth$_() && (this._$_isAnyShaderDepthSampling$_ = !0), 
                s._$BlendsBackground$_() && (this._$_isAnyShaderBackgroundBlending$_ = !0), 
                s._$UsesCrossSampling$_() && (this._$_isAnyShaderCrossSampling$_ = !0), 
                s._$UsesIsSrcTexRotated$_() && (this._$_isAnyIsSrcTexRotated$_ = !0);
                this._$_useCopyTextureBackgroundSampling$_ = this._$_ShouldUseCopyTextureBackgroundSampling$_(h[0]._$GetRenderer$_());
                const r = this._$_ShouldPreDraw$_(h[0], t), n = this._$_ShouldPostDraw$_(h.at(-1), t);
                if (1 !== h.length || r || n) {
                    this._$_canUseFastPath$_ = !1;
                    let e = 0;
                    r && (this._$_numTempSurfacesRequired$_ = 1, this._$_steps$_.push(o._$New$_(o._$Gfx$_._$EffectChain$_._$Step$_._$PreDraw$_, this, -1, 1)), 
                    e = 1);
                    for (let s = 0, i = h.length; s < i; ++s) if (0 !== s || r) {
                        let t = 1 === e ? 2 : 1;
                        s !== i - 1 || n || (t = 0), this._$_numTempSurfacesRequired$_ = Math.max(this._$_numTempSurfacesRequired$_, t), 
                        this._$_steps$_.push(o._$New$_(o._$Gfx$_._$EffectChain$_._$Step$_._$Bounce$_, this, e, t, s)), 
                        e = t;
                    } else this._$_numTempSurfacesRequired$_ = 1, this._$_steps$_.push(o._$New$_(o._$Gfx$_._$EffectChain$_._$Step$_._$FirstBounce$_, this, -1, 1, s)), 
                    e = 1;
                    n && this._$_steps$_.push(o._$New$_(o._$Gfx$_._$EffectChain$_._$Step$_._$PostDraw$_, this, e, 0));
                } else this._$_canUseFastPath$_ = !0;
            }
        }
        _$_ShouldPreDraw$_(t, s) {
            return !!(s._$forcePreDraw$_ || t._$MustPreDraw$_() || s._$is3D$_ && !t._$Supports3DDirectRendering$_() || t._$UsesDepth$_() && !this._$_useFullSurface$_ || 0 !== this._$_boxExtendHorizontal$_ || 0 !== this._$_boxExtendVertical$_) || (t._$GetRenderer$_()._$IsWebGL$_() ? t._$BlendsBackground$_() && (s._$isRotatedOrNegativeSizeInstance$_ || s._$isSourceTextureRotated$_) || t._$UsesAnySrcRectOrPixelSize$_() && s._$isSourceTextureRotated$_ : t._$BlendsBackground$_() && !this._$_useCopyTextureBackgroundSampling$_ && s._$isRotatedOrNegativeSizeInstance$_);
        }
        _$_ShouldPostDraw$_(t, s) {
            return !!s._$forcePostDraw$_ || (t._$GetRenderer$_()._$IsWebGL$_() ? t._$BlendsBackground$_() || t._$UsesCrossSampling$_() : (t._$BlendsBackground$_() || t._$UsesCrossSampling$_()) && this._$_UseRenderTargetBackgroundSampling$_());
        }
        _$_ShouldUseCopyTextureBackgroundSampling$_(t) {
            return t._$IsWebGPU$_() && this._$_isAnyShaderBackgroundBlending$_ && !this._$_isAnyShaderCrossSampling$_;
        }
        _$Render$_(t, s, i) {
            t._$IsWebGPU$_() && null === s && (s = t.GetBackbufferRenderTarget()), 
            this._$_destRenderTarget$_ = s, this._$_contentObject$_ = i._$contentObject$_ || null, 
            this._$_contextObject$_ = i.contextObject || null, this._$_blendMode$_ = i._$blendMode$_ || 0, 
            this._$_devicePixelRatio$_ = i.devicePixelRatio || 1, this._$_layerScale$_ = i._$layerScale$_ || 1, 
            this._$_layerAngle$_ = i._$layerAngle$_ || 0, this._$_time$_ = "number" == typeof i.time ? i.time : this._$_manager$_._$GetTime$_(), 
            this._$_didChangeTransform$_ = !1, t._$ResetDidChangeTransformFlag$_(), 
            this._$_isAnyShaderAnimated$_ && this._$_Redraw$_();
            let e = !1;
            if (this._$_UseCopyTextureBackgroundSampling$_() && (this._$_CalculateDrawSizeAndRectangles$_(t, i), 
            e = !0, this._$_backTex$_ = this._$_manager$_._$_GetWebGPUBackTexture$_(t, this._$_drawWidth$_, this._$_drawHeight$_), 
            Hi._$copy$_(this._$_drawSurfaceRect$_), Hi._$roundOuter$_(), t._$IsWebGPU$_() && t._MaybeDoPendingClearRenderPass(this._$_destRenderTarget$_), 
            t.CopyTextureToTexture(this._$_destRenderTarget$_._$GetTexture$_(), this._$_backTex$_, Hi._$getLeft$_(), Hi._$getTop$_(), Hi.width(), Hi.height())), 
            this._$_canUseFastPath$_) this._$_Render_FastPath$_(t, i); else if (e || this._$_CalculateDrawSizeAndRectangles$_(t, i), 
            0 !== this._$_rcTexOriginal$_.width() || 0 !== this._$_rcTexOriginal$_.height()) {
                t._$SetAlphaBlend$_(), t._$ResetColor$_(), t._$SetBaseZ$_(0), t._$SetCurrentZ$_(0), 
                this._$_cbDrawContentHook$_ = i._$drawContentHook$_ || null, this._$_compositOffX$_ = i._$compositOffX$_ || 0, 
                this._$_compositOffY$_ = i._$compositOffY$_ || 0, this._$_updateOwnProjection$_ = !!i._$updateOwnProjection$_, 
                this._$_OnBeforeStartEffectChain$_(t), this._$_renderTargets$_[0] = s, 
                this._$_renderTargets$_[1] = 1 <= this._$_numTempSurfacesRequired$_ ? this._$_GetRenderTarget$_() : null, 
                this._$_renderTargets$_[2] = 2 === this._$_numTempSurfacesRequired$_ ? this._$_GetRenderTarget$_() : null;
                for (const h of this._$_steps$_) {
                    const r = this._$_GetRenderTargetForId$_(h._$GetSrcTargetId$_()), n = this._$_GetRenderTargetForId$_(h._$GetDestTargetId$_());
                    t._$IsWebGPU$_() ? h._$Run_WebGPU$_(t, r, n) : h._$Run_WebGL$_(t, r, n);
                }
                t._$SetTexture$_(null), this._$_renderTargets$_[1] && this._$_ReleaseRenderTarget$_(this._$_renderTargets$_[1]), 
                this._$_renderTargets$_[2] && this._$_ReleaseRenderTarget$_(this._$_renderTargets$_[2]), 
                this._$_renderTargets$_.fill(null), this._$_OnAfterEndEffectChain$_(t), 
                this._$_destRenderTarget$_ = null, this._$_backTex$_ = null, this._$_contentObject$_ = null, 
                this._$_contextObject$_ = null, this._$_cbDrawContentHook$_ = null;
            }
        }
        _$_CalculateDrawSizeAndRectangles$_(t, s) {
            const [ i, e ] = this._$_manager$_._$GetDrawSize$_(t);
            this._$_SetDrawSize$_(t, i, e), this._$_CalculateRectangles$_(s);
        }
        _$_SetDrawSize$_(t, s, i) {
            if (s <= 0 || i <= 0) throw new Error("invalid draw size");
            this._$_drawWidth$_ === s && this._$_drawHeight$_ === i || this._$_CalculateDeviceTransformMatrices$_(t, s, i, 0, 0, this._$_projectionMatrix$_, this._$_modelViewMatrix$_), 
            this._$_drawWidth$_ = s, this._$_drawHeight$_ = i;
        }
        _$_CalculateDeviceTransformMatrices$_(t, s, i, e, h, r, n) {
            const o = s / 2 + e, a = i / 2 + h, l = (t._$CalculatePerspectiveMatrix$_(r, s / i), 
            t._$CalculateLookAtModelView2$_(o, a, t._$GetDefaultCameraZ$_(i), o, a, 0, i));
            xh._$copy$_(n, l);
        }
        _$_CalculateRectangles$_(t) {
            this._$_layoutRect$_._$copy$_(t._$layoutRect$_), t._$drawSurfaceRect$_ ? this._$_drawSurfaceRect$_._$copy$_(t._$drawSurfaceRect$_) : this._$_drawSurfaceRect$_.set(0, 0, this._$_drawWidth$_, this._$_drawHeight$_), 
            this._$_rcTexOriginal$_._$copy$_(this._$_drawSurfaceRect$_), this._$_rcTexOriginal$_._$divide$_(this._$_drawWidth$_, this._$_drawHeight$_);
            const s = this._$_layerScale$_ * this._$_devicePixelRatio$_;
            this._$_drawSurfaceRect$_._$inflate$_(this._$_boxExtendHorizontal$_ * s, this._$_boxExtendVertical$_ * s), 
            this._$_rcTexDest$_._$copy$_(this._$_drawSurfaceRect$_), this._$_rcTexDest$_._$divide$_(this._$_drawWidth$_, this._$_drawHeight$_), 
            this._$_drawSurfaceRect$_._$clampBoth$_(0, 0, this._$_drawWidth$_, this._$_drawHeight$_), 
            this._$_rcTexBounce$_._$copy$_(this._$_drawSurfaceRect$_), this._$_rcTexBounce$_._$divide$_(this._$_drawWidth$_, this._$_drawHeight$_);
        }
        _$_OnBeforeStartEffectChain$_(t) {
            if (this._$_depthEnabledAtStart$_ = t._$IsDepthEnabled$_(), this._$_coplanarColorPassAtStart$_ = t._$IsCoplanarColorPass$_(), 
            this._$_useFullSurface$_) t._$SetDepthEnabled$_(!1), this._$_isAnyShaderDepthSampling$_ && t._$SetDepthSamplingEnabled$_(!0); else {
                if (Hi._$copy$_(this._$_drawSurfaceRect$_), t._$IsWebGL$_()) {
                    const s = this._$_layerScale$_ * this._$_devicePixelRatio$_;
                    Hi._$inflate$_(Math.max(this._$_boxExtendHorizontal$_, 1) * s, Math.max(this._$_boxExtendVertical$_, 1) * s), 
                    Hi._$roundOuter$_(), Hi._$clamp$_(0, 0, this._$_drawWidth$_, this._$_drawHeight$_);
                } else Hi._$roundOuter$_();
                t._$SetScissorRect$_(Hi._$getLeft$_(), Hi._$getTop$_(), Hi.width(), Hi.height(), this._$_drawHeight$_);
            }
        }
        _$_OnAfterEffectChainDrawContent$_(t) {
            t._$ResetColor$_(), this._$_useFullSurface$_ || (this._$_coplanarColorPassAtStart$_ && t._$CoplanarRestoreStandardRendering$_(), 
            t._$SetDepthEnabled$_(!1), this._$_isAnyShaderDepthSampling$_ && t._$SetDepthSamplingEnabled$_(!0)), 
            t._$IsWebGPU$_() && t.SetNormalizedCoordsProgramVariant(!0);
        }
        _$_OnAfterEndEffectChain$_(t) {
            t._$SetDepthSamplingEnabled$_(!1), this._$_coplanarColorPassAtStart$_ && t._$CoplanarStartColorPass$_(), 
            t._$SetDepthEnabled$_(this._$_depthEnabledAtStart$_), this._$_useFullSurface$_ || t._$RemoveScissorRect$_(), 
            t._$IsWebGPU$_() && t.SetNormalizedCoordsProgramVariant(!1), this._$_didChangeTransform$_ = t._$DidChangeTransform$_();
        }
        _$_ClampRcTexDest$_() {
            this._$_rcTexDest$_._$clamp$_(0, 0, 1, 1);
        }
        _$_GetRenderTargetForId$_(t) {
            return t < 0 ? null : this._$_renderTargets$_[t];
        }
        _$_GetRenderTarget$_() {
            return this._$_manager$_._$GetRenderTarget$_(this);
        }
        _$_GetDestRenderTarget$_() {
            return this._$_destRenderTarget$_;
        }
        _$_ReleaseRenderTarget$_(t) {
            this._$_manager$_._$ReleaseRenderTarget$_(t, this);
        }
        _$_GetShaderProgramAt$_(t) {
            return this._$_shaderProgramList$_[t];
        }
        _$_DrawContent$_(t) {
            this._$_cbDrawContentHook$_ ? this._$_cbDrawContentHook$_(this, t, () => this._$_cbDrawContent$_(t, this)) : this._$_cbDrawContent$_(t, this), 
            this._$_canUseFastPath$_ || this._$_OnAfterEffectChainDrawContent$_(t);
        }
        _$_IsRenderTargetSameSizeAndOffset$_(t) {
            if (this._$_useFullSurface$_) return !0;
            if (0 !== this._$_compositOffX$_ || 0 !== this._$_compositOffY$_) return !1;
            const [ s, i ] = t._$GetRenderTargetSize$_(t._$GetRenderTarget$_());
            return s === this._$_drawWidth$_ && i === this._$_drawHeight$_;
        }
        _$_SetDeviceTransform$_(t, s) {
            let i = this._$_projectionMatrix$_, e = this._$_modelViewMatrix$_;
            if (s && !this._$_IsRenderTargetSameSizeAndOffset$_(t)) {
                i = Xi, e = Yi;
                const [ h, r ] = t._$GetRenderTargetSize$_(t._$GetRenderTarget$_());
                this._$_CalculateDeviceTransformMatrices$_(t, h, r, this._$_compositOffX$_, this._$_compositOffY$_, i, e), 
                this._$_useFullSurface$_ || t._$RemoveScissorRect$_();
            }
            t._$SetProjectionMatrix$_(i), t._$SetModelViewMatrix$_(e);
        }
        _$_Redraw$_() {
            this._$_manager$_._$Redraw$_(this);
        }
        _$_GetShaderParameters$_(t, s) {
            return this._$_cbGetShaderParameters$_(this._$_shaderProgramIndices$_[t], s);
        }
        _$_SetProgramParameters$_(t, s) {
            let i = this._$_rcTexDest$_, e = this._$_rcTexBounce$_, h = this._$_rcTexOriginal$_;
            t._$IsWebGL$_() && (zi._$copy$_(i), zi._$flipAround$_(1), i = zi, Ji._$copy$_(e), 
            Ji._$flipAround$_(1), e = Ji, qi._$copy$_(h), qi._$flipAround$_(1), 
            h = qi), this._$_DoSetProgramParameters$_(t, s, e, h, i, 1 / this._$_drawWidth$_, 1 / this._$_drawHeight$_);
        }
        _$_SetFirstBounceProgramParameters$_(t, s) {
            let e = this._$_rcTexBounce$_, h = this._$_rcTexOriginal$_, r = 1 / this._$_drawWidth$_, n = 1 / this._$_drawHeight$_;
            if (this._$_cbGetSourceTextureInfo$_) {
                let {
                    _$srcTexRect$_: t,
                    _$srcWidth$_: s,
                    _$srcHeight$_: i
                } = this._$_cbGetSourceTextureInfo$_(this._$_contentObject$_);
                t || (Hi.set(0, 0, 0, 0), t = Hi), s = s || this._$_drawWidth$_, 
                i = i || this._$_drawHeight$_, e = t, h = t, r = 1 / s, n = 1 / i;
            } else t._$IsWebGL$_() && (Ji._$copy$_(e), Ji._$flipAround$_(1), e = Ji, 
            qi._$copy$_(h), qi._$flipAround$_(1), h = qi);
            let i = this._$_rcTexDest$_;
            t._$IsWebGL$_() && ((i = zi)._$copy$_(this._$_rcTexDest$_), i._$flipAround$_(1)), 
            this._$_DoSetProgramParameters$_(t, s, e, h, i, r, n), t._$IsWebGPU$_() && this._$_isAnyIsSrcTexRotated$_ && t.SetProgramParameter_IsSrcTexRotated(this._$_isSourceTextureRotated$_);
        }
        _$_GetBackTex$_(t) {
            return this._$_isAnyShaderBackgroundBlending$_ ? t._$IsWebGPU$_() ? this._$_UseCopyTextureBackgroundSampling$_() ? this._$_backTex$_ : this._$_destRenderTarget$_._$GetTexture$_() : this._$_destRenderTarget$_ : null;
        }
        _$_DoSetProgramParameters$_(t, s, i, e, h, r, n) {
            t._$SetProgramParameters$_(this._$_GetBackTex$_(t), h, i, e, this._$_layoutRect$_, r, n, this._$_devicePixelRatio$_, this._$_layerScale$_, this._$_layerAngle$_, this._$_time$_), 
            t._$SetProgramCustomParameters$_(this._$_GetShaderParameters$_(s, t));
        }
        _$_Render_FastPath$_(t, s) {
            const i = this._$_shaderProgramList$_[0], e = t._$IsDepthEnabled$_(), h = i._$UsesDepth$_();
            h && (t._$SetDepthEnabled$_(!1), t._$SetDepthSamplingEnabled$_(!0), 
            this._$_rcTexDest$_.set(0, 0, 1, 1), this._$_rcTexOriginal$_.set(0, 0, 1, 1)), 
            t._$SetProgram$_(i), t._$SetBlendMode$_(this._$_blendMode$_), t._$SetRenderTarget$_(this._$_destRenderTarget$_);
            let r = 0, n = 1;
            if (this._$_rcTexOriginal$_.set(0, 0, 1, 1), i._$UsesAnySrcRectOrPixelSize$_() && this._$_cbGetSourceTextureInfo$_) {
                const {
                    _$srcTexRect$_: o,
                    _$srcWidth$_: a,
                    _$srcHeight$_: l
                } = this._$_cbGetSourceTextureInfo$_(this._$_contentObject$_);
                o && this._$_rcTexOriginal$_._$copy$_(o), r = Number.isFinite(a) ? 1 / a : 0, 
                n = Number.isFinite(l) ? 1 / l : 0;
            } else {
                const [ u, c ] = this._$_manager$_._$GetDrawSize$_(t);
                r = 1 / u, n = 1 / c;
            }
            s._$layoutRect$_ ? this._$_layoutRect$_._$copy$_(s._$layoutRect$_) : this._$_layoutRect$_.set(0, 0, 0, 0), 
            t._$SetProgramParameters$_(this._$_GetBackTex$_(t), this._$_rcTexDest$_, this._$_rcTexOriginal$_, this._$_rcTexOriginal$_, this._$_layoutRect$_, r, n, this._$_devicePixelRatio$_, this._$_layerScale$_, this._$_layerAngle$_, this._$_time$_), 
            t._$SetProgramCustomParameters$_(this._$_GetShaderParameters$_(0, t)), 
            t._$IsWebGPU$_() && this._$_isAnyIsSrcTexRotated$_ && t.SetProgramParameter_IsSrcTexRotated(this._$_isSourceTextureRotated$_), 
            t._$SetBaseZ$_(0), this._$_DrawContent$_(t), h && (t._$SetDepthSamplingEnabled$_(!1), 
            t._$SetDepthEnabled$_(e));
        }
        _$_UseCopyTextureBackgroundSampling$_() {
            return this._$_useCopyTextureBackgroundSampling$_;
        }
        _$_UseRenderTargetBackgroundSampling$_() {
            return !this._$_useCopyTextureBackgroundSampling$_;
        }
        _$IsAnyShaderBackgroundBlending$_() {
            return this._$_isAnyShaderBackgroundBlending$_;
        }
        _$CanSkipCalculatingDrawSurfaceRect$_() {
            return !!this._$_canUseFastPath$_ && !this._$_UseCopyTextureBackgroundSampling$_();
        }
        _$UseFullSurface$_() {
            return this._$_useFullSurface$_;
        }
        _$GetContentObject$_() {
            return this._$_contentObject$_;
        }
        _$GetContextObject$_() {
            return this._$_contextObject$_;
        }
        _$_GetBlendMode$_() {
            return this._$_blendMode$_;
        }
        _$_UpdateOwnProjection$_() {
            return this._$_updateOwnProjection$_;
        }
        _$DidChangeTransform$_() {
            return this._$_didChangeTransform$_;
        }
        _$_GetDrawSurfaceRect$_() {
            return this._$_drawSurfaceRect$_;
        }
        _$_GetRcTexBounce$_() {
            return this._$_rcTexBounce$_;
        }
        _$_ShouldInvalidateRenderTargets$_() {
            return this._$_invalidateRenderTargets$_;
        }
        async _$DebugLogRenderTargetContents$_(t, s, i) {}
    };
}

{
    const Zi = self._$C3$_;
    Zi._$Gfx$_._$EffectChain$_._$Step$_ = class {
        constructor(t, s, i, e = -1) {
            this._$_effectChain$_ = t, this._$_srcTargetId$_ = s, this._$_destTargetId$_ = i, 
            this._$_index$_ = e;
        }
        _$GetEffectChain$_() {
            return this._$_effectChain$_;
        }
        _$GetSrcTargetId$_() {
            return this._$_srcTargetId$_;
        }
        _$GetDestTargetId$_() {
            return this._$_destTargetId$_;
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$GetShaderProgram$_() {
            return this._$GetEffectChain$_()._$_GetShaderProgramAt$_(this._$GetIndex$_());
        }
        _$Run_WebGL$_(t, s, i) {}
        _$Run_WebGPU$_(t, s, i) {}
    };
}

{
    const Qi = self._$C3$_;
    Qi._$Gfx$_._$EffectChain$_._$Step$_._$PreDraw$_ = class extends Qi._$Gfx$_._$EffectChain$_._$Step$_ {
        constructor(t, s, i, e) {
            super(t, s, i, e);
        }
        _$Run_WebGL$_(t, s, i) {
            const e = this._$GetEffectChain$_();
            t._$SetAlphaBlend$_(), t._$SetTextureFillMode$_(), t._$SetRenderTarget$_(i, e._$_UpdateOwnProjection$_()), 
            t._$ClearRgba$_(0, 0, 0, 0), e._$_DrawContent$_(t), e._$_ClampRcTexDest$_();
        }
        _$Run_WebGPU$_(t, s, i) {
            const e = this._$GetEffectChain$_();
            t._$SetAlphaBlend$_(), t._$SetTextureFillMode$_(), t._$SetRenderTarget$_(i, !1), 
            t._$ClearRgba$_(0, 0, 0, 0), e._$_DrawContent$_(t), e._$_ClampRcTexDest$_();
        }
    };
}

{
    const te = self._$C3$_, se = te._$New$_(te.Rect), ie = te._$New$_(te._$Quad$_);
    te._$Gfx$_._$EffectChain$_._$Step$_._$PostDraw$_ = class extends te._$Gfx$_._$EffectChain$_._$Step$_ {
        constructor(t, s, i, e) {
            super(t, s, i, e);
        }
        _$Run_WebGL$_(t, s, i) {
            const e = this._$GetEffectChain$_();
            t._$SetTextureFillMode$_(), t._$SetRenderTarget$_(i), e._$_SetDeviceTransform$_(t, !0), 
            t._$SetBlendMode$_(e._$_GetBlendMode$_()), t._$SetTexture$_(s._$GetTexture$_()), 
            ie._$setFromRect$_(e._$_GetDrawSurfaceRect$_()), se._$copy$_(e._$_GetRcTexBounce$_()), 
            se._$flipAround$_(1), t._$Quad3$_(ie, se), e._$_ShouldInvalidateRenderTargets$_() && t._$InvalidateRenderTarget$_(s);
        }
        _$Run_WebGPU$_(t, s, i) {
            const e = this._$GetEffectChain$_();
            t._$SetTextureFillMode$_(), t._$SetRenderTarget$_(i, !1), e._$_IsRenderTargetSameSizeAndOffset$_(t) ? ie._$setFromRect$_(e._$_GetRcTexBounce$_()) : (t.SetNormalizedCoordsProgramVariant(!1), 
            e._$_SetDeviceTransform$_(t, !0), ie._$setFromRect$_(e._$_GetDrawSurfaceRect$_())), 
            t.SetBackTexture(null), t._$SetBlendMode$_(e._$_GetBlendMode$_()), t._$SetTexture$_(s._$GetTexture$_()), 
            e._$UseFullSurface$_() ? t._$FullscreenQuad$_() : t._$Quad3$_(ie, e._$_GetRcTexBounce$_());
        }
    };
}

{
    const ee = self._$C3$_;
    ee._$Gfx$_._$EffectChain$_._$Step$_._$FirstBounce$_ = class extends ee._$Gfx$_._$EffectChain$_._$Step$_ {
        constructor(t, s, i, e) {
            super(t, s, i, e);
        }
        _$Run_WebGL$_(t, s, i) {
            const e = this._$GetEffectChain$_();
            t._$SetRenderTarget$_(i, e._$_UpdateOwnProjection$_()), t._$ClearRgba$_(0, 0, 0, 0), 
            t._$SetCopyBlend$_(), t._$SetProgram$_(this._$GetShaderProgram$_()), 
            e._$_SetFirstBounceProgramParameters$_(t, this._$GetIndex$_()), e._$_DrawContent$_(t), 
            e._$_ClampRcTexDest$_();
        }
        _$Run_WebGPU$_(t, s, i) {
            const e = this._$GetEffectChain$_();
            t._$SetRenderTarget$_(i, !1), t._$ClearRgba$_(0, 0, 0, 0), t._$SetCopyBlend$_(), 
            t._$SetProgram$_(this._$GetShaderProgram$_()), e._$_SetFirstBounceProgramParameters$_(t, this._$GetIndex$_()), 
            e._$_DrawContent$_(t), e._$_ClampRcTexDest$_();
        }
    };
}

{
    const he = self._$C3$_, re = he._$New$_(he.Rect), ne = he._$New$_(he._$Quad$_);
    he._$Gfx$_._$EffectChain$_._$Step$_._$Bounce$_ = class extends he._$Gfx$_._$EffectChain$_._$Step$_ {
        constructor(t, s, i, e) {
            super(t, s, i, e);
        }
        _$Run_WebGL$_(t, s, i) {
            const e = this._$GetEffectChain$_(), h = (t._$SetRenderTarget$_(i), 
            0 === this._$GetDestTargetId$_());
            h ? t._$SetBlendMode$_(e._$_GetBlendMode$_()) : (t._$ClearRgba$_(0, 0, 0, 0), 
            t._$SetCopyBlend$_()), t._$SetProgram$_(this._$GetShaderProgram$_()), 
            e._$_SetProgramParameters$_(t, this._$GetIndex$_()), t._$SetTexture$_(s._$GetTexture$_()), 
            e._$_SetDeviceTransform$_(t, h), ne._$setFromRect$_(e._$_GetDrawSurfaceRect$_()), 
            re._$copy$_(e._$_GetRcTexBounce$_()), re._$flipAround$_(1), t._$Quad3$_(ne, re), 
            e._$_ShouldInvalidateRenderTargets$_() && t._$InvalidateRenderTarget$_(s);
        }
        _$Run_WebGPU$_(t, s, i) {
            const e = this._$GetEffectChain$_(), h = (t._$SetRenderTarget$_(i, !1), 
            0 === this._$GetDestTargetId$_());
            h ? (t._$SetBlendMode$_(e._$_GetBlendMode$_()), t.SetBackTexture(null), 
            e._$_IsRenderTargetSameSizeAndOffset$_(t) ? ne._$setFromRect$_(e._$_GetRcTexBounce$_()) : (t.SetNormalizedCoordsProgramVariant(!1), 
            e._$_SetDeviceTransform$_(t, !0), ne._$setFromRect$_(e._$_GetDrawSurfaceRect$_()))) : (t._$ClearRgba$_(0, 0, 0, 0), 
            t._$SetCopyBlend$_(), ne._$setFromRect$_(e._$_GetRcTexBounce$_())), 
            t._$SetProgram$_(this._$GetShaderProgram$_()), e._$_SetProgramParameters$_(t, this._$GetIndex$_()), 
            t._$SetTexture$_(s._$GetTexture$_()), e._$UseFullSurface$_() ? t._$FullscreenQuad$_() : t._$Quad3$_(ne, e._$_GetRcTexBounce$_());
        }
    };
}

{
    let u = function(t, s) {
        const i = t[0], e = s[0], h = i - e;
        if (0 != h) return h;
        const r = t[1], n = s[1];
        return r - n;
    }, c = (u, self._$C3$_), f = self._$C3X$_, d = null, s = new Set(), p = [], m = [], i = !1, t = !1, e = new Set([ "vsync", "unlimited-tick", "unlimited-frame" ]);
    self._$IRuntime$_ = class {
        constructor(t) {
            d = t, Object.defineProperties(this, {
                _$assets$_: {
                    value: d._$GetAssetManager$_()._$GetIAssetManager$_(),
                    writable: !1
                },
                _$collisions$_: {
                    value: d._$GetCollisionEngine$_()._$GetICollisionEngine$_(),
                    writable: !1
                },
                _$objects$_: {
                    value: {},
                    writable: !1
                },
                _$globalVars$_: {
                    value: {},
                    writable: !1
                },
                _$projectName$_: {
                    value: d._$GetProjectName$_(),
                    writable: !1
                },
                _$projectVersion$_: {
                    value: d._$GetProjectVersion$_(),
                    writable: !1
                },
                storage: {
                    value: new self._$IStorage$_(d),
                    writable: !1
                },
                isInWorker: {
                    value: d._$IsInWorker$_(),
                    writable: !1
                },
                _$viewportWidth$_: {
                    value: d._$GetOriginalViewportWidth$_(),
                    writable: !1
                },
                _$viewportHeight$_: {
                    value: d._$GetOriginalViewportHeight$_(),
                    writable: !1
                },
                _$sampling$_: {
                    value: d._$GetSampling$_(),
                    writable: !1
                },
                _$isPixelRoundingEnabled$_: {
                    value: d._$IsPixelRoundingEnabled$_(),
                    writable: !1
                },
                _$sdk$_: {
                    value: new self._$ISDKUtils$_(t),
                    writable: !1
                }
            }), d._$UserScriptDispatcher$_().addEventListener("keydown", t => {
                s.has(t.key) ? t.stopPropagation() : s.add(t.key);
            }), d._$UserScriptDispatcher$_().addEventListener("keyup", t => s.delete(t.key)), 
            d._$Dispatcher$_().addEventListener("window-blur", () => s.clear()), 
            d._$IsInWorker$_() && (self.alert = t => (i || (i = !0, console.warn("[Construct] alert() was called from a Web Worker, because the project 'Use worker' setting is enabled. This method is not normally available in a Web Worker. Construct has implemented the alert for you, but note that other features may be missing in worker mode. You may wish to disable 'Use worker', or use a more convenient function like console.log(). For more information please refer to the scripting section of the manual.")), 
            this.alert(t)));
        }
        _$_InitObjects$_(t) {
            Object.defineProperties(this._$objects$_, t);
        }
        _$_InitGlobalVars$_(t) {
            Object.defineProperties(this._$globalVars$_, t);
        }
        addEventListener(t, s) {
            d._$UserScriptDispatcher$_().addEventListener(t, s);
        }
        removeEventListener(t, s) {
            d._$UserScriptDispatcher$_().removeEventListener(t, s);
        }
        _$callFunction$_(t, ...s) {
            f._$RequireString$_(t);
            const i = d._$GetEventSheetManager$_(), e = i._$GetFunctionBlockByName$_(t);
            if (!e) throw new Error(`cannot find function name '${t}'`);
            if (!e._$IsEnabled$_()) return e._$GetDefaultReturnValue$_();
            if (s.length < e._$GetFunctionParameterCount$_()) throw new Error(`not enough function parameters passed for '${t}' (${s.length} passed, ${e._$GetFunctionParameterCount$_()} expected)`);
            let h = e._$GetEventBlock$_(), r = h._$GetSolModifiersIncludingParents$_(), n = i._$GetCurrentEvent$_();
            if (n) {
                r = r.slice(0);
                const a = new Set(r);
                for (const l of n._$GetSolModifiersIncludingParents$_()) a.has(l) || (r.push(l), 
                a.add(l));
                for (const u of i._$GetDynamicSolModifiersSet$_()) a.has(u) || (r.push(u), 
                a.add(u));
            }
            const o = h._$RunAsExpressionFunctionCall$_(r, e._$IsCopyPicked$_(), e._$GetReturnType$_(), e._$GetDefaultReturnValue$_(), ...s);
            return o;
        }
        _$setReturnValue$_(t) {
            const s = d._$GetEventStack$_()._$GetCurrentExpFuncStackFrame$_();
            if (!s) throw new Error("not in a function which returns a value");
            switch (s._$GetFunctionReturnType$_()) {
              case 1:
                "number" == typeof t && s._$SetFunctionReturnValue$_(t);
                break;

              case 2:
                "string" == typeof t && s._$SetFunctionReturnValue$_(t);
                break;

              case 3:
                "number" != typeof t && "string" != typeof t || s._$SetFunctionReturnValue$_(t);
            }
        }
        signal(t) {
            f._$RequireString$_(t), d._$GetEventSheetManager$_()._$Signal$_(t);
        }
        _$waitForSignal$_(t) {
            return f._$RequireString$_(t), d._$GetEventSheetManager$_()._$WaitForSignal$_(t);
        }
        _$getViewportSize$_() {
            return [ d._$GetOriginalViewportWidth$_(), d._$GetOriginalViewportHeight$_() ];
        }
        get isSuspended() {
            return d._$IsSuspended$_();
        }
        get dt() {
            return d._$GetDt$_();
        }
        get _$dtRaw$_() {
            return d._$GetDtRaw$_();
        }
        get gameTime() {
            return d._$GetGameTime$_();
        }
        get _$wallTime$_() {
            return d._$GetWallTime$_();
        }
        get timeScale() {
            return d._$GetTimeScale$_();
        }
        set timeScale(t) {
            f._$RequireFiniteNumber$_(t), d._$SetTimeScale$_(t);
        }
        get fps() {
            return t || (console.warn("IRuntime.fps is deprecated. Use IRuntime.framesPerSecond instead."), 
            t = !0), d._$GetFramesPerSecond$_();
        }
        get framesPerSecond() {
            return d._$GetFramesPerSecond$_();
        }
        get _$ticksPerSecond$_() {
            return d._$GetTicksPerSecond$_();
        }
        get _$cpuUtilisation$_() {
            return d._$GetMainThreadTime$_();
        }
        get _$gpuUtilisation$_() {
            return d._$GetGPUUtilisation$_();
        }
        get _$framerateMode$_() {
            return d._$GetFramerateMode$_();
        }
        set _$framerateMode$_(t) {
            if (!e.has(t)) throw new Error("invalid framerate mode");
            d._$_SetFramerateMode$_(t);
        }
        get _$minDt$_() {
            return d._$GetMinDt$_();
        }
        set _$minDt$_(t) {
            f._$RequireFiniteNumber$_(t), d._$SetMinDt$_(t);
        }
        get _$maxDt$_() {
            return d._$GetMaxDt$_();
        }
        set _$maxDt$_(t) {
            d._$SetMaxDt$_(t);
        }
        random() {
            return d._$Random$_();
        }
        get layout() {
            const t = d._$GetMainRunningLayout$_();
            if (t) return t._$GetILayout$_();
            throw new Error("no layout is running - make sure a layout is loaded before accessing");
        }
        _$getLayout$_(t) {
            let s = d._$GetLayoutManager$_(), i = null;
            if ("number" != typeof t && "string" != typeof t) throw new TypeError("expected string or number");
            if (i = s._$GetLayout$_(t)) return i._$GetILayout$_();
            throw new Error("invalid layout");
        }
        _$getAllLayouts$_() {
            return d._$GetLayoutManager$_()._$GetAllLayouts$_().map(t => t._$GetILayout$_());
        }
        _$goToLayout$_(t) {
            let s = d._$GetLayoutManager$_(), i = null;
            if ("number" != typeof t && "string" != typeof t) throw new TypeError("expected string or number");
            if (!(i = s._$GetLayout$_(t))) throw new Error("invalid layout");
            s._$IsPendingChangeMainLayout$_() || s._$ChangeMainLayout$_(i);
        }
        get keyboard() {
            const t = d._$_GetCommonScriptInterfaces$_().keyboard;
            if (t) return t;
            throw new Error("runtime.keyboard used but Keyboard object missing - add it to your project first");
        }
        get _$mouse$_() {
            const t = d._$_GetCommonScriptInterfaces$_()._$mouse$_;
            if (t) return t;
            throw new Error("runtime.mouse used but Mouse object missing - add it to your project first");
        }
        get _$touch$_() {
            const t = d._$_GetCommonScriptInterfaces$_()._$touch$_;
            if (t) return t;
            throw new Error("runtime.touch used but Touch object missing - add it to your project first");
        }
        get _$timelineController$_() {
            const t = d._$_GetCommonScriptInterfaces$_()._$timelineController$_;
            if (t) return t;
            throw new Error("runtime.timelineController used but Timeline Controller object missing - add it to your project first");
        }
        get _$platformInfo$_() {
            const t = d._$_GetCommonScriptInterfaces$_()._$platformInfo$_;
            if (t) return t;
            throw new Error("runtime.platformInfo used but Platform Info object missing - add it to your project first");
        }
        _$invokeDownload$_(t, s) {
            f._$RequireString$_(t), f._$RequireString$_(s), d._$InvokeDownload$_(t, s);
        }
        _$getInstanceByUid$_(t) {
            f._$RequireFiniteNumber$_(t);
            const s = d._$GetInstanceByUID$_(t);
            return s ? s._$GetInterfaceClass$_() : null;
        }
        _$sortZOrder$_(t, e) {
            f._$RequireFunction$_(e);
            const h = d._$GetCurrentLayout$_();
            for (const s of t) {
                const i = d._$_UnwrapIWorldInstance$_(s), r = i._$GetWorldInfo$_();
                p.push([ r._$GetLayer$_()._$GetIndex$_(), r._$GetZIndex$_() ]), 
                m.push(i);
            }
            if (0 !== p.length) {
                p.sort(u), m.sort((t, s) => e(t._$GetInterfaceClass$_(), s._$GetInterfaceClass$_()));
                let i = !1;
                for (let t = 0, s = p.length; t < s; ++t) {
                    const n = m[t], o = h._$GetLayerByIndex$_(p[t][0]), a = p[t][1], l = o._$_GetInstances$_();
                    l[a] !== n && ((l[a] = n)._$GetWorldInfo$_()._$_SetLayer$_(o, !0), 
                    o._$SetZIndicesChanged$_(n), i = !0);
                }
                i && d._$UpdateRender$_(), c._$clearArray$_(p), c._$clearArray$_(m);
            }
        }
        async _$createWorker$_(t, s) {
            const i = new MessageChannel(), e = i.port1, h = i.port2;
            return await d._$PostComponentMessageToDOMAsync$_("runtime", "script-create-worker", {
                url: t,
                opts: s,
                port2: h
            }, [ h ]), e;
        }
        alert(t) {
            return d._$PostComponentMessageToDOMAsync$_("runtime", "alert", {
                message: t + (d._$IsInWorker$_() ? " [via Web Worker]" : "")
            });
        }
        _$getHTMLLayer$_(t) {
            return f._$RequireFiniteNumber$_(t), d._$_GetHTMLLayerWrapElement$_(t);
        }
        _$addLoadPromise$_(t) {
            d._$AddLoadPromise$_(t);
        }
    };
}

{
    let s = self._$C3$_, n = null;
    self._$IAssetManager$_ = class {
        constructor(t) {
            n = t, Object.defineProperties(this, {
                _$isWebMOpusSupported$_: {
                    value: n._$IsAudioFormatSupported$_("audio/webm; codecs=opus"),
                    writable: !1
                }
            });
        }
        _$loadImageAsset$_(t) {
            const s = self._$IImageInfo$_._$_Unwrap$_(t);
            if (!s) throw new Error("invalid IImageInfo");
            s._$LoadAsset$_(n._$GetRuntime$_());
        }
        _$fetchText$_(t) {
            return n._$FetchText$_(t);
        }
        _$fetchJson$_(t) {
            return n._$FetchJson$_(t);
        }
        _$fetchBlob$_(t) {
            return n._$FetchBlob$_(t);
        }
        _$fetchArrayBuffer$_(t) {
            return n._$FetchArrayBuffer$_(t);
        }
        _$getProjectFileUrl$_(t) {
            return n._$GetProjectFileUrl$_(t);
        }
        _$getMediaFileUrl$_(t) {
            return "flat" === n._$GetFileStructure$_() && s._$IsRelativeURL$_(t) && (t = t.toLowerCase()), 
            n._$GetMediaFileUrl$_(t);
        }
        get _$mediaFolder$_() {
            return n._$GetMediaSubfolder$_();
        }
        async _$decodeWebMOpus$_(t, s) {
            if (this._$isWebMOpusSupported$_) throw new Error("decodeWebMOpus(): not supported because WebM Opus is supported by the platform");
            const i = await n._$GetRuntime$_()._$_WasmDecodeWebMOpus$_(s), e = new Float32Array(i), h = t.createBuffer(1, e.length, 48e3), r = h.getChannelData(0);
            return r.set(e), h;
        }
        _$loadScripts$_(...t) {
            return n._$LoadScripts$_(...t);
        }
        _$compileWebAssembly$_(t) {
            return n._$CompileWebAssembly$_(t);
        }
        _$loadStyleSheet$_(t) {
            return n._$LoadStyleSheet$_(t);
        }
    };
}

{
    let n = self._$C3$_, i = self._$C3X$_, o = null;
    self._$ICollisionEngine$_ = class {
        constructor(t) {
            o = t, Object.defineProperties(this, {
                runtime: {
                    value: o._$GetRuntime$_(),
                    writable: !1
                }
            });
        }
        _$testOverlap$_(t, s) {
            const i = o._$GetRuntime$_(), e = i._$_UnwrapIWorldInstance$_(t), h = i._$_UnwrapIWorldInstance$_(s);
            return o._$TestOverlap$_(e, h);
        }
        _$testOverlapAny$_(t, s) {
            const i = o._$GetRuntime$_(), e = i._$_UnwrapIWorldInstance$_(t);
            for (const h of s) {
                const r = i._$_UnwrapIWorldInstance$_(h);
                if (o._$TestOverlap$_(e, r)) return h;
            }
            return null;
        }
        _$testOverlapSolid$_(t) {
            const s = o._$GetRuntime$_()._$_UnwrapIWorldInstance$_(t), i = o._$TestOverlapSolid$_(s);
            return i ? i._$GetInterfaceClass$_() : null;
        }
        _$setCollisionCellSize$_(t, s) {
            if (i._$RequireFiniteNumber$_(t), i._$RequireFiniteNumber$_(s), t = Math.floor(t), 
            s = Math.floor(s), t <= 0 || s <= 0) throw new Error("invalid cell size");
            o._$SetCollisionCellSize$_(t, s);
        }
        _$getCollisionCellSize$_() {
            return o._$GetCollisionCellSize$_();
        }
        _$getCollisionCandidates$_(t, s) {
            let i = o._$GetRuntime$_(), e;
            e = Array.isArray(t) ? t.map(t => i._$_UnwrapIObjectClass$_(t)) : [ i._$_UnwrapIObjectClass$_(t) ];
            const h = n.Rect._$FromObject$_(s), r = [];
            return o._$GetObjectClassesCollisionCandidates$_(null, e, h, r), r.map(t => t._$GetInterfaceClass$_());
        }
    };
}

{
    const oe = self._$C3X$_;
    self._$IStorage$_ = class {
        constructor(t) {
            this._$_storage$_ = t._$_GetProjectStorage$_();
        }
        getItem(t) {
            return oe._$RequireString$_(t), this._$_storage$_.getItem(t);
        }
        setItem(t, s) {
            return oe._$RequireString$_(t), this._$_storage$_.setItem(t, s);
        }
        removeItem(t) {
            return oe._$RequireString$_(t), this._$_storage$_.removeItem(t);
        }
        clear() {
            return this._$_storage$_.clear();
        }
        keys() {
            return this._$_storage$_.keys();
        }
    };
}

{
    const ae = self._$C3$_, le = new WeakMap(), ue = ae._$_GetInternalAPIToken$_();
    self._$IPlugin$_ = class {
        constructor() {
            const t = ae._$AddonManager$_._$_GetInitObject2$_(ue);
            le.set(this, t), Object.defineProperties(this, {
                runtime: {
                    value: t._$GetRuntime$_()._$GetIRuntime$_(),
                    writable: !1
                },
                _$isSingleGlobal$_: {
                    value: t._$IsSingleGlobal$_(),
                    writable: !1
                },
                _$isWorldType$_: {
                    value: t._$IsWorldType$_(),
                    writable: !1
                },
                _$isHTMLElementType$_: {
                    value: t._$IsHTMLElementType$_(),
                    writable: !1
                },
                _$isRotatable$_: {
                    value: t._$IsRotatable$_(),
                    writable: !1
                },
                _$hasEffects$_: {
                    value: t._$HasEffects$_(),
                    writable: !1
                },
                _$is3d$_: {
                    value: t._$Is3D$_(),
                    writable: !1
                },
                _$supportsHierarchies$_: {
                    value: t._$SupportsSceneGraph$_(),
                    writable: !1
                },
                _$supportsMesh$_: {
                    value: t._$SupportsMesh$_(),
                    writable: !1
                }
            });
        }
        static _$getByConstructor$_(t) {
            if (!t) return null;
            const s = ae._$AddonManager$_._$GetPluginByConstructorFunction$_(t);
            return s ? s._$GetIPlugin$_() : null;
        }
        _$getSingleGlobalObjectType$_() {
            return le.get(this)._$GetSingleGlobalObjectClass$_()._$GetIObjectClass$_();
        }
        _$getSingleGlobalInstance$_() {
            return le.get(this)._$GetSingleGlobalInstance$_()._$GetInterfaceClass$_();
        }
    };
}

{
    const ce = self._$C3$_, fe = self._$C3X$_, de = new WeakMap(), pe = ce._$_GetInternalAPIToken$_();
    self._$IObjectClass$_ = class {
        constructor() {
            const t = ce._$AddonManager$_._$_GetInitObject2$_(pe);
            de.set(this, t), Object.defineProperties(this, {
                name: {
                    value: t._$GetName$_(),
                    writable: !1
                },
                runtime: {
                    value: t._$GetRuntime$_()._$GetIRuntime$_(),
                    writable: !1
                },
                _$plugin$_: {
                    value: t._$GetPlugin$_()._$GetIPlugin$_(),
                    writable: !1
                }
            }), t._$GetRuntime$_()._$_MapScriptInterface$_(this, t);
        }
        addEventListener(t, s) {
            fe._$RequireString$_(t), fe._$RequireFunction$_(s), de.get(this)._$UserScriptDispatcher$_().addEventListener(t, s);
        }
        removeEventListener(t, s) {
            fe._$RequireString$_(t), fe._$RequireFunction$_(s), de.get(this)._$UserScriptDispatcher$_().removeEventListener(t, s);
        }
        _$getAllInstances$_() {
            return [ ...this.instances() ];
        }
        _$getFirstInstance$_() {
            return ce.first(this.instances());
        }
        _$getPickedInstances$_() {
            return [ ...this._$pickedInstances$_() ];
        }
        _$getFirstPickedInstance$_() {
            return ce.first(this._$pickedInstances$_());
        }
        _$getPairedInstance$_(t) {
            const s = de.get(this), i = s._$GetRuntime$_()._$_UnwrapIInstance$_(t), e = s._$GetPairedInstance$_(i);
            return e ? e._$GetInterfaceClass$_() : null;
        }
        *instances() {
            for (const t of de.get(this)._$instancesIncludingPendingCreate$_()) yield t._$GetInterfaceClass$_();
        }
        *_$pickedInstances$_() {
            for (const t of de.get(this)._$GetCurrentSol$_()._$GetInstances$_()) yield t._$GetInterfaceClass$_();
        }
        _$setInstanceClass$_(t) {
            fe._$RequireFunction$_(t);
            const s = de.get(this);
            if (0 < s._$GetInstanceCount$_()) throw new Error("setInstanceClass() called too late, because instances have already been created - call in runOnStartup");
            de.get(this)._$_SetUserScriptInstanceClass$_(t);
        }
        _$createInstance$_(t, s, i, e, h) {
            if (fe._$RequireNumber$_(s), fe._$RequireNumber$_(i), "number" != typeof t && "string" != typeof t) throw new TypeError("invalid layer parameter");
            const r = de.get(this), n = r._$GetRuntime$_(), o = n._$GetMainRunningLayout$_()._$GetLayer$_(t);
            if (!o) throw new Error("invalid layer");
            const a = n._$CreateInstance$_(r, o, s, i, e, h), l = (e && o._$SortAndAddInstancesByZIndex$_(a), 
            n._$GetEventSheetManager$_());
            return l._$BlockFlushingInstances$_(!0), a._$_TriggerOnCreatedOnSelfAndRelated$_(), 
            l._$BlockFlushingInstances$_(!1), l._$IsInEventEngine$_() || n._$GetLayoutManager$_()._$IsEndingLayout$_() || n._$FlushPendingInstances$_(), 
            a._$GetInterfaceClass$_();
        }
    };
}

{
    const me = self._$C3X$_, l = new WeakMap(), ge = [ "above", "below", "top-sublayer", "bottom-sublayer" ];
    self._$ILayout$_ = class {
        constructor(t) {
            l.set(this, t);
            const s = [], i = t._$GetEffectList$_(), e = i._$GetAllEffectTypes$_().length;
            for (let t = 0; t < e; ++t) s.push(new self._$IEffectInstance$_(i, t));
            Object.defineProperties(this, {
                name: {
                    value: t._$GetName$_(),
                    writable: !1
                },
                index: {
                    value: t._$GetIndex$_(),
                    writable: !1
                },
                effects: {
                    value: s,
                    writable: !1
                }
            });
        }
        addEventListener(t, s) {
            me._$RequireString$_(t), me._$RequireFunction$_(s), l.get(this)._$UserScriptDispatcher$_().addEventListener(t, s);
        }
        removeEventListener(t, s) {
            me._$RequireString$_(t), me._$RequireFunction$_(s), l.get(this)._$UserScriptDispatcher$_().removeEventListener(t, s);
        }
        get width() {
            return l.get(this)._$GetWidth$_();
        }
        set width(t) {
            me._$RequireFiniteNumber$_(t), l.get(this)._$SetWidth$_(t);
        }
        get height() {
            return l.get(this)._$GetHeight$_();
        }
        set height(t) {
            me._$RequireFiniteNumber$_(t), l.get(this)._$SetHeight$_(t);
        }
        _$setSize$_(t, s) {
            me._$RequireFiniteNumber$_(t), me._$RequireFiniteNumber$_(s);
            const i = l.get(this);
            i._$SetWidth$_(t), i._$SetHeight$_(s);
        }
        getSize() {
            const t = l.get(this);
            return [ t._$GetWidth$_(), t._$GetHeight$_() ];
        }
        set scale(t) {
            me._$RequireFiniteNumber$_(t), l.get(this)._$SetScale$_(t);
        }
        get scale() {
            return l.get(this)._$GetScale$_();
        }
        set angle(t) {
            me._$RequireFiniteNumber$_(t), l.get(this)._$SetAngle$_(t);
        }
        get angle() {
            return l.get(this)._$GetAngle$_();
        }
        set scrollX(t) {
            me._$RequireNumber$_(t), l.get(this)._$SetScrollX$_(t);
        }
        get scrollX() {
            return l.get(this)._$GetScrollX$_();
        }
        set scrollY(t) {
            me._$RequireNumber$_(t), l.get(this)._$SetScrollY$_(t);
        }
        get scrollY() {
            return l.get(this)._$GetScrollY$_();
        }
        scrollTo(t, s) {
            me._$RequireNumber$_(t), me._$RequireNumber$_(s);
            const i = l.get(this);
            i._$SetScrollX$_(t), i._$SetScrollY$_(s);
        }
        _$getScrollPosition$_() {
            const t = l.get(this);
            return [ t._$GetScrollX$_(), t._$GetScrollY$_() ];
        }
        _$getLayer$_(t) {
            let s = l.get(this), i = null;
            if ("number" != typeof t && "string" != typeof t) throw new TypeError("expected string or number");
            return (i = s._$GetLayer$_(t)) ? i._$GetILayer$_() : null;
        }
        _$getAllLayers$_() {
            return l.get(this)._$GetLayers$_().map(t => t._$GetILayer$_());
        }
        *_$allLayers$_() {
            for (const t of l.get(this)._$allLayers$_()) yield t._$GetILayer$_();
        }
        _$addLayer$_(t, s, i) {
            const e = l.get(this), h = self._$ILayer$_, r = (me._$RequireString$_(t), 
            me._$RequireOptionalInstanceOf$_(s, h), s ? e._$GetRuntime$_()._$_UnwrapScriptInterface$_(s) : null), n = ge.indexOf(i);
            if (n < 0) throw new Error("invalid location");
            e._$AddLayer$_(t, r, n);
        }
        _$moveLayer$_(t, s, i) {
            const e = l.get(this), h = e._$GetRuntime$_(), r = self._$ILayer$_, n = (me._$RequireInstanceOf$_(t, r), 
            h._$_UnwrapScriptInterface$_(t));
            if (!n) throw new Error("invalid layer");
            me._$RequireOptionalInstanceOf$_(s, r);
            const o = s ? h._$_UnwrapScriptInterface$_(s) : null, a = ge.indexOf(i);
            if (a < 0) throw new Error("invalid location");
            e._$MoveLayer$_(n, o, a);
        }
        _$removeLayer$_(t) {
            const s = l.get(this), i = self._$ILayer$_, e = (me._$RequireInstanceOf$_(t, i), 
            s._$GetRuntime$_()._$_UnwrapScriptInterface$_(t));
            if (!e) throw new Error("invalid layer");
            const h = e._$GetRuntime$_();
            s._$RemoveLayer$_(e), h._$GetEventSheetManager$_()._$IsInEventEngine$_() || h._$FlushPendingInstances$_();
        }
        _$removeAllDynamicLayers$_() {
            const t = l.get(this), s = t._$GetRuntime$_();
            t._$RemoveAllDynamicLayers$_(), s._$GetEventSheetManager$_()._$IsInEventEngine$_() || s._$FlushPendingInstances$_();
        }
        _$setVanishingPoint$_(t, s) {
            me._$RequireFiniteNumber$_(t), me._$RequireFiniteNumber$_(s), l.get(this)._$SetVanishingPointXY$_(t, s);
        }
        _$getVanishingPoint$_() {
            return l.get(this)._$_GetVanishingPoint$_();
        }
        set _$projection$_(t) {
            me._$RequireString$_(t);
            const s = l.get(this);
            if ("perspective" === t) s._$SetPerspectiveProjection$_(); else {
                if ("orthographic" !== t) throw new Error("invalid projection");
                s._$SetOrthographicProjection$_();
            }
        }
        get _$projection$_() {
            return l.get(this)._$IsOrthographicProjection$_() ? "orthographic" : "perspective";
        }
    };
}

{
    const ye = self._$C3$_, we = self._$C3X$_, f = new WeakMap(), Se = new Map([ [ "normal", 0 ], [ "additive", 1 ], [ "copy", 3 ], [ "destination-over", 4 ], [ "source-in", 5 ], [ "destination-in", 6 ], [ "source-out", 7 ], [ "destination-out", 8 ], [ "source-atop", 9 ], [ "destination-atop", 10 ] ]), be = new Map([ ...Se.entries() ].map(t => [ t[1], t[0] ])), Me = ye._$New$_(ye._$Color$_);
    self._$ILayer$_ = class {
        constructor(t) {
            f.set(this, t);
            const s = [], i = t._$GetEffectList$_(), e = i._$GetAllEffectTypes$_().length;
            for (let t = 0; t < e; ++t) s.push(new self._$IEffectInstance$_(i, t));
            Object.defineProperties(this, {
                name: {
                    value: t._$GetName$_(),
                    writable: !1
                },
                layout: {
                    value: t._$GetLayout$_()._$GetILayout$_(),
                    writable: !1
                },
                effects: {
                    value: s,
                    writable: !1
                }
            }), t._$GetRuntime$_()._$_MapScriptInterface$_(this, t);
        }
        get _$parentLayer$_() {
            const t = f.get(this)._$GetParentLayer$_();
            return t ? t._$GetILayer$_() : null;
        }
        *_$parentLayers$_() {
            for (const t of f.get(this)._$parentLayers$_()) yield t._$GetILayer$_();
        }
        *_$subLayers$_() {
            for (const t of f.get(this)._$GetSubLayers$_()) yield t._$GetILayer$_();
        }
        *_$allSubLayers$_() {
            for (const t of f.get(this)._$GetSubLayers$_()) for (const s of t._$selfAndAllSubLayers$_()) yield s._$GetILayer$_();
        }
        get index() {
            return f.get(this)._$GetIndex$_();
        }
        get isVisible() {
            return f.get(this)._$_IsVisibleFlagSet$_();
        }
        set isVisible(t) {
            f.get(this)._$SetVisible$_(t);
        }
        get _$isSelfAndParentsVisible$_() {
            return f.get(this)._$IsVisible$_();
        }
        get _$isInteractive$_() {
            return f.get(this)._$IsInteractive$_();
        }
        set _$isInteractive$_(t) {
            f.get(this)._$SetInteractive$_(t);
        }
        get _$isHTMLElementsLayer$_() {
            return f.get(this)._$IsHTMLElementsLayer$_();
        }
        set _$isHTMLElementsLayer$_(t) {
            f.get(this)._$SetIsHTMLElementsLayer$_(!!t);
        }
        get _$isSelfAndParentsInteractive$_() {
            return f.get(this)._$IsSelfAndParentsInteractive$_();
        }
        get opacity() {
            return f.get(this)._$GetOpacity$_();
        }
        set opacity(t) {
            t = ye._$clamp$_(+t, 0, 1), isNaN(t) || f.get(this)._$SetOpacity$_(t);
        }
        set scale(t) {
            we._$RequireFiniteNumber$_(t), f.get(this)._$SetOwnScale$_(t);
        }
        get scale() {
            return f.get(this)._$GetOwnScale$_();
        }
        set scaleRate(t) {
            we._$RequireFiniteNumber$_(t), f.get(this)._$SetScaleRate$_(t);
        }
        get scaleRate() {
            return f.get(this)._$GetScaleRate$_();
        }
        set angle(t) {
            we._$RequireFiniteNumber$_(t), f.get(this)._$SetAngle$_(t);
        }
        get angle() {
            return f.get(this)._$GetOwnAngle$_();
        }
        set parallaxX(t) {
            we._$RequireFiniteNumber$_(t), f.get(this)._$SetParallaxX$_(t);
        }
        get parallaxX() {
            return f.get(this)._$GetParallaxX$_();
        }
        set parallaxY(t) {
            we._$RequireFiniteNumber$_(t), f.get(this)._$SetParallaxY$_(t);
        }
        get parallaxY() {
            return f.get(this)._$GetParallaxY$_();
        }
        set _$zElevation$_(t) {
            we._$RequireFiniteNumber$_(t), f.get(this)._$SetZElevation$_(t);
        }
        get _$zElevation$_() {
            return f.get(this)._$GetZElevation$_();
        }
        set _$isTransparent$_(t) {
            f.get(this)._$SetTransparent$_(t);
        }
        get _$isTransparent$_() {
            return f.get(this)._$IsTransparent$_();
        }
        set _$isForceOwnTexture$_(t) {
            f.get(this)._$SetForceOwnTexture$_(t);
        }
        get _$isForceOwnTexture$_() {
            return f.get(this)._$IsForceOwnTexture$_();
        }
        set _$blendMode$_(t) {
            we._$RequireString$_(t);
            const s = Se.get(t);
            if ("number" != typeof s) throw new Error("invalid blend mode");
            f.get(this)._$SetBlendMode$_(s);
        }
        get _$blendMode$_() {
            return be.get(f.get(this)._$GetBlendMode$_());
        }
        set backgroundColor(t) {
            if (we._$RequireArray$_(t), t.length < 3) throw new Error("expected 3 elements");
            Me._$setRgb$_(t[0], t[1], t[2]);
            const s = f.get(this), i = s._$GetBackgroundColor$_();
            i._$equalsIgnoringAlpha$_(Me) || (i._$copyRgb$_(Me), s._$GetRuntime$_()._$UpdateRender$_());
        }
        get backgroundColor() {
            const t = f.get(this)._$GetBackgroundColor$_();
            return [ t._$getR$_(), t._$getG$_(), t._$getB$_() ];
        }
        set scrollX(t) {
            we._$RequireNumber$_(t);
            const s = f.get(this);
            s._$SetOwnScrollPositionEnabled$_(!0), s._$SetScrollX$_(t);
        }
        get scrollX() {
            return f.get(this)._$GetScrollX$_();
        }
        set scrollY(t) {
            we._$RequireNumber$_(t);
            const s = f.get(this);
            s._$SetOwnScrollPositionEnabled$_(!0), s._$SetScrollY$_(t);
        }
        get scrollY() {
            return f.get(this)._$GetScrollY$_();
        }
        scrollTo(t, s) {
            we._$RequireNumber$_(t), we._$RequireNumber$_(s);
            const i = f.get(this);
            i._$SetOwnScrollPositionEnabled$_(!0), i._$SetScrollX$_(t), i._$SetScrollY$_(s);
        }
        _$getScrollPosition$_() {
            const t = f.get(this);
            return [ t._$GetScrollX$_(), t._$GetScrollY$_() ];
        }
        _$restoreScrollPosition$_() {
            f.get(this)._$SetOwnScrollPositionEnabled$_(!1);
        }
        getViewport() {
            return f.get(this)._$GetViewport$_()._$toDOMRect$_();
        }
        _$cssPxToLayer$_(t, s, i = 0) {
            we._$RequireNumber$_(t), we._$RequireNumber$_(s), we._$RequireNumber$_(i);
            const e = f.get(this), h = e._$GetRuntime$_();
            return e._$CanvasCssToLayer$_(t - h._$GetCanvasClientX$_(), s - h._$GetCanvasClientY$_(), i);
        }
        _$layerToCssPx$_(t, s, i = 0) {
            we._$RequireNumber$_(t), we._$RequireNumber$_(s), we._$RequireNumber$_(i);
            const e = f.get(this), h = e._$GetRuntime$_(), [ r, n ] = e._$LayerToCanvasCss$_(t, s, i);
            return [ r + h._$GetCanvasClientX$_(), n + h._$GetCanvasClientY$_() ];
        }
        _$drawSurfaceToLayer$_(t, s, i = 0) {
            return we._$RequireNumber$_(t), we._$RequireNumber$_(s), we._$RequireNumber$_(i), 
            f.get(this)._$DrawSurfaceToLayer$_(t, s, i);
        }
        _$layerToDrawSurface$_(t, s, i = 0) {
            return we._$RequireNumber$_(t), we._$RequireNumber$_(s), we._$RequireNumber$_(i), 
            f.get(this)._$LayerToDrawSurface$_(t, s, i);
        }
        get _$renderScale$_() {
            return f.get(this)._$GetRenderScale$_();
        }
    };
}

{
    let e = function(t) {
        let s = Te.get(t);
        return s || (s = ve._$New$_(ve.Event._$Dispatcher$_), Te.set(t, s)), s;
    };
    e;
    const ve = self._$C3$_, xe = self._$C3X$_, Ge = new WeakMap(), Te = new WeakMap(), _e = ve._$_GetInternalAPIToken$_();
    self._$IInstance$_ = class {
        constructor() {
            const t = ve._$AddonManager$_._$_GetInitObject2$_(_e), s = (Ge.set(this, t), 
            {
                runtime: {
                    value: t._$GetRuntime$_()._$GetIRuntime$_(),
                    writable: !1
                },
                _$objectType$_: {
                    value: t._$GetObjectClass$_()._$GetIObjectClass$_(),
                    writable: !1
                },
                _$plugin$_: {
                    value: t._$GetPlugin$_()._$GetIPlugin$_(),
                    writable: !1
                }
            });
            t._$_GetInstVarsScriptDescriptor$_(s), t._$_GetBehaviorsScriptDescriptor$_(s), 
            Object.defineProperties(this, s), t._$GetRuntime$_()._$_MapScriptInterface$_(this, t);
        }
        static _$_GetInitInst$_() {
            return ve._$AddonManager$_._$_GetInitObject$_();
        }
        _$_release$_() {
            const t = Te.get(this);
            t && (t._$Release$_(), Te.delete(this)), Ge.delete(this);
        }
        addEventListener(t, s, i) {
            xe._$RequireString$_(t), xe._$RequireFunction$_(s), e(this).addEventListener(t, s, i);
        }
        removeEventListener(t, s, i) {
            xe._$RequireString$_(t), xe._$RequireFunction$_(s), e(this).removeEventListener(t, s, i);
        }
        dispatchEvent(t) {
            e(this).dispatchEvent(t);
        }
        _$destroy$_() {
            const t = Ge.get(this), s = t._$GetRuntime$_();
            s._$DestroyInstance$_(t), s._$GetEventSheetManager$_()._$IsInEventEngine$_() || s._$GetLayoutManager$_()._$IsEndingLayout$_() || s._$GetEventSheetManager$_()._$IsFlushingBlocked$_() || s._$FlushPendingInstances$_();
        }
        _$getOtherContainerInstances$_() {
            const t = Ge.get(this)._$GetSiblings$_();
            return t ? t.map(t => t._$GetInterfaceClass$_()) : [];
        }
        *_$otherContainerInstances$_() {
            const t = Ge.get(this);
            if (t._$IsInContainer$_()) for (const s of t._$siblings$_()) yield s._$GetInterfaceClass$_();
        }
        get uid() {
            return Ge.get(this)._$GetUID$_();
        }
        get _$templateName$_() {
            return Ge.get(this)._$GetTemplateName$_();
        }
        set timeScale(t) {
            xe._$RequireFiniteNumber$_(t), Ge.get(this)._$SetTimeScale$_(t);
        }
        get timeScale() {
            return Ge.get(this)._$GetActiveTimeScale$_();
        }
        _$restoreTimeScale$_() {
            Ge.get(this)._$RestoreTimeScale$_();
        }
        get dt() {
            const t = Ge.get(this);
            return t._$GetRuntime$_()._$GetDt$_(t);
        }
        _$hasTags$_(...t) {
            xe._$RequireArray$_(t);
            const s = new Set(t), i = Ge.get(this)._$GetTagsSet$_();
            return s._$isSubsetOf$_(i);
        }
        _$setAllTags$_(t) {
            xe._$RequireInstanceOf$_(t, Set), Ge.get(this)._$SetTagsSet$_(t);
        }
        _$getAllTags$_() {
            return new Set(Ge.get(this)._$GetTagsSet$_());
        }
        signal(t) {
            xe._$RequireString$_(t);
            const s = Ge.get(this);
            s._$GetRuntime$_()._$GetEventSheetManager$_()._$InstanceSignal$_(s, t);
        }
        _$waitForSignal$_(t) {
            xe._$RequireString$_(t);
            const s = Ge.get(this);
            return s._$GetRuntime$_()._$GetEventSheetManager$_()._$WaitForInstanceSignal$_(s, t);
        }
    };
}

{
    const Ie = self._$C3$_, Ce = self._$C3X$_, Re = new WeakMap(), Pe = Ie._$_GetInternalAPIToken$_();
    self._$ISDKInstanceBase$_ = class extends self._$IInstance$_ {
        constructor(t) {
            super(), Re.set(this, Ie._$AddonManager$_._$_GetInitObject2$_(Pe)), 
            this._$_p_isTicking$_ = !1, this._$_p_tickFunc$_ = null, this._$_p_isTicking2$_ = !1, 
            this._$_p_tickFunc2$_ = null, this._$_p_domComponentId$_ = t?.domComponentId, 
            this._$_p_wrapperComponentId$_ = t?.wrapperComponentId;
        }
        _$_release$_() {
            super._$_release$_(), Re.delete(this);
        }
        _$_getInitProperties$_() {
            return Ie._$AddonManager$_._$_GetInitProperties$_();
        }
        _$_trigger$_(t) {
            const s = Re.get(this);
            s._$GetRuntime$_()._$Trigger$_(t, s);
        }
        _$_triggerAsync$_(t) {
            const s = Re.get(this);
            return s._$GetRuntime$_()._$TriggerAsync$_(t, s);
        }
        _$_addDOMMessageHandler$_(t, s) {
            if (Ce._$RequireString$_(t), Ce._$RequireFunction$_(s), !this._$_p_domComponentId$_) throw new Error("no DOM component id set");
            const i = Re.get(this)._$GetRuntime$_();
            i._$AddDOMComponentMessageHandler$_(this._$_p_domComponentId$_, t, s);
        }
        _$_addDOMMessageHandlers$_(t) {
            Ce._$RequireArray$_(t);
            for (const [ s, i ] of t) this._$_addDOMMessageHandler$_(s, i);
        }
        _$_postToDOM$_(t, s) {
            if (Ce._$RequireString$_(t), !this._$_p_domComponentId$_) throw new Error("no DOM component id set");
            const i = Re.get(this)._$GetRuntime$_();
            i._$PostComponentMessageToDOM$_(this._$_p_domComponentId$_, t, s);
        }
        _$_postToDOMAsync$_(t, s) {
            if (Ce._$RequireString$_(t), !this._$_p_domComponentId$_) throw new Error("no DOM component id set");
            const i = Re.get(this)._$GetRuntime$_();
            return i._$PostComponentMessageToDOMAsync$_(this._$_p_domComponentId$_, t, s);
        }
        _$_postToDOMMaybeSync$_(t, s) {
            const i = Re.get(this)._$GetRuntime$_();
            if (!i._$IsInWorker$_()) return window.c3_runtimeInterface._OnMessageFromRuntime({
                type: "event",
                component: this._$_p_domComponentId$_,
                handler: t,
                data: s,
                responseId: null
            });
            this._$_postToDOM$_(t, s);
        }
        _$_setTicking$_(t) {
            if (this._$_p_isTicking$_ !== (t = !!t)) {
                this._$_p_isTicking$_ = t;
                const s = Re.get(this)._$GetRuntime$_();
                t ? (this._$_p_tickFunc$_ || (this._$_p_tickFunc$_ = () => this._$_tick$_()), 
                s._$Dispatcher$_().addEventListener("tick", this._$_p_tickFunc$_)) : s._$Dispatcher$_().removeEventListener("tick", this._$_p_tickFunc$_);
            }
        }
        _$_isTicking$_() {
            return this._$_p_isTicking$_;
        }
        _$_tick$_() {}
        _$_setTicking2$_(t) {
            if (this._$_p_isTicking2$_ !== (t = !!t)) {
                this._$_p_isTicking2$_ = t;
                const s = Re.get(this)._$GetRuntime$_();
                t ? (this._$_p_tickFunc2$_ || (this._$_p_tickFunc2$_ = () => this._$_tick2$_()), 
                s._$Dispatcher$_().addEventListener("tick2", this._$_p_tickFunc2$_)) : s._$Dispatcher$_().removeEventListener("tick2", this._$_p_tickFunc2$_);
            }
        }
        _$_isTicking2$_() {
            return this._$_p_isTicking2$_;
        }
        _$_tick2$_() {}
        _$_getDebuggerProperties$_() {
            return [];
        }
        _$_saveToJson$_() {
            return null;
        }
        _$_loadFromJson$_(t) {}
        _$_isWrapperExtensionAvailable$_() {
            if (!this._$_p_wrapperComponentId$_) throw new Error("no wrapper component id set");
            const t = Re.get(this)._$GetRuntime$_();
            return t._$HasWrapperComponentId$_(this._$_p_wrapperComponentId$_);
        }
        _$_addWrapperExtensionMessageHandler$_(t, s) {
            if (Ce._$RequireString$_(t), Ce._$RequireFunction$_(s), !this._$_p_wrapperComponentId$_) throw new Error("no wrapper component id set");
            const i = Re.get(this)._$GetRuntime$_();
            i._$AddWrapperExtensionMessageHandler$_(this._$_p_wrapperComponentId$_, t, s);
        }
        _$_addWrapperMessageHandlers$_(t) {
            Ce._$RequireArray$_(t);
            for (const [ s, i ] of t) this._$_addWrapperExtensionMessageHandler$_(s, i);
        }
        _$_sendWrapperExtensionMessage$_(t, s) {
            if (!this._$_p_wrapperComponentId$_) throw new Error("no wrapper component id set");
            this.runtime._$sdk$_._$sendWrapperExtensionMessage$_(this._$_p_wrapperComponentId$_, t, s);
        }
        _$_sendWrapperExtensionMessageAsync$_(t, s) {
            if (this._$_p_wrapperComponentId$_) return this.runtime._$sdk$_._$sendWrapperExtensionMessageAsync$_(this._$_p_wrapperComponentId$_, t, s);
            throw new Error("no wrapper component id set");
        }
    };
}

{
    let t = function(t) {
        return class h extends t {
            constructor(t) {
                super(t);
                const s = Ee._$AddonManager$_._$_GetInitObject2$_(Oe), i = (d.set(this, s), 
                []), e = s._$GetWorldInfo$_(), h = e._$GetInstanceEffectList$_();
                if (h) {
                    const n = e._$GetObjectClass$_()._$GetEffectList$_()._$GetAllEffectTypes$_().length;
                    for (let t = 0; t < n; ++t) i.push(new self._$IEffectInstance$_(h, t));
                }
                const r = {
                    effects: {
                        value: i,
                        writable: !1
                    }
                };
                Object.defineProperties(this, r);
            }
            get layout() {
                return d.get(this)._$GetWorldInfo$_()._$GetLayout$_()._$GetILayout$_();
            }
            get _$layer$_() {
                return d.get(this)._$GetWorldInfo$_()._$GetLayer$_()._$GetILayer$_();
            }
            get x() {
                return d.get(this)._$GetWorldInfo$_()._$GetX$_();
            }
            set x(t) {
                t = +t;
                const s = d.get(this)._$GetWorldInfo$_();
                isNaN(t) || s._$GetX$_() === t || (s._$SetX$_(t), s._$SetBboxChanged$_());
            }
            get y() {
                return d.get(this)._$GetWorldInfo$_()._$GetY$_();
            }
            set y(t) {
                t = +t;
                const s = d.get(this)._$GetWorldInfo$_();
                isNaN(t) || s._$GetY$_() === t || (s._$SetY$_(t), s._$SetBboxChanged$_());
            }
            setPosition(t, s) {
                t = +t, s = +s;
                const i = d.get(this)._$GetWorldInfo$_();
                isNaN(t) || isNaN(s) || i._$GetX$_() === t && i._$GetY$_() === s || (i._$SetXY$_(t, s), 
                i._$SetBboxChanged$_());
            }
            _$getPosition$_() {
                const t = d.get(this)._$GetWorldInfo$_();
                return [ t._$GetX$_(), t._$GetY$_() ];
            }
            _$offsetPosition$_(t, s) {
                if (t = +t, s = +s, !(isNaN(t) || isNaN(s) || 0 === t && 0 === s)) {
                    const i = d.get(this)._$GetWorldInfo$_();
                    i._$OffsetXY$_(t, s), i._$SetBboxChanged$_();
                }
            }
            get _$zElevation$_() {
                return d.get(this)._$GetWorldInfo$_()._$GetZElevation$_();
            }
            set _$zElevation$_(t) {
                t = +t;
                const s = d.get(this), i = s._$GetWorldInfo$_();
                isNaN(t) || i._$GetZElevation$_() === t || (i._$SetZElevation$_(t), 
                s._$GetRuntime$_()._$UpdateRender$_());
            }
            get _$totalZElevation$_() {
                return d.get(this)._$GetWorldInfo$_()._$GetTotalZElevation$_();
            }
            get width() {
                return d.get(this)._$GetWorldInfo$_()._$GetWidth$_();
            }
            set width(t) {
                t = +t;
                const s = d.get(this)._$GetWorldInfo$_();
                isNaN(t) || s._$GetWidth$_() === t || (s._$SetWidth$_(t), s._$SetBboxChanged$_());
            }
            get height() {
                return d.get(this)._$GetWorldInfo$_()._$GetHeight$_();
            }
            set height(t) {
                t = +t;
                const s = d.get(this)._$GetWorldInfo$_();
                isNaN(t) || s._$GetHeight$_() === t || (s._$SetHeight$_(t), s._$SetBboxChanged$_());
            }
            _$setSize$_(t, s) {
                t = +t, s = +s;
                const i = d.get(this)._$GetWorldInfo$_();
                isNaN(t) || isNaN(s) || i._$GetWidth$_() === t && i._$GetHeight$_() === s || (i._$SetSize$_(t, s), 
                i._$SetBboxChanged$_());
            }
            getSize() {
                const t = d.get(this)._$GetWorldInfo$_();
                return [ t._$GetWidth$_(), t._$GetHeight$_() ];
            }
            get angle() {
                return d.get(this)._$GetWorldInfo$_()._$GetAngle$_();
            }
            set angle(t) {
                t = Ee._$clampAngle$_(+t);
                const s = d.get(this)._$GetWorldInfo$_();
                isNaN(t) || s._$GetAngle$_() === t || (s._$SetAngle$_(t), s._$SetBboxChanged$_());
            }
            get _$angleDegrees$_() {
                return Ee._$toDegrees$_(this.angle);
            }
            set _$angleDegrees$_(t) {
                this.angle = Ee._$toRadians$_(t);
            }
            _$getBoundingBox$_() {
                return d.get(this)._$GetWorldInfo$_()._$GetBoundingBox$_()._$toDOMRect$_();
            }
            _$getBoundingQuad$_() {
                return d.get(this)._$GetWorldInfo$_()._$GetBoundingQuad$_()._$toDOMQuad$_();
            }
            _$isOnScreen$_() {
                return d.get(this)._$GetWorldInfo$_()._$IsInViewport2$_();
            }
            get isVisible() {
                return d.get(this)._$GetWorldInfo$_()._$IsVisible$_();
            }
            set isVisible(t) {
                t = !!t;
                const s = d.get(this), i = s._$GetWorldInfo$_();
                i._$IsVisible$_() !== t && (i._$SetVisible$_(t), s._$GetRuntime$_()._$UpdateRender$_());
            }
            get opacity() {
                return d.get(this)._$GetWorldInfo$_()._$GetOpacity$_();
            }
            set opacity(t) {
                t = Ee._$clamp$_(+t, 0, 1);
                const s = d.get(this), i = s._$GetWorldInfo$_();
                isNaN(t) || i._$GetOpacity$_() === t || (i._$SetOpacity$_(t), s._$GetRuntime$_()._$UpdateRender$_());
            }
            set _$colorRgb$_(t) {
                if (Ae._$RequireArray$_(t), t.length < 3) throw new Error("expected 3 elements");
                Le._$setRgb$_(t[0], t[1], t[2]);
                const s = d.get(this), i = s._$GetWorldInfo$_();
                i._$GetUnpremultipliedColor$_()._$equalsIgnoringAlpha$_(Le) || (i._$SetUnpremultipliedColor$_(Le), 
                s._$GetRuntime$_()._$UpdateRender$_());
            }
            get _$colorRgb$_() {
                const t = d.get(this)._$GetWorldInfo$_()._$GetUnpremultipliedColor$_();
                return [ t._$getR$_(), t._$getG$_(), t._$getB$_() ];
            }
            set _$blendMode$_(t) {
                Ae._$RequireString$_(t);
                const s = De.get(t);
                if ("number" != typeof s) throw new Error("invalid blend mode");
                const i = d.get(this), e = i._$GetWorldInfo$_();
                e._$SetBlendMode$_(s), i._$GetRuntime$_()._$UpdateRender$_();
            }
            get _$blendMode$_() {
                return ke.get(d.get(this)._$GetWorldInfo$_()._$GetBlendMode$_());
            }
            _$moveToTop$_() {
                d.get(this)._$GetWorldInfo$_()._$ZOrderMoveToTop$_();
            }
            _$moveToBottom$_() {
                d.get(this)._$GetWorldInfo$_()._$ZOrderMoveToBottom$_();
            }
            _$moveToLayer$_(t) {
                Ae._$RequireInstanceOf$_(t, Fe);
                const s = d.get(this), i = s._$GetRuntime$_()._$_UnwrapScriptInterface$_(t);
                if (!i) throw new Error("invalid layer");
                s._$GetWorldInfo$_()._$ZOrderMoveToLayer$_(i);
            }
            _$moveAdjacentToInstance$_(t, s) {
                Ae._$RequireInstanceOf$_(t, h), d.get(this)._$GetWorldInfo$_()._$ZOrderMoveAdjacentToInstance$_(d.get(t), s);
            }
            get zIndex() {
                return d.get(this)._$GetWorldInfo$_()._$GetZIndex$_();
            }
            get _$isCollisionEnabled$_() {
                return d.get(this)._$GetWorldInfo$_()._$IsCollisionEnabled$_();
            }
            set _$isCollisionEnabled$_(t) {
                d.get(this)._$GetWorldInfo$_()._$SetCollisionEnabled$_(!!t);
            }
            _$containsPoint$_(t, s) {
                return Ae._$RequireNumber$_(t), Ae._$RequireNumber$_(s), d.get(this)._$GetWorldInfo$_()._$ContainsPoint$_(+t, +s);
            }
            _$testOverlap$_(t) {
                Ae._$RequireInstanceOf$_(t, h);
                const s = d.get(this), i = d.get(t);
                return s._$GetRuntime$_()._$GetCollisionEngine$_()._$TestOverlap$_(s, i);
            }
            _$testOverlapSolid$_() {
                const t = d.get(this), s = t._$GetRuntime$_()._$GetCollisionEngine$_()._$TestOverlapSolid$_(t);
                return s ? s._$GetInterfaceClass$_() : null;
            }
            getParent() {
                const t = d.get(this)._$GetParent$_();
                return t ? t._$GetInterfaceClass$_() : null;
            }
            _$getTopParent$_() {
                const t = d.get(this)._$GetTopParent$_();
                return t ? t._$GetInterfaceClass$_() : null;
            }
            *_$parents$_() {
                for (const t of d.get(this)._$parents$_()) yield t._$GetInterfaceClass$_();
            }
            _$getChildCount$_() {
                return d.get(this)._$GetChildCount$_();
            }
            _$getChildAt$_(t) {
                const s = d.get(this)._$GetChildAt$_(t);
                return s ? s._$GetInterfaceClass$_() : null;
            }
            *children() {
                for (const t of d.get(this).children()) yield t._$GetInterfaceClass$_();
            }
            *_$allChildren$_() {
                for (const t of d.get(this)._$allChildren$_()) yield t._$GetInterfaceClass$_();
            }
            _$addChild$_(t, s) {
                Ae._$RequireInstanceOf$_(t, h), Ae._$RequireOptionalObject$_(s), 
                s = s || {};
                const i = d.get(this), e = d.get(t);
                i._$AddChild$_(e, s);
            }
            removeChild(t) {
                Ae._$RequireInstanceOf$_(t, h);
                const s = d.get(this), i = d.get(t);
                s._$RemoveChild$_(i);
            }
            _$removeFromParent$_() {
                const t = d.get(this);
                if (t._$HasParent$_()) {
                    const s = t._$GetParent$_();
                    s._$RemoveChild$_(t);
                }
            }
            _$getHierarchyOpts$_() {
                const t = d.get(this)._$GetWorldInfo$_();
                return {
                    _$transformX$_: t._$GetTransformWithParentX$_(),
                    _$transformY$_: t._$GetTransformWithParentY$_(),
                    _$transformWidth$_: t._$GetTransformWithParentWidth$_(),
                    _$transformHeight$_: t._$GetTransformWithParentHeight$_(),
                    _$transformAngle$_: t._$GetTransformWithParentAngle$_(),
                    _$transformZElevation$_: t._$GetTransformWithParentZElevation$_(),
                    _$transformOpacity$_: t._$GetTransformWithParentOpacity$_(),
                    _$transformVisibility$_: t._$GetTransformWithParentVisibility$_(),
                    _$destroyWithParent$_: t._$GetDestroyWithParent$_()
                };
            }
            _$createMesh$_(t, s) {
                Ae._$RequireFiniteNumber$_(t), Ae._$RequireFiniteNumber$_(s), d.get(this)._$GetWorldInfo$_()._$CreateMesh$_(t, s);
            }
            _$releaseMesh$_() {
                const t = d.get(this)._$GetWorldInfo$_();
                t._$ReleaseMesh$_(), t._$SetBboxChanged$_();
            }
            _$setMeshPoint$_(t, s, i) {
                Ae._$RequireFiniteNumber$_(t), Ae._$RequireFiniteNumber$_(s), Ae._$RequireObject$_(i);
                const e = d.get(this)._$GetWorldInfo$_();
                e._$SetMeshPoint$_(t, s, i) && e._$SetBboxChanged$_();
            }
            _$getMeshPoint$_(t, s) {
                let i = NaN, e = NaN, h = NaN, r = NaN, n = NaN, o = d.get(this)._$GetWorldInfo$_();
                if (o._$HasMesh$_()) {
                    const a = o._$GetSourceMesh$_(), l = a._$GetMeshPointAt$_(t, s);
                    null !== l && (i = l._$GetX$_(), e = l._$GetY$_(), h = l._$GetZElevation$_(), 
                    r = l._$GetU$_(), n = l._$GetV$_());
                }
                return {
                    x: i,
                    y: e,
                    _$zElevation$_: h,
                    u: r,
                    v: n
                };
            }
            _$getMeshSize$_() {
                const t = d.get(this)._$GetWorldInfo$_();
                if (!t._$HasMesh$_()) return [ 0, 0 ];
                const s = t._$GetSourceMesh$_();
                return [ s._$GetHSize$_(), s._$GetVSize$_() ];
            }
        };
    };
    0;
    const Ee = self._$C3$_, Ae = self._$C3X$_, Fe = self._$ILayer$_, d = new WeakMap(), Oe = Ee._$_GetInternalAPIToken$_(), De = new Map([ [ "normal", 0 ], [ "additive", 1 ], [ "copy", 3 ], [ "destination-over", 4 ], [ "source-in", 5 ], [ "destination-in", 6 ], [ "source-out", 7 ], [ "destination-out", 8 ], [ "source-atop", 9 ], [ "destination-atop", 10 ] ]), ke = new Map([ ...De.entries() ].map(t => [ t[1], t[0] ])), Le = Ee._$New$_(Ee._$Color$_);
    self._$IWorldInstance$_ = t(self._$IInstance$_), self._$IWorldInstanceSDKBase$_ = t(self._$ISDKInstanceBase$_);
}

{
    const Be = self._$C3X$_, Ne = new WeakMap();
    self._$IDOMInstance$_ = class extends self._$IWorldInstance$_ {
        constructor() {
            super(), Ne.set(this, self._$IInstance$_._$_GetInitInst$_());
        }
        _$getElement$_() {
            return Ne.get(this)._$GetSdkInstance$_()._$_GetElementInDOMMode$_();
        }
        focus() {
            Ne.get(this)._$GetSdkInstance$_()._$FocusElement$_();
        }
        blur() {
            Ne.get(this)._$GetSdkInstance$_()._$BlurElement$_();
        }
        _$setCssStyle$_(t, s) {
            Be._$RequireString$_(t), Ne.get(this)._$GetSdkInstance$_()._$SetElementCSSStyle$_(t, s);
        }
    };
}

{
    let e = function(t) {
        let s = Ue.get(t);
        return s || (s = We._$New$_(We.Event._$Dispatcher$_), Ue.set(t, s)), s;
    };
    e;
    const We = self._$C3$_, je = self._$C3X$_, Ve = new WeakMap(), Ue = new WeakMap(), He = We._$_GetInternalAPIToken$_();
    self._$IBehaviorInstance$_ = class {
        constructor() {
            const t = We._$AddonManager$_._$_GetInitObject2$_(He), s = (Ve.set(this, t), 
            {
                runtime: {
                    value: t._$GetRuntime$_()._$GetIRuntime$_(),
                    writable: !1
                },
                behavior: {
                    value: t._$GetBehavior$_()._$GetIBehavior$_(),
                    writable: !1
                },
                _$behaviorType$_: {
                    value: t._$GetBehaviorType$_()._$GetIBehaviorType$_(),
                    writable: !1
                }
            });
            Object.defineProperties(this, s), t._$GetRuntime$_()._$_MapScriptInterface$_(this, t);
        }
        static _$_GetInitInst$_() {
            return We._$AddonManager$_._$_GetInitObject$_();
        }
        get _$instance$_() {
            return Ve.get(this)._$GetObjectInstance$_()._$GetInterfaceClass$_();
        }
        _$_release$_() {
            const t = Ue.get(this);
            t && (t._$Release$_(), Ue.delete(this)), Ve.delete(this);
        }
        addEventListener(t, s, i) {
            je._$RequireString$_(t), je._$RequireFunction$_(s), e(this).addEventListener(t, s, i);
        }
        removeEventListener(t, s, i) {
            je._$RequireString$_(t), je._$RequireFunction$_(s), e(this).removeEventListener(t, s, i);
        }
        dispatchEvent(t) {
            e(this).dispatchEvent(t);
        }
    };
}

{
    const ze = self._$C3$_, Je = ze._$_GetInternalAPIToken$_();
    self._$IBehaviorType$_ = class {
        constructor() {
            const t = ze._$AddonManager$_._$_GetInitObject2$_(Je), s = {
                runtime: {
                    value: t._$GetRuntime$_()._$GetIRuntime$_(),
                    writable: !1
                },
                behavior: {
                    value: t._$GetBehavior$_()._$GetIBehavior$_(),
                    writable: !1
                },
                name: {
                    value: t._$GetName$_(),
                    writable: !1
                }
            };
            Object.defineProperties(this, s);
        }
    };
}

{
    const qe = self._$C3$_, Xe = new WeakMap(), Ye = qe._$_GetInternalAPIToken$_();
    self._$IBehavior$_ = class {
        constructor() {
            const t = qe._$AddonManager$_._$_GetInitObject2$_(Ye), s = (Xe.set(this, t), 
            {
                runtime: {
                    value: t._$GetRuntime$_()._$GetIRuntime$_(),
                    writable: !1
                }
            });
            Object.defineProperties(this, s);
        }
        _$getAllInstances$_() {
            return Xe.get(this)._$GetInstances$_().map(t => t._$GetInterfaceClass$_());
        }
        static _$getByConstructor$_(t) {
            if (!t) return null;
            const s = qe._$AddonManager$_._$GetBehaviorByConstructorFunction$_(t);
            return s ? s._$GetIBehavior$_() : null;
        }
    };
}

{
    const $e = self._$C3$_, Ke = self._$C3X$_, Ze = new WeakMap(), Qe = $e._$New$_($e._$Color$_);
    self._$IEffectInstance$_ = class {
        constructor(t, s) {
            Ze.set(this, t);
            const i = {
                index: {
                    value: s,
                    writable: !1
                }
            };
            Object.defineProperties(this, i);
        }
        get name() {
            const t = Ze.get(this)._$GetAllEffectTypes$_();
            return t[this.index]._$GetName$_();
        }
        get isActive() {
            return Ze.get(this)._$IsEffectIndexActive$_(this.index);
        }
        set isActive(t) {
            t = !!t;
            const s = Ze.get(this);
            s._$IsEffectIndexActive$_(this.index) !== t && (s._$SetEffectIndexActive$_(this.index, t), 
            s._$UpdateActiveEffects$_(), s._$GetRuntime$_()._$UpdateRender$_());
        }
        setParameter(t, s) {
            Ke._$RequireFiniteNumber$_(t), t = Math.floor(+t);
            const i = Ze.get(this), e = i._$GetEffectParameter$_(this.index, t);
            if (null === e) throw new RangeError("invalid index");
            if (e instanceof $e._$Color$_) {
                if (!Array.isArray(s) || s.length < 3) throw new TypeError("expected array with 3 elements");
                Qe._$setRgb$_(s[0], s[1], s[2]), s = Qe;
            } else if ("number" != typeof s) throw new TypeError("expected number");
            const h = i._$SetEffectParameter$_(this.index, t, s);
            h && i._$IsEffectIndexActive$_(this.index) && i._$GetRuntime$_()._$UpdateRender$_();
        }
        getParameter(t) {
            Ke._$RequireFiniteNumber$_(t), t = Math.floor(+t);
            const s = Ze.get(this), i = s._$GetEffectParameter$_(this.index, t);
            if (null === i) throw new RangeError("invalid index");
            return i instanceof $e._$Color$_ ? [ i._$getR$_(), i._$getG$_(), i._$getB$_() ] : i;
        }
    };
}

{
    const th = new WeakMap();
    self._$IAnimation$_ = class {
        constructor(t) {
            th.set(this, t), Object.defineProperties(this, {
                name: {
                    value: t._$GetName$_(),
                    writable: !1
                }
            });
        }
        get speed() {
            return th.get(this)._$GetSpeed$_();
        }
        get isLooping() {
            return th.get(this)._$IsLooping$_();
        }
        get repeatCount() {
            return th.get(this)._$GetRepeatCount$_();
        }
        get _$repeatTo$_() {
            return th.get(this)._$GetRepeatTo$_();
        }
        get _$isPingPong$_() {
            return th.get(this)._$IsPingPong$_();
        }
        get frameCount() {
            return th.get(this)._$GetFrameCount$_();
        }
        _$getFrames$_() {
            return th.get(this)._$GetFrames$_().map(t => t._$GetIAnimationFrame$_());
        }
        *frames() {
            for (const t of th.get(this)._$GetFrames$_()) yield t._$GetIAnimationFrame$_();
        }
    };
}

{
    const sh = new WeakMap();
    self._$IImageInfo$_ = class {
        constructor(t) {
            sh.set(this, t);
        }
        static _$_Unwrap$_(t) {
            return sh.get(t);
        }
        get width() {
            return sh.get(this)._$GetWidth$_();
        }
        get height() {
            return sh.get(this)._$GetHeight$_();
        }
        getSize() {
            const t = sh.get(this);
            return [ t._$GetWidth$_(), t._$GetHeight$_() ];
        }
        _$getTexture$_(t) {
            return t._$getTextureForImageInfo$_(this);
        }
        _$getTexRect$_() {
            return sh.get(this)._$GetTexRect$_()._$toDOMRect$_();
        }
    };
}

{
    const ih = self._$C3X$_, eh = new WeakMap();
    self._$IAnimationFrame$_ = class extends self._$IImageInfo$_ {
        constructor(t) {
            super(t._$GetImageInfo$_()), eh.set(this, t), Object.defineProperties(this, {
                duration: {
                    value: t._$GetDuration$_(),
                    writable: !1
                },
                _$originX$_: {
                    value: t._$GetOriginX$_(),
                    writable: !1
                },
                _$originY$_: {
                    value: t._$GetOriginY$_(),
                    writable: !1
                }
            });
        }
        _$getOrigin$_() {
            const t = eh.get(this);
            return [ t._$GetOriginX$_(), t._$GetOriginY$_() ];
        }
        _$getImagePointCount$_() {
            return eh.get(this)._$GetImagePointCount$_();
        }
        _$getImagePointX$_(t) {
            return this._$getImagePoint$_(t)[0];
        }
        _$getImagePointY$_(t) {
            return this._$getImagePoint$_(t)[1];
        }
        _$getImagePoint$_(t) {
            let s = eh.get(this), i = null;
            if ("number" == typeof t) i = s._$GetImagePointByIndex$_(Math.floor(t)); else {
                if ("string" != typeof t) throw new TypeError("expected string or number");
                i = s._$GetImagePointByName$_(t);
            }
            return i ? [ i._$GetX$_(), i._$GetY$_() ] : this._$getOrigin$_();
        }
        _$getPolyPointCount$_() {
            const t = eh.get(this)._$GetCollisionPoly$_();
            return t ? t._$pointCount$_() : 0;
        }
        _$getPolyPointX$_(t) {
            return this._$getPolyPoint$_(t)[0];
        }
        _$getPolyPointY$_(t) {
            return this._$getPolyPoint$_(t)[1];
        }
        _$getPolyPoint$_(t) {
            ih._$RequireFiniteNumber$_(t), t = Math.floor(t);
            const s = eh.get(this)._$GetCollisionPoly$_();
            if (!s || t < 0 || t >= s._$pointCount$_()) return [ 0, 0 ];
            const i = s._$pointsArr$_(), e = i[2 * t], h = i[2 * t + 1];
            return [ e, h ];
        }
        get tag() {
            return eh.get(this)._$GetTag$_();
        }
    };
}

{
    let s = function(t) {
        const s = rh.get(t);
        if (s._$IsReleased$_()) throw new Error("timeline/tween was released and is no longer valid");
        return s;
    };
    s;
    const hh = self._$C3X$_, rh = new WeakMap();
    self._$ITimelineStateBase$_ = class {
        constructor(t) {
            rh.set(this, t), t._$GetRuntime$_()._$_MapScriptInterface$_(this, t);
        }
        pause() {
            s(this)._$Stop$_();
        }
        resume() {
            s(this)._$Resume$_();
        }
        stop() {
            s(this)._$Reset$_();
        }
        _$hasTags$_(t) {
            return s(this)._$HasTags$_(t);
        }
        set time(t) {
            hh._$RequireFiniteNumber$_(t), s(this)._$SetTime$_(t);
        }
        get time() {
            return s(this)._$GetTime$_();
        }
        set totalTime(t) {
            hh._$RequireFiniteNumber$_(t), s(this)._$SetTotalTime$_(t);
        }
        get totalTime() {
            return s(this)._$GetTotalTime$_();
        }
        set isLooping(t) {
            s(this)._$SetLoop$_(!!t);
        }
        get isLooping() {
            return s(this)._$GetLoop$_();
        }
        set _$isPingPong$_(t) {
            s(this)._$SetPingPong$_(!!t);
        }
        get _$isPingPong$_() {
            return s(this)._$GetPingPong$_();
        }
        set playbackRate(t) {
            hh._$RequireFiniteNumber$_(t), s(this)._$SetPlaybackRate$_(t);
        }
        get playbackRate() {
            return s(this)._$GetPlaybackRate$_();
        }
        get progress() {
            const t = s(this);
            return t._$GetTime$_() / t._$GetTotalTime$_();
        }
        get tags() {
            return s(this)._$GetTags$_();
        }
        get finished() {
            return s(this)._$GetPlayPromise$_();
        }
        get isPlaying() {
            return s(this).IsPlaying();
        }
        get _$isPaused$_() {
            return s(this)._$IsPaused$_();
        }
        get _$isReleased$_() {
            return rh.get(this)._$IsReleased$_();
        }
    };
}

{
    let i = new WeakMap();
    self._$ITimelineState$_ = class extends self._$ITimelineStateBase$_ {
        constructor(t) {
            super(t), i.set(this, t);
            const s = {
                name: {
                    value: t._$GetName$_(),
                    writable: !1
                }
            };
            Object.defineProperties(this, s);
        }
    };
}

{
    let i = function(t) {
        const s = h.get(t);
        if (s._$IsReleased$_()) throw new Error("tween was released and is no longer valid");
        return s;
    }, e = (i, self._$C3X$_), h = new WeakMap(), r = new WeakMap(), n = null;
    self._$ITweenState$_ = class extends self._$ITimelineStateBase$_ {
        constructor(t, s, i) {
            super(t), n = n || i._$easeToIndexFunc$_, h.set(this, t), s && r.set(this, s);
        }
        stop() {
            const t = i(this), s = r.get(this);
            s._$ReleaseTween$_(t);
        }
        _$setEase$_(t) {
            e._$RequireString$_(t);
            const s = self._$Ease$_._$GetEaseFromIndex$_(n(t));
            i(this)._$SetEase$_(s);
        }
        get _$instance$_() {
            const t = i(this)._$GetInstance$_();
            return t ? t._$GetInterfaceClass$_() : null;
        }
        get _$isDestroyOnComplete$_() {
            return i(this)._$GetDestroyInstanceOnComplete$_();
        }
        set _$isDestroyOnComplete$_(t) {
            i(this)._$SetDestroyInstanceOnComplete$_(!!t);
        }
        get value() {
            const t = i(this);
            if ("value" !== t._$GetId$_()) throw new Error("not a value tween");
            return t._$GetPropertyTrack$_("value")._$GetSourceAdapterValue$_();
        }
    };
}

self._$ISDKPluginBase$_ = class extends self._$IPlugin$_ {
    constructor() {
        super();
    }
};

{
    const nh = self._$C3$_, oh = self._$C3X$_, ah = new WeakMap(), lh = nh._$_GetInternalAPIToken$_();
    self._$ISDKDOMPluginBase$_ = class extends self._$ISDKPluginBase$_ {
        constructor(t) {
            if (super(), ah.set(this, nh._$AddonManager$_._$_GetInitObject2$_(lh)), 
            !t?.domComponentId) throw new Error("no DOM component ID specified");
            this._$_p_domComponentId$_ = t.domComponentId, this._$_p_nextElementId$_ = 0, 
            this._$_p_instMap$_ = new Map(), this._$_addElementMessageHandler$_("elem-focused", t => t._$_onElemFocused$_()), 
            this._$_addElementMessageHandler$_("elem-blurred", t => {
                t && t._$_onElemBlurred$_();
            });
        }
        _$_addElement$_(t) {
            const s = this._$_p_nextElementId$_++;
            return this._$_p_instMap$_.set(s, t), s;
        }
        _$_removeElement$_(t) {
            this._$_p_instMap$_.delete(t);
        }
        _$_addElementMessageHandler$_(t, i) {
            const s = ah.get(this)._$GetRuntime$_();
            s._$AddDOMComponentMessageHandler$_(this._$_p_domComponentId$_, t, t => {
                const s = this._$_p_instMap$_.get(t.elementId);
                i(s, t);
            });
        }
        _$_addElementMessageHandlers$_(t) {
            oh._$RequireArray$_(t);
            for (const [ s, i ] of t) this._$_addElementMessageHandlers$_(s, i);
        }
    };
}

{
    const uh = self._$C3$_, ch = new WeakMap(), fh = uh._$_GetInternalAPIToken$_();
    self._$ISDKObjectTypeBase$_ = class extends self._$IObjectClass$_ {
        constructor() {
            super();
            const t = uh._$AddonManager$_._$_GetInitObject2$_(fh);
            ch.set(this, t);
        }
        _$_onCreate$_() {}
        _$getImageInfo$_() {
            return ch.get(this)._$GetImageInfo$_()._$GetIImageInfo$_();
        }
        _$_loadTextures$_(t) {}
        _$_releaseTextures$_(t) {}
        _$_onDynamicTextureLoadComplete$_() {}
        _$_preloadTexturesWithInstances$_(t) {}
    };
}

{
    const dh = self._$C3$_, ph = new WeakMap(), mh = dh._$_GetInternalAPIToken$_();
    self._$ISDKWorldInstanceBase$_ = class extends self._$IWorldInstanceSDKBase$_ {
        constructor(t) {
            super(t), ph.set(this, dh._$AddonManager$_._$_GetInitObject2$_(mh)), 
            this._$_p_renderercontextlost_handler$_ = null, this._$_p_renderercontextrestored_handler$_ = null;
        }
        _$_release$_() {
            if (super._$_release$_(), this._$_p_renderercontextlost_handler$_) {
                const t = ph.get(this)._$GetRuntime$_()._$Dispatcher$_();
                t.removeEventListener("renderercontextlost", this._$_p_renderercontextlost_handler$_), 
                t.removeEventListener("renderercontextrestored", this._$_p_renderercontextrestored_handler$_), 
                this._$_p_renderercontextlost_handler$_ = null, this._$_p_renderercontextrestored_handler$_ = null;
            }
            ph.delete(this);
        }
        _$_handleRendererContextLoss$_() {
            if (!this._$_p_renderercontextlost_handler$_) {
                this._$_p_renderercontextlost_handler$_ = () => this._$_onRendererContextLost$_(), 
                this._$_p_renderercontextrestored_handler$_ = () => this._$_onRendererContextRestored$_();
                const t = ph.get(this)._$GetRuntime$_()._$Dispatcher$_();
                t.addEventListener("renderercontextlost", this._$_p_renderercontextlost_handler$_), 
                t.addEventListener("renderercontextrestored", this._$_p_renderercontextrestored_handler$_);
            }
        }
        _$_onRendererContextLost$_() {}
        _$_onRendererContextRestored$_() {}
        _$_draw$_(t) {}
    };
}

{
    const gh = self._$C3$_, yh = gh._$New$_(gh.Rect), wh = new WeakMap(), Sh = gh._$_GetInternalAPIToken$_();
    self._$ISDKDOMInstanceBase$_ = class extends self._$ISDKWorldInstanceBase$_ {
        constructor(t) {
            if (!t?.domComponentId) throw new Error("no DOM component ID specified");
            super(t);
            const s = gh._$AddonManager$_._$_GetInitObject2$_(Sh), i = (wh.set(this, s), 
            this._$_p_elementId$_ = this._$plugin$_._$_addElement$_(this), this._$_p_isElementShowing$_ = !0, 
            this._$_p_elemHasFocus$_ = !1, this._$_p_autoFontSize$_ = !1, this._$_p_autoFontSizeOffset$_ = -.2, 
            this._$_p_lastRect$_ = gh._$New$_(gh.Rect, 0, 0, -1, -1), s._$GetRuntime$_()._$GetCanvasManager$_());
            this._$_p_lastWindowWidth$_ = i._$GetLastWidth$_(), this._$_p_lastWindowHeight$_ = i._$GetLastHeight$_(), 
            this._$_p_lastHTMLIndex$_ = -1, this._$_p_lastHTMLZIndex$_ = -1, this._$_p_isPendingUpdateState$_ = !1, 
            this._$_setTicking$_(!0);
        }
        _$_release$_() {
            super._$_release$_(), this._$plugin$_._$_removeElement$_(this._$_p_elementId$_), 
            this._$_postToDOMElement$_("destroy"), this._$_p_elementId$_ = -1, wh.delete(this);
        }
        _$_getElementInDOMMode$_() {
            const t = wh.get(this)._$GetRuntime$_();
            if (t._$IsInWorker$_()) throw new Error("not valid in worker mode");
            return this._$_postToDOMElementMaybeSync$_("get-element");
        }
        _$_postToDOMElement$_(t, s) {
            (s = s || {}).elementId = this._$_p_elementId$_, this._$_postToDOM$_(t, s);
        }
        _$_postToDOMElementMaybeSync$_(t, s) {
            return (s = s || {}).elementId = this._$_p_elementId$_, this._$_postToDOMMaybeSync$_(t, s);
        }
        _$_postToDOMElementAsync$_(t, s) {
            return (s = s || {}).elementId = this._$_p_elementId$_, this._$_postToDOMAsync$_(t, s);
        }
        _$_createElement$_(t) {
            t = t || {};
            const s = wh.get(this)._$GetWorldInfo$_();
            t.elementId = this._$_p_elementId$_, t.isVisible = s._$IsVisible$_(), 
            t.htmlIndex = s._$GetLayer$_()._$GetHTMLIndex$_(), t.htmlZIndex = s._$GetHTMLZIndex$_(), 
            Object.assign(t, this._$_getElementState$_()), this._$_p_isElementShowing$_ = !!t.isVisible, 
            this._$_postToDOMMaybeSync$_("create", t), this._$_updatePosition$_(!0);
        }
        _$setElementVisible$_(t) {
            this._$_p_isElementShowing$_ !== (t = !!t) && (this._$_p_isElementShowing$_ = t, 
            this._$_postToDOMElement$_("set-visible", {
                isVisible: t
            }));
        }
        _$_tick$_() {
            this._$_updatePosition$_(!1);
        }
        _$_shouldPreserveElement$_() {
            const t = wh.get(this)._$GetRuntime$_(), s = t._$GetCanvasManager$_()._$GetFullscreenMode$_();
            return "Android" === gh._$Platform$_._$OS$_ && ("scale-inner" === s || "scale-outer" === s || "crop" === s);
        }
        _$_updatePosition$_(u) {
            const c = wh.get(this);
            if (!c._$IsDestroyed$_()) {
                let t = c._$GetWorldInfo$_(), s = t._$GetLayer$_(), i = t._$GetBoundingBox$_(), [ e, h ] = s._$LayerToCanvasCss$_(i._$getLeft$_(), i._$getTop$_()), [ r, n ] = s._$LayerToCanvasCss$_(i._$getRight$_(), i._$getBottom$_()), o = c._$GetRuntime$_()._$GetCanvasManager$_(), a = o._$GetCssWidth$_(), l = o._$GetCssHeight$_();
                if (t._$IsVisible$_() && s._$IsVisible$_()) if (!this._$_shouldPreserveElement$_() && (r <= 0 || n <= 0 || a <= e || l <= h)) this._$setElementVisible$_(!1); else {
                    yh.set(e, h, r, n);
                    const f = o._$GetLastWidth$_(), d = o._$GetLastHeight$_(), p = s._$GetHTMLIndex$_(), m = t._$GetHTMLZIndex$_();
                    if (!u && yh.equals(this._$_p_lastRect$_) && this._$_p_lastWindowWidth$_ === f && this._$_p_lastWindowHeight$_ === d && this._$_p_lastHTMLIndex$_ === p && this._$_p_lastHTMLZIndex$_ === m) this._$setElementVisible$_(!0); else {
                        this._$_p_lastRect$_._$copy$_(yh), this._$_p_lastWindowWidth$_ = f, 
                        this._$_p_lastWindowHeight$_ = d, this._$_p_lastHTMLIndex$_ = p, 
                        this._$_p_lastHTMLZIndex$_ = m, this._$setElementVisible$_(!0);
                        let t = null;
                        this._$_p_autoFontSize$_ && (t = s._$GetDisplayScale$_() + this._$_p_autoFontSizeOffset$_), 
                        this._$_postToDOMElement$_("update-position", {
                            left: Math.round(this._$_p_lastRect$_._$getLeft$_()),
                            top: Math.round(this._$_p_lastRect$_._$getTop$_()),
                            width: Math.round(this._$_p_lastRect$_.width()),
                            height: Math.round(this._$_p_lastRect$_.height()),
                            htmlIndex: p,
                            htmlZIndex: m,
                            fontSize: t
                        });
                    }
                } else this._$setElementVisible$_(!1);
            }
        }
        _$focusElement$_() {
            this._$_postToDOMElementMaybeSync$_("focus", {
                focus: !0
            });
        }
        _$blurElement$_() {
            this._$_postToDOMElementMaybeSync$_("focus", {
                focus: !1
            });
        }
        _$_onElemFocused$_() {
            this._$_p_elemHasFocus$_ = !0;
        }
        _$_onElemBlurred$_() {
            this._$_p_elemHasFocus$_ = !1;
        }
        _$isElementFocused$_() {
            return this._$_p_elemHasFocus$_;
        }
        _$setElementCSSStyle$_(t, s) {
            this.postToDOMElement("set-css-style", {
                prop: gh._$CSSToCamelCase$_(t),
                val: s
            });
        }
        _$setElementAttribute$_(t, s) {
            this.postToDOMElement("set-attribute", {
                name: t,
                val: s
            });
        }
        _$removeElementAttribute$_(t) {
            this.postToDOMElement("remove-attribute", {
                name: t
            });
        }
        _$_updateElementState$_() {
            this._$_p_isPendingUpdateState$_ || (this._$_p_isPendingUpdateState$_ = !0, 
            Promise.resolve().then(() => {
                this._$_p_isPendingUpdateState$_ = !1, this._$_postToDOMElement$_("update-state", this._$_getElementState$_());
            }));
        }
        _$_getElementState$_() {}
        _$_getElementId$_() {
            return this._$_p_elementId$_;
        }
    };
}

self._$ISDKBehaviorBase$_ = class extends self._$IBehavior$_ {
    constructor() {
        super();
    }
};

self._$ISDKBehaviorTypeBase$_ = class extends globalThis._$IBehaviorType$_ {
    constructor() {
        super();
    }
    _$_onCreate$_() {}
};

{
    const bh = self._$C3$_, ar = new WeakMap(), lr = bh._$_GetInternalAPIToken$_();
    self._$ISDKBehaviorInstanceBase$_ = class extends self._$IBehaviorInstance$_ {
        constructor() {
            super(), ar.set(this, bh._$AddonManager$_._$_GetInitObject2$_(lr)), 
            this._$_p_isTicking$_ = !1, this._$_p_isTicking2$_ = !1, this._$_p_isPostTicking$_ = !1;
        }
        _$_release$_() {
            super._$_release$_(), this._$_setTicking$_(!1), this._$_setTicking2$_(!1), 
            this._$_setPostTicking$_(!1), ar.delete(this);
        }
        _$_getInitProperties$_() {
            return bh._$AddonManager$_._$_GetInitProperties$_();
        }
        _$_postCreate$_() {}
        _$_trigger$_(t) {
            const s = ar.get(this);
            s._$GetRuntime$_()._$Trigger$_(t, s._$GetObjectInstance$_(), s._$GetBehaviorType$_());
        }
        _$_triggerAsync$_(t) {
            const s = ar.get(this);
            return s._$GetRuntime$_()._$TriggerAsync$_(t, s._$GetObjectInstance$_(), s._$GetBehaviorType$_());
        }
        _$_setTicking$_(t) {
            if (this._$_p_isTicking$_ !== (t = !!t)) {
                this._$_p_isTicking$_ = t;
                const s = ar.get(this)._$GetRuntime$_();
                t ? s._$_AddBehInstToTick$_(this) : s._$_RemoveBehInstToTick$_(this);
            }
        }
        _$_isTicking$_() {
            return this._$_p_isTicking$_;
        }
        _$_tick$_() {}
        _$_setTicking2$_(t) {
            if (this._$_p_isTicking2$_ !== (t = !!t)) {
                this._$_p_isTicking2$_ = t;
                const s = ar.get(this)._$GetRuntime$_();
                t ? s._$_AddBehInstToTick2$_(this) : s._$_RemoveBehInstToTick2$_(this);
            }
        }
        _$_isTicking2$_() {
            return this._$_p_isTicking2$_;
        }
        _$_tick2$_() {}
        _$_setPostTicking$_(t) {
            if (this._$_p_isPostTicking$_ !== (t = !!t)) {
                this._$_p_isPostTicking$_ = t;
                const s = ar.get(this)._$GetRuntime$_();
                t ? s._$_AddBehInstToPostTick$_(this) : s._$_RemoveBehInstToPostTick$_(this);
            }
        }
        _$_isPostTicking$_() {
            return this._$_p_isPostTicking$_;
        }
        _$_postTick$_() {}
        _$_getDebuggerProperties$_() {
            return [];
        }
        _$_saveToJson$_() {
            return null;
        }
        _$_loadFromJson$_(t) {}
    };
}

{
    let e = self._$C3X$_, h = null;
    self._$ISDKUtils$_ = class {
        constructor(t) {
            h = t;
        }
        _$addLoadPromise$_(t) {
            h._$AddLoadPromise$_(t);
        }
        _$sendWrapperExtensionMessage$_(t, s, i) {
            e._$RequireString$_(t), e._$RequireString$_(s), e._$RequireOptionalArray$_(i), 
            h._$SendWrapperExtensionMessage$_(t, s, i);
        }
        _$sendWrapperExtensionMessageAsync$_(t, s, i) {
            return e._$RequireString$_(t), e._$RequireString$_(s), e._$RequireOptionalArray$_(i), 
            h._$SendWrapperExtensionMessageAsync$_(t, s, i);
        }
        _$createLoopingConditionContext$_(t) {
            return e._$RequireOptionalString$_(t), new self._$ILoopingConditionContext$_(h, t);
        }
        set _$isAutoSuspendEnabled$_(t) {
            h._$_SetAutoSuspendEnabled$_(!!t);
        }
        get _$isAutoSuspendEnabled$_() {
            return h._$_IsAutoSuspendEnabled$_();
        }
        _$setSuspended$_(t) {
            h._$SetSuspended$_(!!t);
        }
    };
}

{
    const ur = new WeakMap();
    self._$ILoopingConditionContext$_ = class {
        constructor(t, s) {
            const i = t._$GetEventSheetManager$_(), e = t._$GetCurrentEvent$_(), h = e._$GetSolModifiers$_(), r = t._$GetEventStack$_(), n = r._$GetCurrentStackFrame$_(), o = r._$Push$_(e), a = i._$GetLoopStack$_(), l = a._$Push$_();
            s && l._$SetName$_(s), t._$SetDebuggingEnabled$_(!1), ur.set(this, {
                runtime: t,
                _$currentEvent$_: e,
                _$solModifiers$_: h,
                _$oldFrame$_: n,
                _$newFrame$_: o,
                loop: l
            });
        }
        _$retrigger$_() {
            const {
                runtime: t,
                _$currentEvent$_: s,
                _$solModifiers$_: i,
                _$oldFrame$_: e,
                _$newFrame$_: h,
                loop: r
            } = ur.get(this), n = t._$GetEventSheetManager$_();
            n._$PushCopySol$_(i), s._$Retrigger$_(e, h), n._$PopSol$_(i), r._$SetIndex$_(r._$GetIndex$_() + 1);
        }
        get _$isStopped$_() {
            const t = ur.get(this).loop;
            return t._$IsStopped$_();
        }
        release() {
            const t = ur.get(this).runtime, s = t._$GetEventStack$_(), i = t._$GetEventSheetManager$_()._$GetLoopStack$_();
            t._$SetDebuggingEnabled$_(!0), i._$Pop$_(), s._$Pop$_(), ur.delete(this);
        }
    };
}

{
    let d = self._$C3$_, h = self._$C3X$_, p = null, r = null;
    self._$IRenderer$_ = class {
        constructor(t, s) {
            r = t, p = s;
        }
        _$setAlphaBlendMode$_() {
            p._$SetAlphaBlend$_();
        }
        _$setBlendMode$_(t) {
            p._$SetNamedBlendMode$_(t);
        }
        _$setColorFillMode$_() {
            p._$SetColorFillMode$_();
        }
        _$setTextureFillMode$_() {
            p._$SetTextureFillMode$_();
        }
        _$setSmoothLineFillMode$_() {
            p._$SetSmoothLineFillMode$_();
        }
        setColor(t) {
            p._$SetColorRgba$_(t[0], t[1], t[2], t[3]);
        }
        _$setColorRgba$_(t, s, i, e) {
            p._$SetColorRgba$_(t, s, i, e);
        }
        _$resetColor$_() {
            p._$ResetColor$_();
        }
        _$setOpacity$_(t) {
            p._$SetOpacity$_(t);
        }
        _$setCurrentZ$_(t) {
            p._$SetCurrentZ$_(t);
        }
        _$getCurrentZ$_() {
            p._$GetCurrentZ$_();
        }
        rect(t) {
            p._$Rect2$_(t.left, t.top, t.right, t.bottom);
        }
        _$rect2$_(t, s, i, e) {
            p._$Rect2$_(t, s, i, e);
        }
        _$quad$_(t) {
            p._$Quad$_(d._$Quad$_._$fromDOMQuad$_(t));
        }
        _$quad2$_(t, s, i, e, h, r, n, o) {
            p._$Quad2$_(t, s, i, e, h, r, n, o);
        }
        _$quad3$_(t, s) {
            p._$Quad3$_(d._$Quad$_._$fromDOMQuad$_(t), d.Rect._$fromDOMRect$_(s));
        }
        _$quad4$_(t, s) {
            p._$Quad4$_(d._$Quad$_._$fromDOMQuad$_(t), d._$Quad$_._$fromDOMQuad$_(s));
        }
        _$quad3D$_(t, s, i, e, h, r, n, o, a, l, u, c, f) {
            p._$Quad3D$_(t, s, i, e, h, r, n, o, a, l, u, c, d.Rect._$fromDOMRect$_(f));
        }
        _$quad3D2$_(t, s, i, e, h, r, n, o, a, l, u, c, f) {
            p._$Quad3D2$_(t, s, i, e, h, r, n, o, a, l, u, c, d._$Quad$_._$fromDOMQuad$_(f));
        }
        _$drawMesh$_(t, s, i) {
            p._$DrawMesh$_(t, s, i);
        }
        _$convexPoly$_(t) {
            p._$ConvexPoly$_(t);
        }
        line(t, s, i, e) {
            p._$Line$_(t, s, i, e);
        }
        _$texturedLine$_(t, s, i, e, h, r) {
            p._$TexturedLine$_(t, s, i, e, h, r);
        }
        _$lineRect$_(t, s, i, e) {
            p._$LineRect$_(t, s, i, e);
        }
        _$lineRect2$_(t) {
            p._$LineRect2$_(d.Rect._$fromDOMRect$_(t));
        }
        _$lineQuad$_(t) {
            p._$LineQuad$_(d._$Quad$_._$fromDOMQuad$_(t));
        }
        _$pushLineWidth$_(t) {
            p._$PushLineWidth$_(t);
        }
        _$popLineWidth$_() {
            p._$PopLineWidth$_();
        }
        _$pushLineCap$_(t) {
            p._$PushLineCap$_(t);
        }
        _$popLineCap$_() {
            p._$PopLineCap$_();
        }
        _$setTexture$_(t) {
            h._$RequireOptionalInstanceOf$_(t, self._$ITexture$_);
            const s = t ? r._$_UnwrapScriptInterface$_(t) : null;
            p._$SetTexture$_(s);
        }
        _$loadTextureForImageInfo$_(t, s) {
            const i = self._$IImageInfo$_._$_Unwrap$_(t);
            if (i) return i._$LoadStaticTexture$_(p, {
                _$wrapX$_: s?._$wrapX$_ ?? "clamp-to-edge",
                _$wrapY$_: s?._$wrapY$_ ?? "clamp-to-edge",
                _$sampling$_: s?._$sampling$_ ?? "trilinear",
                _$mipMap$_: s?._$mipMap$_ ?? !0
            });
            throw new Error("invalid IImageInfo");
        }
        _$releaseTextureForImageInfo$_(t) {
            const s = self._$IImageInfo$_._$_Unwrap$_(t);
            if (!s) throw new Error("invalid IImageInfo");
            s._$ReleaseTexture$_();
        }
        _$getTextureForImageInfo$_(t) {
            const s = self._$IImageInfo$_._$_Unwrap$_(t);
            if (!s) throw new Error("invalid IImageInfo");
            const i = s._$GetTexture$_();
            return self._$ITexture$_._$GetInterface$_(r, i);
        }
        _$createDynamicTexture$_(t, s, i) {
            h._$RequireFiniteNumber$_(t), h._$RequireFiniteNumber$_(s);
            const e = p._$CreateDynamicTexture$_(t, s, {
                _$wrapX$_: i?._$wrapX$_ ?? "clamp-to-edge",
                _$wrapY$_: i?._$wrapY$_ ?? "clamp-to-edge",
                _$sampling$_: i?._$sampling$_ ?? "trilinear",
                _$mipMap$_: i?._$mipMap$_ ?? !0
            });
            return self._$ITexture$_._$GetInterface$_(r, e);
        }
        _$updateTexture$_(t, s, i) {
            h._$RequireInstanceOf$_(s, self._$ITexture$_);
            const e = r._$_UnwrapScriptInterface$_(s);
            p._$UpdateTexture$_(t, e, {
                premultiplyAlpha: i?.premultiplyAlpha ?? !0
            });
        }
        deleteTexture(t) {
            h._$RequireInstanceOf$_(t, self._$ITexture$_);
            const s = r._$_UnwrapScriptInterface$_(t);
            p._$DeleteTexture$_(s);
        }
        _$createRendererText$_() {
            const t = p._$CreateRendererText$_();
            return new self._$IRendererText$_(r, t);
        }
        _$setDeviceTransform$_() {
            r._$GetCanvasManager$_()._$SetDeviceTransform$_(p);
        }
        _$setLayerTransform$_(t) {
            h._$RequireInstanceOf$_(t, globalThis._$ILayer$_);
            const s = r._$_UnwrapScriptInterface$_(t);
            s._$_SetTransform$_(p);
        }
    };
}

{
    const cr = new WeakMap(), fr = new WeakMap();
    self._$ITexture$_ = class {
        constructor(t, s) {
            cr.set(this, {
                runtime: t,
                _$texture$_: s
            }), fr.set(s, this), t._$_MapScriptInterface$_(this, s), Object.defineProperties(this, {
                width: {
                    value: s._$GetWidth$_(),
                    writable: !1
                },
                height: {
                    value: s._$GetHeight$_(),
                    writable: !1
                }
            });
        }
        static _$GetInterface$_(t, s) {
            if (!s) return null;
            const i = fr.get(s);
            return i || new self._$ITexture$_(t, s);
        }
    };
}

{
    let e = function(t) {
        return pr.get(t)._$rendererText$_;
    };
    e;
    const dr = self._$C3X$_, pr = new WeakMap();
    self._$IRendererText$_ = class {
        constructor(t, s) {
            pr.set(this, {
                runtime: t,
                _$rendererText$_: s
            }), t._$_MapScriptInterface$_(this, s);
        }
        release() {
            e(this)._$Release$_();
        }
        set _$fontFace$_(t) {
            dr._$RequireString$_(t), e(this)._$SetFontName$_(t);
        }
        get _$fontFace$_() {
            return e(this)._$GetFontName$_();
        }
        set _$sizePt$_(t) {
            dr._$RequireFiniteNumber$_(t), e(this)._$SetFontSize$_(t);
        }
        get _$sizePt$_() {
            return e(this)._$GetFontSize$_();
        }
        set lineHeight(t) {
            dr._$RequireFiniteNumber$_(t), e(this)._$SetLineHeight$_(t);
        }
        get lineHeight() {
            return e(this)._$GetLineHeight$_();
        }
        set _$isBold$_(t) {
            e(this)._$SetBold$_(t);
        }
        get _$isBold$_() {
            return e(this)._$IsBold$_();
        }
        set _$isItalic$_(t) {
            e(this)._$SetItalic$_(t);
        }
        get _$isItalic$_() {
            return e(this)._$IsItalic$_();
        }
        setColor(t) {
            dr._$RequireArray$_(t), this._$setColorRgb$_(t[0], t[1], t[2]);
        }
        _$setColorRgb$_(t, s, i) {
            e(this)._$SetColorRgb$_(t, s, i);
        }
        _$setCssColor$_(t) {
            dr._$RequireString$_(t), e(this)._$SetColor$_(t);
        }
        set _$horizontalAlign$_(t) {
            e(this)._$SetHorizontalAlignment$_(t);
        }
        get _$horizontalAlign$_() {
            return e(this)._$GetHorizontalAlignment$_();
        }
        set verticalAlign(t) {
            e(this)._$SetVerticalAlignment$_(t);
        }
        get verticalAlign() {
            return e(this)._$GetVerticalAlignment$_();
        }
        set _$wordWrapMode$_(t) {
            e(this)._$SetWordWrapMode$_(t);
        }
        get _$wordWrapMode$_() {
            return e(this)._$GetWordWrapMode$_();
        }
        set _$textDirection$_(t) {
            e(this)._$SetTextDirection$_(t);
        }
        get _$textDirection$_() {
            return e(this)._$GetTextDirection$_();
        }
        set text(t) {
            dr._$RequireString$_(t), e(this)._$SetText$_(t);
        }
        get text() {
            return e(this)._$GetText$_();
        }
        _$setSize$_(t, s, i) {
            dr._$RequireFiniteNumber$_(t), dr._$RequireFiniteNumber$_(s), dr._$RequireFiniteNumber$_(i), 
            e(this)._$SetSize$_(t, s, i);
        }
        _$getTexture$_() {
            const {
                runtime: t,
                _$rendererText$_: s
            } = pr.get(this), i = s._$GetTexture$_();
            return self._$ITexture$_._$GetInterface$_(t, i);
        }
        _$getTexRect$_() {
            return e(this)._$GetTexRect$_()._$toDOMRect$_();
        }
        _$setTextureUpdateCallback$_(t) {
            dr._$RequireFunction$_(t), e(this)._$ontextureupdate$_ = t;
        }
        _$releaseTexture$_() {
            e(this)._$ReleaseTexture$_();
        }
        get _$textWidth$_() {
            return e(this)._$GetTextWidth$_();
        }
        get _$textHeight$_() {
            return e(this)._$GetTextHeight$_();
        }
    };
}

{
    let e = function(t) {
        if (!t) return "";
        const s = t.split(".");
        if (s.length < 2) return "";
        const i = s.at(-1).toLowerCase();
        return gr.get(i) || "";
    }, r = function(e) {
        return new Promise((t, s) => {
            const i = document.createElement("script");
            i.onload = t, i.onerror = s, i.async = !1, i.type = "module", i.src = e, 
            document.head.appendChild(i);
        });
    };
    e, r;
    const g = self._$C3$_, mr = new Set([ "local", "remote" ]), gr = new Map([ [ "mp4", "video/mp4" ], [ "webm", "video/webm" ], [ "m4a", "audio/mp4" ], [ "mp3", "audio/mpeg" ], [ "js", "application/javascript" ], [ "wasm", "application/wasm" ], [ "svg", "image/svg+xml" ], [ "html", "text/html" ] ]);
    g._$AssetManager$_ = class extends g._$DefendedBase$_ {
        constructor(t, s) {
            super();
            const i = s.exportType, e = (this._$_runtime$_ = t, this._$_fileStructure$_ = "folders", 
            this._$_cordovaBlobUrlCache$_ = new Map(), this._$_isCordova$_ = "cordova" === i, 
            this._$_isiOSCordova$_ = !!s.isiOSCordova, this._$_isFileProtocol$_ = !!s.isFileProtocol, 
            this._$_swClientId$_ = s.swClientId, this._$_supportedAudioFormats$_ = s.supportedAudioFormats || {}, 
            this._$_audioFiles$_ = new Map(), this._$_preloadSounds$_ = !1, this._$_scriptSubfolder$_ = s.scriptFolder, 
            this._$_mediaSubfolder$_ = "", this._$_fontsSubfolder$_ = "", this._$_iconsSubfolder$_ = "", 
            this._$_fileMap$_ = s.fileMap || new Map(), this._$_fileMapBlobUrls$_ = new Map(), 
            "html5" === i || "scirra-arcade" === i || "instant-games" === i);
            this._$_defaultLoadPolicy$_ = e ? "remote" : "local", this._$_assetsByUrl$_ = new Map(), 
            this._$_webFonts$_ = [], this._$_loadPromises$_ = [], this._$_hasFinishedInitialLoad$_ = !1, 
            this._$_totalAssetSizeToLoad$_ = 0, this._$_assetSizeLoaded$_ = 0, this._$_lastLoadProgress$_ = 0, 
            this._$_hasHadErrorLoading$_ = !1, this._$_loadingRateLimiter$_ = g._$New$_(g._$RateLimiter$_, () => this._$_FireLoadingProgressEvent$_(), 50), 
            this._$_localPromiseThrottle$_ = g._$New$_(g._$PromiseThrottle$_, Math.max(g.hardwareConcurrency, 8)), 
            this._$_remotePromiseThrottle$_ = g._$New$_(g._$PromiseThrottle$_, 20), 
            this._$_iAssetManager$_ = new self._$IAssetManager$_(this);
        }
        _$Release$_() {
            for (const t of this._$_assetsByUrl$_.values()) t._$Release$_();
            this._$_assetsByUrl$_.clear(), g._$clearArray$_(this._$_loadPromises$_), 
            this._$_runtime$_ = null;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$_SetFileStructure$_(t) {
            this._$_fileStructure$_ = t;
        }
        _$GetFileStructure$_() {
            return this._$_fileStructure$_;
        }
        _$GetScriptSubfolder$_() {
            return this._$_scriptSubfolder$_;
        }
        _$_SetMediaSubfolder$_(t) {
            this._$_mediaSubfolder$_ = t;
        }
        _$GetMediaSubfolder$_() {
            return this._$_mediaSubfolder$_;
        }
        _$_SetFontsSubfolder$_(t) {
            this._$_fontsSubfolder$_ = t;
        }
        _$GetFontsSubfolder$_() {
            return this._$_fontsSubfolder$_;
        }
        _$_SetIconsSubfolder$_(t) {
            this._$_iconsSubfolder$_ = t;
        }
        _$GetIconsSubfolder$_() {
            return this._$_iconsSubfolder$_;
        }
        _$IsFileProtocol$_() {
            return this._$_isFileProtocol$_;
        }
        _$FetchBlob$_(t, s) {
            return s = s || this._$_defaultLoadPolicy$_, g._$IsRelativeURL$_(t) ? ("flat" === this._$_fileStructure$_ && (t = t.toLowerCase()), 
            this._$_isCordova$_ && this._$_isFileProtocol$_ ? this._$CordovaFetchLocalFileAsBlob$_(t) : "playable-ad-single-file" === this._$_runtime$_._$GetExportType$_() ? self.c3_runtimeInterface._PlayableAdFetchBlob(t) : ("local" === s ? this._$_localPromiseThrottle$_ : this._$_remotePromiseThrottle$_)._$Add$_(() => g._$FetchBlob$_(t))) : g._$FetchBlob$_(t);
        }
        _$FetchArrayBuffer$_(t) {
            return g._$IsRelativeURL$_(t) ? ("flat" === this._$_fileStructure$_ && (t = t.toLowerCase()), 
            this._$_isCordova$_ && this._$_isFileProtocol$_ ? this._$CordovaFetchLocalFileAsArrayBuffer$_(t) : "playable-ad-single-file" === this._$_runtime$_._$GetExportType$_() ? g._$BlobToArrayBuffer$_(self.c3_runtimeInterface._PlayableAdFetchBlob(t)) : ("local" === this._$_defaultLoadPolicy$_ ? this._$_localPromiseThrottle$_ : this._$_remotePromiseThrottle$_)._$Add$_(() => g._$FetchArrayBuffer$_(t))) : g._$FetchArrayBuffer$_(t);
        }
        _$FetchText$_(t) {
            return g._$IsRelativeURL$_(t) ? ("flat" === this._$_fileStructure$_ && (t = t.toLowerCase()), 
            this._$_isCordova$_ && this._$_isFileProtocol$_ ? this._$CordovaFetchLocalFileAsText$_(t) : "playable-ad-single-file" === this._$_runtime$_._$GetExportType$_() ? g._$BlobToString$_(self.c3_runtimeInterface._PlayableAdFetchBlob(t)) : ("local" === this._$_defaultLoadPolicy$_ ? this._$_localPromiseThrottle$_ : this._$_remotePromiseThrottle$_)._$Add$_(() => g._$FetchText$_(t))) : g._$FetchText$_(t);
        }
        async _$FetchJson$_(t) {
            const s = await this._$FetchText$_(t);
            return JSON.parse(s);
        }
        _$_CordovaFetchLocalFileAs$_(t, s) {
            return "flat" === this._$_fileStructure$_ && (t = t.toLowerCase()), 
            this._$_runtime$_._$PostComponentMessageToDOMAsync$_("runtime", "cordova-fetch-local-file", {
                filename: t,
                as: s
            });
        }
        _$CordovaFetchLocalFileAsText$_(t) {
            return this._$_CordovaFetchLocalFileAs$_(t, "text");
        }
        async _$CordovaFetchLocalFileAsBlob$_(t) {
            const s = await this._$_CordovaFetchLocalFileAs$_(t, "buffer"), i = e(t);
            return new Blob([ s ], {
                type: i
            });
        }
        async _$CordovaFetchLocalFileAsBlobURL$_(t) {
            "flat" === this._$_fileStructure$_ && (t = t.toLowerCase());
            let s = this._$_cordovaBlobUrlCache$_.get(t);
            if (!s) {
                const i = await this._$CordovaFetchLocalFileAsBlob$_(t);
                s = URL.createObjectURL(i), this._$_cordovaBlobUrlCache$_.set(t, s);
            }
            return s;
        }
        _$CordovaFetchLocalFileAsArrayBuffer$_(t) {
            return this._$_CordovaFetchLocalFileAs$_(t, "buffer");
        }
        _$GetMediaFileUrl$_(t) {
            "flat" === this._$_fileStructure$_ && (t = t.toLowerCase());
            let s = this._$_mediaSubfolder$_ + t;
            return s = "Gecko" === g._$Platform$_._$BrowserEngine$_ && "preview" === this._$_runtime$_._$GetExportType$_() ? this._$_GetLocalBlobURLFromFileMap$_(s) : s;
        }
        _$GetProjectFileUrl$_(t) {
            return g._$IsAbsoluteURL$_(t) ? Promise.resolve(t) : this._$_isCordova$_ && this._$_isFileProtocol$_ ? this._$CordovaFetchLocalFileAsBlobURL$_(t) : "playable-ad-single-file" === this._$_runtime$_._$GetExportType$_() ? URL.createObjectURL(self.c3_runtimeInterface._PlayableAdFetchBlob(t)) : ("flat" === this._$_fileStructure$_ && (t = t.toLowerCase()), 
            Promise.resolve(t));
        }
        _$GetProjectFileIframeUrl$_(s) {
            if (g._$IsAbsoluteURL$_(s) || "preview" !== this._$_runtime$_._$GetExportType$_() || !this._$_swClientId$_ || !s) return s;
            try {
                const t = new URL(s, location.href);
                return t.searchParams.set("__c3_client_id", this._$_swClientId$_), 
                t.toString();
            } catch (t) {
                return console.warn("Invalid iframe URL: " + s), s;
            }
        }
        _$LoadProjectFileUrl$_(t) {
            return this._$GetProjectFileUrl$_(t);
        }
        _$LoadImage$_(t) {
            if (t._$loadPolicy$_ && !mr.has(t._$loadPolicy$_)) throw new Error("invalid load policy");
            let s = this._$_assetsByUrl$_.get(t.url);
            return s || (s = g._$New$_(g._$ImageAsset$_, this, {
                url: t.url,
                size: t.size || 0,
                _$loadPolicy$_: t._$loadPolicy$_ || this._$_defaultLoadPolicy$_
            }), this._$_assetsByUrl$_.set(s._$GetURL$_(), s), this._$_hasFinishedInitialLoad$_) || (this._$_totalAssetSizeToLoad$_ += s._$GetSize$_(), 
            this._$_loadPromises$_.push(s._$Load$_().then(() => this._$_AddLoadedSize$_(s._$GetSize$_())))), 
            s;
        }
        _$_ReleaseAsset$_(t) {
            this._$_assetsByUrl$_.delete(t._$GetURL$_());
        }
        async _$WaitForAllToLoad$_() {
            try {
                await Promise.all(this._$_loadPromises$_), this._$_lastLoadProgress$_ = 1;
            } catch (t) {
                console.error("Error loading: ", t), this._$_hasHadErrorLoading$_ = !0, 
                this._$_FireLoadingProgressEvent$_();
            }
        }
        _$SetInitialLoadFinished$_() {
            this._$_hasFinishedInitialLoad$_ = !0;
        }
        _$HasHadErrorLoading$_() {
            return this._$_hasHadErrorLoading$_;
        }
        _$_AddLoadedSize$_(t) {
            this._$_assetSizeLoaded$_ += t, this._$_loadingRateLimiter$_._$Call$_();
        }
        _$_FireLoadingProgressEvent$_() {
            const t = g._$New$_(g.Event, "loadingprogress");
            this._$_lastLoadProgress$_ = g._$clamp$_(this._$_assetSizeLoaded$_ / this._$_totalAssetSizeToLoad$_, 0, 1), 
            t.progress = this._$_lastLoadProgress$_, this._$_runtime$_._$Dispatcher$_().dispatchEvent(t);
        }
        _$GetLoadProgress$_() {
            return this._$_lastLoadProgress$_;
        }
        _$_SetWebFonts$_(t) {
            g._$shallowAssignArray$_(this._$_webFonts$_, t), this._$_webFonts$_.length && this._$_loadPromises$_.push(this._$_LoadWebFonts$_());
        }
        async _$_LoadWebFonts$_() {
            const t = [], s = [];
            for (const [ i, e, h ] of this._$_webFonts$_) this._$_totalAssetSizeToLoad$_ += h, 
            t.push(this._$_LoadWebFont$_(i, e, s).then(() => this._$_AddLoadedSize$_(h)));
            await Promise.all(t), this._$_runtime$_._$IsInWorker$_() && 0 < s.length && await this._$_runtime$_._$PostComponentMessageToDOMAsync$_("runtime", "load-webfonts", {
                webfonts: s
            });
        }
        async _$_LoadWebFont$_(s, i, e) {
            try {
                let t = await this._$GetProjectFileUrl$_(i);
                "Gecko" === g._$Platform$_._$BrowserEngine$_ && (s = `'${s}'`), 
                ("Gecko" === g._$Platform$_._$BrowserEngine$_ && "preview" === this._$_runtime$_._$GetExportType$_() || "playable-ad-single-file" === this._$_runtime$_._$GetExportType$_()) && (t = this._$_GetLocalBlobURLFromFileMap$_(t));
                const h = new FontFace(s, `url('${t}')`);
                (this._$_runtime$_._$IsInWorker$_() ? self : document).fonts.add(h), 
                await h.load(), this._$_runtime$_._$IsInWorker$_() && e.push({
                    name: s,
                    url: t
                });
            } catch (t) {
                console.warn(`[C3 runtime] Failed to load web font '${s}': `, t);
            }
        }
        _$IsAudioFormatSupported$_(t) {
            return !!this._$_supportedAudioFormats$_[t];
        }
        _$_SetAudioFiles$_(t, s) {
            this._$_preloadSounds$_ = !!s;
            for (const [ i, e, h ] of t) this._$_audioFiles$_.set(i, {
                fileName: i,
                _$formats$_: e.map(t => ({
                    type: t[0],
                    _$fileExtension$_: t[1],
                    _$fullName$_: i + t[1],
                    fileSize: t[2]
                })),
                isMusic: h
            });
        }
        _$GetPreferredAudioFile$_(t) {
            "flat" === this._$_fileStructure$_ && (t = t.toLowerCase());
            const s = this._$_audioFiles$_.get(t);
            if (!s) return null;
            let i = null;
            for (const e of s._$formats$_) if (i || "audio/webm; codecs=opus" !== e.type || (i = e), 
            this._$IsAudioFormatSupported$_(e.type)) return e;
            return i;
        }
        _$GetProjectAudioFileUrl$_(t) {
            const s = this._$GetPreferredAudioFile$_(t);
            return s ? {
                url: this._$GetMediaFileUrl$_(s._$fullName$_),
                type: s.type
            } : null;
        }
        _$GetAudioToPreload$_() {
            if (this._$_preloadSounds$_) {
                const t = [];
                for (const s of this._$_audioFiles$_.values()) if (!s.isMusic) {
                    const i = this._$GetPreferredAudioFile$_(s.fileName);
                    i && t.push({
                        originalUrl: s.fileName,
                        url: this._$GetMediaFileUrl$_(i._$fullName$_),
                        type: i.type,
                        fileSize: i.fileSize
                    });
                }
                return t;
            }
            return [];
        }
        _$_GetLocalBlobFromFileMap$_(t) {
            return "preview" === this._$_runtime$_._$GetExportType$_() && (t = new URL(t, location.href).toString()), 
            this._$_fileMap$_.get(t) || null;
        }
        _$_GetLocalBlobURLFromFileMap$_(t) {
            let s = this._$_fileMapBlobUrls$_.get(t);
            if (!s) {
                const i = this._$_GetLocalBlobFromFileMap$_(t);
                if (!i) return t;
                s = URL.createObjectURL(i), this._$_fileMapBlobUrls$_.set(t, s);
            }
            return s;
        }
        _$GetIAssetManager$_() {
            return this._$_iAssetManager$_;
        }
        async _$LoadScripts$_(...t) {
            const s = await Promise.all(t.map(t => this._$GetProjectFileUrl$_(t)));
            if (this._$_runtime$_._$IsInWorker$_()) if (1 === t.length) {
                const i = t[0];
                await self.c3_import((g._$IsRelativeURL$_(i) ? "./" : "") + i);
            } else {
                const e = t.map(t => `import "${g._$IsRelativeURL$_(t) ? "./" : ""}${t}";`).join("\n"), h = URL.createObjectURL(new Blob([ e ], {
                    type: "application/javascript"
                }));
                await self.c3_import(h);
            } else await Promise.all(s.map(t => r(t)));
        }
        async _$CompileWebAssembly$_(t) {
            if (WebAssembly.compileStreaming) {
                const s = await this._$GetProjectFileUrl$_(t);
                return WebAssembly.compileStreaming(fetch(s));
            }
            {
                const i = await g._$FetchArrayBuffer$_(t);
                return WebAssembly.compile(i);
            }
        }
        async _$LoadStyleSheet$_(t) {
            const s = await this._$GetProjectFileUrl$_(t);
            return this._$_runtime$_._$PostComponentMessageToDOMAsync$_("runtime", "add-stylesheet", {
                url: s
            });
        }
    };
}

{
    const yr = self._$C3$_;
    yr._$Asset$_ = class extends yr._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_assetManager$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), 
            this._$_url$_ = s.url || "", this._$_size$_ = s.size, this._$_loadPolicy$_ = s._$loadPolicy$_, 
            this._$_blob$_ = s.blob || null, this._$_isLoaded$_ = !!this._$_blob$_, 
            this._$_loadPromise$_ = null;
        }
        _$Release$_() {
            this._$_loadPromise$_ = null, this._$_assetManager$_ = null, this._$_runtime$_ = null, 
            this._$_blob$_ = null;
        }
        _$GetURL$_() {
            return this._$_url$_;
        }
        _$GetSize$_() {
            return this._$_size$_;
        }
        _$Load$_() {
            return "local" === this._$_loadPolicy$_ || this._$_blob$_ ? (this._$_isLoaded$_ = !0, 
            Promise.resolve()) : (this._$_loadPromise$_ || (this._$_loadPromise$_ = this._$_assetManager$_._$FetchBlob$_(this._$_url$_, this._$_loadPolicy$_).then(t => (this._$_isLoaded$_ = !0, 
            this._$_loadPromise$_ = null, this._$_blob$_ = t)).catch(t => {
                console.error("Error loading resource: ", t), this._$_loadPromise$_ = null;
            })), this._$_loadPromise$_);
        }
        _$IsLoaded$_() {
            return this._$_isLoaded$_;
        }
        _$GetBlob$_() {
            return this._$_blob$_ ? Promise.resolve(this._$_blob$_) : this._$_loadPromise$_ || this._$_assetManager$_._$FetchBlob$_(this._$_url$_, this._$_loadPolicy$_);
        }
    };
}

{
    const wr = self._$C3$_, Sr = new wr._$PromiseThrottle$_(), br = new Set();
    wr._$ImageAsset$_ = class extends wr._$Asset$_ {
        constructor(t, s) {
            super(t, s), this._$_texturePromise$_ = null, this._$_webglTexture$_ = null, 
            this._$_refCount$_ = 0, this._$_imageWidth$_ = -1, this._$_imageHeight$_ = -1, 
            br.add(this);
        }
        _$Release$_() {
            if (0 !== this._$_refCount$_) throw new Error("released image asset which still has texture references");
            this._$_assetManager$_._$_ReleaseAsset$_(this), this._$_texturePromise$_ = null, 
            br.delete(this), super._$Release$_();
        }
        static _$OnRendererContextLost$_() {
            for (const t of br) t._$_texturePromise$_ = null, t._$_webglTexture$_ = null, 
            t._$_refCount$_ = 0;
        }
        _$LoadStaticTexture$_(t, s) {
            return s = s || {}, this._$_refCount$_++, this._$_webglTexture$_ ? Promise.resolve(this._$_webglTexture$_) : (this._$_texturePromise$_ || (s._$anisotropy$_ = this._$_runtime$_._$GetCanvasManager$_()._$GetTextureAnisotropy$_(), 
            this._$_texturePromise$_ = this._$_DoLoadStaticTexture$_(t, s)), this._$_texturePromise$_);
        }
        async _$_DoLoadStaticTexture$_(s, i) {
            try {
                const e = await this._$GetBlob$_();
                return 0 === this._$_refCount$_ ? this._$_texturePromise$_ = null : await Sr._$Add$_(async () => {
                    const t = await s._$CreateStaticTextureAsync$_(e, i);
                    return this._$_texturePromise$_ = null, 0 === this._$_refCount$_ ? (s._$DeleteTexture$_(t), 
                    null) : (this._$_webglTexture$_ = t, this._$_imageWidth$_ = t._$GetWidth$_(), 
                    this._$_imageHeight$_ = t._$GetHeight$_(), this._$_webglTexture$_);
                });
            } catch (t) {
                throw console.error("Failed to load texture: ", t), t;
            }
        }
        _$ReleaseTexture$_() {
            if (this._$_refCount$_ <= 0) throw new Error("texture released too many times");
            if (this._$_refCount$_--, 0 === this._$_refCount$_ && this._$_webglTexture$_) {
                const t = this._$_webglTexture$_._$GetRenderer$_();
                t._$DeleteTexture$_(this._$_webglTexture$_), this._$_webglTexture$_ = null;
            }
        }
        _$GetRefCount$_() {
            return this._$_refCount$_;
        }
        _$GetTexture$_() {
            return this._$_webglTexture$_;
        }
        _$GetWidth$_() {
            return this._$_imageWidth$_;
        }
        _$GetHeight$_() {
            return this._$_imageHeight$_;
        }
        async _$LoadToDrawable$_() {
            const t = await this._$GetBlob$_();
            return wr._$Supports$_.ImageBitmap ? createImageBitmap(t) : wr._$BlobToImage$_(t);
        }
    };
}

{
    let t = function(t, s) {
        return t._$GetWorldInfo$_()._$_GetLastCachedZIndex$_() - s._$GetWorldInfo$_()._$_GetLastCachedZIndex$_();
    };
    t;
    const Mr = self._$C3$_;
    Mr._$RenderCell$_ = class extends Mr._$DefendedBase$_ {
        constructor(t, s, i) {
            super(), this._$_grid$_ = t, this._$_x$_ = s, this._$_y$_ = i, this._$_instances$_ = [], 
            this._$_isSorted$_ = !0, this._$_pendingRemoval$_ = new Set(), this._$_isAnyPendingRemoval$_ = !1;
        }
        _$Release$_() {
            Mr._$clearArray$_(this._$_instances$_), this._$_pendingRemoval$_.clear(), 
            this._$_grid$_ = null;
        }
        _$Reset$_() {
            Mr._$clearArray$_(this._$_instances$_), this._$_isSorted$_ = !0, this._$_pendingRemoval$_.clear(), 
            this._$_isAnyPendingRemoval$_ = !1;
        }
        _$SetChanged$_() {
            this._$_isSorted$_ = !1;
        }
        _$IsEmpty$_() {
            if (this._$_instances$_.length) {
                if (this._$_instances$_.length > this._$_pendingRemoval$_.size) return !1;
                this._$_FlushPending$_();
            }
            return !0;
        }
        _$Insert$_(t) {
            this._$_pendingRemoval$_.has(t) ? (this._$_pendingRemoval$_.delete(t), 
            0 === this._$_pendingRemoval$_.size && (this._$_isAnyPendingRemoval$_ = !1)) : (this._$_instances$_.push(t), 
            this._$_isSorted$_ = 1 === this._$_instances$_.length);
        }
        _$Remove$_(t) {
            this._$_pendingRemoval$_.add(t), this._$_isAnyPendingRemoval$_ = !0, 
            50 <= this._$_pendingRemoval$_.size && this._$_FlushPending$_();
        }
        _$_FlushPending$_() {
            this._$_isAnyPendingRemoval$_ && (this._$_instances$_.length === this._$_pendingRemoval$_.size ? this._$Reset$_() : (Mr._$arrayRemoveAllInSet$_(this._$_instances$_, this._$_pendingRemoval$_), 
            this._$_pendingRemoval$_.clear(), this._$_isAnyPendingRemoval$_ = !1));
        }
        _$_EnsureSorted$_() {
            this._$_isSorted$_ || (this._$_instances$_.sort(t), this._$_isSorted$_ = !0);
        }
        _$Dump$_(t) {
            this._$_FlushPending$_(), this._$_EnsureSorted$_(), this._$_instances$_.length && t.push(this._$_instances$_);
        }
    };
}

{
    const vr = self._$C3$_;
    vr._$RenderGrid$_ = class extends vr._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_cellWidth$_ = t, this._$_cellHeight$_ = s, this._$_cells$_ = vr._$New$_(vr._$PairMap$_);
        }
        _$Release$_() {
            this._$_cells$_._$Release$_(), this._$_cells$_ = null;
        }
        _$GetCell$_(t, s, i) {
            let e = this._$_cells$_._$Get$_(t, s);
            return e || (i ? (e = vr._$New$_(vr._$RenderCell$_, this, t, s), this._$_cells$_.Set(t, s, e), 
            e) : null);
        }
        _$XToCell$_(t) {
            return Math.floor(t / this._$_cellWidth$_);
        }
        _$YToCell$_(t) {
            return Math.floor(t / this._$_cellHeight$_);
        }
        _$Update$_(e, h, r) {
            if (h) for (let i = h._$getLeft$_(), t = h._$getRight$_(); i <= t; ++i) for (let t = h._$getTop$_(), s = h._$getBottom$_(); t <= s; ++t) if (!r || !r._$containsPoint$_(i, t)) {
                const n = this._$GetCell$_(i, t, !1);
                n && (n._$Remove$_(e), n._$IsEmpty$_()) && this._$_cells$_._$Delete$_(i, t);
            }
            if (r) for (let i = r._$getLeft$_(), t = r._$getRight$_(); i <= t; ++i) for (let t = r._$getTop$_(), s = r._$getBottom$_(); t <= s; ++t) h && h._$containsPoint$_(i, t) || this._$GetCell$_(i, t, !0)._$Insert$_(e);
        }
        _$QueryRange$_(t, s) {
            let i = this._$XToCell$_(t._$getLeft$_()), e = this._$YToCell$_(t._$getTop$_()), h = this._$XToCell$_(t._$getRight$_()), r = this._$YToCell$_(t._$getBottom$_());
            for (;i <= h; ++i) for (let t = e; t <= r; ++t) {
                const n = this._$GetCell$_(i, t, !1);
                n && n._$Dump$_(s);
            }
        }
        _$MarkRangeChanged$_(t) {
            let s = t._$getLeft$_(), i = t._$getTop$_(), e = t._$getRight$_(), h = t._$getBottom$_();
            for (;s <= e; ++s) for (let t = i; t <= h; ++t) {
                const r = this._$GetCell$_(s, t, !1);
                r && r._$SetChanged$_();
            }
        }
    };
}

{
    let n = function(t, s) {
        return t._$GetWorldInfo$_()._$_GetLastCachedZIndex$_() - s._$GetWorldInfo$_()._$_GetLastCachedZIndex$_();
    }, t = function(t, s) {
        return t._$GetWorldInfo$_()._$GetZElevation$_() - s._$GetWorldInfo$_()._$GetZElevation$_();
    };
    n, t;
    const S = self._$C3$_, xr = new S.Rect(), Gr = new S._$Quad$_(), Tr = [], _r = (new S.Rect(), 
    new S.Rect(), self._$glMatrix$_), Gh = _r._$vec3$_, Vh = _r._$vec4$_, xh = _r._$mat4$_, Ir = xh.create(), Cr = Gh.create(), Rr = Vh.create(), Pr = Gh.create(), Er = Gh.create(), Ar = Gh.create(), Fr = S._$New$_(S._$Vector2$_), Or = (S._$New$_(S.Rect), 
    []), Dr = [], kr = [], Lr = {
        name: "",
        sid: -1,
        _$isDynamic$_: !1,
        isVisible: !0,
        _$isInteractive$_: !0,
        _$isHTMLElementsLayer$_: !1,
        backgroundColor: [ 1, 1, 1, 1 ],
        _$isTransparent$_: !0,
        _$parallax$_: [ 1, 1 ],
        opacity: 1,
        _$isForceOwnTexture$_: !1,
        _$renderAs3d$_: !1,
        _$useCameraDistanceDrawOrder$_: !1,
        _$useRenderCells$_: !1,
        scaleRate: 1,
        _$blendMode$_: 0,
        _$zElevation$_: 0,
        _$initialInstancesData$_: [],
        _$effectListData$_: [],
        _$subLayersData$_: []
    };
    S._$Layer$_ = class extends S._$DefendedBase$_ {
        constructor(t, s, i) {
            super(), i = Object.assign({}, Lr, i), this._$_layout$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), 
            this._$_parentLayer$_ = s, this._$_name$_ = i.name, this._$_index$_ = -1, 
            this._$_isHTMLElementsLayer$_ = !!i._$isHTMLElementsLayer$_, this._$_htmlIndex$_ = -1, 
            this._$_sid$_ = i.sid, this._$_isDynamic$_ = !!i._$isDynamic$_, this._$_isVisible$_ = !!i.isVisible, 
            this._$_isInteractive$_ = !!i._$isInteractive$_, this._$_backgroundColor$_ = S._$New$_(S._$Color$_), 
            this._$_backgroundColor$_._$setFromJSON$_(i.backgroundColor), this._$_isTransparent$_ = !!i._$isTransparent$_, 
            this._$_parallaxX$_ = i._$parallax$_[0], this._$_parallaxY$_ = i._$parallax$_[1], 
            this._$_color$_ = S._$New$_(S._$Color$_, 1, 1, 1, i.opacity), this._$_premultipliedColor$_ = S._$New$_(S._$Color$_), 
            this._$_isForceOwnTexture$_ = !!i._$isForceOwnTexture$_, this._$_renderAs3d$_ = !!i._$renderAs3d$_, 
            this._$_useCameraDistanceDrawOrder$_ = !!i._$useCameraDistanceDrawOrder$_, 
            this._$_useRenderCells$_ = !!i._$useRenderCells$_, this._$_scaleRate$_ = i.scaleRate, 
            this._$_blendMode$_ = i._$blendMode$_, this._$_curRenderTarget$_ = null, 
            this._$_scale$_ = 1, this._$_zElevation$_ = i._$zElevation$_, this._$_angle$_ = 0, 
            this._$_scrollX$_ = 0, this._$_scrollY$_ = 0, this._$_hasOwnScrollPosition$_ = !1, 
            this._$_viewport$_ = S._$New$_(S.Rect), this._$_viewportZ0$_ = S._$New$_(S.Rect), 
            this._$_viewport3D$_ = S._$New$_(S.Rect), this._$_isViewportChanged$_ = !0, 
            this._$_projectionMatrix$_ = xh.create(), this._$_isProjectionMatrixChanged$_ = !0, 
            this._$_modelViewMatrix$_ = xh.create(), this._$_isMVMatrixChanged$_ = !0, 
            this._$_viewFrustum$_ = S._$New$_(S._$Gfx$_._$ViewFrustum$_), this._$_isViewFrustumChanged$_ = !0, 
            this._$_startupInitialInstances$_ = [], this._$_initialInstancesData$_ = i._$initialInstancesData$_, 
            this._$_initialInstances$_ = [], this._$_createdGlobalUids$_ = [], this._$_initialUIDsToInstanceData$_ = new Map(), 
            this._$_instances$_ = [], this._$_zIndicesUpToDate$_ = !1, this._$_htmlZIndicesUpToDate$_ = !1, 
            this._$_anyInstanceZElevated$_ = !1;
            const h = this._$_runtime$_._$GetCanvasManager$_();
            this._$_effectList$_ = S._$New$_(S._$EffectList$_, this, i._$effectListData$_), 
            this._$_effectChain$_ = S._$New$_(S._$Gfx$_._$EffectChain$_, h._$GetEffectChainManager$_(), {
                _$drawContent$_: (t, s) => {
                    const i = s._$GetContentObject$_(), e = i._$GetRenderTarget$_();
                    t._$SetColor$_(i._$GetPremultipliedColor$_()), t._$DrawRenderTarget$_(e), 
                    t._$InvalidateRenderTarget$_(e), h._$ReleaseAdditionalRenderTarget$_(e);
                },
                _$getShaderParameters$_: t => this._$GetEffectList$_()._$_GetEffectChainShaderParametersForIndex$_(t)
            }), this._$_needsRebuildEffectChainSteps$_ = !0, this._$_wasDefaultColor$_ = !0, 
            this._$_renderGrid$_ = null, this._$_lastRenderList$_ = [], this._$_isRenderListUpToDate$_ = !1, 
            this._$_lastRenderCells$_ = S._$New$_(S.Rect, 0, 0, -1, -1), this._$_curRenderCells$_ = S._$New$_(S.Rect, 0, 0, -1, -1), 
            this._$_iLayer$_ = new self._$ILayer$_(this), this._$_UpdatePremultipliedColor$_(), 
            this._$UsesRenderCells$_() && (this._$_renderGrid$_ = S._$New$_(S._$RenderGrid$_, this._$_runtime$_._$GetOriginalViewportWidth$_(), this._$_runtime$_._$GetOriginalViewportHeight$_())), 
            this._$_subLayers$_ = i._$subLayersData$_.map(t => S._$Layer$_._$CreateFromExportData$_(this._$_layout$_, this, t));
        }
        _$_InitInitialInstances$_() {
            for (const t of this._$_initialInstancesData$_) {
                const s = this._$_runtime$_._$GetObjectClassByIndex$_(t[1]);
                this._$_layout$_._$_AddInitialObjectClass$_(s), s._$GetDefaultInstanceData$_() || (s._$SetDefaultInstanceData$_(t), 
                s._$_SetDefaultLayerIndex$_(this._$_index$_)), this._$_initialInstances$_.push(t), 
                this._$_initialUIDsToInstanceData$_.set(t[2], t);
            }
            S._$shallowAssignArray$_(this._$_startupInitialInstances$_, this._$_initialInstances$_), 
            this._$_initialInstancesData$_ = null;
        }
        static _$CreateFromExportData$_(t, s, i) {
            return S._$New$_(S._$Layer$_, t, s, {
                name: i[0],
                sid: i[2],
                isVisible: i[3],
                _$isInteractive$_: i[13],
                _$isHTMLElementsLayer$_: i[19],
                backgroundColor: i[4].map(t => t / 255),
                _$isTransparent$_: i[5],
                _$parallax$_: [ i[6], i[7] ],
                opacity: i[8],
                _$isForceOwnTexture$_: i[9],
                _$renderAs3d$_: i[17],
                _$useCameraDistanceDrawOrder$_: i[18],
                _$useRenderCells$_: i[10],
                scaleRate: i[11],
                _$blendMode$_: i[12],
                _$zElevation$_: i[16],
                _$initialInstancesData$_: i[14],
                _$effectListData$_: i[15],
                _$subLayersData$_: i[20]
            });
        }
        _$Release$_() {
            for (const t of this._$_subLayers$_) t._$Release$_();
            S._$clearArray$_(this._$_subLayers$_);
            for (const s of this._$_instances$_) this._$_runtime$_._$DestroyInstance$_(s);
            S._$clearArray$_(this._$_instances$_), this._$_effectList$_._$Release$_(), 
            this._$_effectList$_ = null, this._$_effectChain$_._$Release$_(), this._$_effectChain$_ = null, 
            this._$_iLayer$_ = null, this._$_parentLayer$_ = null, this._$_layout$_ = null, 
            this._$_runtime$_ = null;
        }
        _$GetInitialInstanceData$_(t) {
            return this._$_initialUIDsToInstanceData$_.get(t);
        }
        _$CreateInitialInstances$_(h) {
            let r = this._$_layout$_._$IsFirstVisit$_(), n = 0, o = this._$_initialInstances$_;
            for (let e = 0, t = o.length; e < t; ++e) {
                let t = o[e], s = this._$_runtime$_._$GetObjectClassByIndex$_(t[1]), i = !0;
                if (!s._$HasPersistBehavior$_() || r) {
                    const a = this._$_runtime$_._$CreateInstanceFromData$_(t, this, !0);
                    h.push(a), s._$IsGlobal$_() && (i = !1, this._$_createdGlobalUids$_.push(a._$GetUID$_()));
                }
                i && (o[n] = o[e], ++n);
            }
            S._$truncateArray$_(o, n), this._$_runtime$_._$FlushPendingInstances$_(), 
            this._$SetZIndicesChanged$_();
        }
        _$_AddInstance$_(t, s) {
            if (!t._$GetPlugin$_()._$IsWorldType$_()) throw new Error("instance is not of world type");
            const i = t._$GetWorldInfo$_();
            if (i._$GetLayer$_() !== this) throw new Error("instance added to wrong layer");
            this._$_instances$_.push(t), 0 !== i._$GetZElevation$_() && (this._$_anyInstanceZElevated$_ = !0), 
            s && this._$UsesRenderCells$_() && t._$GetWorldInfo$_()._$SetBboxChanged$_(), 
            this._$SetZIndicesChanged$_(t);
        }
        _$_MaybeAddInstance$_(t) {
            this._$_instances$_.includes(t) || (this._$_instances$_.push(t), 0 !== t._$GetWorldInfo$_()._$GetZElevation$_() && (this._$_anyInstanceZElevated$_ = !0), 
            this._$SetZIndicesChanged$_(t));
        }
        _$_PrependInstance$_(t, s) {
            const i = t._$GetWorldInfo$_();
            if (i._$GetLayer$_() !== this) throw new Error("instance added to wrong layer");
            this._$_instances$_.unshift(t), 0 !== i._$GetZElevation$_() && (this._$_anyInstanceZElevated$_ = !0), 
            this._$SetZIndicesChanged$_(t), s && this._$UsesRenderCells$_() && t._$GetWorldInfo$_()._$SetBboxChanged$_();
        }
        _$_RemoveInstance$_(t, s) {
            const i = this._$_instances$_.indexOf(t);
            i < 0 || (s && this._$UsesRenderCells$_() && t._$GetWorldInfo$_()._$_RemoveFromRenderCells$_(), 
            this._$_instances$_.splice(i, 1), this._$SetZIndicesChanged$_(t), this._$_MaybeResetAnyInstanceZElevatedFlag$_());
        }
        _$_SetAnyInstanceZElevated$_() {
            this._$_anyInstanceZElevated$_ = !0;
        }
        _$_MaybeResetAnyInstanceZElevatedFlag$_() {
            0 === this._$_instances$_.length && (this._$_anyInstanceZElevated$_ = !1);
        }
        _$_SortInstancesByLastCachedZIndex$_(t) {
            if (t) {
                const s = new Set();
                for (const i of this._$_instances$_) {
                    const e = i._$GetWorldInfo$_()._$_GetLastCachedZIndex$_();
                    0 <= e && s.add(e);
                }
                let t = -1;
                for (const h of this._$_instances$_) {
                    const r = h._$GetWorldInfo$_();
                    if (!(0 <= r._$_GetLastCachedZIndex$_())) {
                        for (++t; s.has(t); ) ++t;
                        r._$_SetZIndex$_(t);
                    }
                }
            }
            this._$_instances$_.sort(n);
        }
        _$_Start$_() {}
        _$_End$_() {
            for (const t of this._$_instances$_) t._$GetObjectClass$_()._$IsGlobal$_() || this._$_runtime$_._$DestroyInstance$_(t);
            this._$_runtime$_._$FlushPendingInstances$_(), S._$clearArray$_(this._$_instances$_), 
            this._$_anyInstanceZElevated$_ = !1, this._$SetZIndicesChanged$_();
        }
        _$RecreateInitialObjects$_(s, t, i, e, h, r) {
            const n = this._$_runtime$_._$GetEventSheetManager$_(), o = this._$_runtime$_._$GetAllObjectClasses$_(), a = s._$IsFamily$_(), l = [];
            for (const u of this._$_initialInstances$_) {
                const c = u[0], f = c[0], d = c[1];
                if (t._$containsPoint$_(f, d)) {
                    const p = o[u[1]];
                    if (p !== s) {
                        if (!a) continue;
                        if (!s._$FamilyHasMember$_(p)) continue;
                    }
                    let t = h;
                    if (!t) {
                        const y = this._$_runtime$_._$GetCurrentLayout$_();
                        t = this._$GetLayout$_() === y ? this : (t = y._$GetLayerByName$_(this._$GetName$_())) || y._$GetLayerByIndex$_(this._$GetIndex$_());
                    }
                    const m = this._$_runtime$_._$CreateInstanceFromData$_(u, t, !1, void 0, void 0, !1, r), g = (t._$SortAndAddInstancesByZIndex$_(m), 
                    m._$GetWorldInfo$_());
                    g._$OffsetXY$_(i, e), g._$SetBboxChanged$_(), n._$BlockFlushingInstances$_(!0), 
                    m._$_TriggerOnCreatedOnSelfAndRelated$_(), n._$BlockFlushingInstances$_(!1), 
                    l.push(m);
                }
            }
            return l;
        }
        _$GetInstanceCount$_() {
            return this._$_instances$_.length;
        }
        _$GetLayout$_() {
            return this._$_layout$_;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$_SetIndex$_(t) {
            this._$_index$_ = t;
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$_SetHTMLIndex$_(t) {
            this._$_htmlIndex$_ = t;
        }
        _$GetHTMLIndex$_() {
            return this._$_htmlIndex$_;
        }
        _$IsHTMLElementsLayer$_() {
            return this._$_isHTMLElementsLayer$_;
        }
        _$SetIsHTMLElementsLayer$_(t) {
            this._$_isHTMLElementsLayer$_ !== (t = !!t) && (this._$_isHTMLElementsLayer$_ = t, 
            this._$_layout$_._$_ReindexAndUpdateAllLayers$_(), this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetSiblingIndex$_() {
            let t = -1, s = this._$GetParentLayer$_();
            return t = (s ? s._$GetSubLayers$_() : this._$GetLayout$_()._$_GetRootLayers$_()).indexOf(this);
        }
        _$GetSID$_() {
            return this._$_sid$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$IsDynamic$_() {
            return this._$_isDynamic$_;
        }
        _$HasAnyDynamicParentLayer$_() {
            for (const t of this._$parentLayers$_()) if (t._$IsDynamic$_()) return !0;
            return !1;
        }
        _$GetDevicePixelRatio$_() {
            return this._$_runtime$_._$GetDevicePixelRatio$_();
        }
        _$GetEffectList$_() {
            return this._$_effectList$_;
        }
        _$GetEffectChain$_() {
            return this._$_MaybeRebuildEffectChainSteps$_(), this._$_effectChain$_;
        }
        _$_MaybeRebuildEffectChainSteps$_() {
            const t = this._$HasDefaultColor$_();
            if (this._$_needsRebuildEffectChainSteps$_ || t !== this._$_wasDefaultColor$_ || this._$_effectChain$_._$NeedsRebuild$_()) {
                const s = this._$GetEffectList$_()._$GetActiveEffectTypes$_();
                this._$_effectChain$_._$BuildSteps$_(s.map(t => t._$GetShaderProgram$_()), {
                    _$indexMap$_: s.map(t => t._$GetIndex$_()),
                    _$forcePreDraw$_: !t,
                    _$useFullSurface$_: !0
                }), this._$_needsRebuildEffectChainSteps$_ = !1, this._$_wasDefaultColor$_ = t;
            }
        }
        _$UpdateActiveEffects$_() {
            this._$GetEffectList$_()._$UpdateActiveEffects$_(), this._$_needsRebuildEffectChainSteps$_ = !0;
        }
        _$UsesRenderCells$_() {
            return this._$_useRenderCells$_ && !this._$_useCameraDistanceDrawOrder$_;
        }
        _$GetRenderGrid$_() {
            return this._$_renderGrid$_;
        }
        _$SetRenderListStale$_() {
            this._$_isRenderListUpToDate$_ = !1;
        }
        _$IsVisible$_() {
            for (const t of this._$selfAndParentLayers$_()) if (!t._$_IsVisibleFlagSet$_()) return !1;
            return !0;
        }
        _$_IsVisibleFlagSet$_() {
            return this._$_isVisible$_;
        }
        _$SetVisible$_(t) {
            this._$_isVisible$_ !== (t = !!t) && (this._$_isVisible$_ = t, this._$_runtime$_._$UpdateRender$_());
        }
        _$SetInteractive$_(t) {
            this._$_isInteractive$_ = !!t;
        }
        _$IsInteractive$_() {
            return this._$_isInteractive$_;
        }
        _$IsSelfAndParentsInteractive$_() {
            for (const t of this._$selfAndParentLayers$_()) if (!t._$IsInteractive$_()) return !1;
            return !0;
        }
        _$SetOwnScrollPositionEnabled$_(t) {
            if (this._$_hasOwnScrollPosition$_ !== (t = !!t)) {
                if (this._$_hasOwnScrollPosition$_ = t) {
                    const s = this._$GetLayout$_();
                    this._$_scrollX$_ = s._$GetScrollX$_(), this._$_scrollY$_ = s._$GetScrollY$_();
                }
                this._$_SetMVMatrixChanged$_(), this._$_runtime$_._$UpdateRender$_();
            }
        }
        _$IsOwnScrollPositionEnabled$_() {
            return this._$_hasOwnScrollPosition$_;
        }
        _$SetScrollX$_(t) {
            const s = this._$GetLayout$_(), i = s._$GetScrollLeftBound$_(), e = s._$GetScrollRightBound$_();
            this._$_scrollX$_ !== (t = (t = e < t ? e : t) < i ? i : t) && (this._$_scrollX$_ = t, 
            this._$IsOwnScrollPositionEnabled$_()) && (this._$_SetMVMatrixChanged$_(), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$SetScrollY$_(t) {
            const s = this._$GetLayout$_(), i = s._$GetScrollTopBound$_(), e = s._$GetScrollBottomBound$_();
            this._$_scrollY$_ !== (t = (t = e < t ? e : t) < i ? i : t) && (this._$_scrollY$_ = t, 
            this._$IsOwnScrollPositionEnabled$_()) && (this._$_SetMVMatrixChanged$_(), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$GetScrollX$_() {
            return this._$IsOwnScrollPositionEnabled$_() ? this._$_scrollX$_ : this._$GetLayout$_()._$GetScrollX$_();
        }
        _$GetScrollY$_() {
            return this._$IsOwnScrollPositionEnabled$_() ? this._$_scrollY$_ : this._$GetLayout$_()._$GetScrollY$_();
        }
        _$GetViewport$_() {
            return this._$_MaybeUpdateViewport$_(), this._$_viewport$_;
        }
        _$_GetViewportZ0$_() {
            return this._$_MaybeUpdateViewport$_(), this._$_viewportZ0$_;
        }
        _$GetViewport3D$_() {
            return this._$_MaybeUpdateViewport$_(), this._$_viewport3D$_;
        }
        _$_GetVanishingPoint$_() {
            const t = this._$GetLayout$_();
            return [ t._$GetVanishingPointX$_(), t._$GetVanishingPointY$_() ];
        }
        _$GetDefaultCameraZ$_(t) {
            return this._$_runtime$_._$GetDefaultCameraZ$_(t);
        }
        _$GetViewportForZ$_(u, e) {
            const h = this._$_GetViewportZ0$_();
            if (0 === u) e._$copy$_(h); else {
                let n = h._$midX$_(), o = h._$midY$_(), t = this._$Get2DScaleFactorToZ$_(u), s = h.width() / t, i = h.height() / t, [ a, l ] = this._$_GetVanishingPoint$_();
                if (.5 !== a || .5 !== l) {
                    let t = this._$Get2DCameraZ$_(), s = this._$_runtime$_, i = this._$GetDefaultCameraZ$_() / t, e = (a - .5) * s._$GetViewportWidth$_() / i, h = (l - .5) * s._$GetViewportHeight$_() / i, r = this._$GetAngle$_();
                    0 !== r && (Fr.set(e, h), Fr.rotate(r), e = Fr._$getX$_(), h = Fr._$getY$_());
                    const c = S._$unlerp$_(t, 0, u);
                    n += S._$lerp$_(e, 0, c), o += S._$lerp$_(h, 0, c);
                }
                e.set(n - s / 2, o - i / 2, n + s / 2, o + i / 2);
            }
        }
        _$GetOpacity$_() {
            return this._$_color$_._$getA$_();
        }
        _$SetOpacity$_(t) {
            t = S._$clamp$_(t, 0, 1), this._$_color$_._$getA$_() !== t && (this._$_color$_._$setA$_(t), 
            this._$_UpdatePremultipliedColor$_(), this._$_runtime$_._$UpdateRender$_());
        }
        _$_UpdatePremultipliedColor$_() {
            this._$_premultipliedColor$_._$copy$_(this._$_color$_), this._$_premultipliedColor$_._$premultiply$_();
        }
        _$GetPremultipliedColor$_() {
            return this._$_premultipliedColor$_;
        }
        _$HasDefaultColor$_() {
            return this._$_color$_._$equalsRgba$_(1, 1, 1, 1);
        }
        _$GetScaleRate$_() {
            return this._$_scaleRate$_;
        }
        _$SetScaleRate$_(t) {
            this._$_scaleRate$_ !== t && (this._$_scaleRate$_ = t, this._$_SetMVMatrixChanged$_(), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$GetParallaxX$_() {
            return this._$_parallaxX$_;
        }
        _$GetParallaxY$_() {
            return this._$_parallaxY$_;
        }
        _$SetParallax$_(t, s) {
            this._$_parallaxX$_ === t && this._$_parallaxY$_ === s || (this._$_parallaxX$_ = t, 
            this._$_parallaxY$_ = s, this._$_SetMVMatrixChanged$_(), this._$_runtime$_._$UpdateRender$_());
        }
        _$SetParallaxX$_(t) {
            this._$SetParallax$_(t, this._$GetParallaxY$_());
        }
        _$SetParallaxY$_(t) {
            this._$SetParallax$_(this._$GetParallaxX$_(), t);
        }
        _$SetZElevation$_(t) {
            this._$_zElevation$_ !== t && (this._$_zElevation$_ = t, this._$_runtime$_._$UpdateRender$_());
        }
        _$GetZElevation$_() {
            return this._$_zElevation$_;
        }
        _$SetAngle$_(t) {
            t = S._$clampAngle$_(t), this._$_angle$_ !== t && (this._$_angle$_ = t, 
            this._$_SetMVMatrixChanged$_(), this._$_runtime$_._$UpdateRender$_());
        }
        _$GetAngle$_() {
            return S._$clampAngle$_(this._$_layout$_._$GetAngle$_() + this._$_angle$_);
        }
        _$GetOwnAngle$_() {
            return this._$_angle$_;
        }
        _$HasInstances$_() {
            return 0 < this._$_instances$_.length;
        }
        _$_GetInstances$_() {
            return this._$_instances$_;
        }
        _$_GetInstancesInDrawOrder$_() {
            return this._$RendersIn3DMode$_() && this._$_useCameraDistanceDrawOrder$_ ? (S._$shallowAssignArray$_(kr, this._$_GetInstances$_()), 
            kr.sort((t, s) => this._$_SortInstancesByCameraDistance$_(t, s)), kr) : this._$_GetInstances$_();
        }
        _$_AppendAllInstancesIncludingSubLayersInDrawOrder$_(t) {
            S._$appendArray$_(t, this._$_GetInstancesInDrawOrder$_());
            for (const s of this._$_subLayers$_) s._$IsVisible$_() && 0 < s._$GetOpacity$_() && s._$_AppendAllInstancesIncludingSubLayersInDrawOrder$_(t);
        }
        _$_SortInstancesByCameraDistance$_(t, s) {
            const i = this._$GetLayout$_()._$Get3DCameraPosition$_(), e = i[0], h = i[1], r = i[2], n = t._$GetWorldInfo$_(), o = s._$GetWorldInfo$_(), a = n._$GetX$_() - e, l = n._$GetY$_() - h, u = n._$GetZElevation$_() - r, c = o._$GetX$_() - e, f = o._$GetY$_() - h, d = o._$GetZElevation$_() - r;
            return c * c + f * f + d * d - (a * a + l * l + u * u);
        }
        _$GetBackgroundColor$_() {
            return this._$_backgroundColor$_;
        }
        _$IsTransparent$_() {
            return this._$_isTransparent$_;
        }
        _$SetTransparent$_(t) {
            this._$_isTransparent$_ !== (t = !!t) && (this._$_isTransparent$_ = t, 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$IsForceOwnTexture$_() {
            return this._$_isForceOwnTexture$_;
        }
        _$SetForceOwnTexture$_(t) {
            this._$_isForceOwnTexture$_ !== (t = !!t) && (this._$_isForceOwnTexture$_ = t, 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$RendersIn2DMode$_() {
            return !this._$GetRuntime$_()._$Uses3DFeatures$_() || !this._$_renderAs3d$_;
        }
        _$RendersIn3DMode$_() {
            return !this._$RendersIn2DMode$_();
        }
        _$Has3DCamera$_() {
            return this._$RendersIn3DMode$_() && this._$GetLayout$_()._$Is3DCameraEnabled$_();
        }
        _$SelfAndAllSubLayersHave3DCamera$_() {
            if (!this._$Has3DCamera$_()) return !1;
            for (const t of this._$_subLayers$_) if (!t._$SelfAndAllSubLayersHave3DCamera$_()) return !1;
            return !0;
        }
        _$SetBlendMode$_(t) {
            this._$_blendMode$_ !== t && (this._$_blendMode$_ = t, this._$_runtime$_._$UpdateRender$_());
        }
        _$GetBlendMode$_() {
            return this._$_blendMode$_;
        }
        _$IsRootLayer$_() {
            return !this._$_parentLayer$_;
        }
        _$GetParentLayer$_() {
            return this._$_parentLayer$_;
        }
        _$_SetParentLayer$_(t) {
            this._$_parentLayer$_ = t;
        }
        _$GetSubLayers$_() {
            return this._$_subLayers$_;
        }
        _$HasAnySubLayers$_() {
            return 0 < this._$_subLayers$_.length;
        }
        _$_AddSubLayer$_(t, s = !0) {
            s ? this._$_subLayers$_.push(t) : this._$_subLayers$_.unshift(t);
        }
        _$_InsertSubLayer$_(t, s, i) {
            let e = this._$_subLayers$_.indexOf(s);
            if (-1 === e) throw new Error("cannot find layer to insert by");
            i && ++e, this._$_subLayers$_.splice(e, 0, t);
        }
        _$_RemoveSubLayer$_(t) {
            const s = this._$_subLayers$_.indexOf(t);
            if (-1 === s) throw new Error("cannot find layer to remove");
            this._$_subLayers$_.splice(s, 1);
        }
        _$HasAnyVisibleSubLayer$_() {
            for (const t of this._$_subLayers$_) if (t._$ShouldDraw$_()) return !0;
            return !1;
        }
        *_$selfAndAllSubLayers$_() {
            for (const t of this._$_subLayers$_) yield* t._$selfAndAllSubLayers$_();
            yield this;
        }
        *_$parentLayers$_() {
            let t = this._$GetParentLayer$_();
            for (;t; ) yield t, t = t._$GetParentLayer$_();
        }
        *_$selfAndParentLayers$_() {
            yield this, yield* this._$parentLayers$_();
        }
        _$HasParentLayer$_(t) {
            for (const s of this._$parentLayers$_()) if (s === t) return !0;
            return !1;
        }
        _$IsTransformCompatibleWith$_(t) {
            return this === t || this._$_parallaxX$_ === t._$_parallaxX$_ && this._$_parallaxY$_ === t._$_parallaxY$_ && this._$_scale$_ === t._$_scale$_ && this._$_scaleRate$_ === t._$_scaleRate$_ && this._$_angle$_ === t._$_angle$_ && this._$GetScrollX$_() === t._$GetScrollX$_() && this._$GetScrollY$_() === t._$GetScrollY$_();
        }
        _$SaveTransform$_() {
            return {
                parallaxX: this._$GetParallaxX$_(),
                parallaxY: this._$GetParallaxY$_(),
                scale: this._$GetOwnScale$_(),
                scaleRate: this._$GetScaleRate$_(),
                angle: this._$GetOwnAngle$_(),
                hasOwnScroll: this._$IsOwnScrollPositionEnabled$_(),
                scrollX: this._$GetScrollX$_(),
                scrollY: this._$GetScrollY$_()
            };
        }
        _$RestoreTransform$_(t) {
            this._$SetParallax$_(t.parallaxX, t.parallaxY), this._$SetOwnScale$_(t.scale), 
            this._$SetScaleRate$_(t.scaleRate), this._$SetAngle$_(t.angle), this._$SetOwnScrollPositionEnabled$_(t.hasOwnScroll), 
            this._$SetScrollX$_(t.scrollX), this._$SetScrollY$_(t.scrollY), this._$_MaybeUpdateViewport$_();
        }
        _$_RemoveAllInstancesInSet$_(t) {
            if (0 !== t.size) {
                const s = S._$arrayRemoveAllInSet$_(this._$_instances$_, t);
                0 < s && (this._$_MaybeResetAnyInstanceZElevatedFlag$_(), this._$SetZIndicesChanged$_());
            }
        }
        _$SetZIndicesChanged$_(t) {
            this._$_zIndicesUpToDate$_ = !1, this._$_isRenderListUpToDate$_ = !1, 
            t && !t._$GetObjectClass$_()._$GetPlugin$_()._$IsHTMLElementType$_() || (this._$_htmlZIndicesUpToDate$_ = !1);
        }
        _$_UpdateZIndices$_() {
            if (!this._$_zIndicesUpToDate$_) {
                if (this._$_instances$_.sort(t), this._$UsesRenderCells$_()) for (let t = 0, s = this._$_instances$_.length; t < s; ++t) {
                    const i = this._$_instances$_[t]._$GetWorldInfo$_();
                    i._$_SetZIndex$_(t), this._$_renderGrid$_._$MarkRangeChanged$_(i._$GetRenderCellRange$_());
                } else for (let t = 0, s = this._$_instances$_.length; t < s; ++t) this._$_instances$_[t]._$GetWorldInfo$_()._$_SetZIndex$_(t);
                this._$_zIndicesUpToDate$_ = !0;
            }
        }
        _$_UpdateHTMLZIndices$_() {
            if (!this._$_htmlZIndicesUpToDate$_) {
                let t = this._$_layout$_._$GetRootLayersForHTMLLayer$_(this._$GetHTMLIndex$_()), s = t.map(t => [ ...t._$selfAndAllSubLayers$_() ]).flat(), i = 0;
                for (const e of s) {
                    for (const h of e._$_GetInstances$_()) h._$GetObjectClass$_()._$GetPlugin$_()._$IsHTMLElementType$_() && h._$GetWorldInfo$_()._$_SetHTMLZIndex$_(i++);
                    e._$_SetHTMLZIndicesUpToDate$_();
                }
            }
        }
        _$_SetHTMLZIndicesUpToDate$_() {
            this._$_htmlZIndicesUpToDate$_ = !0;
        }
        _$MoveInstanceAdjacent$_(t, s, i) {
            const e = t._$GetWorldInfo$_(), h = s._$GetWorldInfo$_();
            if (e._$GetLayer$_() !== this || h._$GetLayer$_() !== this) throw new Error("can't arrange Z order unless both objects on this layer");
            let r = e._$GetZIndex$_(), n = h._$GetZIndex$_();
            return r !== n + (i ? 1 : -1) && (S._$arrayRemove$_(this._$_instances$_, r), 
            r < n && n--, i && n++, n === this._$_instances$_.length ? this._$_instances$_.push(t) : this._$_instances$_.splice(n, 0, t), 
            this._$SetZIndicesChanged$_(t), !0);
        }
        _$_MergeSortedZArrays$_(t, s) {
            let i = [], e = 0, h = 0, r = t.length, n = s.length;
            for (;e < r && h < n; ) {
                const o = t[e], a = s[h];
                o._$GetWorldInfo$_()._$_GetLastCachedZIndex$_() < a._$GetWorldInfo$_()._$_GetLastCachedZIndex$_() ? (i.push(o), 
                ++e) : (i.push(a), ++h);
            }
            for (;e < r; ++e) i.push(t[e]);
            for (;h < n; ++h) i.push(s[h]);
            return i;
        }
        _$_MergeAllSortedZArrays_pass$_(s) {
            const i = [], e = s.length;
            for (let t = 0; t < e - 1; t += 2) {
                const h = s[t], r = s[t + 1];
                i.push(this._$_MergeSortedZArrays$_(h, r));
            }
            return e % 2 == 1 && i.push(s[e - 1]), i;
        }
        _$_MergeAllSortedZArrays$_(t) {
            for (;1 < t.length; ) t = this._$_MergeAllSortedZArrays_pass$_(t);
            return t[0];
        }
        _$_GetRenderCellInstancesToDraw$_() {
            return this._$_UpdateZIndices$_(), S._$clearArray$_(Tr), this._$_renderGrid$_._$QueryRange$_(this._$GetViewport$_(), Tr), 
            Tr.length ? 1 === Tr.length ? Tr[0] : this._$_MergeAllSortedZArrays$_(Tr) : [];
        }
        _$ShouldDraw$_() {
            return this._$IsVisible$_() && 0 < this._$GetOpacity$_() && this._$_DrawsAnyContentInSelfOrSubLayers$_();
        }
        _$_DrawsAnyContentInSelfOrSubLayers$_() {
            if (this._$HasInstances$_() || !this._$IsTransparent$_()) return !0;
            for (const t of this._$_subLayers$_) if (t._$_DrawsAnyContentInSelfOrSubLayers$_()) return !0;
            return !1;
        }
        _$UsesOwnTexture$_() {
            return this._$IsForceOwnTexture$_() || !this._$HasDefaultColor$_() || 0 !== this._$GetBlendMode$_() || this._$_effectList$_._$HasAnyActiveEffect$_();
        }
        _$SelfOrAnySubLayerUsesOwnTexture$_() {
            if (this._$UsesOwnTexture$_()) return !0;
            for (const t of this._$_subLayers$_) if (t._$SelfOrAnySubLayerUsesOwnTexture$_()) return !0;
            return !1;
        }
        _$GetRenderTarget$_() {
            return this._$_curRenderTarget$_;
        }
        _$Get2DScaleFactorToZ$_(t) {
            if (this._$_layout$_._$IsOrthographicProjection$_()) return 1;
            {
                const s = this._$Get3DCameraZ$_();
                return s / (s - t);
            }
        }
        _$GetResolutionScaleFactorToZ$_(t) {
            const s = this._$_runtime$_._$GetRenderScale$_();
            if (this._$_layout$_._$IsOrthographicProjection$_()) return s;
            {
                const i = this._$Get3DCameraZ$_(), e = this._$GetDefaultCameraZ$_();
                return e / Math.abs(i - t) * s;
            }
        }
        _$_SetMVMatrixChanged$_() {
            this._$_isMVMatrixChanged$_ = !0, this._$_isViewFrustumChanged$_ = !0, 
            this._$_isViewportChanged$_ = !0;
        }
        _$_GetModelViewMatrix$_(t) {
            return this._$_isMVMatrixChanged$_ && (this._$_CalculateModelViewMatrix$_(t, this._$_modelViewMatrix$_, 0, 0, null), 
            this._$_isMVMatrixChanged$_ = !1), this._$_modelViewMatrix$_;
        }
        _$Get2DCameraZ$_(t) {
            return this._$GetDefaultCameraZ$_(t) / this._$GetNormalScale$_();
        }
        _$Get3DCameraZ$_() {
            return this._$Has3DCamera$_() ? this._$GetLayout$_()._$Get3DCameraPosition$_()[2] : this._$Get2DCameraZ$_();
        }
        _$GetCameraPosition$_() {
            if (this._$Has3DCamera$_()) {
                const t = this._$GetLayout$_()._$Get3DCameraPosition$_();
                return [ t[0], t[1], t[2] ];
            }
            return this._$_Get2DCameraPosition$_();
        }
        _$_Get2DCameraPosition$_(t = 0, s = 0, h = 0) {
            let r = this._$_runtime$_, i = this._$GetLayout$_(), e = r._$GetParallaxXOrigin$_(), n = r._$GetParallaxYOrigin$_(), o = (this._$GetScrollX$_() - e) * this._$_parallaxX$_ + e, a = (this._$GetScrollY$_() - n) * this._$_parallaxY$_ + n, l = (r._$IsPixelRoundingEnabled$_() && (o = Math.round(o), 
            a = Math.round(a)), o + t), u = a + s, c = i._$IsOrthographicProjection$_() ? this._$GetDefaultCameraZ$_(h) : this._$Get2DCameraZ$_(h), [ f, d ] = this._$_GetVanishingPoint$_();
            if (.5 !== f || .5 !== d) {
                let t = this._$GetDefaultCameraZ$_(h) / c, s = (f - .5) * r._$GetViewportWidth$_() / t, i = (d - .5) * r._$GetViewportHeight$_() / t, e = this._$GetAngle$_();
                0 !== e && (Fr.set(s, i), Fr.rotate(e), s = Fr._$getX$_(), i = Fr._$getY$_()), 
                l += s, u += i;
            }
            return [ l, u, c ];
        }
        _$_CalculateModelViewMatrix$_(t, s, i, e, h) {
            const r = this._$_runtime$_, n = this._$GetLayout$_();
            if (this._$Has3DCamera$_()) {
                Gh._$copy$_(Pr, n._$Get3DCameraPosition$_()), Gh._$copy$_(Er, n._$Get3DCameraLookAt$_()), 
                Gh._$copy$_(Ar, n._$Get3DCameraUpVector$_());
                const o = r._$GetParallaxXOrigin$_(), a = r._$GetParallaxYOrigin$_(), l = Er[0] - Pr[0], u = Er[1] - Pr[1], c = Er[2] - Pr[2];
                Pr[0] = (Pr[0] - o) * this._$_parallaxX$_ + o, Pr[1] = (Pr[1] - a) * this._$_parallaxY$_ + a, 
                Pr[2] *= Math.max(this._$_parallaxX$_, this._$_parallaxY$_), Er[0] = Pr[0] + l, 
                Er[1] = Pr[1] + u, Er[2] = Pr[2] + c;
            } else {
                const [ f, d, p ] = this._$_Get2DCameraPosition$_(i, e, h), m = (Gh.set(Pr, f, d, p), 
                Gh.set(Er, f, d, p - 100), this._$GetAngle$_());
                0 === m ? Gh.set(Ar, 0, 1, 0) : Gh.set(Ar, Math.sin(m), Math.cos(m), 0);
            }
            t._$CalculateLookAtModelView$_(s, Pr, Er, Ar, h || r._$GetViewportHeight$_());
        }
        _$_SetProjectionMatrixChanged$_() {
            this._$_isProjectionMatrixChanged$_ = !0, this._$_isViewFrustumChanged$_ = !0, 
            this._$_isViewportChanged$_ = !0;
        }
        _$_GetProjectionMatrix$_(t) {
            return this._$_isProjectionMatrixChanged$_ && (this._$_CalculateProjectionMatrix$_(t), 
            this._$_isProjectionMatrixChanged$_ = !1), this._$_projectionMatrix$_;
        }
        _$_CalculateProjectionMatrix$_(t) {
            const s = this._$_runtime$_._$GetCanvasManager$_(), [ i, e ] = this._$_GetVanishingPoint$_();
            if (this._$_layout$_._$IsOrthographicProjection$_()) t._$CalculateOrthographicMatrix$_(this._$_projectionMatrix$_, s._$GetDrawWidth$_(), s._$GetDrawHeight$_()); else if (.5 === i && .5 === e) xh._$copy$_(this._$_projectionMatrix$_, s._$GetDefaultProjectionMatrix$_()); else {
                const h = s._$GetDrawWidth$_(), r = s._$GetDrawHeight$_();
                t._$CalculatePerspectiveMatrix$_(this._$_projectionMatrix$_, h / r, i, e);
            }
        }
        _$_SetTransform$_(t, s = !0, i = 0, e = 0, h = 0) {
            s && t._$SetProjectionMatrix$_(this._$_GetProjectionMatrix$_(t));
            let r = null;
            r = 0 === i && 0 === e && 0 === h ? this._$_GetModelViewMatrix$_(t) : (this._$_CalculateModelViewMatrix$_(t, Ir, i, e, h), 
            Ir), t._$SetModelViewMatrix$_(r);
        }
        _$PrepareForDraw$_(t) {
            this._$_SetTransform$_(t), t._$SetBaseZ$_(this._$GetZElevation$_());
        }
        _$_MaybeStartWebGLProfiling$_(t) {
            let s = null;
            if (t._$IsWebGL$_() && this._$_runtime$_._$IsGPUProfiling$_()) {
                const i = this._$_runtime$_._$GetCanvasManager$_()._$GetLayerTimingsBuffer$_(this);
                i && (s = i._$AddTimeElapsedQuery$_(), t._$StartQuery$_(s));
            }
            return s;
        }
        _$_MaybeStartWebGPUProfiling$_(t) {
            if (t._$IsWebGPU$_() && this._$_runtime$_._$IsGPUProfiling$_()) {
                const s = 2 * (this._$GetIndex$_() + 1);
                t.StartMeasuringRenderPassTime(s, 1 + s);
            }
        }
        _$Draw$_(t, s, i) {
            let e = this._$_runtime$_._$GetCanvasManager$_(), h = this._$UsesOwnTexture$_(), r = null, n = this._$_MaybeStartWebGLProfiling$_(t);
            if (this._$_MaybeStartWebGPUProfiling$_(t), h) {
                const o = {
                    _$sampling$_: this._$_runtime$_._$GetSampling$_(),
                    _$isSampled$_: !0,
                    _$canReadPixels$_: !!t._$IsWebGPU$_() && this._$_runtime$_._$UsesAnyBackgroundBlending$_()
                };
                "low" === e._$GetCurrentFullscreenScalingQuality$_() && (o.width = e._$GetDrawWidth$_(), 
                o.height = e._$GetDrawHeight$_()), r = this._$_runtime$_._$GetAdditionalRenderTarget$_(o), 
                this._$_curRenderTarget$_ = r, t._$SetRenderTarget$_(r), this._$IsTransparent$_() && t._$ClearRgba$_(0, 0, 0, 0);
            } else this._$_curRenderTarget$_ = s, t._$SetRenderTarget$_(s);
            if (this._$IsTransparent$_() || t._$Clear$_(this._$_backgroundColor$_), 
            this._$_layout$_._$_DrawLayerList$_(t, this._$_curRenderTarget$_, this._$_subLayers$_, h && this._$IsTransparent$_()), 
            this._$_MaybeStartWebGPUProfiling$_(t), this._$_SetTransform$_(t), t._$SetBaseZ$_(this._$GetZElevation$_()), 
            t._$SetDepthEnabled$_(this._$RendersIn3DMode$_()), this._$GetNormalScale$_() > Number.EPSILON) {
                this._$_UpdateZIndices$_();
                const a = this._$UsesRenderCells$_() && 0 === this._$GetZElevation$_() && !this._$_anyInstanceZElevated$_;
                this._$Has3DCamera$_() ? this._$_DrawInstances_3DCamera$_(t) : a ? this._$_DrawInstances_RenderCells$_(t) : this._$_DrawInstances$_(t, this._$_GetInstancesInDrawOrder$_());
            }
            t._$SetBaseZ$_(0), t._$SetCurrentZ$_(0), h && (t._$SetDepthEnabled$_(!1), 
            this._$_DrawLayerOwnTextureToRenderTarget$_(t, r, s, i)), n && t._$EndQuery$_(n), 
            this._$_curRenderTarget$_ = null;
        }
        _$_DrawInstances$_(i, e) {
            let h = this._$GetViewport$_(), r = this._$_curRenderTarget$_, n = this._$GetLayout$_()._$IsOrthographicProjection$_(), o = this._$GetLayout$_()._$HasVanishingPointOutsideViewport$_(), a = null;
            for (let t = 0, s = e.length; t < s; ++t) {
                const l = e[t];
                if (l !== a) {
                    const u = (a = l)._$GetWorldInfo$_();
                    u._$IsVisible$_() && u._$IsInViewport$_(h, o, n) && this._$_DrawInstanceMaybeWithEffects$_(l, u, i, r);
                }
            }
        }
        _$_DrawInstances_3DCamera$_(e) {
            const h = this._$_curRenderTarget$_, r = this._$_GetViewFrustum$_(), n = Or, o = Dr, a = this._$_GetInstancesInDrawOrder$_();
            for (let s = 0, i = a.length; s < i; ) {
                const l = a[s], u = l._$GetWorldInfo$_();
                if (u._$IsVisible$_() && u._$IsInViewport3D$_(r)) {
                    (!l._$RendersToOwnZPlane$_() || 0 < u._$GetDepth$_()) && o.push(l);
                    const c = l._$GetWorldInfo$_()._$GetTotalZElevation$_();
                    n.push(l);
                    let t = s + 1;
                    for (;t < i; ++t) {
                        const f = a[t], d = f._$GetWorldInfo$_();
                        if (d._$IsVisible$_() && d._$IsInViewport3D$_(r)) {
                            if (d._$GetTotalZElevation$_() !== c) break;
                            (f._$RendersToOwnZPlane$_() ? (0 < d._$GetDepth$_() && o.push(f), 
                            n) : o).push(f);
                        }
                    }
                    if (1 !== n.length || n[0]._$MustMitigateZFighting$_()) {
                        this._$_DrawCoplanarInstances_3DCamera$_(e, n);
                        for (let t = 0, s = o.length; t < s; ++t) {
                            const p = o[t], m = p._$GetWorldInfo$_();
                            m._$_SetDrawNonBackFacesOnly$_(!0), this._$_DrawInstanceMaybeWithEffects$_(p, m, e, h), 
                            m._$_SetDrawNonBackFacesOnly$_(!1);
                        }
                    } else {
                        this._$_DrawInstanceMaybeWithEffects$_(l, u, e, h);
                        for (let t = 0, s = o.length; t < s; ++t) {
                            const g = o[t];
                            if (g !== l) {
                                const y = g._$GetWorldInfo$_(), w = y._$GetLayer$_();
                                w._$_DrawInstanceMaybeWithEffects$_(g, y, e, h);
                            }
                        }
                    }
                    s = t, S._$clearArray$_(n), S._$clearArray$_(o);
                } else ++s;
            }
        }
        _$_DrawCoplanarInstances_3DCamera$_(i, e) {
            const h = this._$_curRenderTarget$_;
            i._$CoplanarStartStencilPass$_();
            for (let t = 0, s = e.length; t < s; ++t) {
                const r = e[t], n = r._$GetWorldInfo$_();
                n._$_SetDrawBackFaceOnly$_(!0), this._$_DrawInstance$_(r, n, i);
            }
            i._$CoplanarStartColorPass$_();
            for (let t = 0, s = e.length; t < s; ++t) {
                const o = e[t], a = o._$GetWorldInfo$_();
                this._$_DrawInstanceMaybeWithEffects$_(o, a, i, h), a._$_SetDrawBackFaceOnly$_(!1);
            }
            i._$CoplanarRestoreStandardRendering$_();
        }
        _$_DrawInstances_RenderCells$_(t) {
            let s = this._$_renderGrid$_, i = this._$_curRenderCells$_, e = this._$_lastRenderCells$_, h = this._$GetViewport$_(), r;
            i.set(s._$XToCell$_(h._$getLeft$_()), s._$YToCell$_(h._$getTop$_()), s._$XToCell$_(h._$getRight$_()), s._$YToCell$_(h._$getBottom$_())), 
            this._$_isRenderListUpToDate$_ && i.equals(e) ? r = this._$_lastRenderList$_ : (r = this._$_GetRenderCellInstancesToDraw$_(), 
            this._$_isRenderListUpToDate$_ = !0, e._$copy$_(i)), this._$_DrawInstances$_(t, r), 
            r !== this._$_lastRenderList$_ && S._$shallowAssignArray$_(this._$_lastRenderList$_, r);
        }
        _$_DrawInstanceMaybeWithEffects$_(t, s, i, e) {
            s._$HasAnyActiveEffect$_() ? this._$_DrawInstanceWithEffectsAndRestore$_(t, s, i, e) : this._$_DrawInstance$_(t, s, i);
        }
        _$_DrawInstance$_(t, s, i) {
            const e = s._$GetRendererStateGroup$_();
            i._$GetCurrentStateGroup$_() !== e && e._$Apply$_(), t._$Draw$_(i);
        }
        _$_DrawInstanceWithEffectsAndRestore$_(t, s, i, e) {
            this._$_DrawInstanceWithEffects$_(t, s, i, e, null) && this._$_SetTransform$_(i);
        }
        _$_DrawInstanceWithEffects$_(t, s, i, e, h) {
            const r = s._$GetInstanceEffectList$_()._$GetEffectChain$_();
            return r._$Render$_(i, e, {
                _$contentObject$_: t,
                _$blendMode$_: s._$GetBlendMode$_(),
                devicePixelRatio: this._$_runtime$_._$GetEffectDevicePixelRatioParam$_(),
                time: t._$GetInstanceGameTime$_(),
                _$layerScale$_: this._$_runtime$_._$GetEffectLayerScaleParam$_() * this._$GetNormalScale$_(),
                _$layerAngle$_: this._$GetAngle$_(),
                _$layoutRect$_: s._$GetBoundingBox$_(),
                _$drawSurfaceRect$_: r._$CanSkipCalculatingDrawSurfaceRect$_() ? null : this._$_InstanceBoxToDrawSurface$_(s),
                _$drawContentHook$_: h && h._$drawContentHook$_,
                _$compositOffX$_: h && h._$compositOffX$_,
                _$compositOffY$_: h && h._$compositOffY$_,
                _$updateOwnProjection$_: h && h._$updateOwnProjection$_
            }), i._$SetBaseZ$_(this._$GetZElevation$_()), r._$DidChangeTransform$_();
        }
        _$_DrawLayerOwnTextureToRenderTarget$_(t, s, i, e) {
            const h = this._$_effectList$_._$GetActiveEffectTypes$_(), r = this._$_runtime$_;
            0 === h.length ? (t._$SetRenderTarget$_(i), t._$SetTextureFillMode$_(), 
            e && 0 === this._$_blendMode$_ && this._$HasDefaultColor$_() ? t._$CopyRenderTarget$_(s) : (t._$SetBlendMode$_(this._$_blendMode$_), 
            t._$SetColor$_(this._$_premultipliedColor$_), t._$DrawRenderTarget$_(s)), 
            t._$InvalidateRenderTarget$_(s), r._$ReleaseAdditionalRenderTarget$_(s)) : this._$GetEffectChain$_()._$Render$_(t, i, {
                _$contentObject$_: this,
                _$blendMode$_: this._$GetBlendMode$_(),
                devicePixelRatio: r._$GetEffectDevicePixelRatioParam$_(),
                _$layerScale$_: r._$GetEffectLayerScaleParam$_() * this._$GetNormalScale$_(),
                _$layerAngle$_: this._$GetAngle$_(),
                _$layoutRect$_: this._$GetViewport$_(),
                _$drawSurfaceRect$_: null,
                _$invalidateRenderTargets$_: !0
            });
        }
        _$GetOwnScale$_() {
            return this._$_scale$_;
        }
        _$SetOwnScale$_(t) {
            this._$_scale$_ !== t && (this._$_scale$_ = t, this._$_layout$_._$BoundScrolling$_(), 
            this._$_SetMVMatrixChanged$_(), this._$_runtime$_._$UpdateRender$_());
        }
        _$GetRenderScale$_() {
            return this._$GetNormalScale$_() * this._$_runtime$_._$GetRenderScale$_();
        }
        _$GetDisplayScale$_() {
            return this._$GetNormalScale$_() * this._$_runtime$_._$GetDisplayScale$_();
        }
        _$GetNormalScale$_() {
            return (this._$_scale$_ * this._$_layout$_._$GetScale$_() - 1) * this._$_scaleRate$_ + 1;
        }
        _$_MaybeUpdateViewport$_() {
            if (this._$_isViewportChanged$_) {
                this._$_isViewportChanged$_ = !1;
                let t = this._$_runtime$_._$GetParallaxXOrigin$_(), s = this._$_runtime$_._$GetParallaxYOrigin$_(), i = (this._$GetScrollX$_() - t) * this._$_parallaxX$_ + t, e = (this._$GetScrollY$_() - s) * this._$_parallaxY$_ + s, h = this._$GetNormalScale$_(), r = this._$_runtime$_._$GetViewportWidth$_() / h, n = this._$_runtime$_._$GetViewportHeight$_() / h, o = i - r / 2, a = e - n / 2;
                this._$_runtime$_._$IsPixelRoundingEnabled$_() && (o = Math.round(o), 
                a = Math.round(a));
                const l = this._$_viewportZ0$_, u = (l.set(o, a, o + r, a + n), 
                this._$GetAngle$_()), c = (0 !== u && (xr._$copy$_(l), xr.offset(-l._$midX$_(), -l._$midY$_()), 
                Gr._$setFromRotatedRect$_(xr, u), Gr._$getBoundingBox$_(xr), xr.offset(l._$midX$_(), l._$midY$_()), 
                l._$copy$_(xr)), this._$_zElevation$_);
                this._$GetViewportForZ$_(c, this._$_viewport$_), this._$Has3DCamera$_() ? this._$CalculateViewport3D$_(c, this._$_viewport3D$_) : this._$_viewport3D$_._$copy$_(this._$_viewport$_);
            }
        }
        _$CalculateViewport3D$_(t, s) {
            let i = this._$_runtime$_._$GetCanvasManager$_(), e = i._$GetCssWidth$_(), h = i._$GetCssHeight$_(), [ r, n ] = this._$CanvasCssToLayer$_(0, 0, t), [ o, a ] = this._$CanvasCssToLayer$_(e, 0, t), [ l, u ] = this._$CanvasCssToLayer$_(e, h, t), [ c, f ] = this._$CanvasCssToLayer$_(0, h, t), d = Math.min(r, o, l, c), p = Math.min(n, a, u, f), m = Math.max(r, o, l, c), g = Math.max(n, a, u, f);
            isFinite(d) || (d = -1 / 0), isFinite(p) || (p = -1 / 0), isFinite(m) || (m = 1 / 0), 
            isFinite(g) || (g = 1 / 0), s.set(d, p, m, g);
        }
        _$CanvasCssToLayer$_(t, s, i = 0) {
            return this._$_CanvasToLayer$_(t, s, i, this._$GetDisplayScale$_());
        }
        _$DrawSurfaceToLayer$_(t, s, i = 0) {
            return this._$_CanvasToLayer$_(t, s, i, this._$GetRenderScale$_() * this._$GetDevicePixelRatio$_());
        }
        _$_CanvasToLayer$_(t, s, i, e) {
            const h = this._$_runtime$_, r = h._$GetRenderer$_(), n = this._$GetNormalScale$_(), o = h._$GetViewportWidth$_() / n, a = h._$GetViewportHeight$_() / n, l = Rr, u = (Vh.set(l, 0, 0, o, a), 
            t /= e, s = l[3] - s / e, this._$_GetProjectionMatrix$_(r)), c = this._$_GetModelViewMatrix$_(r), f = Cr, d = S._$Gfx$_._$UnprojectScreenToWorldZ$_(t, s, i, c, u, l, f);
            return d ? [ f[0], f[1] ] : [ NaN, NaN ];
        }
        _$CanvasCssToLayer_DefaultTransform$_(t, s) {
            const i = this._$_scale$_, e = this._$_scaleRate$_, h = this._$_parallaxX$_, r = this._$_parallaxY$_, n = this._$_angle$_, o = (this._$_scale$_ = 1, 
            this._$_scaleRate$_ = 1, this._$_parallaxX$_ = 1, this._$_parallaxY$_ = 1, 
            this._$_angle$_ = 0, this._$_SetMVMatrixChanged$_(), this._$CanvasCssToLayer$_(t, s));
            return this._$_scale$_ = i, this._$_scaleRate$_ = e, this._$_parallaxX$_ = h, 
            this._$_parallaxY$_ = r, this._$_angle$_ = n, this._$_SetMVMatrixChanged$_(), 
            o;
        }
        _$LayerToCanvasCss$_(t, s, i = 0) {
            return this._$_LayerToCanvas$_(t, s, i, this._$GetDisplayScale$_());
        }
        _$LayerToDrawSurface$_(t, s, i = 0) {
            return this._$_LayerToCanvas$_(t, s, i, this._$GetRenderScale$_() * this._$GetDevicePixelRatio$_());
        }
        _$_LayerToCanvas$_(t, s, i, e) {
            const h = this._$_runtime$_, r = h._$GetRenderer$_(), n = this._$GetNormalScale$_(), o = h._$GetViewportWidth$_() / n, a = h._$GetViewportHeight$_() / n, l = Rr, u = (Vh.set(l, 0, 0, o, a), 
            this._$_GetProjectionMatrix$_(r)), c = this._$_GetModelViewMatrix$_(r), f = Cr, d = S._$Gfx$_._$Project$_(t, s, i, c, u, l, f);
            return d ? [ f[0] * e, (l[3] - f[1]) * e ] : [ NaN, NaN ];
        }
        _$_GetLayerToDrawSurfaceScale$_(t, s) {
            return t *= this._$GetRenderScale$_() * this._$GetDevicePixelRatio$_(), 
            0 !== s && (t *= this._$Get2DScaleFactorToZ$_(s)), t;
        }
        _$_InstanceBoxToDrawSurface$_(t) {
            const s = t._$GetBoundingBox$_(), i = t._$GetTotalZElevation$_(), e = t._$GetDepth$_(), l = i + e, u = s._$getLeft$_(), c = s._$getTop$_(), f = s._$getRight$_(), d = s._$getBottom$_();
            if (this._$Has3DCamera$_()) {
                if (this._$_IsPointBehindNearPlane$_(u, c, i) || this._$_IsPointBehindNearPlane$_(f, c, i) || this._$_IsPointBehindNearPlane$_(f, d, i) || this._$_IsPointBehindNearPlane$_(u, d, i)) return null;
                if (0 < e && (this._$_IsPointBehindNearPlane$_(u, c, l) || this._$_IsPointBehindNearPlane$_(f, c, l) || this._$_IsPointBehindNearPlane$_(f, d, l) || this._$_IsPointBehindNearPlane$_(u, d, l))) return null;
            } else if (l >= this._$Get2DCameraZ$_()) return null;
            let [ p, m ] = this._$LayerToDrawSurface$_(u, c, i), [ g, y ] = this._$LayerToDrawSurface$_(f, d, i);
            if (0 !== this._$GetAngle$_() || 0 < e || this._$Has3DCamera$_()) {
                const [ w, S ] = this._$LayerToDrawSurface$_(f, c, i), [ b, M ] = this._$LayerToDrawSurface$_(u, d, i);
                if (0 < e) {
                    let [ t, s ] = this._$LayerToDrawSurface$_(u, c, l), [ i, e ] = this._$LayerToDrawSurface$_(f, c, l), [ h, r ] = this._$LayerToDrawSurface$_(f, d, l), [ n, o ] = this._$LayerToDrawSurface$_(u, d, l), a = Math.min(p, g, w, b, t, i, h, n);
                    g = Math.max(p, g, w, b, t, i, h, n), p = a, a = Math.min(m, y, S, M, s, e, r, o), 
                    y = Math.max(m, y, S, M, s, e, r, o), m = a;
                } else {
                    let t = Math.min(p, g, w, b);
                    g = Math.max(p, g, w, b), p = t, t = Math.min(m, y, S, M), y = Math.max(m, y, S, M), 
                    m = t;
                }
            }
            return xr.set(p, m, g, y), xr;
        }
        _$_GetViewFrustum$_() {
            return this._$_isViewFrustumChanged$_ && (this._$_UpdateViewFrustum$_(), 
            this._$_isViewFrustumChanged$_ = !1), this._$_viewFrustum$_;
        }
        _$_UpdateViewFrustum$_() {
            const t = this._$_runtime$_._$GetRenderer$_(), s = this._$_GetProjectionMatrix$_(t), i = this._$_GetModelViewMatrix$_(t);
            this._$_viewFrustum$_._$CalculatePlanes$_(i, s);
        }
        _$_IsPointBehindNearPlane$_(t, s, i) {
            return this._$_GetViewFrustum$_()._$IsBehindNearPlane$_(t, s, i);
        }
        _$_SaveToJson$_() {
            const t = {
                d: this._$IsDynamic$_(),
                s: this._$GetOwnScale$_(),
                a: this._$GetOwnAngle$_(),
                v: this._$_IsVisibleFlagSet$_(),
                i: this._$IsInteractive$_(),
                html: this._$IsHTMLElementsLayer$_(),
                bc: this._$_backgroundColor$_.toJSON(),
                t: this._$IsTransparent$_(),
                sx: this._$_scrollX$_,
                sy: this._$_scrollY$_,
                hosp: this._$_hasOwnScrollPosition$_,
                px: this._$GetParallaxX$_(),
                py: this._$GetParallaxY$_(),
                c: this._$_color$_.toJSON(),
                sr: this._$GetScaleRate$_(),
                fx: this._$_effectList$_._$SaveToJson$_(),
                cg: this._$_createdGlobalUids$_
            };
            return t;
        }
        _$_LoadFromJson$_(t) {
            this._$_isDynamic$_ = !!t.d, this._$_scale$_ = t.s, this._$_angle$_ = t.a, 
            this._$_isVisible$_ = !!t.v, this._$_isInteractive$_ = !t.hasOwnProperty("i") || t.i, 
            this._$_isHTMLElementsLayer$_ = !!t.html, this._$_backgroundColor$_._$setFromJSON$_(t.bc), 
            this._$_isTransparent$_ = !!t.t, t.hasOwnProperty("sx") && (this._$_scrollX$_ = t.sx), 
            t.hasOwnProperty("sy") && (this._$_scrollY$_ = t.sy), t.hasOwnProperty("hosp") && (this._$_hasOwnScrollPosition$_ = !!t.hosp), 
            this._$_parallaxX$_ = t.px, this._$_parallaxY$_ = t.py, this._$_color$_._$setFromJSON$_(t.c), 
            this._$_UpdatePremultipliedColor$_(), this._$_scaleRate$_ = t.sr, S._$shallowAssignArray$_(this._$_createdGlobalUids$_, t.cg), 
            S._$shallowAssignArray$_(this._$_initialInstances$_, this._$_startupInitialInstances$_);
            let i = new Set(this._$_createdGlobalUids$_), e = 0;
            for (let t = 0, s = this._$_initialInstances$_.length; t < s; ++t) i.has(this._$_initialInstances$_[t][2]) || (this._$_initialInstances$_[e] = this._$_initialInstances$_[t], 
            ++e);
            S._$truncateArray$_(this._$_initialInstances$_, e), this._$_effectList$_._$LoadFromJson$_(t.fx), 
            this._$_needsRebuildEffectChainSteps$_ = !0;
        }
        _$_LoadFromJsonAfterInstances$_() {
            this._$_SortInstancesByLastCachedZIndex$_(!1), this._$SetZIndicesChanged$_(), 
            this._$_SetMVMatrixChanged$_(), this._$_SetProjectionMatrixChanged$_();
        }
        _$GetILayer$_() {
            return this._$_iLayer$_;
        }
        _$SortAndAddInstancesByZIndex$_(t, s = !1) {
            if (this._$_instances$_.includes(t)) s && this._$_instances$_.sort((t, s) => {
                const i = t._$GetWorldInfo$_()._$GetSceneGraphZIndex$_(), e = s._$GetWorldInfo$_()._$GetSceneGraphZIndex$_();
                return i - e;
            }); else if (t._$HasChildren$_()) {
                const i = [ ...t._$allChildren$_() ];
                i.push(t), i.sort((t, s) => {
                    const i = t._$GetWorldInfo$_()._$GetSceneGraphZIndex$_(), e = s._$GetWorldInfo$_()._$GetSceneGraphZIndex$_();
                    return i - e;
                });
                for (const e of i) if (e._$IsInContainer$_()) for (const h of e._$siblings$_()) if (!i.includes(h)) {
                    const r = [ ...h._$allChildren$_() ];
                    r.push(h), r.sort((t, s) => {
                        const i = t._$GetWorldInfo$_()._$GetSceneGraphZIndex$_(), e = s._$GetWorldInfo$_()._$GetSceneGraphZIndex$_();
                        return i - e;
                    }), r && r.length && i.splice(i.length, 0, ...r);
                }
                for (const n of i) n._$GetPlugin$_()._$IsWorldType$_() && this._$_AddInstance$_(n, !0);
            } else if (t._$GetPlugin$_()._$IsWorldType$_() && this._$_AddInstance$_(t, !0), 
            t._$IsInContainer$_()) for (const o of t._$siblings$_()) {
                const a = [ ...o._$allChildren$_() ];
                if (a.push(o), a.sort((t, s) => {
                    const i = t._$GetWorldInfo$_()._$GetSceneGraphZIndex$_(), e = s._$GetWorldInfo$_()._$GetSceneGraphZIndex$_();
                    return i - e;
                }), a && a.length) for (const l of a) l._$GetPlugin$_()._$IsWorldType$_() && this._$_AddInstance$_(l, !0);
            }
        }
    };
}

{
    let l = function(t, s, i, e) {
        return t[0] === Math.fround(s) && t[1] === Math.fround(i) && t[2] === Math.fround(e);
    }, M = function(t, s) {
        I !== t && (t._$PrepareForDraw$_(s), I = t);
    }, v = (l, M, self._$C3$_), e = self.C3Debugger, h = (v._$New$_(v.Rect), v._$New$_(v.Rect), 
    v._$New$_(v.Rect)), x = v._$New$_(v._$Color$_), t = self._$glMatrix$_, u = t._$vec3$_, a = [], G = [], T = [], _ = [], I = null;
    v._$Layout$_ = class extends v._$DefendedBase$_ {
        constructor(t, s, i) {
            super(), this._$_layoutManager$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), 
            this._$_name$_ = i[0], this._$_originalWidth$_ = i[1], this._$_originalHeight$_ = i[2], 
            this._$_width$_ = i[1], this._$_height$_ = i[2], this._$_isUnboundedScrolling$_ = !!i[3], 
            this._$_isOrthographicProjection$_ = !!i[4], this._$_vanishingPointX$_ = i[5], 
            this._$_vanishingPointY$_ = i[6], this._$_eventSheetName$_ = i[7], this._$_eventSheet$_ = null, 
            this._$_sid$_ = i[8], this._$_index$_ = s, this._$_scrollX$_ = 0, this._$_scrollY$_ = 0, 
            this._$_scale$_ = 1, this._$_angle$_ = 0, this._$_initialObjectClasses$_ = new Set(), 
            this._$_textureLoadedTypes$_ = new Set(), this._$_textureLoadPendingPromises$_ = new Set(), 
            this._$_createdInstances$_ = [], this._$_createdPersistedInstances$_ = [], 
            this._$_createdPersistedInstancesToDataMap$_ = new Map(), this._$_createdPersistedIndexToInstanceMap$_ = new Map(), 
            this._$_initialNonWorld$_ = [], this._$_is3dCameraEnabled$_ = !1, this._$_cam3dposition$_ = u.create(), 
            this._$_cam3dlook$_ = u.create(), this._$_cam3dup$_ = u.create(), this._$_rootLayers$_ = [], 
            this._$_allLayersFlat$_ = [], this._$_layersByName$_ = new Map(), this._$_layersBySid$_ = new Map(), 
            this._$_pendingSetHTMLLayerCount$_ = -1;
            const h = this._$_runtime$_._$GetCanvasManager$_();
            this._$_effectList$_ = v._$New$_(v._$EffectList$_, this, i[11]), this._$_effectChain$_ = v._$New$_(v._$Gfx$_._$EffectChain$_, h._$GetEffectChainManager$_(), {
                _$drawContent$_: (t, s) => {
                    const i = s._$GetContentObject$_(), e = i._$GetRenderTarget$_();
                    t._$ResetColor$_(), t._$DrawRenderTarget$_(e), t._$InvalidateRenderTarget$_(e), 
                    h._$ReleaseAdditionalRenderTarget$_(e);
                },
                _$getShaderParameters$_: t => this._$GetEffectList$_()._$_GetEffectChainShaderParametersForIndex$_(t)
            }), this._$_needsRebuildEffectChainSteps$_ = !0, this._$_wasFullScreenQualityLow$_ = !1, 
            this._$_curRenderTarget$_ = null, this._$_persistData$_ = {}, this._$_persistedIntances$_ = new Map(), 
            this._$_isFirstVisit$_ = !0, this._$_iLayout$_ = new self._$ILayout$_(this), 
            this._$_userScriptDispatcher$_ = v._$New$_(v.Event._$Dispatcher$_);
            for (const e of i[9]) this._$_rootLayers$_.push(v._$Layer$_._$CreateFromExportData$_(this, null, e));
            this._$_ReindexLayers$_();
            for (const r of this._$allLayers$_()) r._$_InitInitialInstances$_();
            for (const n of i[10]) {
                const o = this._$_runtime$_._$GetObjectClassByIndex$_(n[1]);
                if (!o) throw new Error("missing nonworld object class");
                o._$GetDefaultInstanceData$_() || o._$SetDefaultInstanceData$_(n), 
                this._$_initialNonWorld$_.push(n), this._$_AddInitialObjectClass$_(o);
            }
        }
        _$Release$_() {
            for (const t of this._$_allLayersFlat$_) t._$Release$_();
            v._$clearArray$_(this._$_allLayersFlat$_), this._$_textureLoadPendingPromises$_.clear(), 
            this._$_eventSheet$_ = null, this._$_layoutManager$_ = null, this._$_runtime$_ = null;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$GetSID$_() {
            return this._$_sid$_;
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$GetEffectList$_() {
            return this._$_effectList$_;
        }
        _$GetEffectChain$_() {
            return this._$_MaybeRebuildEffectChainSteps$_(), this._$_effectChain$_;
        }
        _$_MaybeRebuildEffectChainSteps$_() {
            const t = "low" === this._$_runtime$_._$GetCanvasManager$_()._$GetCurrentFullscreenScalingQuality$_();
            if (this._$_needsRebuildEffectChainSteps$_ || this._$_wasFullScreenQualityLow$_ !== t || this._$_effectChain$_._$NeedsRebuild$_()) {
                const s = this._$GetEffectList$_()._$GetActiveEffectTypes$_();
                this._$_effectChain$_._$BuildSteps$_(s.map(t => t._$GetShaderProgram$_()), {
                    _$indexMap$_: s.map(t => t._$GetIndex$_()),
                    _$forcePostDraw$_: t,
                    _$useFullSurface$_: !0
                }), this._$_needsRebuildEffectChainSteps$_ = !1, this._$_wasFullScreenQualityLow$_ = t;
            }
        }
        _$UpdateActiveEffects$_() {
            this._$GetEffectList$_()._$UpdateActiveEffects$_(), this._$_needsRebuildEffectChainSteps$_ = !0;
        }
        _$GetMinLayerScale$_() {
            let i = this._$_allLayersFlat$_[0]._$GetNormalScale$_();
            for (let t = 1, s = this._$_allLayersFlat$_.length; t < s; ++t) {
                const e = this._$_allLayersFlat$_[t];
                0 === e._$GetParallaxX$_() && 0 === e._$GetParallaxY$_() || (i = Math.min(i, e._$GetNormalScale$_()));
            }
            return i;
        }
        _$_GetScrollBoundMarginHorizontal$_() {
            return .5 * this._$_runtime$_._$GetViewportWidth$_() / this._$GetMinLayerScale$_();
        }
        _$_GetScrollBoundMarginVertical$_() {
            return .5 * this._$_runtime$_._$GetViewportHeight$_() / this._$GetMinLayerScale$_();
        }
        _$GetScrollLeftBound$_() {
            return this._$IsUnboundedScrolling$_() ? -1 / 0 : this._$_GetScrollBoundMarginHorizontal$_();
        }
        _$GetScrollRightBound$_() {
            return this._$IsUnboundedScrolling$_() ? 1 / 0 : this._$GetWidth$_() - this._$_GetScrollBoundMarginHorizontal$_();
        }
        _$GetScrollTopBound$_() {
            return this._$IsUnboundedScrolling$_() ? -1 / 0 : this._$_GetScrollBoundMarginVertical$_();
        }
        _$GetScrollBottomBound$_() {
            return this._$IsUnboundedScrolling$_() ? 1 / 0 : this._$GetHeight$_() - this._$_GetScrollBoundMarginVertical$_();
        }
        _$SetScrollX$_(t) {
            const s = this._$GetScrollLeftBound$_(), i = this._$GetScrollRightBound$_();
            this._$_scrollX$_ !== (t = (t = i < t ? i : t) < s ? s : t) && (this._$_scrollX$_ = t, 
            this._$_SetAllLayersMVChanged$_(), this._$_runtime$_._$UpdateRender$_());
        }
        _$GetScrollX$_() {
            return this._$_scrollX$_;
        }
        _$SetScrollY$_(t) {
            const s = this._$GetScrollTopBound$_(), i = this._$GetScrollBottomBound$_();
            this._$_scrollY$_ !== (t = (t = i < t ? i : t) < s ? s : t) && (this._$_scrollY$_ = t, 
            this._$_SetAllLayersMVChanged$_(), this._$_runtime$_._$UpdateRender$_());
        }
        _$GetScrollY$_() {
            return this._$_scrollY$_;
        }
        _$IsUnboundedScrolling$_() {
            return this._$_isUnboundedScrolling$_;
        }
        _$BoundScrolling$_() {
            this._$SetScrollX$_(this._$GetScrollX$_()), this._$SetScrollY$_(this._$GetScrollY$_());
            for (const t of this._$_allLayersFlat$_) t._$IsOwnScrollPositionEnabled$_() && (t._$SetScrollX$_(t._$GetScrollX$_()), 
            t._$SetScrollY$_(t._$GetScrollY$_()));
        }
        _$SetVanishingPointXY$_(t, s) {
            this._$_vanishingPointX$_ === t && this._$_vanishingPointY$_ === s || (this._$_vanishingPointX$_ = t, 
            this._$_vanishingPointY$_ = s, this._$IsPerspectiveProjection$_() && (this._$_SetAllLayersProjectionChanged$_(), 
            this._$_SetAllLayersMVChanged$_(), this._$_runtime$_._$UpdateRender$_()));
        }
        _$GetVanishingPointX$_() {
            return this._$IsOrthographicProjection$_() ? .5 : this._$_vanishingPointX$_;
        }
        _$GetVanishingPointY$_() {
            return this._$IsOrthographicProjection$_() ? .5 : this._$_vanishingPointY$_;
        }
        _$HasVanishingPointOutsideViewport$_() {
            const t = this._$GetVanishingPointX$_(), s = this._$GetVanishingPointY$_();
            return t < 0 || 1 < t || s < 0 || 1 < s;
        }
        _$SetPerspectiveProjection$_() {
            this._$_isOrthographicProjection$_ && (this._$_isOrthographicProjection$_ = !1, 
            this._$_SetAllLayersProjectionChanged$_(), this._$_SetAllLayersMVChanged$_(), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$SetOrthographicProjection$_() {
            this._$_isOrthographicProjection$_ || (this._$_isOrthographicProjection$_ = !0, 
            this._$_SetAllLayersProjectionChanged$_(), this._$_SetAllLayersMVChanged$_(), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$IsOrthographicProjection$_() {
            return this._$_isOrthographicProjection$_;
        }
        _$IsPerspectiveProjection$_() {
            return !this._$IsOrthographicProjection$_();
        }
        _$Set3DCameraEnabled$_(t) {
            this._$_is3dCameraEnabled$_ !== (t = !!t) && (this._$_is3dCameraEnabled$_ = t, 
            this._$_SetAllLayersMVChanged$_(), this._$_runtime$_._$UpdateRender$_());
        }
        _$Is3DCameraEnabled$_() {
            return this._$_is3dCameraEnabled$_;
        }
        _$Set3DCameraOrientation$_(t, s, i, e, h, r, n, o, a) {
            l(this._$_cam3dposition$_, t, s, i) && l(this._$_cam3dlook$_, e, h, r) && l(this._$_cam3dup$_, n, o, a) || (u.set(this._$_cam3dposition$_, t, s, i), 
            u.set(this._$_cam3dlook$_, e, h, r), u.set(this._$_cam3dup$_, n, o, a), 
            this._$Set3DCameraChanged$_());
        }
        _$Set3DCameraChanged$_() {
            this._$_SetAllLayersMVChanged$_(), this._$_runtime$_._$UpdateRender$_();
        }
        _$Get3DCameraPosition$_() {
            return this._$_cam3dposition$_;
        }
        _$Get3DCameraLookAt$_() {
            return this._$_cam3dlook$_;
        }
        _$Get3DCameraUpVector$_() {
            return this._$_cam3dup$_;
        }
        _$GetScale$_() {
            return this._$_scale$_;
        }
        _$SetScale$_(t) {
            this._$_scale$_ !== t && (this._$_scale$_ = t, this._$_SetAllLayersMVChanged$_(), 
            this._$BoundScrolling$_(), this._$_runtime$_._$UpdateRender$_());
        }
        _$SetAngle$_(t) {
            t = v._$clampAngle$_(t), this._$_angle$_ !== t && (this._$_angle$_ = t, 
            this._$_SetAllLayersMVChanged$_(), this._$_runtime$_._$UpdateRender$_());
        }
        _$GetAngle$_() {
            return this._$_angle$_;
        }
        _$GetWidth$_() {
            return this._$_width$_;
        }
        _$SetWidth$_(t) {
            !isFinite(t) || t < 1 || (this._$_width$_ = t);
        }
        _$GetHeight$_() {
            return this._$_height$_;
        }
        _$SetHeight$_(t) {
            !isFinite(t) || t < 1 || (this._$_height$_ = t);
        }
        _$GetEventSheet$_() {
            return this._$_eventSheet$_;
        }
        _$_GetRootLayers$_() {
            return this._$_rootLayers$_;
        }
        *_$allLayers$_() {
            for (const t of this._$_rootLayers$_) yield* t._$selfAndAllSubLayers$_();
        }
        _$GetLayers$_() {
            return this._$_allLayersFlat$_;
        }
        _$GetLayerCount$_() {
            return this._$_allLayersFlat$_.length;
        }
        _$GetLayer$_(t) {
            return "number" == typeof t ? this._$GetLayerByIndex$_(t) : this._$GetLayerByName$_(t.toString());
        }
        _$GetLayerByIndex$_(t) {
            return t = v._$clamp$_(Math.floor(t), 0, this._$_allLayersFlat$_.length - 1), 
            this._$_allLayersFlat$_[t];
        }
        _$GetLayerByName$_(t) {
            return this._$_layersByName$_.get(t.toLowerCase()) || null;
        }
        _$HasLayerByName$_(t) {
            return !!this._$GetLayerByName$_(t);
        }
        _$GetLayerBySID$_(t) {
            return this._$_layersBySid$_.get(t) || null;
        }
        _$_SetAllLayersProjectionChanged$_() {
            for (const t of this._$_allLayersFlat$_) t._$_SetProjectionMatrixChanged$_();
        }
        _$_SetAllLayersMVChanged$_() {
            for (const t of this._$_allLayersFlat$_) t._$_SetMVMatrixChanged$_();
        }
        _$AddLayer$_(t, s, i) {
            if (this._$HasLayerByName$_(t)) throw new Error(`layer name '${t}' already in use`);
            if (!s && i < 2) throw new Error("invalid insert position");
            const e = 2 <= i ? s : s._$GetParentLayer$_(), h = v._$New$_(v._$Layer$_, this, e, {
                name: t,
                sid: Math.floor(1e15 * Math.random()),
                _$isDynamic$_: !0
            });
            this._$_InsertLayer$_(h, s, i), this._$GetRuntime$_()._$UpdateRender$_(), 
            this._$_ReindexAndUpdateAllLayers$_();
        }
        _$MoveLayer$_(t, s, i) {
            if (!s && i < 2) throw new Error("invalid insert position");
            t === s && i < 2 || (this._$_RemoveLayer$_(t), this._$_InsertLayer$_(t, s, i), 
            this._$GetRuntime$_()._$UpdateRender$_(), this._$_ReindexAndUpdateAllLayers$_());
        }
        _$RemoveLayer$_(t) {
            if (this._$_RemoveLayer$_(t)) {
                const s = this._$_runtime$_._$GetEventSheetManager$_();
                s._$BlockFlushingInstances$_(!0), t._$Release$_(), s._$BlockFlushingInstances$_(!1), 
                this._$GetRuntime$_()._$UpdateRender$_(), this._$_ReindexAndUpdateAllLayers$_();
            }
        }
        _$RemoveAllDynamicLayers$_() {
            const t = new Set();
            for (const s of this._$allLayers$_()) s._$IsDynamic$_() && !s._$HasAnyDynamicParentLayer$_() && t.add(s);
            if (0 !== t.size) {
                const i = this._$_runtime$_._$GetEventSheetManager$_();
                i._$BlockFlushingInstances$_(!0);
                for (const e of t) this._$_RemoveLayer$_(e), e._$Release$_();
                i._$BlockFlushingInstances$_(!1), this._$GetRuntime$_()._$UpdateRender$_(), 
                this._$_ReindexAndUpdateAllLayers$_();
            }
        }
        _$_InsertLayer$_(s, i, e) {
            if (2 <= e) if (i) {
                if (i === s || i._$HasParentLayer$_(s)) throw new Error(`cannot move layer '${s._$GetName$_()}' to sub-layer of itself`);
                i._$_AddSubLayer$_(s, 2 === e), s._$_SetParentLayer$_(i);
            } else 2 === e ? this._$_rootLayers$_.push(s) : this._$_rootLayers$_.unshift(s), 
            s._$_SetParentLayer$_(null); else {
                const t = i._$GetParentLayer$_();
                if (t) {
                    if (i._$HasParentLayer$_(s)) throw new Error(`cannot move layer '${s._$GetName$_()}' to sub-layer of itself`);
                    t._$_InsertSubLayer$_(s, i, 0 === e), s._$_SetParentLayer$_(t);
                } else {
                    let t = this._$_rootLayers$_.indexOf(i);
                    if (-1 === t) throw new Error("cannot find layer to insert by");
                    0 === e && ++t, this._$_rootLayers$_.splice(t, 0, s), s._$_SetParentLayer$_(null);
                }
            }
        }
        _$_RemoveLayer$_(t) {
            const s = t._$GetParentLayer$_();
            if (s) return s._$_RemoveSubLayer$_(t), !0;
            if (1 < this._$_rootLayers$_.length) {
                const i = this._$_rootLayers$_.indexOf(t);
                if (-1 === i) throw new Error("cannot find layer to remove");
                return this._$_rootLayers$_.splice(i, 1), !0;
            }
            return !1;
        }
        _$_ReindexLayers$_() {
            this._$_allLayersFlat$_ = [ ...this._$allLayers$_() ], this._$_layersByName$_.clear(), 
            this._$_layersBySid$_.clear();
            for (let t = 0, s = this._$_allLayersFlat$_.length; t < s; ++t) {
                const i = this._$_allLayersFlat$_[t];
                i._$_SetIndex$_(t), this._$_layersByName$_.set(i._$GetName$_().toLowerCase(), i), 
                this._$_layersBySid$_.set(i._$GetSID$_(), i);
            }
        }
        _$_ReindexHTMLLayers$_() {
            let t = 0;
            for (const s of this._$_rootLayers$_) {
                for (const i of s._$selfAndAllSubLayers$_()) i._$_SetHTMLIndex$_(t);
                s._$IsHTMLElementsLayer$_() && t++;
            }
        }
        _$GetHTMLLayerCount$_() {
            return this._$_rootLayers$_.at(-1)._$GetHTMLIndex$_() + 1;
        }
        async _$_ReindexAndUpdateAllLayers$_() {
            this._$_ReindexLayers$_(), this._$_ReindexHTMLLayers$_(), this._$_pendingSetHTMLLayerCount$_ = this._$GetHTMLLayerCount$_();
        }
        _$_GetPendingSetHTMLLayerCount$_() {
            return this._$_pendingSetHTMLLayerCount$_;
        }
        _$_ResetPendingHTMLLayerCount$_() {
            this._$_pendingSetHTMLLayerCount$_ = -1;
        }
        _$GetRootLayersForHTMLLayer$_(t) {
            const s = [];
            for (const i of this._$_rootLayers$_) {
                const e = i._$GetHTMLIndex$_();
                if (e === t) s.push(i); else if (t < e) break;
            }
            return s;
        }
        _$SaveTransform$_() {
            return {
                scrollX: this._$GetScrollX$_(),
                scrollY: this._$GetScrollY$_(),
                scale: this._$GetScale$_(),
                angle: this._$GetAngle$_(),
                vpX: this._$GetVanishingPointX$_(),
                vpY: this._$GetVanishingPointY$_()
            };
        }
        _$RestoreTransform$_(t) {
            this._$SetScrollX$_(t.scrollX), this._$SetScrollY$_(t.scrollY), this._$SetScale$_(t.scale), 
            this._$SetAngle$_(t.angle), this._$SetVanishingPointXY$_(t.vpX, t.vpY);
        }
        _$GetLayoutBackgroundColor$_() {
            let t = this._$_rootLayers$_.filter(t => t._$ShouldDraw$_())[0];
            for (;t; ) {
                if (!t._$IsTransparent$_()) return x._$copyRgb$_(t._$GetBackgroundColor$_()), 
                x._$setA$_(1), x;
                if (t._$UsesOwnTexture$_()) return x._$setRgba$_(0, 0, 0, 0), x;
                t = t._$GetSubLayers$_().filter(t => t._$ShouldDraw$_())[0];
            }
            return x._$setRgba$_(0, 0, 0, 0), x;
        }
        _$IsFirstVisit$_() {
            return this._$_isFirstVisit$_;
        }
        _$_GetInitialObjectClasses$_() {
            return [ ...this._$_initialObjectClasses$_ ];
        }
        _$_AddInitialObjectClass$_(t) {
            if (t._$IsInContainer$_()) for (const s of t._$GetContainer$_()._$GetObjectTypes$_()) this._$_initialObjectClasses$_.add(s); else this._$_initialObjectClasses$_.add(t);
        }
        _$_GetTextureLoadedObjectTypes$_() {
            return [ ...this._$_textureLoadedTypes$_ ];
        }
        _$_Load$_(t, s) {
            if (t === this || !s) return Promise.resolve();
            t && (v._$CopySet$_(this._$_textureLoadedTypes$_, t._$_textureLoadedTypes$_), 
            t._$_textureLoadedTypes$_.clear());
            const i = [];
            for (const e of this._$_initialObjectClasses$_) this._$_textureLoadedTypes$_.has(e) || (i.push(e._$LoadTextures$_(s)), 
            this._$_textureLoadedTypes$_.add(e));
            return Promise.all(i);
        }
        async _$MaybeLoadTexturesFor$_(t) {
            if (t._$IsFamily$_()) throw new Error("cannot load textures for family");
            const s = this._$_runtime$_._$GetRenderer$_();
            if (s && !s._$IsContextLost$_() && !this._$_textureLoadedTypes$_.has(t)) {
                this._$_textureLoadedTypes$_.add(t);
                const i = t._$LoadTextures$_(s);
                this._$_AddPendingTextureLoadPromise$_(i), await i, t._$OnDynamicTextureLoadComplete$_(), 
                this._$_runtime$_._$UpdateRender$_();
            }
        }
        _$_AddPendingTextureLoadPromise$_(t) {
            this._$_textureLoadPendingPromises$_.add(t), t.then(() => this._$_textureLoadPendingPromises$_.delete(t)).catch(() => this._$_textureLoadPendingPromises$_.delete(t));
        }
        _$WaitForPendingTextureLoadsToComplete$_() {
            return Promise.all([ ...this._$_textureLoadPendingPromises$_ ]);
        }
        _$MaybeUnloadTexturesFor$_(t) {
            if (t._$IsFamily$_() || 0 < t._$GetInstanceCount$_()) throw new Error("cannot unload textures");
            const s = this._$_runtime$_._$GetRenderer$_();
            s && this._$_textureLoadedTypes$_.has(t) && (this._$_textureLoadedTypes$_.delete(t), 
            t._$ReleaseTextures$_(s));
        }
        _$_Unload$_(t, s) {
            if (t !== this && s) for (const i of this._$_textureLoadedTypes$_) i._$IsGlobal$_() || t._$_initialObjectClasses$_.has(i) || (i._$ReleaseTextures$_(), 
            this._$_textureLoadedTypes$_.delete(i));
        }
        _$_OnRendererContextLost$_() {
            this._$_textureLoadedTypes$_.clear();
        }
        async _$_StartRunning$_(t) {
            const s = this._$_runtime$_, i = this._$_layoutManager$_, e = s._$GetEventSheetManager$_(), h = (this._$_eventSheetName$_ && (this._$_eventSheet$_ = e._$GetEventSheetByName$_(this._$_eventSheetName$_), 
            this._$_eventSheet$_._$_UpdateDeepIncludes$_()), i._$_SetMainRunningLayout$_(this), 
            this._$_width$_ = this._$_originalWidth$_, this._$_height$_ = this._$_originalHeight$_, 
            this._$_scrollX$_ = s._$GetOriginalViewportWidth$_() / 2, this._$_scrollY$_ = s._$GetOriginalViewportHeight$_() / 2, 
            this._$BoundScrolling$_(), this._$_SetAllLayersProjectionChanged$_(), 
            this._$_SetAllLayersMVChanged$_(), this._$_ReindexHTMLLayers$_(), await this._$_runtime$_._$GetCanvasManager$_()._$SetHTMLLayerCount$_(this._$GetHTMLLayerCount$_(), !0), 
            this._$_MoveGlobalObjectsToThisLayout$_(t), this._$_runtime$_._$SetUsingCreatePromises$_(!0), 
            this._$_CreateInitialInstances$_(), this._$_isFirstVisit$_ || this._$_CreatePersistedInstances$_(), 
            this._$_CreateAndLinkContainerInstances$_(this._$_createdInstances$_), 
            this._$_CreateAndLinkContainerInstances$_(this._$_createdPersistedInstances$_), 
            this._$_CreateInitialNonWorldInstances$_(), i._$ClearPendingChangeLayout$_(), 
            s._$FlushPendingInstances$_(), this._$_runtime$_._$SetUsingCreatePromises$_(!1), 
            this._$_runtime$_._$GetCreatePromises$_());
            if (await Promise.all(h), v._$clearArray$_(h), !s._$IsLoadingState$_()) {
                for (const r of this._$_createdInstances$_) r._$SetupInitialSceneGraphConnections$_();
                for (const n of this._$_createdPersistedInstances$_) n._$SetupPersistedSceneGraphConnections$_(this._$_createdPersistedInstancesToDataMap$_, this._$_createdPersistedIndexToInstanceMap$_);
                for (const [ o, a ] of Object.entries(this._$_persistData$_)) {
                    const l = this._$_runtime$_._$GetObjectClassBySID$_(parseInt(o, 10));
                    l && !l._$IsFamily$_() && l._$HasPersistBehavior$_() && v._$clearArray$_(a);
                }
                for (const u of this._$_createdInstances$_) u._$_TriggerOnCreated$_();
                for (const c of this._$_createdPersistedInstances$_) c._$_TriggerOnCreated$_();
            }
            v._$clearArray$_(this._$_createdInstances$_), v._$clearArray$_(this._$_createdPersistedInstances$_), 
            this._$_createdPersistedInstancesToDataMap$_.clear(), this._$_createdPersistedIndexToInstanceMap$_.clear(), 
            await Promise.all([ ...this._$_initialObjectClasses$_ ].map(t => t._$PreloadTexturesWithInstances$_(this._$_runtime$_._$GetRenderer$_()))), 
            t && (s._$Dispatcher$_().dispatchEvent(new v.Event("beforefirstlayoutstart")), 
            await s._$DispatchUserScriptEventAsyncWait$_(new v.Event("beforeprojectstart"))), 
            await this._$DispatchRuntimeUserScriptEventAsyncWait$_(new v.Event("beforeanylayoutstart")), 
            s._$Dispatcher$_().dispatchEvent(new v.Event("beforelayoutstart")), 
            await this._$DispatchUserScriptEventAsyncWait$_(new v.Event("beforelayoutstart")), 
            s._$IsLoadingState$_() || await s._$TriggerAsync$_(v._$Plugins$_._$System$_._$Cnds$_._$OnLayoutStart$_, null, null), 
            s._$Dispatcher$_().dispatchEvent(new v.Event("afterlayoutstart")), await this._$DispatchUserScriptEventAsyncWait$_(new v.Event("afterlayoutstart")), 
            await this._$DispatchRuntimeUserScriptEventAsyncWait$_(new v.Event("afteranylayoutstart")), 
            t && (s._$Dispatcher$_().dispatchEvent(new v.Event("afterfirstlayoutstart")), 
            await s._$DispatchUserScriptEventAsyncWait$_(new v.Event("afterprojectstart"))), 
            e._$_RunQueuedTriggers$_(i), await this._$WaitForPendingTextureLoadsToComplete$_(), 
            this._$_isFirstVisit$_ = !1;
        }
        _$_MoveGlobalObjectsToThisLayout$_(t) {
            for (const s of this._$_runtime$_._$GetAllObjectClasses$_()) if (!s._$IsFamily$_() && s._$IsWorldType$_()) for (const i of s._$GetInstances$_()) {
                const e = i._$GetWorldInfo$_(), h = e._$GetLayer$_(), r = v._$clamp$_(h._$GetIndex$_(), 0, this._$_allLayersFlat$_.length - 1), n = this._$_allLayersFlat$_[r];
                e._$_SetLayer$_(n, !0), n._$_MaybeAddInstance$_(i);
            }
            if (!t) for (const o of this._$_allLayersFlat$_) o._$_SortInstancesByLastCachedZIndex$_(!1);
        }
        _$_CreateInitialInstances$_() {
            for (const t of this._$_allLayersFlat$_) t._$CreateInitialInstances$_(this._$_createdInstances$_), 
            t._$_Start$_();
        }
        _$_CreatePersistedInstances$_() {
            let s = !1;
            for (const [ t, i ] of Object.entries(this._$_persistData$_)) {
                const e = this._$_runtime$_._$GetObjectClassBySID$_(parseInt(t, 10));
                if (e && !e._$IsFamily$_() && e._$HasPersistBehavior$_()) for (const h of i) {
                    let t = null;
                    if (!e._$IsWorldType$_() || (t = h.hasOwnProperty("instJson") ? this._$GetLayerBySID$_(h.instJson.w.l) : this._$GetLayerBySID$_(h.w.l))) {
                        const r = this._$_runtime$_._$CreateInstanceFromData$_(e, t, !1, 0, 0, !0);
                        h.hasOwnProperty("instJson") ? r._$LoadFromJson$_(h.instJson) : r._$LoadFromJson$_(h), 
                        s = !0, this._$_createdPersistedInstances$_.push(r), h.hasOwnProperty("instJson") && (this._$_createdPersistedInstancesToDataMap$_.set(r, h), 
                        this._$_createdPersistedIndexToInstanceMap$_.set(h.index, r));
                    }
                }
            }
            for (const n of this._$_allLayersFlat$_) n._$_SortInstancesByLastCachedZIndex$_(!0), 
            n._$SetZIndicesChanged$_();
            s && (this._$_runtime$_._$FlushPendingInstances$_(), this._$_runtime$_._$_RefreshUidMap$_());
        }
        _$_CreateAndLinkContainerInstances$_(s) {
            for (const i of s) if (i._$IsInContainer$_()) {
                const e = i._$GetWorldInfo$_(), t = i._$GetIID$_();
                for (const h of i._$GetObjectClass$_()._$GetContainer$_()._$objectTypes$_()) if (h !== i._$GetObjectClass$_()) {
                    const r = h._$GetInstances$_();
                    if (r.length > t) i._$_AddSibling$_(r[t]); else {
                        let t;
                        t = e ? this._$_runtime$_._$CreateInstanceFromData$_(h, e._$GetLayer$_(), !0, e._$GetX$_(), e._$GetY$_(), !0) : this._$_runtime$_._$CreateInstanceFromData$_(h, null, !0, 0, 0, !0), 
                        this._$_runtime$_._$FlushPendingInstances$_(), h._$_UpdateIIDs$_(), 
                        i._$_AddSibling$_(t), s.push(t);
                    }
                }
            }
        }
        _$_CreateInitialNonWorldInstances$_() {
            for (const t of this._$_initialNonWorld$_) {
                const s = this._$_runtime$_._$GetObjectClassByIndex$_(t[1]);
                s._$IsInContainer$_() || this._$_runtime$_._$CreateInstanceFromData$_(t, null, !0);
            }
        }
        _$_CreateGlobalNonWorlds$_() {
            let i = [], e = this._$_initialNonWorld$_, h = 0;
            for (let t = 0, s = e.length; t < s; ++t) {
                const r = e[t], n = this._$_runtime$_._$GetObjectClassByIndex$_(r[1]);
                n._$IsGlobal$_() ? n._$IsInContainer$_() && n._$GetContainer$_()._$HasAnyWorldType$_() || i.push(this._$_runtime$_._$CreateInstanceFromData$_(r, null, !0)) : (e[h] = r, 
                ++h);
            }
            v._$truncateArray$_(e, h), this._$_runtime$_._$FlushPendingInstances$_(), 
            this._$_CreateAndLinkContainerInstances$_(i);
        }
        _$RecreateInitialObjects$_(t, s, i, e, h, r, n) {
            if (i) return i._$RecreateInitialObjects$_(t, s, h, r, e, n);
            {
                const o = [];
                for (const a of this._$_allLayersFlat$_) o.push(a._$RecreateInitialObjects$_(t, s, h, r, e, n));
                return o.flat();
            }
        }
        async _$_StopRunning$_() {
            const t = this._$_layoutManager$_;
            this._$_runtime$_._$IsLoadingState$_() || (await this._$DispatchRuntimeUserScriptEventAsyncWait$_(new v.Event("beforeanylayoutend")), 
            await this._$DispatchUserScriptEventAsyncWait$_(new v.Event("beforelayoutend")), 
            await this._$_runtime$_._$TriggerAsync$_(v._$Plugins$_._$System$_._$Cnds$_._$OnLayoutEnd$_, null, null), 
            await this._$DispatchUserScriptEventAsyncWait$_(new v.Event("afterlayoutend")), 
            await this._$DispatchRuntimeUserScriptEventAsyncWait$_(new v.Event("afteranylayoutend"))), 
            t._$SetIsEndingLayout$_(!0), this._$_runtime$_._$GetEventSheetManager$_()._$ClearAllScheduledWaits$_(), 
            this._$_isFirstVisit$_ || this._$_SavePersistData$_();
            for (const s of this._$_allLayersFlat$_) s._$_End$_();
            for (const i of this._$_runtime$_._$GetAllObjectClasses$_()) if (!(i._$IsGlobal$_() || i._$IsWorldType$_() || i._$GetPlugin$_()._$IsSingleGlobal$_() || i._$IsFamily$_())) {
                for (const e of i._$GetInstances$_()) this._$_runtime$_._$DestroyInstance$_(e);
                this._$_runtime$_._$FlushPendingInstances$_();
            }
            t._$SetIsEndingLayout$_(!1), t._$GetMainRunningLayout$_() === this && t._$_SetMainRunningLayout$_(null);
        }
        _$_SaveInstanceToPersist$_(t, s) {
            const i = t._$GetObjectClass$_()._$GetSID$_().toString(), e = (this._$_persistData$_.hasOwnProperty(i) || (this._$_persistData$_[i] = []), 
            this._$_persistData$_[i]), h = {
                index: s,
                instJson: t._$SaveToJson$_(),
                sceneGraphJson: {
                    children: []
                }
            };
            e.push(h), this._$_persistedIntances$_.set(t, h);
        }
        _$_SaveSceneGraphInfoToPersist$_(t) {
            const s = this._$_persistedIntances$_.get(t);
            for (const i of t._$GetChildren$_()) {
                const e = this._$_persistedIntances$_.get(i);
                e && s.sceneGraphJson.children.push({
                    index: e.index,
                    flags: v._$SceneGraphInfo$_._$_GetFlagsNumber$_(i._$GetWorldInfo$_())
                });
            }
        }
        _$_SavePersistData$_() {
            this._$_persistedIntances$_.clear();
            let t = 0;
            for (const s of this._$_allLayersFlat$_) {
                s._$_UpdateZIndices$_();
                for (const i of s._$_GetInstances$_()) {
                    const e = i._$GetObjectClass$_();
                    !e._$IsGlobal$_() && e._$HasPersistBehavior$_() && (this._$_SaveInstanceToPersist$_(i, t), 
                    t++);
                }
            }
            for (const h of this._$_allLayersFlat$_) for (const r of h._$_GetInstances$_()) {
                const n = r._$GetObjectClass$_();
                !n._$IsGlobal$_() && n._$HasPersistBehavior$_() && this._$_SaveSceneGraphInfoToPersist$_(r);
            }
            this._$_persistedIntances$_.clear();
        }
        _$ResetPersistData$_() {
            this._$_persistData$_ = {}, this._$_isFirstVisit$_ = !0;
        }
        _$GetRenderTarget$_() {
            return this._$_curRenderTarget$_;
        }
        _$UsesOwnTexture$_() {
            const t = this._$_runtime$_, s = t._$GetRenderer$_()._$IsWebGL$_();
            return "low" === t._$GetCanvasManager$_()._$GetCurrentFullscreenScalingQuality$_() || s && t._$UsesAnyBackgroundBlending$_() || this._$_effectList$_._$HasAnyActiveEffect$_() || s && t._$Uses3DFeatures$_();
        }
        _$_MaybeStartDrawToOwnTexture$_(t) {
            const s = this._$_runtime$_._$GetCanvasManager$_();
            if (this._$UsesOwnTexture$_()) {
                t._$SetRenderTarget$_(null), t._$ClearRgba$_(0, 0, 0, 0);
                const i = {
                    _$sampling$_: this._$_runtime$_._$GetSampling$_(),
                    _$isSampled$_: t._$IsWebGPU$_() || this._$_runtime$_._$UsesAnyBackgroundBlending$_() || this._$_effectList$_._$HasAnyActiveEffect$_(),
                    _$canReadPixels$_: !!t._$IsWebGPU$_() && this._$_runtime$_._$UsesAnyBackgroundBlending$_()
                };
                "low" === s._$GetCurrentFullscreenScalingQuality$_() && (i.width = s._$GetDrawWidth$_(), 
                i.height = s._$GetDrawHeight$_()), this._$_curRenderTarget$_ = this._$_runtime$_._$GetAdditionalRenderTarget$_(i);
            } else this._$_curRenderTarget$_ = null;
        }
        _$_MaybeCopyOwnTextureToBackbuffer$_(t) {
            this._$_runtime$_._$_NeedsHTMLLayerCompositing$_(t) && (t._$SetDepthEnabled$_(!1), 
            t._$SetRenderTarget$_(null), t._$SetTextureFillMode$_(), t._$CopyRenderTarget$_(this._$_curRenderTarget$_));
        }
        _$_MaybeEndDrawToOwnTexture$_(t) {
            this._$UsesOwnTexture$_() && (t._$SetDepthEnabled$_(!1), this._$_DrawLayoutOwnTextureToRenderTarget$_(t, this._$_curRenderTarget$_));
        }
        _$DrawMain$_(t) {
            t._$SetRenderTarget$_(this._$_curRenderTarget$_), t._$Clear$_(this._$GetLayoutBackgroundColor$_()), 
            this._$_runtime$_._$Uses3DFeatures$_() && t._$ClearDepth$_();
            const s = this._$GetRootLayersForHTMLLayer$_(0);
            this._$_DrawLayerList$_(t, this._$_curRenderTarget$_, s, !0), t._$IsWebGPU$_() && t.StartMeasuringRenderPassTime(0, 1), 
            this._$_MaybeEndDrawToOwnTexture$_(t), this._$_curRenderTarget$_ = null;
        }
        _$DrawForHTMLLayerIndex$_(t, s) {
            let i = null;
            this._$_runtime$_._$_NeedsHTMLLayerCompositing$_(t) && (i = this._$_curRenderTarget$_), 
            t._$SetRenderTarget$_(i), t._$ClearRgba$_(0, 0, 0, 0), this._$_runtime$_._$Uses3DFeatures$_() && t._$ClearDepth$_();
            const e = this._$GetRootLayersForHTMLLayer$_(s);
            this._$_DrawLayerList$_(t, i, e, !0), this._$_MaybeCopyOwnTextureToBackbuffer$_(t), 
            t._$EndBatch$_(), this._$_runtime$_._$GetCanvasManager$_()._$BlitMainCanvasToHTMLLayerCanvas$_(s);
        }
        _$_DrawLayerList$_(t, e, s, h) {
            const r = s.filter(t => t._$ShouldDraw$_());
            for (let s = 0, i = r.length; s < i; ) {
                const n = r[s];
                if (n._$SelfAndAllSubLayersHave3DCamera$_() && !n._$SelfOrAnySubLayerUsesOwnTexture$_()) {
                    a.push(n);
                    for (let t = s + 1; t < i; ++t) {
                        const o = r[t];
                        if (!o._$SelfAndAllSubLayersHave3DCamera$_() || o._$SelfOrAnySubLayerUsesOwnTexture$_()) break;
                        a.push(r[t]);
                    }
                    if (2 <= a.length || 1 === a.length && a[0]._$HasAnyVisibleSubLayer$_()) {
                        this._$_Draw3DLayers$_(t, e, a), s += a.length, v._$clearArray$_(a);
                        continue;
                    }
                    v._$clearArray$_(a);
                }
                n._$Draw$_(t, e, h && 0 === s), ++s;
            }
        }
        _$_DrawLayoutOwnTextureToRenderTarget$_(t, s) {
            const i = this._$_effectList$_._$GetActiveEffectTypes$_(), e = this._$_runtime$_;
            0 === i.length ? (t._$SetRenderTarget$_(null), t._$SetTextureFillMode$_(), 
            t._$CopyRenderTarget$_(s), t._$InvalidateRenderTarget$_(s), e._$ReleaseAdditionalRenderTarget$_(s)) : (h.set(0, 0, e._$GetViewportWidth$_(), e._$GetViewportHeight$_()), 
            this._$GetEffectChain$_()._$Render$_(t, null, {
                _$contentObject$_: this,
                _$blendMode$_: 3,
                devicePixelRatio: this._$_runtime$_._$GetEffectDevicePixelRatioParam$_(),
                _$layerScale$_: this._$_runtime$_._$GetEffectLayerScaleParam$_() * this._$GetScale$_(),
                _$layerAngle$_: this._$GetAngle$_(),
                _$layoutRect$_: h,
                _$drawSurfaceRect$_: null,
                _$invalidateRenderTargets$_: !0
            }));
        }
        _$_Draw3DLayers$_(e, h, t) {
            t[0]._$IsTransparent$_() || (x._$copyRgb$_(t[0]._$GetBackgroundColor$_()), 
            x._$setA$_(1), e._$Clear$_(x));
            this._$_runtime$_._$GetCanvasManager$_();
            e._$SetDepthEnabled$_(!0);
            const r = G, n = T, o = _;
            for (const a of t) a._$_UpdateZIndices$_(), a._$_AppendAllInstancesIncludingSubLayersInDrawOrder$_(r);
            const s = t[0], i = s._$_MaybeStartWebGLProfiling$_(e);
            s._$_MaybeStartWebGPUProfiling$_(e);
            for (let s = 0, i = r.length; s < i; ) {
                const l = r[s], u = l._$GetWorldInfo$_(), c = u._$GetLayer$_();
                if (u._$IsVisible$_() && u._$IsInViewport3D$_(c._$_GetViewFrustum$_())) {
                    (!l._$RendersToOwnZPlane$_() || 0 < u._$GetDepth$_()) && o.push(l);
                    const f = l._$GetWorldInfo$_()._$GetTotalZElevation$_();
                    n.push(l);
                    let t = s + 1;
                    for (;t < i; ++t) {
                        const d = r[t], p = d._$GetWorldInfo$_();
                        if (p._$IsVisible$_() && p._$IsInViewport3D$_(p._$GetLayer$_()._$_GetViewFrustum$_())) {
                            if (p._$GetTotalZElevation$_() !== f) break;
                            (d._$RendersToOwnZPlane$_() ? (0 < p._$GetDepth$_() && o.push(d), 
                            n) : o).push(d);
                        }
                    }
                    if (1 !== n.length || n[0]._$MustMitigateZFighting$_()) {
                        this._$_Draw3DLayersCoplanarInstances$_(e, h, n);
                        for (let t = 0, s = o.length; t < s; ++t) {
                            const m = o[t], g = m._$GetWorldInfo$_(), y = g._$GetLayer$_();
                            g._$_SetDrawNonBackFacesOnly$_(!0), M(y, e), y._$_DrawInstanceMaybeWithEffects$_(m, g, e, h), 
                            g._$_SetDrawNonBackFacesOnly$_(!1);
                        }
                    } else {
                        M(c, e), c._$_DrawInstanceMaybeWithEffects$_(l, u, e, h);
                        for (let t = 0, s = o.length; t < s; ++t) {
                            const w = o[t];
                            if (w !== l) {
                                const S = w._$GetWorldInfo$_(), b = S._$GetLayer$_();
                                M(b, e), b._$_DrawInstanceMaybeWithEffects$_(w, S, e, h);
                            }
                        }
                    }
                    s = t, v._$clearArray$_(n), v._$clearArray$_(o);
                } else ++s;
            }
            i && e._$EndQuery$_(i), v._$clearArray$_(r), I = null;
        }
        _$_Draw3DLayersCoplanarInstances$_(i, e, h) {
            i._$CoplanarStartStencilPass$_();
            for (let t = 0, s = h.length; t < s; ++t) {
                const r = h[t], n = r._$GetWorldInfo$_(), o = n._$GetLayer$_();
                n._$_SetDrawBackFaceOnly$_(!0), M(o, i), o._$_DrawInstance$_(r, n, i);
            }
            i._$CoplanarStartColorPass$_();
            for (let t = 0, s = h.length; t < s; ++t) {
                const a = h[t], l = a._$GetWorldInfo$_(), u = l._$GetLayer$_();
                M(u, i), u._$_DrawInstanceMaybeWithEffects$_(a, l, i, e), l._$_SetDrawBackFaceOnly$_(!1);
            }
            i._$CoplanarRestoreStandardRendering$_();
        }
        _$_SaveToJson$_() {
            const t = {
                sx: this._$GetScrollX$_(),
                sy: this._$GetScrollY$_(),
                s: this._$GetScale$_(),
                a: this._$GetAngle$_(),
                w: this._$GetWidth$_(),
                h: this._$GetHeight$_(),
                ortho: this._$IsOrthographicProjection$_(),
                vpX: this._$GetVanishingPointX$_(),
                vpY: this._$GetVanishingPointY$_(),
                fv: this._$_isFirstVisit$_,
                persist: this._$_persistData$_,
                fx: this._$_effectList$_._$SaveToJson$_(),
                layers: {},
                dynamicLayers: []
            };
            for (const s of this._$_allLayersFlat$_) if (s._$IsDynamic$_()) {
                const i = s._$GetParentLayer$_();
                t.dynamicLayers.push({
                    sid: s._$GetSID$_(),
                    name: s._$GetName$_(),
                    parentSid: i ? i._$GetSID$_() : null,
                    siblingIndex: s._$_GetSiblingIndex$_(),
                    data: s._$_SaveToJson$_()
                });
            } else t.layers[s._$GetSID$_().toString()] = s._$_SaveToJson$_();
            return t;
        }
        _$_LoadFromJson$_(t) {
            this._$_scrollX$_ = t.sx, this._$_scrollY$_ = t.sy, this._$_scale$_ = t.s, 
            this._$_angle$_ = t.a, this._$_width$_ = t.w, this._$_height$_ = t.h, 
            this._$_isOrthographicProjection$_ = !!t.ortho, t.hasOwnProperty("vpX") && (this._$_vanishingPointX$_ = t.vpX), 
            t.hasOwnProperty("vpY") && (this._$_vanishingPointY$_ = t.vpY), this._$_isFirstVisit$_ = !!t.fv, 
            this._$_persistData$_ = t.persist, this._$_effectList$_._$LoadFromJson$_(t.fx), 
            this._$_needsRebuildEffectChainSteps$_ = !0;
            for (const [ s, i ] of Object.entries(t.layers)) {
                const e = parseInt(s, 10), h = this._$GetLayerBySID$_(e);
                h && h._$_LoadFromJson$_(i);
            }
            if (t.hasOwnProperty("dynamicLayers")) {
                this._$RemoveAllDynamicLayers$_(), this._$_runtime$_._$FlushPendingInstances$_();
                const r = new Map(), n = t.dynamicLayers;
                for (let t = n.length - 1; 0 <= t; --t) {
                    const o = n[t], a = o.sid, l = o.name, u = o.parentSid, c = o.siblingIndex, f = o.data;
                    if (this._$_ReindexLayers$_(), !this._$HasLayerByName$_(l) && !this._$GetLayerBySID$_(a)) {
                        let t, s;
                        if (null === u) t = null, s = this._$_rootLayers$_; else {
                            if (!(t = this._$GetLayerBySID$_(u))) continue;
                            s = t._$GetSubLayers$_();
                        }
                        const d = v._$New$_(v._$Layer$_, this, t, {
                            name: l,
                            sid: a,
                            _$isDynamic$_: !0
                        });
                        s.push(d);
                        let i = r.get(s);
                        i || (i = [], r.set(s, i)), i.push({
                            _$layer$_: d,
                            siblingIndex: c
                        }), d._$_LoadFromJson$_(f);
                    }
                }
                for (const [ p, m ] of r) {
                    m.sort((t, s) => t.siblingIndex - s.siblingIndex);
                    for (const g of m) {
                        let t = g._$layer$_, s = g.siblingIndex, i = p.indexOf(t);
                        p.splice(i, 1), p.splice(s, 0, t);
                    }
                }
            }
            this._$_ReindexAndUpdateAllLayers$_(), this._$_SetAllLayersProjectionChanged$_(), 
            this._$_SetAllLayersMVChanged$_();
        }
        _$GetILayout$_() {
            return this._$_iLayout$_;
        }
        _$UserScriptDispatcher$_() {
            return this._$_userScriptDispatcher$_;
        }
        _$DispatchUserScriptEvent$_(t) {
            t.layout = this._$GetILayout$_();
            const s = this._$_runtime$_, i = s._$IsDebug$_() && !s._$GetEventSheetManager$_()._$IsInEventEngine$_();
            i && e.StartMeasuringScriptTime(), this._$_userScriptDispatcher$_.dispatchEvent(t), 
            i && e.AddScriptTime();
        }
        _$DispatchUserScriptEventAsyncWait$_(t) {
            return t.layout = this._$GetILayout$_(), this._$_userScriptDispatcher$_._$dispatchEventAndWaitAsync$_(t);
        }
        _$DispatchRuntimeUserScriptEventAsyncWait$_(t) {
            return t.layout = this._$GetILayout$_(), this._$_runtime$_._$DispatchUserScriptEventAsyncWait$_(t);
        }
        _$_LogLayerTree$_() {
            this._$_LogLayerList$_(this._$_rootLayers$_);
        }
        _$_LogLayerList$_(t, s = 0) {
            const i = t.slice(0);
            i.reverse();
            for (const e of i) console.log("\t".repeat(s) + "- " + e._$GetName$_()), 
            this._$_LogLayerList$_(e._$GetSubLayers$_(), s + 1);
        }
    };
}

{
    const Br = self._$C3$_;
    Br._$LayoutManager$_ = class extends Br._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_runtime$_ = t, this._$_allLayouts$_ = [], this._$_layoutsByName$_ = new Map(), 
            this._$_layoutsBySid$_ = new Map(), this._$_mainRunningLayout$_ = null, 
            this._$_runningSubLayouts$_ = [], this._$_firstLayout$_ = null, this._$_isEndingLayout$_ = 0, 
            this._$_pendingChangeLayout$_ = null;
        }
        _$Release$_() {
            this._$_runtime$_ = null, this._$_mainRunningLayout$_ = null, this._$_firstLayout$_ = null, 
            this._$_pendingChangeLayout$_ = null, Br._$clearArray$_(this._$_allLayouts$_), 
            this._$_layoutsByName$_.clear(), this._$_layoutsBySid$_.clear(), Br._$clearArray$_(this._$_runningSubLayouts$_);
        }
        _$Create$_(t) {
            const s = Br._$New$_(Br._$Layout$_, this, this._$_allLayouts$_.length, t);
            this._$_allLayouts$_.push(s), this._$_layoutsByName$_.set(s._$GetName$_().toLowerCase(), s), 
            this._$_layoutsBySid$_.set(s._$GetSID$_(), s);
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$SetFirstLayout$_(t) {
            this._$_firstLayout$_ = t;
        }
        _$GetFirstLayout$_() {
            if (this._$_firstLayout$_) return this._$_firstLayout$_;
            if (this._$_allLayouts$_.length) return this._$_allLayouts$_[0];
            throw new Error("no first layout");
        }
        _$GetLayoutByName$_(t) {
            return this._$_layoutsByName$_.get(t.toLowerCase()) || null;
        }
        _$GetLayoutBySID$_(t) {
            return this._$_layoutsBySid$_.get(t) || null;
        }
        _$GetLayoutByIndex$_(t) {
            return t = Br._$clamp$_(Math.floor(t), 0, this._$_allLayouts$_.length - 1), 
            this._$_allLayouts$_[t];
        }
        _$GetLayout$_(t) {
            return "number" == typeof t ? this._$GetLayoutByIndex$_(t) : this._$GetLayoutByName$_(t.toString());
        }
        _$GetAllLayouts$_() {
            return this._$_allLayouts$_;
        }
        _$_SetMainRunningLayout$_(t) {
            this._$_mainRunningLayout$_ = t;
        }
        _$GetMainRunningLayout$_() {
            return this._$_mainRunningLayout$_;
        }
        _$_AddRunningSubLayout$_(t) {
            if (this._$_runningSubLayouts$_.includes(t)) throw new Error("layout already running");
            this._$_runningSubLayouts$_.push(t);
        }
        _$_RemoveRunningSubLayout$_(t) {
            const s = this._$_runningSubLayouts$_.indexOf(t);
            if (-1 === s) throw new Error("layout not running");
            this._$_runningSubLayouts$_.splice(s, 1);
        }
        *_$runningLayouts$_() {
            this._$_mainRunningLayout$_ && (yield this._$_mainRunningLayout$_), 
            this._$_runningSubLayouts$_.length && (yield* this._$_runningSubLayouts$_);
        }
        _$IsLayoutRunning$_(t) {
            return this._$_mainRunningLayout$_ === t || this._$_runningSubLayouts$_.includes(t);
        }
        _$SetIsEndingLayout$_(t) {
            if (t) this._$_isEndingLayout$_++; else {
                if (this._$_isEndingLayout$_ <= 0) throw new Error("already unset");
                this._$_isEndingLayout$_--;
            }
        }
        _$IsEndingLayout$_() {
            return 0 < this._$_isEndingLayout$_;
        }
        _$ChangeMainLayout$_(t) {
            this._$_pendingChangeLayout$_ = t;
        }
        _$ClearPendingChangeLayout$_() {
            this._$_pendingChangeLayout$_ = null;
        }
        _$IsPendingChangeMainLayout$_() {
            return !!this._$_pendingChangeLayout$_;
        }
        _$GetPendingChangeMainLayout$_() {
            return this._$_pendingChangeLayout$_;
        }
        _$SetAllLayerProjectionChanged$_() {
            const t = this._$GetMainRunningLayout$_();
            t && t._$_SetAllLayersProjectionChanged$_();
        }
        _$SetAllLayerMVChanged$_() {
            const t = this._$GetMainRunningLayout$_();
            t && t._$_SetAllLayersMVChanged$_();
        }
    };
}

{
    const Nr = self._$C3$_, Wr = new RegExp("<(.+?)>", "g");
    Nr._$TimelineManager$_ = class extends Nr._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_runtime$_ = t, this._$_timelineDataManager$_ = Nr._$New$_(Nr._$TimelineDataManager$_), 
            this._$_pluginInstance$_ = null, this._$_timelines$_ = [], this._$_timelinesByName$_ = new Map(), 
            this._$_objectClassToTimelineMap$_ = new Map(), this._$_timelinesCreatedByTemplate$_ = new Map(), 
            this._$_scheduledTimelines$_ = [], this._$_playingTimelines$_ = [], 
            this._$_markedForRemovalTimelines$_ = [], this._$_hasRuntimeListeners$_ = !1, 
            this._$_changingLayout$_ = !1, this._$_isTickingTimelines$_ = !1, this._$_tickFunc$_ = () => this._$_OnTick$_(), 
            this._$_tick2Func$_ = () => this._$_OnTick2$_(), this._$_beforeLayoutChange$_ = () => this._$_OnBeforeChangeLayout$_(), 
            this._$_layoutChange$_ = () => this._$_OnAfterChangeLayout$_(), this._$_instanceDestroy$_ = t => this._$_OnInstanceDestroy$_(t._$instance$_), 
            this._$_beforeLoad$_ = t => this._$_OnBeforeLoad$_(), this._$_afterLoad$_ = t => this._$_OnAfterLoad$_(), 
            this._$_afterLayoutStart$_ = t => this._$_OnAfterLayoutStart$_(), this._$_destroyedWhileLoadingState$_ = [], 
            this._$_renderChange$_ = 0;
        }
        _$Release$_() {
            this._$RemoveRuntimeListeners$_(), this._$_tickFunc$_ = null, this._$_tick2Func$_ = null, 
            this._$_beforeLayoutChange$_ = null, this._$_layoutChange$_ = null, 
            this._$_instanceDestroy$_ = null, this._$_afterLoad$_ = null;
            for (const t of this._$_timelines$_) t._$Stop$_(), t._$Release$_();
            Nr._$clearArray$_(this._$_timelines$_), this._$_timelines$_ = null, 
            this._$_timelineDataManager$_._$Release$_(), this._$_timelineDataManager$_ = null, 
            Nr._$clearArray$_(this._$_scheduledTimelines$_), this._$_scheduledTimelines$_ = null, 
            Nr._$clearArray$_(this._$_playingTimelines$_), this._$_playingTimelines$_ = null, 
            Nr._$clearArray$_(this._$_markedForRemovalTimelines$_), this._$_markedForRemovalTimelines$_ = null, 
            this._$_timelinesByName$_.clear(), this._$_timelinesByName$_ = null, 
            this._$_objectClassToTimelineMap$_.clear(), this._$_objectClassToTimelineMap$_ = null, 
            this._$_timelinesCreatedByTemplate$_.clear(), this._$_timelinesCreatedByTemplate$_ = null, 
            Nr._$clearArray$_(this._$_destroyedWhileLoadingState$_), this._$_destroyedWhileLoadingState$_ = null, 
            this._$_runtime$_ = null;
        }
        _$AddRuntimeListeners$_() {
            const t = this._$_runtime$_._$Dispatcher$_();
            t.addEventListener("pretick", this._$_tickFunc$_), t.addEventListener("tick2", this._$_tick2Func$_), 
            t.addEventListener("beforelayoutchange", this._$_beforeLayoutChange$_), 
            t.addEventListener("layoutchange", this._$_layoutChange$_), t.addEventListener("instancedestroy", this._$_instanceDestroy$_), 
            t.addEventListener("beforeload", this._$_beforeLoad$_), t.addEventListener("afterload", this._$_afterLoad$_), 
            t.addEventListener("afterlayoutstart", this._$_afterLayoutStart$_);
        }
        _$RemoveRuntimeListeners$_() {
            const t = this._$_runtime$_._$Dispatcher$_();
            t.removeEventListener("pretick", this._$_tickFunc$_), t.removeEventListener("tick2", this._$_tick2Func$_), 
            t.removeEventListener("beforelayoutchange", this._$_beforeLayoutChange$_), 
            t.removeEventListener("layoutchange", this._$_layoutChange$_), t.removeEventListener("instancedestroy", this._$_instanceDestroy$_), 
            t.removeEventListener("beforeload", this._$_beforeLoad$_), t.removeEventListener("afterload", this._$_afterLoad$_), 
            t.removeEventListener("afterlayoutstart", this._$_afterLayoutStart$_);
        }
        _$Create$_(t) {
            this._$_timelineDataManager$_._$Add$_(t);
            const s = Nr._$TimelineState$_._$CreateInitial$_(t, this);
            this._$Add$_(s), this._$SetTimelineObjectClassesToMap$_(s), this._$_timelinesCreatedByTemplate$_.set(s._$GetName$_(), 0);
        }
        _$CreateFromTemplate$_(t) {
            const s = this._$GetTimelineDataManager$_(), i = t._$GetTemplateName$_(), e = s._$Get$_(i), h = Nr._$TimelineState$_._$CreateFromTemplate$_(i + ":" + this._$_timelinesCreatedByTemplate$_.get(i), e, this);
            return this._$_IncreaseTemplateTimelinesCount$_(i), this._$Add$_(h), 
            h;
        }
        _$_IncreaseTemplateTimelinesCount$_(t) {
            this._$_timelinesCreatedByTemplate$_.set(t, this._$_timelinesCreatedByTemplate$_.get(t) + 1);
        }
        _$_SetCreatedTemplateTimelinesCount$_() {
            for (const t of this._$_timelines$_) if (!t._$IsTemplate$_()) {
                const s = t._$GetTemplateName$_();
                this._$_IncreaseTemplateTimelinesCount$_(s);
            }
        }
        _$_ClearCreatedTemplateTimelinesCount$_() {
            for (const t of this._$_timelinesCreatedByTemplate$_.keys()) this._$_timelinesCreatedByTemplate$_.set(t, 0);
        }
        _$Add$_(t) {
            this._$_timelines$_.push(t), this._$_timelinesByName$_.set(t._$GetName$_().toLowerCase(), t);
        }
        _$Remove$_(t) {
            t._$Removed$_(), t._$IsTemplate$_() || (Nr._$arrayFindRemove$_(this._$_timelines$_, t), 
            Nr._$arrayFindRemove$_(this._$_scheduledTimelines$_, t), Nr._$arrayFindRemove$_(this._$_playingTimelines$_, t), 
            Nr._$arrayFindRemove$_(this._$_markedForRemovalTimelines$_, t), this._$_timelinesByName$_.delete(t._$GetName$_().toLowerCase()), 
            this._$RemoveTimelineFromObjectClassMap$_(t), t._$IsReleased$_()) || t._$Release$_();
        }
        _$Trigger$_(t) {
            this._$_runtime$_._$Trigger$_(t, this._$_pluginInstance$_, null);
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetTimelineDataManager$_() {
            return this._$_timelineDataManager$_;
        }
        _$SetPluginInstance$_(t) {
            this._$_pluginInstance$_ = t;
        }
        _$GetPluginInstance$_() {
            return this._$_pluginInstance$_;
        }
        *_$GetTimelines$_() {
            for (const t of this._$_timelines$_) yield t;
        }
        *_$GetPlayingTimelines$_() {
            for (const t of this._$_playingTimelines$_) yield t;
        }
        _$SetTimelineObjectClassToMap$_(t, s) {
            this._$_objectClassToTimelineMap$_.has(t) || this._$_objectClassToTimelineMap$_.set(t, new Set()), 
            this._$_objectClassToTimelineMap$_.get(t).add(s);
        }
        _$SetTimelineObjectClassesToMap$_(t) {
            for (const s of t._$GetObjectClasses$_()) this._$SetTimelineObjectClassToMap$_(s, t);
        }
        _$RemoveTimelineFromObjectClassMap$_(t) {
            for (const [ s, i ] of this._$_objectClassToTimelineMap$_.entries()) i.has(t) && (i.delete(t), 
            0 === i.size) && this._$_objectClassToTimelineMap$_.delete(s);
        }
        _$GetTimelinesForObjectClass$_(t) {
            if (this._$_objectClassToTimelineMap$_.has(t)) return this._$_objectClassToTimelineMap$_.get(t);
        }
        _$GetTimelineOfTemplateForInstances$_(t, s) {
            if (s) for (const i of this._$_timelines$_) {
                const e = s.every(t => i._$HasTrackInstance$_(t._$instance$_, t.trackId));
                if (e && i._$GetName$_().includes(t._$GetName$_())) return i;
            }
        }
        _$GetTimelineByName$_(t) {
            return this._$_timelinesByName$_.get(t.toLowerCase()) || null;
        }
        _$GetScheduledOrPlayingTimelineByName$_(t) {
            for (const s of this._$_scheduledTimelines$_) if (s._$GetName$_() === t) return s;
            for (const i of this._$_playingTimelines$_) if (i._$GetName$_() === t) return i;
            return null;
        }
        *_$GetTimelinesByName$_(i) {
            if (Wr.test(i)) {
                Wr.lastIndex = 0;
                let t, s = new Set();
                do {
                    if (t = Wr.exec(i)) {
                        const e = t[1].split(",");
                        for (const h of e) s.add(h);
                    }
                } while (t);
                for (const r of s.values()) {
                    const n = this._$GetTimelineByName$_(r);
                    n && (yield n);
                }
                s.clear();
            } else {
                const t = this._$GetTimelineByName$_(i);
                t && (yield t);
            }
        }
        *_$GetTimelinesByTags$_(t) {
            for (const s of this._$_timelines$_) s._$HasTags$_(t) && (yield s);
        }
        _$AddScheduledTimeline$_(t) {
            this._$_scheduledTimelines$_.includes(t) || this._$_scheduledTimelines$_.push(t), 
            this._$_MaybeEnableRuntimeListeners$_();
        }
        _$RemovePlayingTimeline$_(t) {
            Nr._$arrayFindRemove$_(this._$_playingTimelines$_, t), this._$_MaybeDisableRuntimeListeners$_();
        }
        _$ScheduleTimeline$_(t) {
            this._$_playingTimelines$_.includes(t) ? (t._$SetPlaying$_(!0), t._$SetScheduled$_(!1), 
            t._$SetMarkedForRemoval$_(!1)) : (t._$SetPlaying$_(!1), t._$SetScheduled$_(!0), 
            t._$SetMarkedForRemoval$_(!1), this._$_scheduledTimelines$_.includes(t) || this._$_scheduledTimelines$_.push(t)), 
            this._$_MaybeEnableRuntimeListeners$_();
        }
        _$DeScheduleTimeline$_(t) {
            t._$SetPlaying$_(!1), t._$SetScheduled$_(!1), t._$ResolvePlayPromise$_(), 
            Nr._$arrayFindRemove$_(this._$_scheduledTimelines$_, t), this._$_MaybeDisableRuntimeListeners$_();
        }
        _$CompleteTimeline$_(t) {
            t._$SetPlaying$_(!1), t._$SetScheduled$_(!1), this._$_playingTimelines$_.includes(t) && (t._$SetMarkedForRemoval$_(!0), 
            this._$_markedForRemovalTimelines$_.push(t), Nr._$arrayFindRemove$_(this._$_playingTimelines$_, t)), 
            this._$_scheduledTimelines$_.includes(t) && t._$SetMarkedForRemoval$_(!0);
        }
        _$CompleteTimelineBeforeChangeOfLayout$_(t) {
            t._$SetPlaying$_(!1), t._$SetScheduled$_(!1), t._$SetMarkedForRemoval$_(!1), 
            t._$SetPlaybackRate$_(1), Nr._$arrayFindRemove$_(this._$_playingTimelines$_, t);
        }
        _$CompleteTimelineAndResolve$_(t) {
            this._$CompleteTimeline$_(t), t._$ResolvePlayPromise$_();
        }
        _$_OnTick$_() {
            if (!this._$GetRuntime$_()._$IsLoadingState$_() && this._$_hasRuntimeListeners$_ && !this._$_changingLayout$_) {
                for (this._$_isTickingTimelines$_ = !0; this._$_scheduledTimelines$_.length; ) {
                    const t = this._$_scheduledTimelines$_.pop();
                    (t._$IsMarkedForRemoval$_() ? (t._$SetInitialStateForce$_(), 
                    this._$_markedForRemovalTimelines$_) : (t._$SetInitialState$_(), 
                    this._$_playingTimelines$_)).push(t), 0 !== t._$GetRenderChange$_() && (this._$_renderChange$_ = 1);
                }
                const s = this._$_runtime$_._$_GetDtFast$_(), i = this._$_runtime$_._$GetDt1$_(), e = this._$_runtime$_._$GetTimeScale$_();
                for (let t = this._$_playingTimelines$_.length - 1; 0 <= t; t--) {
                    const h = this._$_playingTimelines$_[t];
                    h && h._$Tick$_(s, e, i);
                }
                this._$_isTickingTimelines$_ = !1, 0 !== this._$_renderChange$_ && this._$GetRuntime$_()._$UpdateRender$_();
            }
        }
        _$_OnTick2$_() {
            if (!this._$GetRuntime$_()._$IsLoadingState$_() && this._$_hasRuntimeListeners$_ && !this._$_changingLayout$_) {
                let i;
                for (let t = 0, s = this._$_markedForRemovalTimelines$_.length; t < s; t++) {
                    const e = this._$_markedForRemovalTimelines$_[t];
                    i = i || new Set(), e._$Removed$_(), this._$_MaybeExecuteTimelineFinishTriggers$_(e), 
                    i.add(e);
                }
                if (i) {
                    Nr._$arrayRemoveAllInSet$_(this._$_markedForRemovalTimelines$_, i);
                    for (let t = this._$_renderChange$_ = 0, s = this._$_playingTimelines$_.length; t < s; t++) if (0 !== this._$_playingTimelines$_[t]._$GetRenderChange$_()) {
                        this._$_renderChange$_ = 1;
                        break;
                    }
                }
                this._$_MaybeDisableRuntimeListeners$_();
            }
        }
        _$_MaybeExecuteTimelineFinishTriggers$_(t) {
            t._$IsReleased$_() || t._$HasValidTracks$_() && t._$IsComplete$_() && t._$InitialStateSet$_() && t._$FinishTriggers$_();
        }
        _$_MaybeEnableRuntimeListeners$_() {
            this._$_hasRuntimeListeners$_ || (this._$_hasRuntimeListeners$_ = !0);
        }
        _$_MaybeDisableRuntimeListeners$_() {
            this._$_markedForRemovalTimelines$_.length || this._$_playingTimelines$_.length || this._$_scheduledTimelines$_.length || this._$_isTickingTimelines$_ || (this._$_hasRuntimeListeners$_ = !1);
        }
        _$_OnBeforeChangeLayout$_() {
            for (this._$_changingLayout$_ = !0; this._$_scheduledTimelines$_.length; ) this._$DeScheduleTimeline$_(this._$_scheduledTimelines$_.pop());
            const t = new Set();
            for (const s of this._$_playingTimelines$_) {
                const i = s._$_OnBeforeChangeLayout$_();
                i && (s._$Removed$_(), t.add(s));
            }
            Nr._$arrayRemoveAllInSet$_(this._$_playingTimelines$_, t), t.clear();
            for (const e of this._$_markedForRemovalTimelines$_) {
                const h = e._$_OnBeforeChangeLayout$_();
                h && (e._$Removed$_(), t.add(e));
            }
            Nr._$arrayRemoveAllInSet$_(this._$_markedForRemovalTimelines$_, t), 
            this._$_MaybeDisableRuntimeListeners$_();
            for (const r of this._$_timelines$_) r._$CleanCaches$_();
        }
        _$_OnAfterChangeLayout$_() {
            this._$_changingLayout$_ = !1;
        }
        _$_OnInstanceDestroy$_(t) {
            const s = t._$GetObjectClass$_(), i = this._$GetTimelinesForObjectClass$_(s);
            if (i) if (this._$_runtime$_._$IsLoadingState$_()) this._$_destroyedWhileLoadingState$_.push(t); else for (const e of i) e._$IsTemplate$_() || (e._$IsReleased$_() ? this._$Remove$_(e) : e._$HasValidTracks$_() || (this._$_MaybeExecuteTimelineFinishTriggers$_(e), 
            this._$Remove$_(e)));
        }
        _$_OnBeforeLoad$_() {
            for (const t of this._$_scheduledTimelines$_.map(t => t)) this._$_MaybeExecuteTimelineFinishTriggers$_(t), 
            this._$Remove$_(t);
            for (const s of this._$_playingTimelines$_.map(t => t)) this._$_MaybeExecuteTimelineFinishTriggers$_(s), 
            this._$Remove$_(s);
        }
        _$_OnAfterLoad$_() {
            for (const t of this._$_destroyedWhileLoadingState$_) this._$_OnInstanceDestroy$_(t);
            Nr._$clearArray$_(this._$_destroyedWhileLoadingState$_);
            for (const s of this._$_timelines$_) s._$_OnAfterLoad$_();
        }
        _$_OnAfterLayoutStart$_() {
            const t = this._$_runtime$_._$GetLayoutManager$_(), s = t._$GetMainRunningLayout$_();
            if (s) for (const i of this._$_timelines$_) {
                const e = i._$GetStartOnLayout$_();
                e && s._$GetName$_() === e && this._$ScheduleTimeline$_(i);
            }
        }
        _$_SaveToJson$_() {
            return {
                timelinesJson: this._$_SaveTimelinesToJson$_(),
                scheduledTimelinesJson: this._$_SaveScheduledTimelinesToJson$_(),
                playingTimelinesJson: this._$_SavePlayingTimelinesToJson$_(),
                markedForRemovalTimelinesJson: this._$_SaveMarkedForRemovalTimelinesToJson$_(),
                hasRuntimeListeners: this._$_hasRuntimeListeners$_,
                changingLayout: this._$_changingLayout$_,
                isTickingTimelines: this._$_isTickingTimelines$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (this._$_ClearCreatedTemplateTimelinesCount$_(), this._$_LoadTimelinesFromJson$_(t.timelinesJson), 
            this._$_LoadScheduledTimelinesFromJson$_(t.scheduledTimelinesJson), 
            this._$_LoadPlayingTimelinesFromJson$_(t.playingTimelinesJson), this._$_LoadMarkedForRemovalTimelinesFromJson$_(t.markedForRemovalTimelinesJson), 
            this._$_hasRuntimeListeners$_ = !t.hasRuntimeListeners, this._$_changingLayout$_ = !!t.changingLayout, 
            this._$_isTickingTimelines$_ = !!t.isTickingTimelines, this._$_SetCreatedTemplateTimelinesCount$_(), 
            this._$_MaybeEnableRuntimeListeners$_(), this._$_MaybeDisableRuntimeListeners$_());
        }
        _$_SaveTimelinesToJson$_() {
            return this._$_timelines$_.map(t => t._$_SaveToJson$_());
        }
        _$_LoadTimelinesFromJson$_(t) {
            for (const s of t) {
                let t = this._$GetTimelineByName$_(s.name);
                if (t) t._$_LoadFromJson$_(s); else {
                    const i = this._$_GetTemplateNameFromJson$_(s);
                    if (!i) continue;
                    const e = this._$GetTimelineByName$_(i);
                    (t = this._$CreateFromTemplate$_(e))._$_LoadFromJson$_(s);
                }
                t._$HasTracks$_() || this._$Remove$_(t);
            }
        }
        _$_GetTemplateNameFromJson$_(t) {
            const s = t.name, i = s.split(":");
            return i && 2 === i.length ? i[0] : null;
        }
        _$_SaveScheduledTimelinesToJson$_() {
            return this._$_SaveTimelines$_(this._$_scheduledTimelines$_);
        }
        _$_LoadScheduledTimelinesFromJson$_(t) {
            this._$_LoadTimelines$_(t, this._$_scheduledTimelines$_);
        }
        _$_SavePlayingTimelinesToJson$_() {
            return this._$_SaveTimelines$_(this._$_playingTimelines$_);
        }
        _$_LoadPlayingTimelinesFromJson$_(t) {
            this._$_LoadTimelines$_(t, this._$_playingTimelines$_);
        }
        _$_SaveMarkedForRemovalTimelinesToJson$_() {
            return this._$_SaveTimelines$_(this._$_markedForRemovalTimelines$_);
        }
        _$_LoadMarkedForRemovalTimelinesFromJson$_(t) {
            this._$_LoadTimelines$_(t, this._$_markedForRemovalTimelines$_);
        }
        _$_IsTimelineInJson$_(t, s) {
            if (s) for (const i of s) if (i === t._$GetName$_()) return !0;
            return !1;
        }
        _$_SaveTimelines$_(t) {
            return t.map(t => t._$GetName$_());
        }
        _$_LoadTimelines$_(t, s) {
            const i = new Set();
            for (const e of s) this._$_IsTimelineInJson$_(e, t) || i.add(e);
            if (Nr._$arrayRemoveAllInSet$_(s, i), t) for (const h of t) {
                const r = this._$GetTimelineByName$_(h);
                if (r) {
                    const n = s.find((s => t => t._$GetName$_() === s)(h));
                    n || s.push(r);
                }
            }
        }
    };
}

{
    const jr = self._$C3$_, Vr = [ 0, 0 ], Ur = [ 0, 0 ], Hr = [ 0, 0 ], zr = [ 0, 0, 0, 0, 0 ], Jr = new Array(4), qr = [ {
        x: 0,
        y: 0,
        t: 0,
        _$distance$_: 0
    }, {
        x: 0,
        y: 0,
        t: 0,
        _$distance$_: 0
    }, {
        x: 0,
        y: 0,
        t: 0,
        _$distance$_: 0
    } ], Xr = {
        x: 0,
        y: 0,
        t: 0,
        _$distance$_: 0
    };
    jr._$TimelineInfo$_ = class {
        constructor(t, s) {
            this._$_initialized$_ = !1, this._$_timeline$_ = t, this._$_segments$_ = [];
            let i = null;
            if (i = s ? this._$_timeline$_._$GetTrackById$_(s) : jr.first(this._$_timeline$_._$GetTracks$_())) {
                const e = i._$GetPropertyTrack$_("offsetX"), h = i._$GetPropertyTrack$_("offsetY");
                if (e && h) {
                    this._$_xTrack$_ = e, this._$_yTrack$_ = h;
                    const r = e._$GetPropertyKeyframeDataItemArrayIncludingDisabled$_(), n = h._$GetPropertyKeyframeDataItemArrayIncludingDisabled$_();
                    for (let t = 1, s = Math.min(r.length, n.length); t < s; ++t) {
                        const o = r[t], a = (o._$GetNext$_(), o._$GetPrevious$_()), l = n[t], u = (l._$GetNext$_(), 
                        l._$GetPrevious$_());
                        a && "cubic-bezier" === a._$GetPathMode$_() && u && "cubic-bezier" === u._$GetPathMode$_() ? this._$_segments$_.push(jr._$New$_(jr._$TimelineCubicBezierSegmentInfo$_, a, u, o, l, this._$_segments$_.length)) : (a && "line" === a._$GetPathMode$_() && u && u._$GetPathMode$_(), 
                        this._$_segments$_.push(jr._$New$_(jr._$TimelineLineSegmentInfo$_, o, l, this._$_segments$_.length)));
                    }
                    this._$_initialized$_ = !0;
                }
            }
        }
        _$Release$_() {
            for (const t of this._$_segments$_) t._$Release$_();
            jr._$clearArray$_(this._$_segments$_), this._$_segments$_ = null, this._$_timeline$_ = null, 
            this._$_xTrack$_ = null, this._$_yTrack$_ = null;
        }
        _$WasInitialized$_() {
            return this._$_initialized$_;
        }
        _$segments$_() {
            return this._$_segments$_;
        }
        _$SetOrigin$_(t) {
            const s = "relative" === this._$_xTrack$_._$GetResultMode$_() ? t._$GetX$_() : 0, i = "relative" === this._$_yTrack$_._$GetResultMode$_() ? t._$GetY$_() : 0;
            for (const e of this._$_segments$_) e._$SetOrigin$_(s, i);
        }
        _$Project$_(s, i, t) {
            let e = NaN, h = this._$_segments$_.length;
            for (let t = 0; t < h; t++) {
                const r = this._$_segments$_[t];
                if ("cubic-bezier" === r._$GetType$_()) {
                    const n = r._$Project$_(s, i);
                    (isNaN(e) || n[3] < e) && (e = n[3], Hr[0] = n[2], Hr[1] = r._$GetIndex$_());
                }
            }
            return Hr;
        }
        _$ProjectWithOptions$_(s, i, t) {
            const e = t.tRange;
            jr._$IsFiniteNumber$_(e[0]) || (e[0] = 0), jr._$IsFiniteNumber$_(e[1]) || (e[1] = 1);
            let h = NaN, r = this._$_segments$_.length;
            for (let t = 0; t < r; t++) {
                const n = this._$_segments$_[t];
                if ("cubic-bezier" === n._$GetType$_()) {
                    const o = n._$ProjectWithRange$_(s, i, e);
                    (isNaN(h) || o[3] < h) && (h = o[3], Hr[0] = o[2], Hr[1] = n._$GetIndex$_());
                }
            }
            return Hr;
        }
        _$Tangent$_(t, s) {
            return this._$_segments$_[s]._$Tangent$_(t);
        }
        _$TangentAngle$_(t, s) {
            return this._$_segments$_[s]._$TangentAngle$_(t);
        }
    }, jr._$TimelineCubicBezierSegmentInfo$_ = class {
        constructor(t, s, i, e, h) {
            this._$_index$_ = h;
            const r = t._$GetAddOn$_("cubic-bezier"), n = i._$GetAddOn$_("cubic-bezier"), o = s._$GetAddOn$_("cubic-bezier"), a = e._$GetAddOn$_("cubic-bezier");
            this._$_aX$_ = t._$GetValueWithResultMode$_(), this._$_aY$_ = s._$GetValueWithResultMode$_(), 
            this._$_bX$_ = t._$GetValueWithResultMode$_() + r._$GetStartAnchor$_(), 
            this._$_bY$_ = s._$GetValueWithResultMode$_() + o._$GetStartAnchor$_(), 
            this._$_cX$_ = i._$GetValueWithResultMode$_() + n._$GetEndAnchor$_(), 
            this._$_cY$_ = e._$GetValueWithResultMode$_() + a._$GetEndAnchor$_(), 
            this._$_dX$_ = i._$GetValueWithResultMode$_(), this._$_dY$_ = e._$GetValueWithResultMode$_(), 
            this._$_aXO$_ = 0, this._$_aYO$_ = 0, this._$_bXO$_ = 0, this._$_bYO$_ = 0, 
            this._$_cXO$_ = 0, this._$_cYO$_ = 0, this._$_dXO$_ = 0, this._$_dYO$_ = 0, 
            this._$_d0x$_ = 0, this._$_d0y$_ = 0, this._$_d1x$_ = 0, this._$_d1y$_ = 0, 
            this._$_d2x$_ = 0, this._$_d2y$_ = 0, this._$_x1Factor$_ = 0, this._$_x2Factor$_ = 0, 
            this._$_x3Factor$_ = 0, this._$_y1Factor$_ = 0, this._$_y2Factor$_ = 0, 
            this._$_y3Factor$_ = 0, this._$_lutIndex$_ = NaN, this._$_initialized$_ = !1, 
            this._$_len$_ = 100, this._$_arcLengths$_ = new Array(this._$_len$_ + 1), 
            this._$_arcLengths$_[0] = 0, this._$_length$_ = 0, this._$_lut$_ = [], 
            this._$_lutObjects$_ = [];
            for (let t = 0; t < 100; t++) this._$_lutObjects$_.push({
                x: 0,
                y: 0,
                t: 0,
                _$distance$_: 0
            });
            this._$_CalculateLength$_();
        }
        _$Release$_() {
            jr._$clearArray$_(this._$_arcLengths$_), this._$_arcLengths$_ = null, 
            jr._$clearArray$_(this._$_lut$_), this._$_lut$_ = null, jr._$clearArray$_(this._$_lutObjects$_), 
            this._$_lutObjects$_ = null;
        }
        _$GetType$_() {
            return "cubic-bezier";
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$GetStepCount$_() {
            return Math.floor(this._$_length$_ / 25);
        }
        _$GetStepIncrement$_() {
            return 1 / this._$GetStepCount$_();
        }
        _$SetOrigin$_(t, s) {
            this._$_originX$_ = t, this._$_originY$_ = s, this._$_arcLengths$_ = new Array(this._$_len$_ + 1), 
            this._$_arcLengths$_[0] = 0, this._$_CalculateLength$_(), this._$_aXO$_ = this._$_aX$_ + this._$_originX$_, 
            this._$_aYO$_ = this._$_aY$_ + this._$_originY$_, this._$_bXO$_ = this._$_bX$_ + this._$_originX$_, 
            this._$_bYO$_ = this._$_bY$_ + this._$_originY$_, this._$_cXO$_ = this._$_cX$_ + this._$_originX$_, 
            this._$_cYO$_ = this._$_cY$_ + this._$_originY$_, this._$_dXO$_ = this._$_dX$_ + this._$_originX$_, 
            this._$_dYO$_ = this._$_dY$_ + this._$_originY$_, this._$_d0x$_ = 3 * (this._$_bXO$_ - this._$_aXO$_), 
            this._$_d0y$_ = 3 * (this._$_bYO$_ - this._$_aYO$_), this._$_d1x$_ = 3 * (this._$_cXO$_ - this._$_bXO$_), 
            this._$_d1y$_ = 3 * (this._$_cYO$_ - this._$_bYO$_), this._$_d2x$_ = 3 * (this._$_dXO$_ - this._$_cXO$_), 
            this._$_d2y$_ = 3 * (this._$_dYO$_ - this._$_cYO$_), this._$_x1Factor$_ = 3 * (this._$_bXO$_ - this._$_aXO$_), 
            this._$_x2Factor$_ = 3 * (this._$_aXO$_ + this._$_cXO$_ - 2 * this._$_bXO$_), 
            this._$_x3Factor$_ = this._$_dXO$_ - this._$_aXO$_ + 3 * (this._$_bXO$_ - this._$_cXO$_), 
            this._$_y1Factor$_ = 3 * (this._$_bYO$_ - this._$_aYO$_), this._$_y2Factor$_ = 3 * (this._$_aYO$_ + this._$_cYO$_ - 2 * this._$_bYO$_), 
            this._$_y3Factor$_ = this._$_dYO$_ - this._$_aYO$_ + 3 * (this._$_bYO$_ - this._$_cYO$_);
        }
        Map(t) {
            if (!this._$_initialized$_) return NaN;
            const s = this._$_Map$_(t);
            return Ur[0] = this._$_X$_(s), Ur[1] = this._$_Y$_(s), Ur;
        }
        _$Project$_(t, s) {
            const i = this._$_GenerateLUT$_(100), e = this._$_FindClosestFromLUT$_(t, s, i), h = this._$_RefineProjection$_(t, s, i, e);
            return zr[0] = h.x, zr[1] = h.y, zr[2] = h.t, zr[3] = h._$distance$_, 
            zr;
        }
        _$ProjectWithRange$_(t, s, i) {
            const e = this._$_GenerateLUT$_(100), h = this._$_FindClosestFromLUTWithRange$_(t, s, e, i), r = this._$_RefineProjection$_(t, s, e, h);
            return zr[0] = r.x, zr[1] = r.y, zr[2] = r.t, zr[3] = r._$distance$_, 
            zr;
        }
        _$Tangent$_(t) {
            const s = 1 - t, i = s * s, e = 2 * s * t, h = t * t, r = i * this._$_d0x$_ + e * this._$_d1x$_ + h * this._$_d2x$_, n = i * this._$_d0y$_ + e * this._$_d1y$_ + h * this._$_d2y$_, o = Math.hypot(r, n);
            return Vr[0] = r / o, Vr[1] = n / o, Vr;
        }
        _$TangentAngle$_(t) {
            const s = 1 - t, i = s * s, e = 2 * s * t, h = t * t, r = i * this._$_d0x$_ + e * this._$_d1x$_ + h * this._$_d2x$_, n = i * this._$_d0y$_ + e * this._$_d1y$_ + h * this._$_d2y$_;
            return Math.atan2(n, r);
        }
        _$_Map$_(h) {
            if (this._$_initialized$_) {
                let t = h * this._$_arcLengths$_[this._$_len$_], s = 0, i = this._$_len$_, e = 0;
                for (;s < i; ) e = s + ((i - s) / 2 | 0), this._$_arcLengths$_[e] < t ? s = e + 1 : i = e;
                this._$_arcLengths$_[e] > t && e--;
                const r = this._$_arcLengths$_[e];
                return r === t ? e / this._$_len$_ : (e + (t - r) / (this._$_arcLengths$_[e + 1] - r)) / this._$_len$_;
            }
        }
        _$_X$_(t) {
            return this._$_initialized$_ ? self._$Ease$_._$GetRuntimeEase$_("cubicbezier")(t, this._$_aX$_ + this._$_originX$_, this._$_bX$_ + this._$_originX$_, this._$_cX$_ + this._$_originX$_, this._$_dX$_ + this._$_originX$_) : NaN;
        }
        _$_Y$_(t) {
            return this._$_initialized$_ ? self._$Ease$_._$GetRuntimeEase$_("cubicbezier")(t, this._$_aY$_ + this._$_originY$_, this._$_bY$_ + this._$_originY$_, this._$_cY$_ + this._$_originY$_, this._$_dY$_ + this._$_originY$_) : NaN;
        }
        _$_GenerateLUT$_(s) {
            if (!(this._$_lut$_.length >= (s = s || 100))) {
                this._$_lut$_ = new Array(s), s++;
                for (let t = 0; t < s - 1; t++) {
                    const i = t / (s - 1), e = i ** 2, h = i ** 3, r = this._$_x1Factor$_ * i, n = this._$_x2Factor$_ * e, o = this._$_x3Factor$_ * h, a = this._$_y1Factor$_ * i, l = this._$_y2Factor$_ * e, u = this._$_y3Factor$_ * h, c = this._$_aXO$_ + r + n + o, f = this._$_aYO$_ + a + l + u;
                    this._$_lutObjects$_[t].x = c, this._$_lutObjects$_[t].y = f, 
                    this._$_lutObjects$_[t].t = i, this._$_lutObjects$_[t]._$distance$_ = 0, 
                    this._$_lut$_[t] = this._$_lutObjects$_[t];
                }
            }
            return this._$_lut$_;
        }
        _$_FindClosestFromLUT$_(s, i, e, t = 0, h = Number.MAX_SAFE_INTEGER) {
            let r = 0;
            if (isNaN(this._$_lutIndex$_)) for (let t = 0; t < 100; t++) {
                const n = e[t], o = n.x - s, a = n.y - i;
                n._$distance$_ = o * o + a * a, n._$distance$_ < h && (h = n._$distance$_, 
                r = t);
            } else {
                for (let t = this._$_lutIndex$_; t < this._$_lutIndex$_ + 5 && !(t >= e.length); t++) {
                    const l = e[t], u = l.x - s, c = l.y - i;
                    l._$distance$_ = u * u + c * c, l._$distance$_ < h && (h = l._$distance$_, 
                    r = t);
                }
                for (let t = this._$_lutIndex$_; t > this._$_lutIndex$_ - 5 && !(t < 0); t--) {
                    const f = e[t], d = f.x - s, p = f.y - i;
                    f._$distance$_ = d * d + p * p, f._$distance$_ < h && (h = f._$distance$_, 
                    r = t);
                }
            }
            return this._$_lutIndex$_ = r;
        }
        _$_FindClosestFromLUTWithRange$_(s, i, e, h, r = Number.MAX_SAFE_INTEGER) {
            let n = 0;
            if (isNaN(this._$_lutIndex$_)) for (let t = 0; t < 100; t++) {
                const o = e[t], a = o.x - s, l = o.y - i;
                o._$distance$_ = a * a + l * l, o.t >= h[0] && o.t <= h[1] && o._$distance$_ < r && (r = o._$distance$_, 
                n = t);
            } else {
                for (let t = this._$_lutIndex$_; t < this._$_lutIndex$_ + 5 && !(t >= e.length); t++) {
                    const u = e[t], c = u.x - s, f = u.y - i;
                    u._$distance$_ = c * c + f * f, u.t >= h[0] && u.t <= h[1] && u._$distance$_ < r && (r = u._$distance$_, 
                    n = t);
                }
                for (let t = this._$_lutIndex$_; t > this._$_lutIndex$_ - 5 && !(t < 0); t--) {
                    const d = e[t], p = d.x - s, m = d.y - i;
                    d._$distance$_ = p * p + m * m, d.t >= h[0] && d.t <= h[1] && d._$distance$_ < r && (r = d._$distance$_, 
                    n = t);
                }
            }
            return this._$_lutIndex$_ = n;
        }
        _$_RefineProjection$_(n, o, a, l) {
            let u = a[l], t = 1, c = Number.MAX_SAFE_INTEGER;
            t: do {
                let t = a.length, s = 0 === l ? 0 : l - 1, i = l === t - 1 ? t - 1 : l + 1, e = a[s].t, h = a[i].t, r = (h - e) / 4;
                if (r < .001) break;
                Jr[0] = a[s];
                for (let t = 1; t <= 2; t++) {
                    const f = e + t * r, d = f ** 2, p = f ** 3, m = this._$_x1Factor$_ * f, g = this._$_x2Factor$_ * d, y = this._$_x3Factor$_ * p, w = this._$_y1Factor$_ * f, S = this._$_y2Factor$_ * d, b = this._$_y3Factor$_ * p, M = this._$_aXO$_ + m + g + y, v = this._$_aYO$_ + w + S + b, x = M - n, G = v - o, T = x * x + G * G;
                    if (T < c) {
                        c = T, l = t, Xr.x = M, Xr.y = v, Xr.t = f, Xr._$distance$_ = T, 
                        u = Xr;
                        break t;
                    }
                    const _ = qr[t - 1];
                    _.x = M, _.y = v, _.t = f, _._$distance$_ = T, Jr[t] = _;
                }
                Jr[3] = a[i], a = Jr;
            } while (t++ < 20);
            return u;
        }
        _$_CalculateLength$_() {
            this._$_initialized$_ = !0;
            let s = this._$_X$_(0), i = this._$_Y$_(0), e = 0;
            for (let t = 1; t <= this._$_len$_; t++) {
                const h = this._$_X$_(.01 * t), r = this._$_Y$_(.01 * t), n = s - h, o = i - r;
                e += Math.hypot(n, o), this._$_arcLengths$_[t] = e, s = h, i = r;
            }
            this._$_length$_ = e;
        }
    }, jr._$TimelineLineSegmentInfo$_ = class {
        constructor(t, s, i) {
            this._$_index$_ = i, this._$_targetX$_ = t._$GetValueWithResultMode$_(), 
            this._$_targetY$_ = s._$GetValueWithResultMode$_(), this._$_originX$_ = 0, 
            this._$_originY$_ = 0;
        }
        _$Release$_() {}
        _$GetType$_() {
            return "line";
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$SetOrigin$_(t, s) {
            this._$_originX$_ = t, this._$_originY$_ = s;
        }
        _$GetX$_() {
            return this._$_targetX$_ + this._$_originX$_;
        }
        _$GetY$_() {
            return this._$_targetY$_ + this._$_originY$_;
        }
    };
}

{
    const b = self._$C3$_;
    b._$TimelineState$_ = class extends b._$DefendedBase$_ {
        constructor(t, s, i) {
            super(), this._$_runtime$_ = i._$GetRuntime$_(), this._$_timelineManager$_ = i, 
            this._$_timelineDataItem$_ = s, this._$_name$_ = t, this._$_tracks$_ = [], 
            this._$_tracksLength$_ = 0, this._$_beforeAndAfterTracks$_ = null, this._$_beforeAndAfterTracksLength$_ = 0, 
            this._$CreateTrackStates$_(), this._$_playPromise$_ = null, this._$_playResolve$_ = null, 
            this._$_playheadTime$_ = 0, this._$_overshoot$_ = 0, this._$_playbackRate$_ = 1, 
            this._$_pingPongState$_ = 0, this._$_currentRepeatCount$_ = 1, this._$_isPlaying$_ = !1, 
            this._$_isScheduled$_ = !1, this._$_initialStateSet$_ = !1, this._$_complete$_ = !0, 
            this._$_released$_ = !1, this._$_markedForRemoval$_ = !1, this._$_completedTick$_ = -1, 
            this._$_implicitPause$_ = !1, this._$_isTemplate$_ = !1, this._$_finishedTriggers$_ = !1, 
            this._$_firstTick$_ = !1, this._$_lastDelta$_ = NaN, this._$_tags$_ = [ "" ], 
            this._$_stringTags$_ = "", this._$_tagsChanged$_ = !1, this._$_renderChange$_ = 0, 
            this._$_hasNestedContent$_ = 0, this._$_iTimelineState$_ = null;
        }
        static _$CreateInitial$_(t, s) {
            const i = s._$GetTimelineDataManager$_(), e = i._$GetNameId$_(), h = i._$Get$_(t[e]), r = b._$New$_(b._$TimelineState$_, t[e], h, s);
            return r._$SetIsTemplate$_(!0), r;
        }
        static _$CreateFromTemplate$_(t, s, i) {
            return b._$New$_(b._$TimelineState$_, t, s, i);
        }
        _$Release$_() {
            if (!this._$IsReleased$_()) {
                const t = this._$_runtime$_._$Dispatcher$_();
                this._$_timelineManager$_._$DeScheduleTimeline$_(this), this._$_timelineManager$_._$CompleteTimelineAndResolve$_(this);
                for (const s of this._$_tracks$_) s._$Release$_();
                b._$clearArray$_(this._$_tracks$_), this._$_tracks$_ = null, this._$_runtime$_ = null, 
                this._$_timelineManager$_ = null, this._$_timelineDataItem$_ = null, 
                this._$_released$_ = !0, this._$_playPromise$_ = null, this._$_playResolve$_ = null, 
                this._$FireReleaseEvent$_(t);
            }
        }
        _$FireReleaseEvent$_(t) {
            const s = b._$New$_(b.Event, "timelinestatereleased");
            s._$timelineState$_ = this, t.dispatchEvent(s);
        }
        _$GetType$_() {
            return 0;
        }
        _$CreateTrackStates$_() {
            for (const t of this._$_timelineDataItem$_._$GetTrackData$_()._$trackDataItems$_()) this._$_tracksLength$_ = this._$_tracks$_.push(b._$TrackState$_._$Create$_(this, t));
        }
        _$GetTimelineManager$_() {
            return this._$_timelineManager$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetTracks$_() {
            return this._$_tracks$_;
        }
        _$GetSimilarPropertyTracks$_(e, h, r, n) {
            if (this._$_hasNestedContent$_) {
                let i;
                for (let s = 0; s < this._$_tracks$_.length; s++) {
                    let t = this._$_tracks$_[s];
                    if (e === t._$GetInstance$_()) {
                        const o = t._$GetPropertyTrack$_(r);
                        o && h.constructor === o._$GetSourceAdapter$_().constructor && o._$GetResultMode$_() === n._$GetResultMode$_() && (i = i || []).push(o);
                    }
                }
                return i;
            }
        }
        _$HasTracks$_() {
            return !!this._$_tracks$_.length;
        }
        _$GetTrackById$_(t) {
            for (const s of this._$_tracks$_) if (b._$equalsNoCase$_(s._$GetId$_(), t)) return s;
            return null;
        }
        _$GetTrackByName$_(t) {
            for (const s of this._$_tracks$_) if (!s._$IsInstanceTrack$_() && b._$equalsNoCase$_(s._$GetName$_(), t)) return s;
            return null;
        }
        _$SetName$_(t) {
            this._$_name$_ = t;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$GetTimelineDataItem$_() {
            return this._$_timelineDataItem$_;
        }
        _$GetTemplateName$_() {
            return this._$_timelineDataItem$_._$GetName$_();
        }
        _$GetTotalTime$_() {
            return this._$_timelineDataItem$_._$GetTotalTime$_();
        }
        _$SetTotalTime$_(t) {
            this._$_timelineDataItem$_._$SetTotalTime$_(t);
        }
        _$GetStep$_() {
            return this._$_timelineDataItem$_._$GetStep$_();
        }
        _$SetStep$_(t) {
            this._$_timelineDataItem$_._$SetStep$_(t);
        }
        _$GetInterpolationMode$_() {
            return this._$_timelineDataItem$_._$GetInterpolationMode$_();
        }
        _$SetInterpolationMode$_(t) {
            this._$_timelineDataItem$_._$SetInterpolationMode$_(t);
        }
        _$GetResultMode$_() {
            return this._$_timelineDataItem$_._$GetResultMode$_();
        }
        _$SetResultMode$_(t) {
            this._$_timelineDataItem$_._$GetResultMode$_(t);
        }
        _$SetEase$_(t) {
            for (const s of this._$GetTracks$_()) s._$SetEase$_(t);
        }
        _$GetLoop$_() {
            return this._$_timelineDataItem$_._$GetLoop$_();
        }
        _$SetLoop$_(t) {
            return this._$_timelineDataItem$_._$SetLoop$_(t);
        }
        _$GetPingPong$_() {
            return this._$_timelineDataItem$_._$GetPingPong$_();
        }
        _$SetPingPong$_(t) {
            return this._$_timelineDataItem$_._$SetPingPong$_(t);
        }
        _$GetRepeatCount$_() {
            return this._$_timelineDataItem$_._$GetRepeatCount$_();
        }
        _$SetRepeatCount$_(t) {
            return this._$_timelineDataItem$_._$SetRepeatCount$_(t);
        }
        _$SetPlaybackRate$_(t) {
            return this._$_playbackRate$_ = t;
        }
        _$GetPlaybackRate$_() {
            return this._$_playbackRate$_;
        }
        _$GetStartOnLayout$_() {
            return this._$_timelineDataItem$_._$GetStartOnLayout$_();
        }
        _$GetTransformWithSceneGraph$_() {
            return this._$_timelineDataItem$_._$GetTransformWithSceneGraph$_();
        }
        _$GetUseSystemTimescale$_() {
            return this._$_timelineDataItem$_._$GetUseSystemTimescale$_();
        }
        _$GetPingPongState$_() {
            return this._$_pingPongState$_;
        }
        _$IsForwardPlayBack$_() {
            return !this.IsPlaying() || 0 < this._$_playbackRate$_;
        }
        _$GetPlayPromise$_() {
            return this._$_playPromise$_ || (this._$_playPromise$_ = new Promise(t => {
                this._$_playResolve$_ = t;
            })), this._$_playPromise$_;
        }
        _$ResolvePlayPromise$_() {
            this._$_playPromise$_ && (this._$_playResolve$_(), this._$_playPromise$_ = null, 
            this._$_playResolve$_ = null);
        }
        _$SetTags$_(t) {
            this._$_tags$_ = b._$TimelineState$_._$_GetTagArray$_(t), this._$_tagsChanged$_ = !0;
        }
        _$GetTags$_() {
            return this._$_tags$_;
        }
        _$GetStringTags$_() {
            return this._$_tagsChanged$_ && (this._$_stringTags$_ = this._$_tags$_.join(" ")), 
            this._$_tagsChanged$_ = !1, this._$_stringTags$_;
        }
        _$HasTags$_(t) {
            if (!this._$_tags$_) return !1;
            if (!this._$_tags$_.length) return !1;
            const s = b._$TimelineState$_._$_GetTagArray$_(t);
            return !!s && !!s.length && s.every(b._$TimelineState$_._$_HasTag$_, this);
        }
        _$OnStarted$_() {
            b._$Plugins$_.Timeline && this.constructor === b._$TimelineState$_ && (b._$Plugins$_.Timeline._$Cnds$_.PushTriggerTimeline(this), 
            this._$_timelineManager$_._$Trigger$_(b._$Plugins$_.Timeline._$Cnds$_.OnTimelineStarted), 
            this._$_timelineManager$_._$Trigger$_(b._$Plugins$_.Timeline._$Cnds$_.OnTimelineStartedByName), 
            this._$_timelineManager$_._$Trigger$_(b._$Plugins$_.Timeline._$Cnds$_.OnTimelineStartedByTags), 
            this._$_timelineManager$_._$Trigger$_(b._$Plugins$_.Timeline._$Cnds$_.OnAnyTimelineStarted), 
            b._$Plugins$_.Timeline._$Cnds$_.PopTriggerTimeline());
        }
        _$OnCompleted$_() {
            this._$_completedTick$_ = this._$_runtime$_._$GetTickCount$_();
        }
        _$FinishTriggers$_() {
            this._$_finishedTriggers$_ || (this._$_finishedTriggers$_ = !0, b._$Plugins$_.Timeline && this.constructor === b._$TimelineState$_ && (b._$Plugins$_.Timeline._$Cnds$_.PushTriggerTimeline(this), 
            this._$_timelineManager$_._$Trigger$_(b._$Plugins$_.Timeline._$Cnds$_.OnTimelineFinished), 
            this._$_timelineManager$_._$Trigger$_(b._$Plugins$_.Timeline._$Cnds$_.OnTimelineFinishedByName), 
            this._$_timelineManager$_._$Trigger$_(b._$Plugins$_.Timeline._$Cnds$_.OnTimelineFinishedByTags), 
            this._$_timelineManager$_._$Trigger$_(b._$Plugins$_.Timeline._$Cnds$_.OnAnyTimelineFinished), 
            b._$Plugins$_.Timeline._$Cnds$_.PopTriggerTimeline()));
        }
        _$SetPlaying$_(t) {
            this._$_isPlaying$_ = t;
        }
        _$IsCompletedTick$_() {
            return this._$_completedTick$_ === this._$_runtime$_._$GetTickCount$_();
        }
        IsPlaying(t = !1) {
            return !!this._$IsCompletedTick$_() || !(!this._$IsScheduled$_() || t) || this._$_isPlaying$_;
        }
        _$_IsPlaying$_() {
            return this.IsPlaying(!0);
        }
        _$IsPaused$_() {
            return this._$_IsPaused$_();
        }
        _$_IsPaused$_() {
            return !(this._$IsReleased$_() || this._$IsScheduled$_() || this._$_IsPlaying$_() || this._$IsComplete$_());
        }
        _$SetScheduled$_(t) {
            this._$_isScheduled$_ = t;
        }
        _$IsScheduled$_() {
            return this._$_isScheduled$_;
        }
        _$SetComplete$_(t) {
            this._$_complete$_ = t;
            const s = this._$GetTime$_();
            (s <= 0 || s >= this._$GetTotalTime$_()) && (this._$_complete$_ = !0);
        }
        _$IsComplete$_() {
            return this._$_complete$_;
        }
        _$IsReleased$_() {
            return this._$_released$_;
        }
        _$SetMarkedForRemoval$_(t) {
            this._$_markedForRemoval$_ = t;
        }
        _$IsMarkedForRemoval$_() {
            return this._$_markedForRemoval$_;
        }
        _$SetImplicitPause$_(t) {
            this._$_implicitPause$_ = t;
        }
        _$IsImplicitPause$_() {
            return this._$_implicitPause$_;
        }
        _$SetIsTemplate$_(t) {
            this._$_isTemplate$_ = !!t;
        }
        _$IsTemplate$_() {
            return this._$_isTemplate$_;
        }
        _$InitialStateSet$_() {
            return this._$_initialStateSet$_;
        }
        _$GetTime$_() {
            return this._$_playheadTime$_;
        }
        _$SetTime$_(t) {
            const s = this._$GetTime$_();
            this._$_SetTime$_(t), this._$SetComplete$_(!1), this._$IsComplete$_() || this._$SetImplicitPause$_(!0), 
            !this._$_IsPlaying$_() && !this._$IsScheduled$_() && this._$_initialStateSet$_ || (this._$_IsPlaying$_() || this._$IsScheduled$_() || this._$_initialStateSet$_ ? this._$_IsPlaying$_() ? this._$Stop$_() : this._$IsScheduled$_() && (this._$_timelineManager$_._$DeScheduleTimeline$_(this), 
            this._$SetInitialStateFromSetTime$_()) : this._$SetInitialStateFromSetTime$_()), 
            this._$_SetUpdateStateBefore$_(), this._$_Interpolate$_(this._$GetTime$_(), !1, !0, !0, s), 
            this._$_SetUpdateStateAfter$_(), this._$_renderChange$_ && this._$GetRuntime$_()._$UpdateRender$_(), 
            this._$_OnSetTime$_();
        }
        _$_SetTime$_(t) {
            (t = b._$IsFiniteNumber$_(t) ? t : this._$GetTotalTime$_()) < 0 ? this._$_playheadTime$_ = 0 : t >= this._$GetTotalTime$_() ? this._$_playheadTime$_ = this._$GetTotalTime$_() : this._$_playheadTime$_ = t;
        }
        _$_SetTimeAndReset$_(t) {
            (t = b._$IsFiniteNumber$_(t) ? t : this._$GetTotalTime$_()) < 0 ? this._$_playheadTime$_ = 0 : t >= this._$GetTotalTime$_() ? this._$_playheadTime$_ = this._$GetTotalTime$_() : this._$_playheadTime$_ = t;
            for (const s of this._$_tracks$_) s._$SetResetState$_();
        }
        _$_OnSetTime$_() {
            b._$Plugins$_.Timeline && this.constructor === b._$TimelineState$_ && (b._$Plugins$_.Timeline._$Cnds$_.PushTriggerTimeline(this), 
            this._$_timelineManager$_._$Trigger$_(b._$Plugins$_.Timeline._$Cnds$_.OnTimeSet), 
            this._$_timelineManager$_._$Trigger$_(b._$Plugins$_.Timeline._$Cnds$_.OnTimeSetByName), 
            this._$_timelineManager$_._$Trigger$_(b._$Plugins$_.Timeline._$Cnds$_.OnTimeSetByTags), 
            b._$Plugins$_.Timeline._$Cnds$_.PopTriggerTimeline());
        }
        _$_CanResume$_() {
            if (!this._$GetLoop$_()) if (this._$GetPingPong$_() && 1 === this._$_pingPongState$_) {
                if (this._$IsForwardPlayBack$_()) {
                    if (this._$GetTime$_() >= this._$GetTotalTime$_()) return !1;
                } else if (this._$GetTime$_() <= 0) return !1;
            } else if (!this._$GetLoop$_() && !this._$GetPingPong$_()) if (this._$IsForwardPlayBack$_()) {
                if (this._$GetTime$_() >= this._$GetTotalTime$_()) return !1;
            } else if (this._$GetTime$_() <= 0) return !1;
            return !0;
        }
        _$Resume$_() {
            this._$IsReleased$_() || this._$_CanResume$_() && this.Play(!0);
        }
        Play(t = !1) {
            return !this._$IsReleased$_() && !this._$IsScheduled$_() && (this._$_IsPlaying$_() && this._$IsCompletedTick$_() ? this._$_SchedulePlayingTimeline$_() : !this._$_IsPlaying$_() && !!(this._$IsComplete$_() || t || this._$IsImplicitPause$_()) && this._$_ScheduleStoppedTimeline$_());
        }
        _$_SchedulePlayingTimeline$_() {
            return this._$SetImplicitPause$_(!1), this._$_timelineManager$_._$RemovePlayingTimeline$_(this), 
            this._$_timelineManager$_._$ScheduleTimeline$_(this), this._$GetPlayPromise$_(), 
            !0;
        }
        _$_ScheduleStoppedTimeline$_() {
            return this._$SetImplicitPause$_(!1), this._$_timelineManager$_._$ScheduleTimeline$_(this), 
            this._$GetPlayPromise$_(), !0;
        }
        _$Stop$_(t = !1) {
            this._$IsReleased$_() || (this._$SetComplete$_(t), this._$_timelineManager$_._$CompleteTimeline$_(this), 
            this._$IsComplete$_() && this._$ResolvePlayPromise$_());
        }
        _$Reset$_(t = !0, s = !1) {
            if (!this._$IsReleased$_()) {
                if (!this._$_IsPlaying$_() && this._$IsScheduled$_()) return this._$_timelineManager$_._$DeScheduleTimeline$_(this);
                if (!this._$IsComplete$_()) {
                    this._$Stop$_(!0), this._$IsForwardPlayBack$_() ? this._$_SetTime$_(0) : this._$_SetTime$_(this._$GetTotalTime$_());
                    const i = this._$GetTime$_();
                    this._$_SetUpdateStateBefore$_(), s ? this._$_InterpolateBeforeChangeLayout$_(i) : this._$_Interpolate$_(i, !1, !1, !0), 
                    t && this._$_OnSetTime$_(), this._$_SetUpdateStateAfter$_(), 
                    this._$_renderChange$_ && t && this._$GetRuntime$_()._$UpdateRender$_();
                }
            }
        }
        _$ResetBeforeChangeLayout$_() {
            this._$Reset$_(!1, !0);
        }
        _$_InterpolateBeforeChangeLayout$_(t) {
            this._$_Interpolate$_(t, !1, !1, !0, NaN, !1, !0);
        }
        _$_OnBeforeChangeLayout$_() {
            if (!this._$IsReleased$_()) {
                if (!this._$GetRuntime$_()._$IsLoadingState$_() && this._$HasValidGlobalTracks$_()) return !1;
                this._$_timelineManager$_._$CompleteTimelineBeforeChangeOfLayout$_(this), 
                this._$GetRuntime$_()._$IsLoadingState$_() || this._$ResetBeforeChangeLayout$_();
            }
            return !0;
        }
        _$SetInitialStateFromSetTime$_() {
            this._$SetInitialState$_(!0);
        }
        _$SetInitialStateForce$_() {
            this._$SetInitialState$_(!1, !0), this._$SetPlaying$_(!1), this._$SetScheduled$_(!1);
        }
        _$SetInitialState$_(t = !1, s = !1) {
            if (!this._$IsMarkedForRemoval$_() || s) {
                if (t) {
                    this._$_finishedTriggers$_ = !1, this._$_initialStateSet$_ = !0, 
                    this._$_firstTick$_ = !0, this._$_SetUpdateStateBefore$_();
                    for (const i of this._$_tracks$_) i._$SetInitialState$_();
                } else if (this._$SetPlaying$_(!0), this._$SetScheduled$_(!1), this._$OnStarted$_(), 
                this._$IsComplete$_()) {
                    this._$_completedTick$_ = -1, 0 !== this._$_pingPongState$_ && (this._$_playbackRate$_ = Math.abs(this._$_playbackRate$_)), 
                    this._$_pingPongState$_ = 0, this._$_currentRepeatCount$_ = 1, 
                    this._$_complete$_ = !1, this._$_finishedTriggers$_ = !1, this._$_initialStateSet$_ = !0, 
                    this._$_firstTick$_ = !0, this._$IsForwardPlayBack$_() ? this._$_SetTime$_(0) : this._$_SetTime$_(this._$GetTotalTime$_()), 
                    this._$_SetUpdateStateBefore$_();
                    for (const e of this._$_tracks$_) e._$SetInitialState$_();
                } else {
                    this._$_firstTick$_ = !0, this._$_finishedTriggers$_ = !1, this._$_SetUpdateStateBefore$_();
                    for (const h of this._$_tracks$_) h._$SetResumeState$_();
                }
                this._$_SetUpdateStateAfter$_();
            }
        }
        _$GetRenderChange$_() {
            return this._$_renderChange$_;
        }
        _$_SetUpdateStateBefore$_() {
            this._$_hasNestedContent$_ = 0;
            for (const t of this._$_tracks$_) t._$IsNested$_() && (this._$_hasNestedContent$_ = 1);
        }
        _$_SetUpdateStateAfter$_() {
            this._$_renderChange$_ = 0;
            for (const t of this._$_tracks$_) t._$_SetUpdateState$_(), 0 === this._$_renderChange$_ && 1 === t._$GetRenderChange$_() && (this._$_renderChange$_ = 1), 
            this._$_beforeAndAfterTracks$_ || 1 !== t._$GetNeedsBeforeAndAfter$_() || (this._$_beforeAndAfterTracks$_ || (this._$_beforeAndAfterTracks$_ = []), 
            this._$_beforeAndAfterTracksLength$_ = this._$_beforeAndAfterTracks$_.push(t));
        }
        _$Tick$_(t, s, i) {
            if (this._$GetUseSystemTimescale$_()) {
                if (0 === t && 0 === this._$_lastDelta$_) return;
                this._$_lastDelta$_ = t, t = i;
            } else {
                if (0 === i && 0 === this._$_lastDelta$_) return;
                t = this._$_lastDelta$_ = i, s = 1;
            }
            const e = this._$_playheadTime$_ + this._$_overshoot$_, h = t * s * this._$_playbackRate$_, r = e + h, n = this._$_timelineDataItem$_._$_totalTime$_;
            r < 0 ? (this._$_playheadTime$_ = 0, this._$_overshoot$_ = -r) : n <= r ? (this._$_playheadTime$_ = n, 
            this._$_overshoot$_ = this._$_playheadTime$_ - r) : (this._$_playheadTime$_ = r, 
            this._$_overshoot$_ = 0);
            let o = !1, a = !1, l = this._$GetLoop$_(), u = this._$GetPingPong$_();
            l || u ? l && !u ? 0 < this._$_playbackRate$_ ? this._$_playheadTime$_ >= n && (this._$_SetTimeAndReset$_(0), 
            a = !0) : this._$_playheadTime$_ <= 0 && (this._$_SetTimeAndReset$_(n), 
            a = !0) : !l && u ? 0 < this._$_playbackRate$_ ? this._$_playheadTime$_ >= n && (this._$_SetTime$_(n), 
            this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), a = !0, 1 === this._$_pingPongState$_ ? this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
            this._$_pingPongState$_ = 0) : o = !0 : 0 === this._$_pingPongState$_ && (this._$_pingPongState$_ = 1)) : this._$_playheadTime$_ <= 0 && (this._$_SetTime$_(0), 
            this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), a = !0, 1 === this._$_pingPongState$_ ? this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
            this._$_pingPongState$_ = 0) : o = !0 : 0 === this._$_pingPongState$_ && (this._$_pingPongState$_ = 1)) : l && u && (0 < this._$_playbackRate$_ ? this._$_playheadTime$_ >= n && (this._$_SetTime$_(n), 
            this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), a = !0, this._$_pingPongState$_++, 
            b.wrap(this._$_pingPongState$_, 0, 2)) : this._$_playheadTime$_ <= 0 && (this._$_SetTime$_(0), 
            this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), a = !0, this._$_pingPongState$_++, 
            b.wrap(this._$_pingPongState$_, 0, 2))) : 0 < this._$_playbackRate$_ ? this._$_playheadTime$_ >= n && (this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
            this._$_SetTimeAndReset$_(0), a = !0) : (this._$_SetTime$_(n), o = !0)) : this._$_playheadTime$_ <= 0 && (this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
            this._$_SetTimeAndReset$_(n), a = !0) : (this._$_SetTime$_(0), o = !0));
            let c, f = this._$_tracksLength$_;
            if (o) {
                for (c = 0; c < f; c++) this._$_tracks$_[c]._$SetEndState$_();
                this._$Stop$_(!0), this._$OnCompleted$_();
            } else {
                const d = this._$_beforeAndAfterTracksLength$_;
                for (c = 0; c < d; c++) this._$_beforeAndAfterTracks$_[c]._$BeforeInterpolate$_();
                if (1 === this._$_hasNestedContent$_) for (c = 0; c < f; c++) {
                    const p = this._$_tracks$_[c], m = p._$GetStartOffset$_(), g = this._$_playheadTime$_ - m, y = e - m;
                    g < 0 && 0 < y ? (this._$_playheadTime$_ = m < 0 ? 0 : n <= m ? n : m, 
                    p._$Interpolate$_(m, !0, !1, a, this._$_firstTick$_, !1)) : p._$Interpolate$_(this._$_playheadTime$_, !0, !1, a, this._$_firstTick$_, !1);
                } else for (c = 0; c < f; c++) this._$_tracks$_[c]._$Interpolate$_(this._$_playheadTime$_, !0, !1, a, this._$_firstTick$_, !1);
                for (c = 0; c < d; c++) this._$_beforeAndAfterTracks$_[c]._$AfterInterpolate$_();
                this._$_firstTick$_ && (this._$_firstTick$_ = !1);
            }
        }
        _$_Interpolate$_(s, i = !1, e = !1, h = !1, r = NaN, t = !1, n = !1) {
            for (const o of this._$_tracks$_) o._$BeforeInterpolate$_();
            for (const a of this._$_tracks$_) {
                let t = s;
                if ("number" == typeof r && !isNaN(r)) {
                    const l = this._$GetTime$_(), u = l - a._$GetStartOffset$_(), c = r - a._$GetStartOffset$_();
                    u < 0 && 0 < c && (t = a._$GetStartOffset$_(), this._$_SetTime$_(t));
                }
                a._$Interpolate$_(t, i, e, h, this._$_firstTick$_, n);
            }
            for (const f of this._$_tracks$_) f._$AfterInterpolate$_();
            this._$_firstTick$_ && t && (this._$_firstTick$_ = !1);
        }
        _$AddTrack$_() {
            const t = this._$_timelineDataItem$_._$GetTrackData$_()._$AddEmptyTrackDataItem$_(), s = b._$TrackState$_._$Create$_(this, t);
            return this._$_tracksLength$_ = this._$_tracks$_.push(s), s;
        }
        _$Removed$_() {
            if (!this._$IsReleased$_()) for (const t of this._$_tracks$_) t._$TimelineRemoved$_();
        }
        _$CleanCaches$_() {
            for (const t of this._$_tracks$_) t._$CleanCaches$_();
        }
        _$ClearTrackInstances$_() {
            for (const t of this._$_tracks$_) t._$ClearInstance$_();
        }
        _$SetTrackInstance$_(t, s, i) {
            if (s) {
                if ("number" == typeof i && 0 <= i) {
                    const e = this._$_tracks$_[i];
                    return e ? (e._$SetInstance$_(s), void this._$_timelineManager$_._$SetTimelineObjectClassToMap$_(s._$GetObjectClass$_(), this)) : void 0;
                }
                for (const h of this._$_tracks$_) if (h._$IsInstanceTrack$_()) if (t) {
                    if (h._$GetId$_() === t) {
                        h._$SetInstance$_(s), this._$_timelineManager$_._$SetTimelineObjectClassToMap$_(s._$GetObjectClass$_(), this);
                        break;
                    }
                } else if (!h._$HasInstance$_()) {
                    h._$SetInstance$_(s), this._$_timelineManager$_._$SetTimelineObjectClassToMap$_(s._$GetObjectClass$_(), this);
                    break;
                }
            }
        }
        _$HasTrackInstance$_(t, s) {
            for (const i of this._$_tracks$_) if (i._$IsInstanceTrack$_()) if (s) {
                if (s === i._$GetId$_() && t === i._$GetInstance$_()) return !0;
            } else if (t === i._$GetInstance$_()) return !0;
            return !1;
        }
        _$HasValidTracks$_() {
            return this._$_tracks$_.some(t => !t._$IsInstanceTrack$_() || t._$CanInstanceBeValid$_());
        }
        _$HasValidGlobalTracks$_() {
            return this._$_tracks$_.some(t => {
                if (t._$IsInstanceTrack$_()) {
                    if (!t._$CanInstanceBeValid$_()) return !1;
                    const s = t._$GetObjectClass$_();
                    return s ? s._$IsGlobal$_() : !1;
                }
                return !1;
            });
        }
        _$GetPropertyTrack$_(t) {
            for (const s of this._$GetTracks$_()) for (const i of s._$GetPropertyTracks$_()) if (i._$GetPropertyName$_() === t) return i;
        }
        _$GetTrackFromInstance$_(t) {
            for (const s of this._$_tracks$_) if (t === s._$GetInstance$_()) return s;
            return null;
        }
        _$GetKeyframeWithTags$_(t) {
            let s = t ? t.split(" ") : [], i = new Set(s.map(t => t.toLowerCase().trim()));
            s = [ ...i.values() ];
            for (const e of this._$GetTracks$_()) for (const h of e._$GetKeyframeDataItems$_()) {
                const r = s.every(t => h._$HasTag$_(t));
                if (r) return h;
            }
        }
        _$GetObjectClasses$_() {
            const t = [];
            for (const s of this._$GetTracks$_()) t.push(s._$GetObjectClass$_());
            return t.filter(t => t);
        }
        _$_OnAfterLoad$_() {
            for (const t of this._$GetTracks$_()) t._$_OnAfterLoad$_();
        }
        _$_SaveToJson$_() {
            return {
                tracksJson: this._$_SaveTracksToJson$_(),
                name: this._$_name$_,
                playheadTime: this._$GetTime$_(),
                playbackRate: this._$_playbackRate$_,
                pingPongState: this._$_pingPongState$_,
                currentRepeatCount: this._$_currentRepeatCount$_,
                isPlaying: this._$_isPlaying$_,
                isScheduled: this._$_isScheduled$_,
                initialStateSet: this._$_initialStateSet$_,
                finishedTriggers: this._$_finishedTriggers$_,
                complete: this._$_complete$_,
                released: this._$_released$_,
                markedForRemoval: this._$_markedForRemoval$_,
                completedTick: this._$_completedTick$_,
                implicitPause: this._$_implicitPause$_,
                isTemplate: this._$_isTemplate$_,
                tags: this._$_tags$_.join(" "),
                stringTags: this._$_stringTags$_,
                tagsChanged: this._$_tagsChanged$_,
                firstTick: this._$_firstTick$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (this._$_LoadTracksFromJson$_(t.tracksJson), this._$_name$_ = t.name, 
            this._$_playheadTime$_ = t.playheadTime, this._$_playbackRate$_ = t.playbackRate, 
            this._$_pingPongState$_ = t.pingPongState, this._$_currentRepeatCount$_ = t.currentRepeatCount, 
            this._$_isPlaying$_ = !!t.isPlaying, this._$_isScheduled$_ = !!t.isScheduled, 
            this._$_initialStateSet$_ = !!t.initialStateSet, this._$_finishedTriggers$_ = !!t.hasOwnProperty("finishedTriggers") && !!t.finishedTriggers, 
            this._$_complete$_ = !!t.complete, this._$_released$_ = !!t.released, 
            this._$_markedForRemoval$_ = !!t.markedForRemoval, this._$_completedTick$_ = t.completedTick, 
            this._$_implicitPause$_ = !!t.implicitPause, this._$_isTemplate$_ = !!t.isTemplate, 
            this._$_tags$_ = t.tags.split(" "), this._$_stringTags$_ = t.stringTags, 
            this._$_tagsChanged$_ = !!t.tagsChanged, this._$_firstTick$_ = !!t.firstTick);
        }
        _$_SaveTracksToJson$_() {
            return this._$_tracks$_.map(t => t._$_SaveToJson$_());
        }
        _$_LoadTracksFromJson$_(t) {
            this._$ClearTrackInstances$_(), t.forEach((t, s) => {
                const i = this._$_tracks$_[s];
                i._$_LoadFromJson$_(t);
            }), this._$_tracks$_.filter(t => t._$CanInstanceBeValid$_());
        }
        static _$_HasTag$_(t) {
            const s = this._$GetTags$_();
            return "" === t ? 1 === s.length && "" === s[0] : s.map(t => t.toLowerCase()).includes(t.toLowerCase());
        }
        static _$_GetTagArray$_(t) {
            if (b._$IsArray$_(t)) return t.slice(0);
            if (b._$IsString$_(t)) return t.split(" ");
            throw new Error("invalid tags");
        }
        _$GetITimelineState$_() {
            return this._$_iTimelineState$_ || (this._$_iTimelineState$_ = b._$New$_(self._$ITimelineState$_, this)), 
            this._$_iTimelineState$_;
        }
    };
}

{
    const Yr = self._$C3$_;
    Yr._$TrackState$_ = class extends Yr._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_timeline$_ = t, this._$_trackDataItem$_ = s, this._$_trackData$_ = s._$GetTrackData$_(), 
            this._$_instanceUid$_ = NaN, this._$_objectClassIndex$_ = NaN, this._$_instance$_ = null, 
            this._$_worldInfo$_ = null, this._$_cleared$_ = !1, this._$_isNested$_ = 0 < s._$GetStartOffset$_(), 
            this._$_initialStateOfNestedSet$_ = !1, this._$_endStateOfNestedSet$_ = !1, 
            this._$_instanceUidToLoad$_ = NaN, this._$_lastKeyframeDataItem$_ = null, 
            this._$_keyframeDataItems$_ = this._$_trackDataItem$_._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_(), 
            this._$_propertyTracks$_ = [], this._$CreatePropertyTrackStates$_(), 
            this._$_worldInfoChange$_ = 0, this._$_renderChange$_ = 0, this._$_needsBeforeAndAfter$_ = 0;
        }
        static _$Create$_(t, s) {
            return Yr._$New$_(Yr._$TrackState$_, t, s);
        }
        _$Release$_() {
            this._$_keyframeDataItems$_ = null;
            for (const t of this._$_propertyTracks$_) t._$Release$_();
            Yr._$clearArray$_(this._$_propertyTracks$_), this._$_propertyTracks$_ = null, 
            this._$_timeline$_ = null, this._$_instance$_ = null, this._$_worldInfo$_ = null, 
            this._$_trackDataItem$_ = null, this._$_lastKeyframeDataItem$_ = null;
        }
        _$CreatePropertyTrackStates$_() {
            for (const t of this._$_trackDataItem$_._$GetPropertyTrackData$_()._$propertyTrackDataItems$_()) this._$_propertyTracks$_.push(Yr._$PropertyTrackState$_._$Create$_(this, t));
        }
        _$TimelineRemoved$_() {
            for (const t of this._$_propertyTracks$_) t._$TimelineRemoved$_();
        }
        _$CleanCaches$_() {
            for (const t of this._$_propertyTracks$_) t._$CleanCaches$_();
            this._$_instance$_ = null, this._$_worldInfo$_ = null;
        }
        _$GetTimeline$_() {
            return this._$_timeline$_;
        }
        _$GetRuntime$_() {
            return this._$_timeline$_._$GetRuntime$_();
        }
        _$GetKeyframeDataItems$_() {
            return this._$_keyframeDataItems$_ || (this._$_keyframeDataItems$_ = this._$_trackDataItem$_._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_()), 
            this._$_keyframeDataItems$_;
        }
        _$GetPropertyTracks$_() {
            return this._$_propertyTracks$_;
        }
        _$GetPropertyTrack$_(s) {
            for (let t = 0; t < this._$_propertyTracks$_.length; t++) {
                const i = this._$_propertyTracks$_[t];
                if (i._$GetPropertyName$_() === s) return i;
            }
        }
        _$MaybeGetInstance$_() {
            this._$_instance$_ || this._$GetInstance$_();
        }
        _$IsInstanceValid$_() {
            return !!this._$_instance$_ && !this._$_instance$_._$IsDestroyed$_();
        }
        _$CanInstanceBeValid$_() {
            if (!this._$IsInstanceTrack$_()) return !1;
            const t = this._$GetInstanceUID$_(), s = this._$GetRuntime$_()._$GetInstanceByUID$_(t);
            return !!s && !s._$IsDestroyed$_();
        }
        _$GetObjectClass$_() {
            if (this._$IsInstanceTrack$_()) {
                const t = this._$GetObjectClassIndex$_();
                if (-1 !== t) return this._$GetRuntime$_()._$GetObjectClassByIndex$_(t);
            }
        }
        _$GetTrackIndexInTimeline$_() {
            return this._$_timeline$_._$GetTracks$_().indexOf(this);
        }
        _$ClearInstance$_() {
            this._$_instance$_ = null, this._$_instanceUid$_ = NaN, this._$_worldInfo$_ = null, 
            this._$_objectClassIndex$_ = NaN, this._$_cleared$_ = !0;
        }
        _$HasInstance$_() {
            return !!this._$_instance$_;
        }
        _$GetInstance$_() {
            if (!this._$_cleared$_) {
                if (!this._$_instance$_ || !this._$IsInstanceValid$_()) {
                    const t = this._$GetInstanceUID$_();
                    this._$_instance$_ = this._$GetRuntime$_()._$GetInstanceByUID$_(t);
                }
                return this._$_instance$_;
            }
        }
        _$SetInstance$_(t) {
            if (this._$_cleared$_ = !1, this._$_instance$_ !== t) {
                this._$CleanCaches$_(), this._$_instance$_ = t, this._$_objectClassIndex$_ = t._$GetObjectClass$_()._$GetIndex$_(), 
                this._$_instanceUid$_ = t._$GetUID$_(), this._$_worldInfo$_ = t._$GetWorldInfo$_();
                for (const s of this._$propertyTrackItems$_()) {
                    const i = s._$propertyTrack$_, e = s._$sourceAdapter$_, h = i._$GetSourceAdapterId$_();
                    switch (h) {
                      case "instance-variable":
                        {
                            e._$GetEditorIndex$_();
                            const r = t._$GetObjectClass$_(), n = r._$GetInstanceVariableIndexByName$_(s.name), o = r._$GetInstanceVariableName$_(n), a = r._$GetInstanceVariableType$_(n);
                            o === s.name && a === s.type && e._$UpdateInstanceVariableIndex$_(n);
                            break;
                        }

                      case "behavior":
                        {
                            const l = s._$behaviorType$_, u = this._$GetObjectClass$_(), c = t._$GetObjectClass$_(), f = e._$GetBehaviorType$_(c);
                            if (l && f) {
                                const d = l._$GetName$_();
                                u._$GetBehaviorIndexByName$_(d), c._$GetBehaviorIndexByName$_(d), 
                                e._$GetEditorIndex$_();
                                e._$UpdateBehaviorTypeSid$_(f._$GetSID$_());
                            }
                            break;
                        }
                    }
                }
            }
        }
        *_$propertyTrackItems$_() {
            for (const t of this._$_propertyTracks$_) {
                const s = t._$GetSourceAdapter$_(), i = this._$GetObjectClass$_(), e = {
                    _$propertyTrack$_: t,
                    _$sourceAdapter$_: s
                };
                switch (t._$GetSourceAdapterId$_()) {
                  case "world-instance":
                    e.property = t._$GetPropertyName$_();
                    break;

                  case "instance-variable":
                    {
                        const h = s._$GetEditorIndex$_();
                        e.name = i._$GetInstanceVariableName$_(h), e.type = i._$GetInstanceVariableType$_(h);
                        break;
                    }

                  case "effect":
                    {
                        const r = i._$GetEffectList$_(), n = s._$GetEffectType$_(r);
                        e._$effectType$_ = n;
                        break;
                    }

                  case "behavior":
                    {
                        const o = s._$GetBehaviorType$_(i);
                        e._$behaviorType$_ = o;
                        break;
                    }

                  case "plugin":
                    e._$plugin$_ = i._$GetPlugin$_();
                }
                yield e;
            }
        }
        _$GetWorldInfo$_() {
            if (!this._$_worldInfo$_ || !this._$IsInstanceValid$_()) {
                const t = this._$GetInstance$_();
                t && (this._$_worldInfo$_ = t._$GetWorldInfo$_());
            }
            return this._$_worldInfo$_;
        }
        _$GetTrackDataItem$_() {
            return this._$_trackDataItem$_;
        }
        _$GetInstanceUID$_() {
            return isNaN(this._$_instanceUid$_) ? this._$_trackDataItem$_._$GetInstanceUID$_() : this._$_instanceUid$_;
        }
        _$SetInstanceUID$_(t) {
            this._$_trackDataItem$_._$SetInstanceUID$_(t);
        }
        _$GetInterpolationMode$_() {
            return this._$_trackDataItem$_._$GetInterpolationMode$_();
        }
        _$SetInterpolationMode$_(t) {
            this._$_trackDataItem$_._$SetInterpolationMode$_(t);
        }
        _$GetResultMode$_() {
            return this._$_trackDataItem$_._$GetResultMode$_();
        }
        _$GetId$_() {
            return this._$_trackDataItem$_._$GetId$_();
        }
        _$GetStartOffset$_() {
            return this._$_trackDataItem$_._$GetStartOffset$_();
        }
        _$GetLocalTotalTime$_() {
            return this._$_trackDataItem$_._$GetLocalTotalTime$_();
        }
        _$SetLocalTotalTime$_(t) {
            this._$_trackDataItem$_._$SetLocalTotalTime$_(t);
        }
        _$SetResultMode$_(t) {
            this._$_trackDataItem$_._$SetResultMode$_(t);
        }
        _$SetEase$_(t) {
            for (const s of this._$GetKeyframeDataItems$_()) s._$SetEase$_(t);
            for (const i of this._$GetPropertyTracks$_()) i._$SetEase$_(t);
        }
        _$GetEnable$_() {
            return this._$_trackDataItem$_._$GetEnable$_();
        }
        _$SetEnable$_(t) {
            this._$_trackDataItem$_._$SetEnable$_(t);
        }
        _$GetObjectClassIndex$_() {
            return isNaN(this._$_objectClassIndex$_) ? this._$_trackDataItem$_._$GetObjectClassIndex$_() : this._$_objectClassIndex$_;
        }
        _$SetObjectClassIndex$_(t) {
            this._$_trackDataItem$_._$SetObjectClassIndex$_(t);
        }
        _$SetOriginalWidth$_(t) {
            this._$_trackDataItem$_._$SetOriginalWidth$_(t);
        }
        _$GetOriginalWidth$_() {
            const t = this._$GetInstance$_();
            if (t) {
                const s = t._$GetSdkInstance$_();
                if (s._$IsOriginalSizeKnown$_()) return t._$GetSdkInstance$_()._$GetOriginalWidth$_();
            }
            return this._$_trackDataItem$_._$GetOriginalWidth$_();
        }
        _$SetOriginalHeight$_(t) {
            this._$_trackDataItem$_._$SetOriginalHeight$_(t);
        }
        _$GetOriginalHeight$_() {
            const t = this._$GetInstance$_();
            if (t) {
                const s = t._$GetSdkInstance$_();
                if (s._$IsOriginalSizeKnown$_()) return t._$GetSdkInstance$_()._$GetOriginalHeight$_();
            }
            return this._$_trackDataItem$_._$GetOriginalHeight$_();
        }
        _$GetType$_() {
            return this._$_trackDataItem$_._$GetType$_();
        }
        _$GetName$_() {
            return this._$_trackDataItem$_._$GetName$_();
        }
        _$IsInstanceTrack$_() {
            return 0 === this._$GetType$_();
        }
        _$IsValueTrack$_() {
            return 1 === this._$GetType$_();
        }
        _$IsAudioTrack$_() {
            return 2 === this._$GetType$_();
        }
        _$GetWorldInfoChange$_() {
            return this._$_worldInfoChange$_;
        }
        _$GetRenderChange$_() {
            return this._$_renderChange$_;
        }
        _$GetNeedsBeforeAndAfter$_() {
            return this._$_needsBeforeAndAfter$_;
        }
        _$IsNested$_() {
            return this._$_isNested$_;
        }
        _$SetResetState$_() {
            for (const t of this._$_propertyTracks$_) t._$SetResetState$_();
        }
        _$SetInitialState$_() {
            if (this._$MaybeGetInstance$_(), this._$IsInstanceValid$_() || !this._$IsInstanceTrack$_()) {
                const t = this._$GetTimeline$_(), s = t._$IsForwardPlayBack$_(), i = s ? 0 : this._$GetLocalTotalTime$_();
                for (const h of this._$_propertyTracks$_) h._$SetInitialState$_(i), 
                0 === this._$_worldInfoChange$_ && 1 === h._$GetWorldInfoChange$_() && (this._$_worldInfoChange$_ = 1), 
                0 === this._$_renderChange$_ && 1 === h._$GetRenderChange$_() && (this._$_renderChange$_ = 1);
                this._$_needsBeforeAndAfter$_ = 0;
                const e = this._$_propertyTracks$_.some(t => t._$GetNeedsBeforeAndAfter$_());
                e && (this._$_needsBeforeAndAfter$_ = 1), this._$_lastKeyframeDataItem$_ = this._$_GetLastKeyFrameBeforeTime$_(i), 
                this._$_initialStateOfNestedSet$_ = !1, this._$_endStateOfNestedSet$_ = !1, 
                this._$Interpolate$_(i), this._$OnKeyframeReached$_(this._$_GetLastKeyFrameBeforeTime$_(i));
            }
        }
        _$SetResumeState$_() {
            if (this._$MaybeGetInstance$_(), this._$IsInstanceValid$_() || !this._$IsInstanceTrack$_()) {
                this._$_timeline$_._$IsForwardPlayBack$_();
                const t = this._$_timeline$_._$GetTime$_() - this._$GetStartOffset$_();
                this._$_lastKeyframeDataItem$_ = this._$_GetLastKeyFrameBeforeTime$_(t);
                for (const s of this._$_propertyTracks$_) s._$SetResumeState$_(t);
            }
        }
        _$SetEndState$_() {
            if (!this._$GetTimeline$_()._$IsComplete$_() && (this._$MaybeGetInstance$_(), 
            this._$IsInstanceValid$_() || !this._$IsInstanceTrack$_()) && !this._$_isNested$_) {
                const t = this._$_timeline$_._$GetTime$_(), s = this._$GetStartOffset$_() + this._$GetLocalTotalTime$_();
                s <= t ? this._$Interpolate$_(this._$GetLocalTotalTime$_(), !0, !1, !0, !1, !1, !0) : t <= 0 && this._$Interpolate$_(0, !0, !1, !0, !1, !1, !0);
            }
        }
        _$_SetUpdateState$_() {
            for (let t = 0, s = this._$_propertyTracks$_.length; t < s; t++) {
                const i = this._$_propertyTracks$_[t];
                i._$_SetUpdateState$_(), 0 === this._$_worldInfoChange$_ && 1 === i._$GetWorldInfoChange$_() && (this._$_worldInfoChange$_ = 1), 
                0 === this._$_renderChange$_ && 1 === i._$GetRenderChange$_() && (this._$_renderChange$_ = 1);
            }
        }
        _$BeforeInterpolate$_() {
            const s = this._$_propertyTracks$_.length;
            for (let t = 0; t < s; t++) this._$_propertyTracks$_[t]._$BeforeInterpolate$_();
        }
        _$Interpolate$_(i, t = !1, e = !1, h = !1, s = !1, r = !1, n = !1) {
            this._$_instance$_ || this._$GetInstance$_();
            const o = this._$_instance$_ && !this._$_instance$_._$IsDestroyed$_(), a = 0 === this._$_trackDataItem$_._$_type$_;
            if ((o || !a) && !(r && a && this._$GetObjectClass$_()._$IsGlobal$_() || (i -= this._$GetStartOffset$_()) < 0)) {
                this._$MaybeSetInitialStateOfNestedTrack$_(i, t), this._$MaybeTriggerKeyframeReachedConditions$_(i, t, s);
                for (let t = 0, s = this._$_propertyTracks$_.length; t < s; t++) this._$_propertyTracks$_[t]._$Interpolate$_(i, e, h, n);
                this._$MaybeSetEndStateOfNestedTrack$_(i, t), 0 !== this._$_worldInfoChange$_ && (this._$_worldInfo$_ || (this._$_worldInfo$_ = this._$_instance$_._$GetWorldInfo$_()), 
                this._$_worldInfo$_) && this._$_worldInfo$_._$SetBboxChanged$_();
            }
        }
        _$AfterInterpolate$_() {
            const s = this._$_propertyTracks$_.length;
            for (let t = 0; t < s; t++) this._$_propertyTracks$_[t]._$AfterInterpolate$_();
        }
        _$MaybeSetInitialStateOfNestedTrack$_(t, s) {
            if (s && this._$_isNested$_ && !this._$_initialStateOfNestedSet$_) {
                const i = this._$GetTimeline$_();
                if (i._$IsForwardPlayBack$_()) {
                    if (t < 0) return;
                } else if (t > this._$GetLocalTotalTime$_()) return;
                for (const e of this._$_propertyTracks$_) e._$SetInitialState$_();
                this._$_initialStateOfNestedSet$_ = !0;
            }
        }
        _$MaybeSetEndStateOfNestedTrack$_(t, s) {
            if (s && this._$_isNested$_ && !this._$_endStateOfNestedSet$_) {
                const i = this._$GetTimeline$_();
                if (i._$IsForwardPlayBack$_()) {
                    if (t >= this._$GetLocalTotalTime$_()) {
                        for (const e of this._$_propertyTracks$_) e._$Interpolate$_(this._$GetLocalTotalTime$_(), !1, !0);
                        this._$_endStateOfNestedSet$_ = !0;
                    }
                } else if (t <= 0) {
                    for (const h of this._$_propertyTracks$_) h._$Interpolate$_(0, !1, !0);
                    this._$_endStateOfNestedSet$_ = !0;
                }
            }
        }
        _$MaybeTriggerKeyframeReachedConditions$_(t, s, i) {
            if (!i && s && Yr._$Plugins$_.Timeline) {
                const e = this._$GetTimeline$_(), h = this._$_lastKeyframeDataItem$_._$GetNext$_(), r = this._$_lastKeyframeDataItem$_._$GetTime$_(), n = h ? h._$GetTime$_() : e._$GetTotalTime$_();
                if (t <= r || n <= t) if (this._$_lastKeyframeDataItem$_ = this._$_trackData$_._$GetFirstKeyFrameDataItemLowerOrEqualThan$_(t, this._$_trackDataItem$_), 
                e._$IsForwardPlayBack$_()) h && this._$OnKeyframeReached$_(this._$_lastKeyframeDataItem$_); else {
                    const o = this._$_lastKeyframeDataItem$_._$GetNext$_();
                    o && this._$OnKeyframeReached$_(o);
                }
            }
        }
        _$_GetLastKeyFrameBeforeTime$_(t) {
            const s = this._$_trackData$_._$GetKeyFrameDataItemAtTime$_(t, this._$_trackDataItem$_);
            return s || this._$_trackData$_._$GetFirstKeyFrameDataItemLowerOrEqualThan$_(t, this._$_trackDataItem$_);
        }
        _$OnKeyframeReached$_(t) {
            if (Yr._$Plugins$_.Timeline) {
                const s = this._$GetTimeline$_(), i = s._$GetTimelineManager$_();
                Yr._$Plugins$_.Timeline._$Cnds$_.PushTriggerTimeline(s), Yr._$Plugins$_.Timeline._$Cnds$_.PushTriggerKeyframe(t), 
                i._$Trigger$_(Yr._$Plugins$_.Timeline._$Cnds$_.OnAnyKeyframeReached), 
                i._$Trigger$_(Yr._$Plugins$_.Timeline._$Cnds$_._$OnKeyframeReached$_), 
                Yr._$Plugins$_.Timeline._$Cnds$_.PopTriggerTimeline(s), Yr._$Plugins$_.Timeline._$Cnds$_.PopTriggerKeyframe(t);
            }
        }
        _$AddKeyframe$_() {
            const t = this._$_trackDataItem$_._$GetKeyframeData$_(), s = t._$AddEmptyKeyframeDataItem$_();
            return s;
        }
        _$AddPropertyTrack$_() {
            const t = this._$_trackDataItem$_._$GetPropertyTrackData$_(), s = t._$AddEmptyPropertyTrackDataItem$_(), i = Yr._$PropertyTrackState$_._$Create$_(this, s);
            return this._$_propertyTracks$_.push(i), i;
        }
        _$DeleteKeyframes$_(t) {
            const s = this._$_trackDataItem$_._$GetKeyframeData$_();
            s._$DeleteKeyframeDataItems$_(t);
        }
        _$DeletePropertyKeyframes$_(t) {
            for (const s of this._$_propertyTracks$_) s._$DeletePropertyKeyframes$_(t);
        }
        _$SaveState$_() {
            for (const t of this._$_propertyTracks$_) t._$SaveState$_();
        }
        _$CompareInitialStateWithCurrent$_() {
            if (this._$MaybeGetInstance$_(), this._$IsInstanceValid$_() || !this._$IsInstanceTrack$_()) for (const t of this._$_propertyTracks$_) t._$CompareInitialStateWithCurrent$_();
        }
        _$CompareSaveStateWithCurrent$_() {
            if (this._$MaybeGetInstance$_(), this._$IsInstanceValid$_() || !this._$IsInstanceTrack$_()) {
                let t = !1;
                for (const s of this._$_propertyTracks$_) {
                    const i = s._$CompareSaveStateWithCurrent$_();
                    !t && i && (t = !0);
                }
                if (t) {
                    const e = this._$AddKeyframe$_();
                    e._$SetTime$_(this._$GetTimeline$_()._$GetTime$_()), e._$SetEase$_("noease"), 
                    e._$SetEnable$_(!0), e._$SetTags$_("");
                }
            }
        }
        _$_OnAfterLoad$_() {
            isNaN(this._$_instanceUidToLoad$_) || this._$_LoadInstanceFromJson$_(this._$_instanceUidToLoad$_), 
            this._$_instanceUidToLoad$_ = NaN;
        }
        _$_SaveToJson$_() {
            const t = this._$GetInstance$_(), s = t ? t._$GetUID$_() : this._$GetInstanceUID$_();
            return {
                propertyTracksJson: this._$_SavePropertyTracksToJson$_(),
                lastKeyframeDataItemJson: this._$_SaveLastKeyframeDataItemToJson$_(),
                initialStateOfNestedSet: this._$_initialStateOfNestedSet$_,
                endStateOfNestedSet: this._$_endStateOfNestedSet$_,
                instanceUid: s,
                cleared: this._$_cleared$_
            };
        }
        _$_LoadFromJson$_(t) {
            if (t) {
                this._$_LoadPropertyTracksFromJson$_(t.propertyTracksJson), this._$_LoadLastKeyframeDataItemFromJson$_(t.lastKeyframeDataItemJson), 
                this._$_instanceUidToLoad$_ = t.instanceUid, this._$_initialStateOfNestedSet$_ = !1, 
                t.hasOwnProperty.initialStateOfNestedSet && (this._$_initialStateOfNestedSet$_ = t.initialStateOfNestedSet), 
                this._$_endStateOfNestedSet$_ = !1, t.hasOwnProperty.endStateOfNestedSet && (this._$_endStateOfNestedSet$_ = t.endStateOfNestedSet), 
                this._$_cleared$_ = !!t.hasOwnProperty("cleared") && t.cleared;
                for (const s of this._$_propertyTracks$_) 0 === this._$_worldInfoChange$_ && 1 === s._$GetWorldInfoChange$_() && (this._$_worldInfoChange$_ = 1), 
                0 === this._$_renderChange$_ && 1 === s._$GetRenderChange$_() && (this._$_renderChange$_ = 1);
                this._$_needsBeforeAndAfter$_ = 0, this._$_propertyTracks$_.some(t => t._$GetNeedsBeforeAndAfter$_()) && (this._$_needsBeforeAndAfter$_ = 1);
            }
        }
        _$_SaveLastKeyframeDataItemToJson$_() {
            const t = this._$_trackDataItem$_._$GetKeyframeData$_();
            return t._$GetKeyframeDataItemIndex$_(this._$_lastKeyframeDataItem$_);
        }
        _$_SavePropertyTracksToJson$_() {
            return this._$_propertyTracks$_.map(t => t._$_SaveToJson$_());
        }
        _$_LoadPropertyTracksFromJson$_(t) {
            t.forEach((t, s) => {
                const i = this._$_propertyTracks$_[s];
                i._$_LoadFromJson$_(t);
            });
        }
        _$_LoadInstanceFromJson$_(t) {
            if (Yr._$IsFiniteNumber$_(t)) {
                const s = this._$GetRuntime$_()._$GetInstanceByUID$_(t);
                if (s) {
                    const i = this._$GetTimeline$_();
                    i._$SetTrackInstance$_(this._$_trackDataItem$_._$GetId$_(), s, this._$GetTrackIndexInTimeline$_());
                }
            }
        }
        _$_LoadLastKeyframeDataItemFromJson$_(t) {
            const s = this._$_trackDataItem$_._$GetKeyframeData$_();
            this._$_lastKeyframeDataItem$_ = s._$GetKeyframeDataItemFromIndex$_(t);
        }
    };
}

{
    const $r = self._$C3$_;
    $r._$PropertyTrackState$_ = class extends $r._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_track$_ = t, this._$_propertyTrackDataItem$_ = s, this._$_propertyTrackData$_ = s._$GetPropertyTrackData$_(), 
            this._$_worldInfoChange$_ = 0, this._$_renderChange$_ = 0, this._$_needsBeforeAndAfter$_ = 0, 
            this._$_sourceAdapter$_ = this._$GetSourceAdapter$_(), this._$_propertyKeyframeDataItems$_ = this._$_propertyTrackDataItem$_._$GetPropertyKeyframeData$_()._$GetPropertyKeyframeDataItemArray$_(), 
            this._$_lastPropertyKeyframeDataItem$_ = null, this._$_absoluteValueObject$_ = null;
        }
        static _$Create$_(t, s) {
            return $r._$New$_($r._$PropertyTrackState$_, t, s);
        }
        _$Release$_() {
            this._$_track$_ = null, this._$_sourceAdapter$_ && (this._$_sourceAdapter$_._$Release$_(), 
            this._$_sourceAdapter$_ = null), this._$_propertyKeyframeDataItems$_ = null, 
            this._$_propertyTrackDataItem$_ = null, this._$_propertyTrackData$_ = null;
        }
        _$GetWorldInfoChange$_() {
            return this._$_worldInfoChange$_;
        }
        _$GetRenderChange$_() {
            return this._$_renderChange$_;
        }
        _$GetNeedsBeforeAndAfter$_() {
            return this._$_needsBeforeAndAfter$_;
        }
        _$HasAbsoluteValueObject$_() {
            return !!this._$_absoluteValueObject$_;
        }
        _$SetAbsoluteValueObject$_(t) {
            this._$_absoluteValueObject$_ = t;
        }
        _$GetAbsoluteValueObject$_() {
            return this._$_absoluteValueObject$_;
        }
        _$GetTrack$_() {
            return this._$_track$_;
        }
        _$GetPropertyTrackDataItem$_() {
            return this._$_propertyTrackDataItem$_;
        }
        _$GetPropertyTrackData$_() {
            return this._$_propertyTrackData$_;
        }
        _$GetTimeline$_() {
            return this._$_track$_._$GetTimeline$_();
        }
        _$GetRuntime$_() {
            return this._$_track$_._$GetRuntime$_();
        }
        _$GetInstance$_() {
            return this._$_track$_._$GetInstance$_();
        }
        _$GetSourceAdapter$_() {
            if (!this._$_sourceAdapter$_) {
                let t = this._$_propertyTrackDataItem$_._$GetSourceAdapterId$_(), s;
                switch (t) {
                  case "behavior":
                    s = new $r._$PropertyTrackState$_._$BehaviorSourceAdapter$_(this);
                    break;

                  case "effect":
                    s = new $r._$PropertyTrackState$_._$EffectSourceAdapter$_(this), 
                    this._$_renderChange$_ = 1;
                    break;

                  case "instance-variable":
                    s = new $r._$PropertyTrackState$_._$InstanceVariableSourceAdapter$_(this);
                    break;

                  case "plugin":
                    s = new $r._$PropertyTrackState$_._$PluginSourceAdapter$_(this), 
                    this._$_renderChange$_ = 1;
                    break;

                  case "world-instance":
                    s = new $r._$PropertyTrackState$_._$PropertySourceAdapter$_(this), 
                    this._$_renderChange$_ = 1, this._$_worldInfoChange$_ = 1;
                    break;

                  case "value":
                    s = new $r._$PropertyTrackState$_._$ValueSourceAdapter$_(this);
                    break;

                  case "audio":
                    s = new $r._$PropertyTrackState$_._$AudioSourceAdapter$_(this);
                }
                this._$_sourceAdapter$_ = s;
            }
            return this._$_sourceAdapter$_;
        }
        _$GetSourceAdapterId$_() {
            return this._$_propertyTrackDataItem$_._$GetSourceAdapterId$_();
        }
        _$SetSourceAdapterId$_(t) {
            this._$_propertyTrackDataItem$_._$SetSourceAdapterId$_(t);
        }
        _$GetSourceAdapterArgs$_() {
            return this._$_propertyTrackDataItem$_._$GetSourceAdapterArguments$_();
        }
        _$SetSourceAdapterArgs$_(t) {
            this._$_propertyTrackDataItem$_._$SetSourceAdapterArguments$_(t);
        }
        _$GetSourceAdapterValue$_() {
            return this._$GetSourceAdapter$_()._$GetValue$_();
        }
        _$GetPropertyName$_() {
            return this._$_propertyTrackDataItem$_._$GetProperty$_();
        }
        _$SetPropertyName$_(t) {
            this._$_propertyTrackDataItem$_._$SetProperty$_(t);
        }
        _$GetPropertyType$_() {
            return this._$_propertyTrackDataItem$_._$GetType$_();
        }
        _$SetPropertyType$_(t) {
            this._$_propertyTrackDataItem$_._$SetType$_(t);
        }
        _$GetPropertyKeyframeType$_() {
            return this._$GetPropertyTrackData$_()._$GetFirstPropertyKeyframeDataItem$_(this._$_propertyTrackDataItem$_)._$GetType$_();
        }
        _$GetMin$_() {
            return this._$_propertyTrackDataItem$_._$GetMin$_();
        }
        _$SetMin$_(t) {
            this._$_propertyTrackDataItem$_._$SetMin$_(t);
        }
        _$GetMax$_() {
            return this._$_propertyTrackDataItem$_._$GetMax$_();
        }
        _$SetMax$_(t) {
            this._$_propertyTrackDataItem$_._$SetMax$_(t);
        }
        _$GetEnable$_() {
            return this._$_propertyTrackDataItem$_._$GetEnable$_();
        }
        _$SetEnable$_(t) {
            this._$_propertyTrackDataItem$_._$SetEnable$_(t);
        }
        _$GetInterpolationMode$_() {
            return this._$_propertyTrackDataItem$_._$GetInterpolationMode$_();
        }
        _$SetInterpolationMode$_(t) {
            this._$_propertyTrackDataItem$_._$SetInterpolationMode$_(t);
        }
        _$GetResultMode$_() {
            return this._$_propertyTrackDataItem$_._$GetResultMode$_();
        }
        _$SetResultMode$_(t) {
            this._$_propertyTrackDataItem$_._$SetResultMode$_(t);
        }
        _$SetEase$_(t) {
            for (const s of this._$GetPropertyKeyframeDataItems$_()) s._$SetEase$_(t);
        }
        _$CanHavePropertyKeyframes$_() {
            return this._$_propertyTrackDataItem$_._$CanHavePropertyKeyframes$_();
        }
        _$GetPropertyKeyframeDataItems$_() {
            return this._$_propertyKeyframeDataItems$_ || (this._$_propertyKeyframeDataItems$_ = this._$_propertyTrackDataItem$_._$GetPropertyKeyframeData$_()._$GetPropertyKeyframeDataItemArray$_()), 
            this._$_propertyKeyframeDataItems$_;
        }
        _$GetPropertyKeyframeDataItemArrayIncludingDisabled$_() {
            return this._$_propertyTrackDataItem$_._$GetPropertyKeyframeData$_()._$GetPropertyKeyframeDataItemArrayIncludingDisabled$_();
        }
        _$GetPropertyKeyFrameDataItemAtTime$_(t) {
            return this._$_propertyTrackData$_._$GetPropertyKeyFrameDataItemAtTime$_(t, this._$_propertyTrackDataItem$_);
        }
        _$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t) {
            return this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_);
        }
        _$GetPropertyKeyframeDataItemPairForTime$_(t) {
            let s = this._$_propertyTrackData$_._$GetPropertyKeyFrameDataItemAtTime$_(t, this._$_propertyTrackDataItem$_), i;
            return i = s ? this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemHigherThan$_(t, this._$_propertyTrackDataItem$_) : (s = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_), 
            this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemHigherOrEqualThan$_(t, this._$_propertyTrackDataItem$_)), 
            {
                start: s,
                end: i
            };
        }
        *_$GetPropertyKeyframeValues$_() {
            for (const t of this._$GetPropertyKeyframeDataItems$_()) yield t._$GetValueWithResultMode$_();
        }
        *_$GetPropertyKeyframeTimes$_() {
            for (const t of this._$GetPropertyKeyframeDataItems$_()) yield t._$GetTime$_();
        }
        _$TimelineRemoved$_() {
            this._$GetSourceAdapter$_()._$TimelineRemoved$_();
        }
        _$CleanCaches$_() {
            this._$GetSourceAdapter$_()._$CleanCaches$_();
        }
        _$GetCurrentState$_() {
            return this._$GetSourceAdapter$_()._$GetCurrentState$_();
        }
        _$SetResetState$_() {
            this._$GetSourceAdapter$_()._$SetResetState$_();
        }
        _$SetInitialState$_(t) {
            this._$GetSourceAdapter$_()._$SetInitialState$_(), this._$_lastPropertyKeyframeDataItem$_ = this._$_GetLastPropertyKeyFrameBeforeTime$_(t), 
            this._$_SetUpdateState$_();
        }
        _$SetResumeState$_(t) {
            this._$GetSourceAdapter$_()._$SetResumeState$_(), this._$_lastPropertyKeyframeDataItem$_ = this._$_GetLastPropertyKeyFrameBeforeTime$_(t);
        }
        _$_SetUpdateState$_() {
            const t = this._$GetTrack$_();
            if (this._$_needsBeforeAndAfter$_ = 0, t._$IsInstanceTrack$_()) {
                const s = this._$GetTimeline$_(), i = t._$GetInstance$_(), e = this._$GetSourceAdapter$_(), h = this._$GetPropertyName$_(), r = e._$MayNeedBeforeAndAfterInterpolate$_();
                if (r) {
                    const n = s._$GetSimilarPropertyTracks$_(i, e, h, this);
                    n && n.length && (this._$_needsBeforeAndAfter$_ = 1);
                } else this._$_needsBeforeAndAfter$_ = 0;
            }
        }
        _$_GetLastPropertyKeyFrameBeforeTime$_(t) {
            const s = this._$GetTimeline$_(), i = this._$_propertyTrackData$_._$GetPropertyKeyFrameDataItemAtTime$_(t, this._$_propertyTrackDataItem$_);
            return i || (s._$IsForwardPlayBack$_() ? this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_) : this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemHigherOrEqualThan$_(t, this._$_propertyTrackDataItem$_));
        }
        _$BeforeInterpolate$_() {
            this._$_sourceAdapter$_._$BeforeInterpolate$_();
        }
        _$Interpolate$_(t, s = !1, i = !1, e = !1) {
            let h, r, n = !1;
            if (s) h = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_); else {
                if (this._$_lastPropertyKeyframeDataItem$_) {
                    const o = this._$GetTimeline$_(), a = this._$_lastPropertyKeyframeDataItem$_._$GetNext$_(), l = this._$_lastPropertyKeyframeDataItem$_._$GetTime$_(), u = a ? a._$GetTime$_() : o._$GetTotalTime$_();
                    (t <= l || u <= t) && (this._$_lastPropertyKeyframeDataItem$_ = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_), 
                    n = !0);
                } else this._$_lastPropertyKeyframeDataItem$_ = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_), 
                n = !0;
                h = this._$_lastPropertyKeyframeDataItem$_;
            }
            h && (r = h._$GetNext$_()), this._$_sourceAdapter$_._$Interpolate$_(t, h, r, s, i, e, n);
        }
        _$GetInterpolatedValue$_(t) {
            if (this._$_lastPropertyKeyframeDataItem$_) {
                const e = this._$GetTimeline$_(), h = this._$_lastPropertyKeyframeDataItem$_._$GetNext$_(), r = this._$_lastPropertyKeyframeDataItem$_._$GetTime$_(), n = h ? h._$GetTime$_() : e._$GetTotalTime$_();
                (t <= r || n <= t) && (this._$_lastPropertyKeyframeDataItem$_ = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_));
            } else this._$_lastPropertyKeyframeDataItem$_ = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_);
            const s = this._$_lastPropertyKeyframeDataItem$_, i = s._$GetNext$_();
            return this._$_sourceAdapter$_._$GetInterpolatedValue$_(t, s, i);
        }
        _$GetInterpolatedValueFast$_(t, s, i) {
            return this._$_sourceAdapter$_._$GetInterpolatedValue$_(t, s, i);
        }
        _$AfterInterpolate$_() {
            this._$_sourceAdapter$_._$AfterInterpolate$_();
        }
        static _$GetStartPropertyKeyframeForTime$_(t, s) {
            const i = s._$GetPropertyTrackDataItem$_(), e = s._$_propertyTrackData$_;
            return e._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, i);
        }
        static _$GetEndPropertyKeyframeForTime$_(t, s) {
            const i = s._$GetPropertyTrackDataItem$_(), e = s._$_propertyTrackData$_;
            return e._$GetFirstPropertyKeyFrameDataItemHigherOrEqualThan$_(t, i);
        }
        _$AddPropertyKeyframe$_() {
            const t = this._$_propertyTrackDataItem$_._$GetPropertyKeyframeData$_(), s = t._$AddEmptyPropertyKeyframeDataItem$_();
            return this._$_lastPropertyKeyframeDataItem$_ = null, s;
        }
        _$DeletePropertyKeyframes$_(t) {
            this._$_lastPropertyKeyframeDataItem$_ = null;
            const s = this._$_propertyTrackDataItem$_._$GetPropertyKeyframeData$_();
            s._$DeletePropertyKeyframeDataItems$_(t);
        }
        _$SaveState$_() {
            this._$GetSourceAdapter$_()._$SaveState$_();
        }
        _$CompareInitialStateWithCurrent$_() {
            const t = this._$GetSourceAdapter$_()._$CompareInitialStateWithCurrent$_();
            if (t) {
                const s = this._$_propertyTrackData$_._$GetFirstPropertyKeyframeDataItem$_(this._$_propertyTrackDataItem$_), i = this._$GetSourceAdapter$_()._$GetCurrentState$_();
                s._$SetAbsoluteValue$_(i);
            }
        }
        _$CompareSaveStateWithCurrent$_() {
            const t = this._$GetSourceAdapter$_()._$CompareSaveStateWithCurrent$_();
            return t && this._$AddPropertyKeyframeAtCurrentTime$_(), this._$GetSourceAdapter$_()._$ClearSaveState$_(), 
            t;
        }
        _$AddPropertyKeyframeAtCurrentTime$_() {
            const t = this._$GetTimeline$_()._$GetTime$_(), s = this._$GetSourceAdapter$_(), i = $r._$PropertyTrackState$_._$GetStartPropertyKeyframeForTime$_(t, this), e = this._$AddPropertyKeyframe$_();
            e._$SetType$_(i._$GetType$_()), e._$SetTime$_(t), e._$SetEase$_(i._$GetEase$_()), 
            e._$SetEnable$_(!0), e._$SetValue$_(s._$GetValueAtTime$_()), e._$SetAbsoluteValue$_(s._$GetCurrentState$_());
        }
        _$_SaveToJson$_() {
            return {
                sourceAdapterJson: this._$GetSourceAdapter$_()._$_SaveToJson$_()
            };
        }
        _$_LoadFromJson$_(t) {
            t && this._$GetSourceAdapter$_()._$_LoadFromJson$_(t.sourceAdapterJson);
        }
    };
}

{
    const Kr = self._$C3$_, Zr = Kr._$PropertyTrackState$_;
    Zr._$PropertySourceAdapter$_ = class {
        constructor(t) {
            this._$_propertyTrack$_ = t, this._$_propertyAdapter$_ = null, this._$GetPropertyAdapter$_();
        }
        _$Release$_() {
            this._$_propertyAdapter$_ && (this._$_propertyAdapter$_._$Release$_(), 
            this._$_propertyAdapter$_ = null), this._$_propertyTrack$_ = null;
        }
        _$MayNeedBeforeAndAfterInterpolate$_() {
            return this._$_propertyAdapter$_._$MayNeedBeforeAndAfterInterpolate$_();
        }
        _$GetPropertyTrack$_() {
            return this._$_propertyTrack$_;
        }
        _$TimelineRemoved$_() {
            this._$_propertyAdapter$_ && this._$_propertyAdapter$_._$TimelineRemoved$_();
        }
        _$CleanCaches$_() {
            this._$_propertyAdapter$_ && this._$_propertyAdapter$_._$CleanCaches$_();
        }
        _$GetPropertyAdapter$_() {
            return this._$_propertyAdapter$_ || (this._$_propertyAdapter$_ = this._$_CreatePropertyAdapter$_()), 
            this._$_propertyAdapter$_;
        }
        _$GetEditorIndex$_() {}
        _$GetIndex$_() {
            return this._$GetEditorIndex$_();
        }
        _$GetTarget$_() {}
        _$SetResetState$_() {
            this._$GetPropertyAdapter$_()._$SetResetState$_();
        }
        _$SetInitialState$_() {
            this._$GetPropertyAdapter$_()._$SetInitialState$_();
        }
        _$SetResumeState$_() {
            this._$GetPropertyAdapter$_()._$SetResumeState$_();
        }
        _$BeforeInterpolate$_() {
            this._$_propertyAdapter$_._$BeforeChangeProperty$_();
        }
        _$Interpolate$_(t, s, i, e, h, r, n) {
            let o = this._$_propertyTrack$_._$GetPropertyKeyframeType$_(), a;
            switch (o) {
              case "numeric":
                a = Zr._$NumericTypeAdapter$_._$Interpolate$_(t, s, i, this._$_propertyTrack$_);
                break;

              case "angle":
                a = Zr._$AngleTypeAdapter$_._$Interpolate$_(t, s, i, this._$_propertyTrack$_);
                break;

              case "boolean":
                a = Zr._$BooleanTypeAdapter$_._$Interpolate$_(t, s, i, this._$_propertyTrack$_);
                break;

              case "color":
                a = Zr._$ColorTypeAdapter$_._$Interpolate$_(t, s, i, this._$_propertyTrack$_);
                break;

              case "text":
                a = Zr._$TextTypeAdapter$_._$Interpolate$_(t, s, i, this._$_propertyTrack$_);
            }
            this._$_propertyAdapter$_._$ChangeProperty$_(t, a, s, i, e, h, r, n);
        }
        _$GetInterpolatedValue$_(t, s, i) {
            switch (this._$_propertyTrack$_._$GetPropertyKeyframeType$_()) {
              case "numeric":
                return Zr._$NumericTypeAdapter$_._$Interpolate$_(t, s, i, this._$_propertyTrack$_);

              case "angle":
                return Zr._$AngleTypeAdapter$_._$Interpolate$_(t, s, i, this._$_propertyTrack$_);

              case "boolean":
                return Zr._$BooleanTypeAdapter$_._$Interpolate$_(t, s, i, this._$_propertyTrack$_);

              case "color":
                return Zr._$ColorTypeAdapter$_._$Interpolate$_(t, s, i, this._$_propertyTrack$_);

              case "text":
                return Zr._$TextTypeAdapter$_._$Interpolate$_(t, s, i, this._$_propertyTrack$_);
            }
        }
        _$AfterInterpolate$_() {
            this._$_propertyAdapter$_._$AfterChangeProperty$_();
        }
        _$SaveState$_() {
            this._$GetPropertyAdapter$_()._$SetSaveState$_();
        }
        _$ClearSaveState$_() {
            this._$GetPropertyAdapter$_()._$ClearSaveState$_();
        }
        _$GetCurrentState$_() {
            return this._$GetPropertyAdapter$_()._$GetCurrentState$_();
        }
        _$CompareInitialStateWithCurrent$_() {
            return this._$GetPropertyAdapter$_()._$CompareInitialStateWithCurrent$_();
        }
        _$CompareSaveStateWithCurrent$_() {
            return this._$GetPropertyAdapter$_()._$CompareSaveStateWithCurrent$_();
        }
        _$GetValueAtTime$_() {
            const t = this._$_propertyTrack$_, s = t._$GetTrack$_(), i = s._$GetTimeline$_()._$GetTime$_(), e = Zr._$GetStartPropertyKeyframeForTime$_(i, t), h = e._$GetNext$_(), r = t._$GetPropertyKeyframeType$_();
            switch (r) {
              case "numeric":
                return Zr._$NumericTypeAdapter$_._$Interpolate$_(i, e, h, t);

              case "angle":
                return Zr._$AngleTypeAdapter$_._$Interpolate$_(i, e, h, t);

              case "boolean":
                return Zr._$BooleanTypeAdapter$_._$Interpolate$_(i, e, h, t);

              case "color":
                return Zr._$ColorTypeAdapter$_._$Interpolate$_(i, e, h, t);

              case "text":
                return Zr._$TextTypeAdapter$_._$Interpolate$_(i, e, h, t);
            }
        }
        _$_CreatePropertyAdapter$_() {
            const t = this._$_propertyTrack$_, s = t._$CanHavePropertyKeyframes$_() ? t._$GetPropertyKeyframeType$_() : "";
            switch (s) {
              case "combo":
              case "boolean":
              case "text":
              case "string":
                return new Zr._$PropertyInterpolationAdapter$_._$NoInterpolationAdapter$_(this);

              case "numeric":
              case "number":
              case "angle":
                return new ("combo" === this._$_propertyTrack$_._$GetPropertyType$_() ? Zr._$PropertyInterpolationAdapter$_._$NoInterpolationAdapter$_ : Zr._$PropertyInterpolationAdapter$_._$NumericInterpolationAdapter$_)(this);

              case "color":
              case "offsetColor":
                return new Zr._$PropertyInterpolationAdapter$_._$ColorInterpolationAdapter$_(this);

              default:
                return new Zr._$PropertyInterpolationAdapter$_._$NumericInterpolationAdapter$_(this);
            }
        }
        _$_SaveToJson$_() {
            return {
                propertyAdapterJson: this._$GetPropertyAdapter$_()._$_SaveToJson$_()
            };
        }
        _$_LoadFromJson$_(t) {
            t && this._$GetPropertyAdapter$_()._$_LoadFromJson$_(t.propertyAdapterJson);
        }
    };
}

{
    const Qr = self._$C3$_;
    class tn extends Qr._$PropertyTrackState$_._$PropertySourceAdapter$_ {
        constructor(t) {
            super(t), this._$_updatedIndex$_ = NaN;
        }
        _$GetEditorIndex$_() {
            return this._$_propertyTrack$_._$GetPropertyTrackDataItem$_()._$GetSourceAdapterArguments$_()[0];
        }
        _$GetIndex$_() {
            return this._$_updatedIndex$_ || super._$GetIndex$_();
        }
        _$GetTarget$_() {
            return this._$_propertyTrack$_._$GetTrack$_()._$GetInstance$_();
        }
        _$UpdateInstanceVariableIndex$_(t) {
            const s = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_()._$GetSourceAdapterArguments$_()[0];
            s !== t && (this._$_updatedIndex$_ = t);
        }
        _$Interpolate$_(t, s, i, e, h, r, n) {
            this._$GetPropertyAdapter$_()._$CanChange$_(s._$GetValue$_()) && super._$Interpolate$_(t, s, i, e, h, r, n);
        }
        _$GetInterpolatedValue$_(t, s, i) {
            if (this._$GetPropertyAdapter$_()._$CanChange$_(s._$GetValue$_())) return super._$GetInterpolatedValue$_(t, s, i);
        }
        _$_SaveToJson$_() {
            return Object.assign(super._$_SaveToJson$_(), {
                index: this._$_updatedIndex$_
            });
        }
        _$_LoadFromJson$_(t) {
            t && (super._$_LoadFromJson$_(t), this._$_updatedIndex$_ = t.index);
        }
    }
    Qr._$PropertyTrackState$_._$InstanceVariableSourceAdapter$_ = tn;
}

{
    const sn = self._$C3$_;
    class en extends sn._$PropertyTrackState$_._$PropertySourceAdapter$_ {
        constructor(t) {
            super(t), this._$_sid$_ = NaN;
        }
        _$GetEditorIndex$_() {
            const t = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_();
            return t._$GetSourceAdapterArguments$_()[1];
        }
        _$GetTarget$_() {
            const t = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_(), s = this._$_propertyTrack$_._$GetTrack$_(), i = this._$_sid$_ || t._$GetSourceAdapterArguments$_()[0], e = s._$GetInstance$_(), h = e._$GetBehaviorIndexBySID$_(i), r = e._$GetBehaviorInstances$_()[h];
            return r._$GetSdkInstance$_();
        }
        _$GetBehaviorType$_(t) {
            const s = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_(), i = s._$GetSourceAdapterArguments$_()[2];
            return t._$GetBehaviorTypeByName$_(i);
        }
        _$UpdateBehaviorTypeSid$_(t) {
            const s = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_();
            s._$GetSourceAdapterArguments$_()[0] !== t && (this._$_sid$_ = t);
        }
        _$Interpolate$_(t, s, i, e, h, r, n) {
            const o = this._$_propertyTrack$_._$GetTrack$_(), a = o._$GetInstance$_();
            this._$GetBehaviorType$_(a._$GetObjectClass$_()) && super._$Interpolate$_(t, s, i, e, h, r, n);
        }
        _$GetInterpolatedValue$_(t, s, i) {
            const e = this._$_propertyTrack$_._$GetTrack$_(), h = e._$GetInstance$_();
            if (this._$GetBehaviorType$_(h._$GetObjectClass$_())) return super._$GetInterpolatedValue$_(t, s, i);
        }
        _$_SaveToJson$_() {
            return Object.assign(super._$_SaveToJson$_(), {
                sid: this._$_sid$_
            });
        }
        _$_LoadFromJson$_(t) {
            t && (super._$_LoadFromJson$_(t), this._$_sid$_ = t.sid);
        }
    }
    sn._$PropertyTrackState$_._$BehaviorSourceAdapter$_ = en;
}

{
    const hn = self._$C3$_;
    class rn extends hn._$PropertyTrackState$_._$PropertySourceAdapter$_ {
        constructor(t) {
            super(t);
        }
        _$GetEditorIndex$_() {
            return this._$_propertyTrack$_._$GetPropertyTrackDataItem$_()._$GetSourceAdapterArguments$_()[1];
        }
        _$GetTarget$_() {
            const t = this._$_propertyTrack$_, s = t._$GetTrack$_(), i = s._$GetWorldInfo$_(), e = i._$GetInstanceEffectList$_(), h = e._$GetEffectList$_(), r = this._$GetEffectType$_(h), n = r._$GetIndex$_();
            return e._$IsEffectIndexActive$_(n) ? e._$GetEffectParametersForIndex$_(n) : null;
        }
        _$GetEffectType$_(t) {
            const s = this._$_propertyTrack$_, i = s._$GetPropertyTrackDataItem$_()._$GetSourceAdapterArguments$_()[0];
            return t._$GetEffectTypeByName$_(i);
        }
        _$Interpolate$_(t, s, i, e, h, r, n) {
            this._$_IsEffectActive$_() && super._$Interpolate$_(t, s, i, e, h, r, n);
        }
        _$GetInterpolatedValue$_(t, s, i) {
            if (this._$_IsEffectActive$_()) return super._$GetInterpolatedValue$_(t, s, i);
        }
        _$_IsEffectActive$_() {
            const t = this._$_propertyTrack$_, s = t._$GetTrack$_(), i = s._$GetWorldInfo$_(), e = i._$GetInstanceEffectList$_(), h = e._$GetEffectList$_(), r = this._$GetEffectType$_(h);
            if (r) {
                const n = r._$GetIndex$_();
                return e._$IsEffectIndexActive$_(n);
            }
        }
    }
    hn._$PropertyTrackState$_._$EffectSourceAdapter$_ = rn;
}

{
    const nn = self._$C3$_;
    class on extends nn._$PropertyTrackState$_._$PropertySourceAdapter$_ {
        constructor(t) {
            super(t);
        }
        _$GetEditorIndex$_() {
            return this._$_propertyTrack$_._$GetPropertyTrackDataItem$_()._$GetSourceAdapterArguments$_()[0];
        }
        _$GetTarget$_() {
            return this._$_propertyTrack$_._$GetTrack$_()._$GetInstance$_()._$GetSdkInstance$_();
        }
        _$Interpolate$_(t, s, i, e, h, r, n) {
            const o = this._$_propertyTrack$_._$GetTrack$_(), a = o._$GetObjectClass$_()._$GetPlugin$_(), l = o._$GetInstance$_()._$GetObjectClass$_()._$GetPlugin$_();
            a === l && super._$Interpolate$_(t, s, i, e, h, r, n);
        }
        _$GetInterpolatedValue$_(t, s, i) {
            const e = this._$_propertyTrack$_._$GetTrack$_(), h = e._$GetObjectClass$_()._$GetPlugin$_(), r = e._$GetInstance$_()._$GetObjectClass$_()._$GetPlugin$_();
            if (h === r) return super._$GetInterpolatedValue$_(t, s, i);
        }
        _$GetOptionalCallbacks$_() {
            const t = this._$_propertyTrack$_._$GetTrack$_(), s = t._$GetObjectClass$_()._$GetPlugin$_();
            if (nn._$Plugins$_._$Sprite$_ && s instanceof nn._$Plugins$_._$Sprite$_ && ("initial-frame" === this._$_propertyTrack$_._$GetPropertyName$_() || "initial-animation" === this._$_propertyTrack$_._$GetPropertyName$_())) switch (this._$_propertyTrack$_._$GetResultMode$_()) {
              case "relative":
              case "absolute":
                return null;
            }
        }
    }
    nn._$PropertyTrackState$_._$PluginSourceAdapter$_ = on;
}

{
    const an = self._$C3$_;
    class ln extends an._$PropertyTrackState$_._$PropertySourceAdapter$_ {
        constructor(t) {
            super(t), this._$_value$_ = 0, this._$_init$_ = !1;
        }
        _$MayNeedBeforeAndAfterInterpolate$_() {
            return !1;
        }
        _$SetInitialState$_() {
            let t = this._$_propertyTrack$_._$GetPropertyTrackData$_(), s = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_();
            s = t._$GetFirstPropertyKeyframeDataItem$_(s), this._$_value$_ = s._$GetValueWithResultMode$_();
        }
        _$SetResumeState$_() {}
        _$GetValue$_() {
            return this._$_init$_ || this._$_propertyTrack$_._$Interpolate$_(0), 
            this._$_value$_;
        }
        _$Interpolate$_(t, s, i, e, h, r, n) {
            this._$_value$_ = an._$PropertyTrackState$_._$NumericTypeAdapter$_._$Interpolate$_(t, s, i, this._$_propertyTrack$_), 
            this._$_init$_ = !0;
        }
        _$SaveState$_() {}
        _$ClearSaveState$_() {}
        _$GetCurrentState$_() {
            return this._$_value$_;
        }
        _$CompareInitialStateWithCurrent$_() {
            return !1;
        }
        _$CompareSaveStateWithCurrent$_() {
            return !1;
        }
        _$_SaveToJson$_() {
            return {
                value: this._$_value$_,
                init: this._$_init$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (this._$_value$_ = t.value, this._$_init$_ = !t.hasOwnProperty("init") || t.init);
        }
    }
    an._$PropertyTrackState$_._$ValueSourceAdapter$_ = ln;
}

{
    const un = self._$C3$_;
    class cn extends un._$PropertyTrackState$_._$PropertySourceAdapter$_ {
        constructor(t) {
            super(t), this._$_audioPlaybackStarted$_ = !1, this._$_sdkInstance$_ = null, 
            this._$_actions$_ = null, this._$_expressions$_ = null, this._$_timeline$_ = this._$_propertyTrack$_._$GetTimeline$_(), 
            this._$_track$_ = this._$_propertyTrack$_._$GetTrack$_(), this._$_sourceAdapterArgs$_ = this._$_propertyTrack$_._$GetSourceAdapterArgs$_(), 
            this._$_fileArgs$_ = this._$_sourceAdapterArgs$_[0], this._$_startOffsetTime$_ = this._$_sourceAdapterArgs$_[1], 
            this._$_sourceAdapterArgs$_[3] ? this._$_audioTag$_ = this._$_sourceAdapterArgs$_[3] : this._$_audioTag$_ = Math.random().toString(36).slice(2), 
            this._$_pauseTime$_ = NaN, this._$_pauseVolume$_ = NaN, this._$_volume$_ = NaN, 
            this._$_audioSource$_ = null, this._$_Initialize$_();
        }
        _$Release$_() {
            super._$Release$_(), this._$_sdkInstance$_ = null, this._$_actions$_ = null, 
            this._$_expressions$_ = null, this._$_timeline$_ = null, this._$_track$_ = null, 
            this._$_sourceAdapterArgs$_ = null, this._$_fileArgs$_ = null, this._$_audioSource$_ = null;
        }
        _$_Initialize$_() {
            if (self._$C3$_._$Plugins$_.Audio) {
                const t = this._$_propertyTrack$_._$GetRuntime$_(), s = t._$GetSingleGlobalObjectClassByCtor$_(self._$C3$_._$Plugins$_.Audio);
                s && (this._$_sdkInstance$_ = s._$GetSingleGlobalInstance$_()._$GetSdkInstance$_()), 
                this._$_actions$_ = self._$C3$_._$Plugins$_.Audio._$Acts$_, this._$_expressions$_ = self._$C3$_._$Plugins$_.Audio._$Exps$_;
            }
        }
        _$_MaybeSetAudioSource$_() {
            if (!this._$_audioSource$_) {
                const t = this._$_propertyTrack$_._$GetTrack$_(), s = t._$GetPropertyTrack$_("audioSource");
                s && (this._$_audioSource$_ = s._$GetSourceAdapter$_());
            }
        }
        _$_GetPauseVolume$_() {
            const t = this._$_propertyTrack$_._$GetTrack$_(), s = t._$GetPropertyTrack$_("volume");
            return (s ? s._$GetSourceAdapter$_() : this)._$_pauseVolume$_;
        }
        _$TimelineRemoved$_() {
            super._$TimelineRemoved$_(), this._$_audioPlaybackStarted$_ = !1, this._$_sdkInstance$_ && (this._$_expressions$_ && (this._$_pauseTime$_ = this._$_expressions$_._$PlaybackTime$_.call(this._$_sdkInstance$_, this._$_audioTag$_), 
            this._$_pauseVolume$_ = this._$_expressions$_._$Volume$_.call(this._$_sdkInstance$_, this._$_audioTag$_)), 
            this._$_actions$_) && this._$_actions$_._$Stop$_.call(this._$_sdkInstance$_, this._$_audioTag$_);
        }
        _$GetAudioTag$_() {
            return this._$_audioTag$_;
        }
        _$GetVolume$_() {
            return this._$_volume$_;
        }
        _$SetVolume$_(t) {
            this._$_volume$_ = t;
        }
        _$SetInitialState$_() {
            super._$SetInitialState$_(), this._$_pauseTime$_ = NaN, this._$_audioPlaybackStarted$_ = !1;
        }
        _$SetResumeState$_() {
            super._$SetResumeState$_();
            const t = this._$_propertyTrack$_._$GetTimeline$_(), s = t._$GetTime$_();
            switch (this._$_pauseTime$_ = s - this._$_startOffsetTime$_, this._$_propertyTrack$_._$GetPropertyName$_()) {
              case "audioSource":
                break;

              case "volume":
                this._$_pauseVolume$_ = this._$_propertyTrack$_._$GetInterpolatedValue$_(s);
            }
            this._$_audioPlaybackStarted$_ = !1;
        }
        _$Interpolate$_(t, s, i, e, h, r, n) {
            if (this._$_sdkInstance$_) switch (this._$_propertyTrack$_._$GetPropertyName$_()) {
              case "audioSource":
                {
                    if (!this._$_timeline$_._$IsForwardPlayBack$_()) return;
                    if (e) return void (this._$_actions$_ && this._$_actions$_._$Stop$_.call(this._$_sdkInstance$_, this._$_audioTag$_));
                    if (t < this._$_startOffsetTime$_) return void (this._$_audioPlaybackStarted$_ = !1);
                    const o = this._$_expressions$_._$PlaybackRate$_.call(this._$_sdkInstance$_, this._$_audioTag$_), a = this._$_timeline$_._$GetPlaybackRate$_();
                    if (a !== o && this._$_actions$_._$SetPlaybackRate$_.call(this._$_sdkInstance$_, this._$_audioTag$_, a), 
                    this._$_audioPlaybackStarted$_) return;
                    if (!this._$_propertyTrack$_._$GetTimeline$_().IsPlaying()) return;
                    if (this._$_audioPlaybackStarted$_ = !0, isNaN(this._$_pauseTime$_)) {
                        const l = self.performance.now(), u = t - this._$_startOffsetTime$_, c = this._$_sdkInstance$_._$GetAudioContextState$_();
                        if ("suspended" === c) return void (this._$_audioPlaybackStarted$_ = !1);
                        const f = self.performance.now(), d = (f - l) / 1e3, p = u + d;
                        if (this._$_actions$_) {
                            let t = this._$GetVolume$_();
                            isNaN(t) ? (this._$SetVolume$_(0), t = 0) : this._$SetVolume$_(t), 
                            this._$_actions$_._$PlayFromTimeline$_.call(this._$_sdkInstance$_, this._$_fileArgs$_, t, this._$_audioTag$_, p);
                        }
                    } else {
                        const m = this._$_pauseTime$_, g = (this._$_pauseTime$_ = NaN, 
                        this._$_GetPauseVolume$_()), y = (this._$_pauseVolume$_ = NaN, 
                        this._$_sdkInstance$_._$GetAudioContextState$_());
                        if ("suspended" === y) return void (this._$_audioPlaybackStarted$_ = !1);
                        this._$_actions$_ && (this._$SetVolume$_(g), this._$_actions$_._$PlayFromTimeline$_.call(this._$_sdkInstance$_, this._$_fileArgs$_, g, this._$_audioTag$_, m));
                    }
                    break;
                }

              case "volume":
                this._$_MaybeSetAudioSource$_(), super._$Interpolate$_(t, s, i, e, h, r, n);
            }
        }
        _$GetInterpolatedValue$_(t, s, i) {
            if (this._$_sdkInstance$_) switch (this._$_propertyTrack$_._$GetPropertyName$_()) {
              case "audioSource":
                return;

              case "volume":
                return this._$_MaybeSetAudioSource$_(), super._$GetInterpolatedValue$_(t, s, i);
            }
        }
        _$Getter$_(t, s) {
            return this._$_audioSource$_ ? this._$_audioSource$_._$GetVolume$_() : 0;
        }
        _$Setter$_(t, s, i, e) {
            this._$_audioSource$_ && this._$_audioSource$_._$SetVolume$_(this._$Getter$_() + s), 
            this._$_actions$_ && this._$_audioSource$_ && this._$_actions$_._$SetVolume$_.call(this._$_sdkInstance$_, this._$_audioSource$_._$GetAudioTag$_(), this._$_audioSource$_._$GetVolume$_());
        }
        _$AbsoluteSetter$_(t, s, i) {
            this._$_audioSource$_ && this._$_audioSource$_._$SetVolume$_(s), this._$_actions$_ && this._$_audioSource$_ && this._$_actions$_._$SetVolume$_.call(this._$_sdkInstance$_, this._$_audioSource$_._$GetAudioTag$_(), this._$_audioSource$_._$GetVolume$_());
        }
        _$DoesRounding$_() {
            return !0;
        }
        _$_SaveToJson$_() {
            return {
                audioPlaybackStarted: this._$_audioPlaybackStarted$_,
                audioTag: this._$_audioTag$_,
                pauseTime: this._$_pauseTime$_,
                pauseVolume: this._$_pauseVolume$_,
                volume: this._$_volume$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (this._$_audioPlaybackStarted$_ = t.audioPlaybackStarted, this._$_audioTag$_ = t.audioTag, 
            this._$_pauseTime$_ = t.pauseTime, this._$_pauseVolume$_ = t.pauseVolume, 
            this._$_volume$_ = t.volume, this._$_Initialize$_());
        }
    }
    un._$PropertyTrackState$_._$AudioSourceAdapter$_ = cn;
}

{
    const fn = self._$C3$_;
    fn._$PropertyTrackState$_._$PropertyInterpolationAdapter$_ = class {
        constructor(t) {
            this._$_sourceAdapter$_ = t, this._$_propertyTrack$_ = t._$GetPropertyTrack$_(), 
            this._$_worldInfo$_ = this._$_propertyTrack$_._$GetTrack$_()._$GetWorldInfo$_(), 
            this._$_property$_ = this._$_propertyTrack$_._$GetPropertyName$_(), 
            this._$_firstAbsoluteUpdate$_ = !1, this._$_saveState$_ = null, this._$_target$_ = null;
        }
        _$Release$_() {
            this._$_sourceAdapter$_ = null, this._$_propertyTrack$_ = null, this._$_worldInfo$_ = null, 
            this._$_saveState$_ = null, this._$_target$_ = null;
        }
        _$MayNeedBeforeAndAfterInterpolate$_() {
            return !1;
        }
        _$TimelineRemoved$_() {}
        _$CleanCaches$_() {
            this._$_worldInfo$_ = null, this._$_saveState$_ = null, this._$_target$_ = null;
        }
        _$GetSourceAdapter$_() {
            return this._$_sourceAdapter$_;
        }
        _$GetPropertyTrack$_() {
            return this._$_propertyTrack$_;
        }
        _$GetWorldInfo$_() {
            return this._$_worldInfo$_ || (this._$_worldInfo$_ = this._$_propertyTrack$_._$GetTrack$_()._$GetWorldInfo$_()), 
            this._$_worldInfo$_;
        }
        _$SetFirstAbsoluteUpdate$_(t) {
            this._$_firstAbsoluteUpdate$_ = !!t;
        }
        _$GetFirstAbsoluteUpdate$_() {
            return this._$_firstAbsoluteUpdate$_;
        }
        _$SetResetState$_() {}
        _$SetInitialState$_() {}
        _$SetResumeState$_() {}
        _$SetSaveState$_() {
            this._$_saveState$_ = this._$GetCurrentState$_();
        }
        _$ClearSaveState$_() {
            this._$_saveState$_ = null;
        }
        _$GetCurrentState$_() {}
        _$CompareInitialStateWithCurrent$_() {}
        _$CompareSaveStateWithCurrent$_() {}
        _$CanChange$_(t) {
            const s = typeof this._$_Getter$_(), i = typeof t;
            return s == i;
        }
        _$BeforeChangeProperty$_() {}
        _$ChangeProperty$_(t, s, i, e, h, r, n, o) {}
        _$AfterChangeProperty$_() {}
        _$_FirstKeyframeGetter$_() {
            const t = this._$_PickTimelinePlaybackMode$_(() => {
                const t = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_(), s = this._$_propertyTrack$_._$GetPropertyTrackData$_();
                return s._$GetFirstPropertyKeyframeDataItem$_(t);
            }, () => {
                const t = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_(), s = this._$_propertyTrack$_._$GetPropertyTrackData$_();
                return s._$GetLastPropertyKeyframeDataItem$_(t);
            });
            return t._$GetAbsoluteValue$_();
        }
        _$_CurrentKeyframeGetter$_() {
            const t = this._$_propertyTrack$_._$GetTimeline$_(), e = t._$GetTime$_() - this._$_propertyTrack$_._$GetTrack$_()._$GetStartOffset$_(), s = this._$_PickTimelinePlaybackMode$_(() => {
                const t = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_(), s = this._$_propertyTrack$_._$GetPropertyTrackData$_();
                return s._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(e, t);
            }, () => {
                const t = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_(), s = this._$_propertyTrack$_._$GetPropertyTrackData$_(), i = s._$GetFirstPropertyKeyFrameDataItemHigherOrEqualThan$_(e, t);
                return i || s._$GetLastPropertyKeyframeDataItem$_(t);
            });
            return s._$GetAbsoluteValue$_();
        }
        _$_PickTimelinePlaybackMode$_(t, s) {
            const i = this._$_propertyTrack$_._$GetTimeline$_();
            return (i._$IsForwardPlayBack$_() ? t : s)();
        }
        _$_PickResultMode$_(t, s) {
            const i = this._$_propertyTrack$_._$GetResultMode$_();
            return ("relative" === i ? t : s)();
        }
        _$_PickFirstAbsoluteUpdate$_(t, s) {
            return (this._$GetFirstAbsoluteUpdate$_() ? (this._$SetFirstAbsoluteUpdate$_(!1), 
            t) : s)();
        }
        _$_GetAbsoluteInitialValue$_(t) {}
        _$_GetIndex$_() {
            return this._$_sourceAdapter$_._$GetIndex$_();
        }
        _$_GetTarget$_() {
            return this._$_target$_ || (this._$_target$_ = this._$_sourceAdapter$_._$GetTarget$_()), 
            this._$_target$_;
        }
        _$_PickSource$_(t, s, i, e, h, r) {
            const n = this._$_propertyTrack$_._$GetSourceAdapterId$_();
            switch (n) {
              case "behavior":
                return t();

              case "effect":
                return s();

              case "instance-variable":
                return i();

              case "plugin":
                return e();

              case "world-instance":
                return h();

              case "audio":
                return r();
            }
        }
        _$_SaveToJson$_() {
            return {
                firstAbsoluteUpdate: this._$_firstAbsoluteUpdate$_,
                saveState: this._$_saveState$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (this._$_firstAbsoluteUpdate$_ = t.firstAbsoluteUpdate, this._$_saveState$_ = t.saveState);
        }
        _$_GetPropertyKeyframeStubs$_(t, s = !1) {
            const i = [];
            for (const e of t) {
                const h = e._$GetTrack$_()._$GetStartOffset$_();
                for (const r of e._$GetPropertyKeyframeDataItems$_()) (!s || 0 !== r._$GetTime$_()) && s || i.push({
                    time: h + r._$GetTime$_(),
                    value: r._$GetAbsoluteValue$_()
                });
            }
            return i.sort((t, s) => t.time - s.time);
        }
        _$_GetLastPropertyKeyframeStub$_(t, s, i) {
            return this._$_GetPropertyKeyframeStubLowerThanPlayhead$_(s, i);
        }
        _$_GetPropertyKeyframeStubLowerThanPlayhead$_(s, i) {
            for (let t = i.length - 1; 0 <= t; t--) {
                const e = i[t].time;
                if (e <= s) return i[t];
            }
            return null;
        }
    };
}

{
    const dn = self._$C3$_, pn = new Map(), mn = [ 0, 0, 0 ];
    class gn extends dn._$PropertyTrackState$_._$PropertyInterpolationAdapter$_ {
        constructor(t) {
            super(t);
        }
        _$SetResetState$_() {}
        _$SetInitialState$_() {}
        _$SetResumeState$_() {}
        _$GetCurrentState$_() {
            const t = this._$_propertyTrack$_._$GetSourceAdapterId$_(), s = this._$_GetTarget$_(), i = this._$_GetIndex$_();
            switch (t) {
              case "behavior":
                return this._$_ToColorArray$_(s._$GetPropertyValueByIndex$_(i));

              case "effect":
                return this._$_ToColorArray$_(s[i]);

              case "plugin":
                return this._$_ToColorArray$_(s._$GetPropertyValueByIndex$_(i));

              case "world-instance":
                return this._$_ToColorArray$_(this._$_Getter$_());
            }
        }
        _$CompareInitialStateWithCurrent$_() {
            const t = this._$_FirstKeyframeGetter$_();
            return !this._$_CompareColors$_(t, this._$_Getter$_());
        }
        _$CompareSaveStateWithCurrent$_() {
            return !dn._$IsNullOrUndefined$_(this._$_saveState$_) && !this._$_CompareColors$_(this._$_saveState$_, this._$_Getter$_());
        }
        _$_CompareColors$_(t, s) {
            return t = this._$_GetColorFromArray$_(t), s = this._$_GetColorFromArray$_(s), 
            t._$equalsIgnoringAlpha$_(s);
        }
        _$_FirstKeyframeGetter$_() {
            const t = super._$_FirstKeyframeGetter$_();
            return this._$_GetColorFromArray$_(t);
        }
        _$_CurrentKeyframeGetter$_() {
            const t = super._$_CurrentKeyframeGetter$_();
            return this._$_GetColorFromArray$_(t);
        }
        _$_GetAbsoluteInitialValue$_(t) {}
        _$_ToColorArray$_(t) {
            return (dn._$IsInstanceOf$_(t, dn._$Color$_) ? t.toArray() : t).slice(0, 3);
        }
        _$_GetColorFromArray$_(t) {
            return dn._$IsInstanceOf$_(t, dn._$Color$_) ? t : new dn._$Color$_(t[0], t[1], t[2], 1);
        }
        _$CanChange$_(t) {
            return !0;
        }
        _$MayNeedBeforeAndAfterInterpolate$_() {
            return !0;
        }
        _$BeforeChangeProperty$_() {
            const t = this._$_propertyTrack$_._$GetTimeline$_(), s = this._$_propertyTrack$_._$GetInstance$_(), i = this._$_propertyTrack$_._$GetSourceAdapter$_(), e = t._$GetSimilarPropertyTracks$_(s, i, this._$_property$_, this._$_propertyTrack$_);
            if (e && 1 < e.length) {
                pn.has(s) || pn.set(s, new Map());
                const h = pn.get(s), r = this._$_propertyTrack$_._$GetSourceAdapterId$_(), n = (h.has(r) || h.set(r, new Map()), 
                h.get(r));
                n.has(this._$_property$_) || n.set(this._$_property$_, {
                    _$used$_: !1,
                    color: new dn._$Color$_(0, 0, 0, 1)
                });
            }
        }
        _$_GetTmpColor$_(t, s, i) {
            const e = pn.get(t).get(s).get(i);
            return e._$used$_ = !0, e.color;
        }
        _$ChangeProperty$_(t, s, i, e, h, r, n, o) {
            const a = this._$_propertyTrack$_._$GetTimeline$_(), l = this._$_propertyTrack$_._$GetTrack$_(), u = this._$_propertyTrack$_._$GetInstance$_(), c = this._$_propertyTrack$_._$GetSourceAdapter$_(), f = this._$_propertyTrack$_._$GetSourceAdapterId$_(), d = this._$_property$_, p = a._$GetSimilarPropertyTracks$_(u, c, d, this._$_propertyTrack$_);
            if (p && 1 < p.length) {
                const m = this._$_GetPropertyKeyframeStubs$_(p, !0), g = this._$_GetLastPropertyKeyframeStub$_(a, a._$GetTime$_(), m);
                if (g) {
                    const y = l._$GetStartOffset$_(), w = g.time - y;
                    if (0 == w) this._$_GetTmpColor$_(u, f, this._$_property$_)._$addRgb$_(s[0], s[1], s[2]); else if (!(w < 0)) {
                        const S = s[0], b = s[1], M = s[2], v = this._$_propertyTrack$_._$Interpolate$_(w, !1, !0), x = dn._$Color$_._$DiffChannel$_(S, v[0]), G = dn._$Color$_._$DiffChannel$_(b, v[1]), T = dn._$Color$_._$DiffChannel$_(M, v[2]);
                        this._$_GetTmpColor$_(u, f, this._$_property$_)._$addRgb$_(x, G, T);
                    }
                }
            } else this._$_Setter$_(s[0], s[1], s[2]);
        }
        _$AfterChangeProperty$_() {
            const t = this._$_propertyTrack$_._$GetInstance$_();
            if (pn.has(t)) {
                const s = pn.get(t), i = this._$_propertyTrack$_._$GetSourceAdapterId$_();
                if (s.has(i)) {
                    const e = s.get(i);
                    if (e.has(this._$_property$_)) {
                        const h = e.get(this._$_property$_), r = h._$used$_, n = h.color;
                        r && this._$_Setter$_(n._$getR$_(), n._$getG$_(), n._$getB$_()), 
                        0 === e.size && s.delete(i), 0 === s.size && pn.delete(t);
                    }
                }
            }
        }
        _$_Getter$_() {
            const t = this._$_propertyTrack$_._$GetSourceAdapterId$_(), s = this._$_GetTarget$_(), i = this._$_GetIndex$_();
            switch (t) {
              case "behavior":
                return this._$_GetColorFromArray$_(s._$GetPropertyValueByIndex$_(i));

              case "effect":
                return s[i].clone();

              case "plugin":
                return this._$_GetColorFromArray$_(s._$GetPropertyValueByIndex$_(i));

              case "world-instance":
                return this._$GetWorldInfo$_()._$GetUnpremultipliedColor$_().clone();
            }
        }
        _$_Setter$_(t, s, i) {
            const e = this._$_propertyTrack$_._$GetSourceAdapterId$_(), h = this._$_GetTarget$_(), r = this._$_GetIndex$_();
            switch (e) {
              case "behavior":
                mn[0] = t, mn[1] = s, mn[2] = i, h._$SetPropertyValueByIndex$_(r, mn);
                break;

              case "effect":
                h[r]._$setRgb$_(t, s, i);
                break;

              case "plugin":
                mn[0] = t, mn[1] = s, mn[2] = i, h._$SetPropertyValueByIndex$_(r, mn);
                break;

              case "world-instance":
                this._$GetWorldInfo$_()._$SetUnpremultipliedColorRGB$_(t, s, i);
            }
        }
        _$_SaveToJson$_() {}
        _$_LoadFromJson$_(t) {}
    }
    dn._$PropertyTrackState$_._$PropertyInterpolationAdapter$_._$ColorInterpolationAdapter$_ = gn;
}

{
    const yn = self._$C3$_, wn = yn._$PropertyTrackState$_;
    class Sn extends yn._$PropertyTrackState$_._$PropertyInterpolationAdapter$_ {
        constructor(t) {
            super(t);
        }
        _$SetResetState$_() {}
        _$SetInitialState$_() {}
        _$SetResumeState$_() {}
        _$GetCurrentState$_() {
            return this._$_Getter$_();
        }
        _$CompareInitialStateWithCurrent$_() {
            const t = this._$_FirstKeyframeGetter$_();
            return t !== this._$GetCurrentState$_();
        }
        _$CompareSaveStateWithCurrent$_() {
            return !yn._$IsNullOrUndefined$_(this._$_saveState$_) && this._$_saveState$_ !== this._$GetCurrentState$_();
        }
        _$MayNeedBeforeAndAfterInterpolate$_() {
            return !1;
        }
        _$ChangeProperty$_(t, s, i, e, h, r, n, o) {
            const a = this._$_propertyTrack$_, l = a._$GetTrack$_(), u = a._$GetSourceAdapterId$_(), c = a._$GetTimeline$_(), f = l._$GetInstance$_(), d = a._$GetSourceAdapter$_(), p = this._$_property$_, m = c._$GetSimilarPropertyTracks$_(f, d, p, a);
            if (m && 1 < m.length) {
                const y = this._$_GetPropertyKeyframeStubs$_(m), w = t + l._$GetStartOffset$_(), S = this._$_GetLastPropertyKeyframeStub$_(c, w, y);
                S && (s = S.value);
            }
            const g = a._$GetPropertyKeyframeType$_();
            switch (g) {
              case "numeric":
                if (wn._$NumericTypeAdapter$_._$WillChange$_(this._$_GetIndex$_(), this._$_GetTarget$_(), s, u)) break;
                return;

              case "angle":
                if (wn._$AngleTypeAdapter$_._$WillChange$_(this._$_GetIndex$_(), this._$_GetTarget$_(), s, u)) break;
                return;

              case "boolean":
                if (wn._$BooleanTypeAdapter$_._$WillChange$_(this._$_GetIndex$_(), this._$_GetTarget$_(), s, u)) break;
                return;

              case "color":
                if (wn._$ColorTypeAdapter$_._$WillChange$_(this._$_GetIndex$_(), this._$_GetTarget$_(), s, u)) break;
                return;

              case "text":
                if (!wn._$TextTypeAdapter$_._$WillChange$_(this._$_GetIndex$_(), this._$_GetTarget$_(), s, u)) return;
            }
            this._$_Setter$_(s);
        }
        _$_Getter$_() {
            const t = this._$_propertyTrack$_._$GetSourceAdapterId$_(), s = this._$_GetTarget$_(), i = this._$_GetIndex$_();
            switch (t) {
              case "behavior":
                return s._$GetPropertyValueByIndex$_(i);

              case "effect":
                return s[i];

              case "instance-variable":
                return s._$GetInstanceVariableValue$_(i);

              case "plugin":
                return s._$GetPropertyValueByIndex$_(i);
            }
        }
        _$_Setter$_(t) {
            const s = this._$_propertyTrack$_._$GetSourceAdapterId$_(), i = this._$_GetTarget$_(), e = this._$_GetIndex$_();
            switch (s) {
              case "behavior":
                i._$SetPropertyValueByIndex$_(e, t);
                break;

              case "effect":
                i[e] = t;
                break;

              case "instance-variable":
                i._$SetInstanceVariableValue$_(e, t);
                break;

              case "plugin":
                i._$SetPropertyValueByIndex$_(e, t);
            }
        }
    }
    yn._$PropertyTrackState$_._$PropertyInterpolationAdapter$_._$NoInterpolationAdapter$_ = Sn;
}

{
    const bn = self._$C3$_, Mn = (bn._$PropertyTrackState$_._$PropertyInterpolationAdapter$_, 
    new Map()), vn = (t, s, i, e, h, r = !1, n = null, o = null) => {
        Mn.set(t, {
            _$setter$_: s,
            _$absolute_setter$_: i,
            _$getter$_: e,
            round: h,
            _$fRound$_: r,
            init: n,
            reset: o
        });
    };
    vn("offsetX", (t, s, i, e) => {
        "relative" === e._$_propertyTrack$_._$GetResultMode$_() ? t._$OffsetX$_(s, i._$GetTimeline$_()._$GetTransformWithSceneGraph$_()) : t._$OffsetX$_(s);
    }, (t, s) => t._$SetX$_(s), t => t._$GetX$_(), !0), vn("offsetY", (t, s, i, e) => {
        "relative" === e._$_propertyTrack$_._$GetResultMode$_() ? t._$OffsetY$_(s, i._$GetTimeline$_()._$GetTransformWithSceneGraph$_()) : t._$OffsetY$_(s);
    }, (t, s) => t._$SetY$_(s), t => t._$GetY$_(), !0), vn("offsetWidth", (s, t, o, i, e) => {
        if (0 !== t) {
            const h = "relative" === i._$_propertyTrack$_._$GetResultMode$_(), l = 1 === i._$_typeAdapter$_._$GetType$_();
            if ((h || l) && s._$HasParent$_() && s._$GetTransformWithParentWidth$_()) {
                if (isNaN(i._$_absoluteToFactor$_)) {
                    let e = [], t = s._$GetParent$_();
                    for (;t; ) e.push(t), t = t._$GetParent$_();
                    e.reverse();
                    let a = (t, s) => s._$GetTimeline$_()._$GetTrackFromInstance$_(t._$GetInstance$_()), h = (t, s) => {
                        const i = a(t, s);
                        if (i) return i._$GetOriginalWidth$_();
                        const e = t._$GetInstance$_()._$GetSdkInstance$_();
                        return e._$IsOriginalSizeKnown$_() ? e._$GetOriginalWidth$_() : t._$_GetSceneGraphInfo$_()._$_GetStartWidth$_();
                    }, r = (t, s, i, e = 0) => {
                        const h = a(t, s);
                        if (!h) return e;
                        const r = h._$GetPropertyTrack$_(i);
                        if (!r) return e;
                        const n = r._$GetPropertyTrackDataItem$_()._$GetPropertyKeyframeData$_();
                        if (!n) return e;
                        const o = n._$GetLastPropertyKeyframeDataItem$_();
                        return o ? o._$GetValue$_() : e;
                    }, n;
                    if (l) {
                        let t = e[e.length - 1];
                        n = t._$GetWidth$_();
                    } else {
                        let s = e[0], t = s._$_GetSceneGraphInfo$_()._$_GetStartWidth$_(), i = s._$_GetSceneGraphInfo$_()._$GetStartScaleX$_();
                        n = t * i, n = (n += r(s, o, "offsetWidth")) + h(s, o) * r(s, o, "offsetScaleX");
                        for (let t = 1; t < e.length; t++) {
                            const u = (s = e[t])._$_GetSceneGraphInfo$_()._$GetStartScaleX$_();
                            n = (n = (n *= u) + r(s, o, "offsetWidth")) + h(s, o) * r(s, o, "offsetScaleX");
                        }
                    }
                    i._$_absoluteToFactor$_ = 0 === n ? Number.EPSILON : n;
                }
                e || s._$OffsetWidth$_(t / i._$_absoluteToFactor$_, !0);
            } else s._$OffsetWidth$_(t);
        }
    }, (t, s) => t._$SetWidth$_(s), t => t._$GetWidth$_(), !0), vn("offsetHeight", (s, t, o, i, e) => {
        if (0 !== t) {
            const h = "relative" === i._$_propertyTrack$_._$GetResultMode$_(), a = 1 === i._$_typeAdapter$_._$GetType$_();
            if ((h || a) && s._$HasParent$_() && s._$GetTransformWithParentHeight$_()) {
                if (isNaN(i._$_absoluteToFactor$_)) {
                    let e = [], t = s._$GetParent$_();
                    for (;t; ) e.push(t), t = t._$GetParent$_();
                    e.reverse();
                    let h = (t, s) => {
                        e = t;
                        const i = s._$GetTimeline$_()._$GetTrackFromInstance$_(e._$GetInstance$_());
                        var e;
                        if (i) return i._$GetOriginalHeight$_();
                        const h = t._$GetInstance$_()._$GetSdkInstance$_();
                        return h._$IsOriginalSizeKnown$_() ? h._$GetOriginalHeight$_() : t._$_GetSceneGraphInfo$_()._$_GetStartHeight$_();
                    }, r = (t, s, i, e = 0) => {
                        const h = s._$GetTimeline$_()._$GetTrackFromInstance$_(t._$GetInstance$_());
                        if (!h) return e;
                        const r = h._$GetPropertyTrack$_(i);
                        if (!r) return e;
                        const n = r._$GetPropertyTrackDataItem$_()._$GetPropertyKeyframeData$_();
                        if (!n) return e;
                        const o = n._$GetLastPropertyKeyframeDataItem$_();
                        return o ? o._$GetValue$_() : e;
                    }, n;
                    if (a) {
                        let t = e[e.length - 1];
                        n = t._$GetHeight$_();
                    } else {
                        let s = e[0], t = s._$_GetSceneGraphInfo$_()._$_GetStartHeight$_(), i = s._$_GetSceneGraphInfo$_()._$GetStartScaleY$_();
                        n = t * i, n = (n += r(s, o, "offsetHeight")) + h(s, o) * r(s, o, "offsetScaleY");
                        for (let t = 1; t < e.length; t++) {
                            const l = (s = e[t])._$_GetSceneGraphInfo$_()._$GetStartScaleY$_();
                            n = (n = (n *= l) + r(s, o)) + h(s, o) * r(s, o, "offsetScaleY");
                        }
                    }
                    i._$_absoluteToFactor$_ = 0 === n ? Number.EPSILON : n;
                }
                e || s._$OffsetHeight$_(t / i._$_absoluteToFactor$_, !0);
            } else s._$OffsetHeight$_(t);
        }
    }, (t, s) => t._$SetHeight$_(s), t => t._$GetHeight$_(), !0), vn("offsetAngle", (t, s, i, e, h) => {
        t._$OffsetAngle$_(s);
    }, (t, s) => t._$SetAngle$_(s), t => t._$GetAngle$_(), !1, !0), vn("offsetOpacity", (t, s, i, e, h) => {
        const r = e._$_opacityFactor$_ || 1, n = (s /= r, t._$GetOpacity$_()), o = n + s;
        if (0 === e._$_clampAccumulator$_) 1 < o ? e._$_clampAccumulator$_ += o - 1 : o < 0 && (e._$_clampAccumulator$_ += o), 
        t._$OffsetOpacity$_(s); else {
            const a = t._$GetOpacity$_() + s;
            0 < s && 0 < e._$_clampAccumulator$_ ? 1 < a && (e._$_clampAccumulator$_ += a - 1) : 0 < s && e._$_clampAccumulator$_ < 0 ? (e._$_clampAccumulator$_ += s, 
            0 < e._$_clampAccumulator$_ && (t._$OffsetOpacity$_(e._$_clampAccumulator$_), 
            e._$_clampAccumulator$_ = 0)) : s < 0 && 0 < e._$_clampAccumulator$_ ? (e._$_clampAccumulator$_ += s, 
            e._$_clampAccumulator$_ < 0 && (t._$OffsetOpacity$_(e._$_clampAccumulator$_), 
            e._$_clampAccumulator$_ = 0)) : s < 0 && e._$_clampAccumulator$_ < 0 && a < 0 && (e._$_clampAccumulator$_ += a);
        }
    }, (t, s) => {
        t._$SetOpacity$_(s);
    }, t => t._$GetOpacity$_(), !1, !0, (r, h, n) => {
        switch (r._$_clampAccumulator$_ = 0, r._$_propertyTrack$_._$GetResultMode$_()) {
          case "relative":
            {
                r._$_propertyTrack$_._$GetPropertyTrackData$_();
                let t = r._$_propertyTrack$_._$GetPropertyTrackDataItem$_(), s = t._$GetPropertyKeyframeData$_(), i = s._$GetPropertyKeyframeDataItemArray$_(), e = r._$GetWorldInfo$_()._$GetOpacity$_(), h = e;
                for (const o of i) {
                    const a = o._$GetTime$_(), l = r._$_propertyTrack$_._$GetInterpolatedValue$_(a);
                    h = e + l, h = bn._$clamp$_(h, 0, 1);
                }
                r._$_totalForewardOpacityDelta$_ = e - h, r._$_totalForewardOpacityDelta$_ = Math.round(100 * (r._$_totalForewardOpacityDelta$_ + Number.EPSILON)) / 100, 
                h = e;
                for (let t = i.length - 1; 0 <= t; t--) {
                    const u = i[t]._$GetTime$_(), c = r._$_propertyTrack$_._$GetInterpolatedValue$_(u);
                    h -= c, h = bn._$clamp$_(h, 0, 1);
                }
                r._$_totalBackwardOpacityDelta$_ = h, r._$_totalBackwardOpacityDelta$_ = Math.round(100 * (r._$_totalBackwardOpacityDelta$_ + Number.EPSILON)) / 100;
                break;
            }
        }
        const t = "relative" === r._$_propertyTrack$_._$GetResultMode$_(), s = 1 === r._$_typeAdapter$_._$GetType$_();
        if ((t || s) && h._$HasParent$_() && h._$GetTransformWithParentOpacity$_()) {
            let s = [], t = h._$GetParent$_();
            for (;t; ) s.push(t), t = t._$GetParent$_();
            s.reverse();
            let i = (t, s, i) => {
                const e = s._$GetTimeline$_()._$GetTrackFromInstance$_(t._$GetInstance$_());
                if (!e) return 0;
                const h = e._$GetPropertyTrack$_(i);
                if (!h) return 0;
                const r = h._$GetPropertyTrackDataItem$_()._$GetPropertyKeyframeData$_();
                if (!r) return 0;
                const n = r._$GetLastPropertyKeyframeDataItem$_();
                return n ? n._$GetValue$_() : 0;
            }, e = s[0]._$_GetSceneGraphInfo$_()._$GetStartOpacity$_();
            e += i(s[0], n, "offsetOpacity");
            for (let t = 1; t < s.length; t++) e += i(s[t], n, "offsetOpacity");
            r._$_opacityFactor$_ = 0 === e ? 1 : e;
        }
    }, i => {
        switch (i._$_propertyTrack$_._$GetResultMode$_()) {
          case "relative":
            {
                i._$_clampAccumulator$_ = 0;
                let t = i._$GetWorldInfo$_(), s = t._$GetOpacity$_();
                s = Math.round(100 * (s + Number.EPSILON)) / 100, i._$_propertyTrack$_._$GetTimeline$_()._$IsForwardPlayBack$_() ? (t._$SetOpacity$_(s + i._$_totalForewardOpacityDelta$_), 
                i._$_lastValue$_ = 0) : (t._$SetOpacity$_(s - i._$_totalBackwardOpacityDelta$_), 
                i._$_lastValue$_ = i._$GetSourceAdapter$_()._$GetValueAtTime$_());
                break;
            }
        }
    }), vn("offsetOriginX", (t, s) => t._$OffsetOriginX$_(s), (t, s) => t._$SetOriginX$_(s), t => t._$GetOriginX$_(), !1), 
    vn("offsetOriginY", (t, s) => t._$OffsetOriginY$_(s), (t, s) => t._$SetOriginY$_(s), t => t._$GetOriginY$_(), !1), 
    vn("offsetZElevation", (t, s) => t._$OffsetZElevation$_(s), (t, s) => t._$SetZElevation$_(s), t => t._$GetZElevation$_(), !0), 
    vn("offsetScaleX", (t, s, i, e) => {
        if (0 !== s) {
            const h = t._$GetWidth$_() < 0 ? -1 : 1;
            if ("relative" === e._$_propertyTrack$_._$GetResultMode$_() && t._$HasParent$_() && t._$GetTransformWithParentWidth$_()) {
                const r = i._$GetOriginalWidth$_() * h * s;
                isNaN(e._$_absoluteToFactor$_) && Mn.get("offsetWidth")._$setter$_(t, 1, i, e, !0), 
                t._$OffsetWidth$_(r / e._$_absoluteToFactor$_, !0);
            } else t._$OffsetWidth$_(i._$GetOriginalWidth$_() * h * s);
        }
    }, (t, s, i) => {
        t._$SetWidth$_(i._$GetOriginalWidth$_() * s);
    }, (e, h) => {
        const r = e._$GetWidth$_() < 0 ? -1 : 1;
        if (e._$GetTransformWithParentWidth$_()) {
            let t = e._$GetParent$_(), s = h._$GetTimeline$_()._$GetTrackFromInstance$_(t._$GetInstance$_()), i = NaN;
            if (s) i = t._$GetWidth$_() / s._$GetOriginalWidth$_(); else {
                const n = t._$GetInstance$_()._$GetSdkInstance$_();
                i = n._$IsOriginalSizeKnown$_() ? t._$GetWidth$_() / n._$GetOriginalWidth$_() : 1;
            }
            return e._$GetWidth$_() * r / (h._$GetOriginalWidth$_() * i);
        }
        return e._$GetWidth$_() * r / h._$GetOriginalWidth$_();
    }, !1), vn("offsetScaleY", (t, s, i, e) => {
        if (0 !== s) {
            const h = t._$GetHeight$_() < 0 ? -1 : 1;
            if ("relative" === e._$_propertyTrack$_._$GetResultMode$_() && t._$HasParent$_() && t._$GetTransformWithParentHeight$_()) {
                const r = i._$GetOriginalHeight$_() * h * s;
                isNaN(e._$_absoluteToFactor$_) && Mn.get("offsetHeight")._$setter$_(t, 1, i, e, !0), 
                t._$OffsetHeight$_(r / e._$_absoluteToFactor$_, !0);
            } else t._$OffsetHeight$_(i._$GetOriginalHeight$_() * h * s);
        }
    }, (t, s, i) => {
        t._$SetHeight$_(i._$GetOriginalHeight$_() * s);
    }, (e, h) => {
        const r = e._$GetHeight$_() < 0 ? -1 : 1;
        if (e._$GetTransformWithParentHeight$_()) {
            let t = e._$GetParent$_(), s = h._$GetTimeline$_()._$GetTrackFromInstance$_(t._$GetInstance$_()), i = NaN;
            if (s) i = t._$GetHeight$_() / s._$GetOriginalHeight$_(); else {
                const n = t._$GetInstance$_()._$GetSdkInstance$_();
                i = n._$IsOriginalSizeKnown$_() ? t._$GetHeight$_() / n._$GetOriginalHeight$_() : 1;
            }
            return e._$GetHeight$_() * r / (h._$GetOriginalHeight$_() * i);
        }
        return e._$GetHeight$_() * r / h._$GetOriginalHeight$_();
    }, !1);
    class xn extends bn._$PropertyTrackState$_._$PropertyInterpolationAdapter$_ {
        constructor(t) {
            super(t), this._$_lastValue$_ = 0, this._$_clampAccumulator$_ = 0, this._$_totalForewardOpacityDelta$_ = 0, 
            this._$_totalBackwardOpacityDelta$_ = 0, this._$_opacityFactor$_ = NaN, 
            this._$_absoluteToFactor$_ = NaN, this._$_angleReflectMirrorOrFlip$_ = void 0, 
            this._$_angleReflectMirrorAndFlip$_ = void 0, this._$_instance_getter$_ = null, 
            this._$_instance_setter$_ = null, this._$_instance_absolute_setter$_ = null, 
            this._$_reset_action$_ = null, this._$_init_action$_ = null, this._$_source_adapter_getter$_ = null, 
            this._$_source_adapter_setter$_ = null, this._$_source_adapter_absolute_setter$_ = null, 
            this._$_round$_ = !1, this._$_fRound$_ = !1, bn._$IsInstanceOf$_(this._$_propertyTrack$_._$GetTimeline$_(), bn._$TweenState$_) ? this._$_typeAdapter$_ = new bn._$PropertyTrackState$_._$PropertyInterpolationAdapter$_._$NumericInterpolationAdapterForTween$_(this) : this._$_typeAdapter$_ = new bn._$PropertyTrackState$_._$PropertyInterpolationAdapter$_._$NumericInterpolationAdapterForTimeline$_(this);
            const s = this._$_propertyTrack$_._$GetPropertyName$_();
            switch (this._$_propertyTrack$_._$GetSourceAdapterId$_()) {
              case "world-instance":
                {
                    const i = Mn.get(s);
                    this._$_instance_getter$_ = i._$getter$_, this._$_instance_setter$_ = i._$setter$_, 
                    this._$_instance_absolute_setter$_ = i._$absolute_setter$_, 
                    this._$_round$_ = i.round, this._$_fRound$_ = i._$fRound$_, 
                    this._$_init_action$_ = i.init, this._$_reset_action$_ = i.reset;
                    break;
                }

              case "audio":
                this._$_source_adapter_getter$_ = t._$Getter$_, this._$_source_adapter_setter$_ = t._$Setter$_, 
                this._$_source_adapter_absolute_setter$_ = t._$AbsoluteSetter$_, 
                this._$_round$_ = !!t._$DoesRounding$_(), this._$_fRound$_ = !1;
            }
        }
        _$Release$_() {
            this._$_typeAdapter$_ = null, this._$_instance_getter$_ = null, this._$_instance_setter$_ = null, 
            this._$_instance_absolute_setter$_ = null, this._$_reset_action$_ = null, 
            this._$_init_action$_ = null, this._$_source_adapter_getter$_ = null, 
            this._$_source_adapter_setter$_ = null, this._$_source_adapter_absolute_setter$_ = null, 
            super._$Release$_();
        }
        _$MayNeedBeforeAndAfterInterpolate$_() {
            return this._$_typeAdapter$_._$MayNeedBeforeAndAfterInterpolate$_();
        }
        _$GetLastValue$_() {
            return this._$_lastValue$_;
        }
        _$SetLastValue$_(t) {
            this._$_lastValue$_ = t;
        }
        _$SetResetState$_() {
            this._$_reset_action$_ && this._$_reset_action$_(this);
        }
        _$SetInitialState$_() {
            const t = this._$_typeAdapter$_._$SetInitialState$_();
            if ("number" == typeof t && (this._$_lastValue$_ = t), this._$_init_action$_) {
                const s = this._$GetWorldInfo$_(), i = this._$_propertyTrack$_._$GetTrack$_();
                this._$_init_action$_(this, s, i);
            }
        }
        _$SetResumeState$_() {
            const t = this._$_typeAdapter$_._$SetResumeState$_();
            "number" == typeof t && (this._$_lastValue$_ = t);
        }
        _$GetCurrentState$_() {
            return this._$_Getter$_();
        }
        _$CompareInitialStateWithCurrent$_() {
            const t = this._$_FirstKeyframeGetter$_();
            return t !== this._$GetCurrentState$_();
        }
        _$CompareSaveStateWithCurrent$_() {
            return !bn._$IsNullOrUndefined$_(this._$_saveState$_) && this._$_saveState$_ !== this._$GetCurrentState$_();
        }
        _$BeforeChangeProperty$_() {
            this._$_typeAdapter$_._$BeforeChangeProperty$_();
        }
        _$ChangeProperty$_(t, s, i, e, h, r, n, o) {
            return this._$_typeAdapter$_._$ChangeProperty$_(t, s, i, e, h, r, n, o);
        }
        _$AfterChangeProperty$_() {
            this._$_typeAdapter$_._$AfterChangeProperty$_();
        }
        _$_Getter$_() {
            const t = this._$_GetTarget$_(), s = this._$_GetIndex$_(), i = this._$GetWorldInfo$_(), e = this._$_propertyTrack$_._$GetTrack$_(), h = this._$_propertyTrack$_._$GetSourceAdapterId$_();
            switch (h) {
              case "behavior":
                return t._$GetPropertyValueByIndex$_(s);

              case "effect":
                return t[s];

              case "instance-variable":
                return t._$GetInstanceVariableValue$_(s);

              case "plugin":
                return t._$GetPropertyValueByIndex$_(s);

              case "world-instance":
                return this._$_instance_getter$_(i, e);

              case "audio":
                return this._$_source_adapter_getter$_.call(this._$GetSourceAdapter$_(), i, e);
            }
        }
        _$_Setter$_(t, s, i) {
            const e = this._$_GetTarget$_(), h = this._$_GetIndex$_(), r = this._$GetWorldInfo$_(), n = this._$_propertyTrack$_._$GetTrack$_(), o = this._$_propertyTrack$_._$GetSourceAdapterId$_();
            switch (o) {
              case "behavior":
                e._$OffsetPropertyValueByIndex$_(h, t);
                break;

              case "effect":
                e[h] += t;
                break;

              case "instance-variable":
                e._$SetInstanceVariableOffset$_(h, t);
                break;

              case "plugin":
                e._$OffsetPropertyValueByIndex$_(h, t, this._$GetSourceAdapter$_()._$GetOptionalCallbacks$_());
                break;

              case "world-instance":
                this._$_instance_setter$_(r, t, n, this);
                break;

              case "audio":
                this._$_source_adapter_setter$_.call(this._$GetSourceAdapter$_(), r, t, n, this);
            }
        }
        _$_SetterAbsolute$_(t, s, i) {
            let e = this._$_propertyTrack$_._$GetInterpolationMode$_();
            if ("discrete" !== (e = "default" === e ? "continuous" : e) || s) {
                if ("discrete" === e && i) {
                    const l = this._$_propertyTrack$_._$GetTimeline$_(), u = l._$GetTime$_(), c = this._$_propertyTrack$_._$GetPropertyKeyFrameDataItemAtTime$_(u);
                    if (!c) return;
                }
                const h = this._$_GetTarget$_(), r = this._$_GetIndex$_(), n = this._$GetWorldInfo$_(), o = this._$_propertyTrack$_._$GetTrack$_(), a = this._$_propertyTrack$_._$GetSourceAdapterId$_();
                switch (a) {
                  case "behavior":
                    h._$SetPropertyValueByIndex$_(r, t);
                    break;

                  case "effect":
                    h[r] = t;
                    break;

                  case "instance-variable":
                    h._$SetInstanceVariableValue$_(r, t);
                    break;

                  case "plugin":
                    h._$SetPropertyValueByIndex$_(r, t, this._$GetSourceAdapter$_()._$GetOptionalCallbacks$_());
                    break;

                  case "world-instance":
                    this._$_instance_absolute_setter$_(n, t, o);
                    break;

                  case "audio":
                    this._$_source_adapter_absolute_setter$_.call(this._$GetSourceAdapter$_(), n, t, o);
                }
            }
        }
        _$_MaybeEnsureValue$_(t, s, i, e, h, r, n, o) {
            this._$_typeAdapter$_._$_MaybeEnsureValue$_(t, s, i, e, h, r, n, o);
        }
        _$_AddDelta$_(t, s, i, e, h) {
            let r = (t = "angle" === this._$_propertyTrack$_._$GetPropertyType$_() ? bn._$toDegrees$_(t) : t).toString(), n = r.split(".")[1] || "", o = n.length, a = this._$_Getter$_(), l;
            switch (l = 0 === o ? this._$_round$_ ? Math.round(a) : this._$_fRound$_ ? "angle" === this._$_propertyTrack$_._$GetPropertyType$_() ? bn._$toRadians$_(Math.round(bn._$toDegrees$_(a))) : Number(bn.toFixed(a, 2)) : a : this._$_round$_ ? Number(bn.toFixed(a, o)) : (this._$_fRound$_, 
            a), this._$_Setter$_(l - a, s, i), this._$_propertyTrack$_._$GetPropertyName$_()) {
              case "offsetWidth":
              case "offsetScaleX":
                {
                    const u = this._$GetWorldInfo$_(), c = u._$GetWidth$_(), f = Number(bn.toFixed(c, 2));
                    u._$OffsetWidth$_(f - c);
                    break;
                }

              case "offsetHeight":
              case "offsetScaleY":
                {
                    const d = this._$GetWorldInfo$_(), p = d._$GetHeight$_(), m = Number(bn.toFixed(p, 2));
                    d._$OffsetHeight$_(m - p);
                    break;
                }
            }
        }
        _$_SaveToJson$_() {
            return Object.assign(super._$_SaveToJson$_(), {
                v: this._$_lastValue$_,
                a: this._$_clampAccumulator$_,
                fod: this._$_totalForewardOpacityDelta$_,
                bod: this._$_totalBackwardOpacityDelta$_,
                of: this._$_opacityFactor$_,
                sf: this._$_absoluteToFactor$_,
                armorf: this._$_angleReflectMirrorOrFlip$_,
                armandf: this._$_angleReflectMirrorAndFlip$_
            });
        }
        _$_LoadFromJson$_(t) {
            t && (super._$_LoadFromJson$_(t), this._$_lastValue$_ = t.v, this._$_clampAccumulator$_ = t.a, 
            this._$_totalForewardOpacityDelta$_ = bn._$IsFiniteNumber$_(t.fod) ? t.fod : 0, 
            this._$_totalBackwardOpacityDelta$_ = bn._$IsFiniteNumber$_(t.bod) ? t.bod : 0, 
            this._$_opacityFactor$_ = bn._$IsFiniteNumber$_(t.of) ? t.of : NaN, 
            this._$_absoluteToFactor$_ = bn._$IsFiniteNumber$_(t.sf) ? t.sf : NaN, 
            this._$_angleReflectMirrorOrFlip$_ = bn._$IsFiniteNumber$_(t.armorf) ? t.armorf : void 0, 
            this._$_angleReflectMirrorAndFlip$_ = bn._$IsFiniteNumber$_(t.armandf) ? t.armandf : void 0);
        }
    }
    bn._$PropertyTrackState$_._$PropertyInterpolationAdapter$_._$NumericInterpolationAdapter$_ = xn;
}

{
    const Gn = self._$C3$_;
    class Tn {
        constructor(t) {
            this._$_used$_ = !1, this._$_value$_ = 0, this._$_propertyKeyframeReached$_ = !1, 
            this._$_endState$_ = !1, this._$_propertyTracks$_ = t;
            for (let t = 0, s = this._$_propertyTracks$_.length; t < s; t++) this._$_propertyTracks$_[t]._$SetAbsoluteValueObject$_(this);
        }
        _$GetPropertyTracks$_() {
            return this._$_propertyTracks$_;
        }
        _$SetUsed$_() {
            this._$_used$_ = !0;
        }
        _$GetUsed$_() {
            return this._$_used$_;
        }
        _$SetValue$_(t) {
            this._$_value$_ = t;
        }
        _$GetValue$_() {
            return this._$_value$_;
        }
        _$SetPropertyKeyframeReached$_(t) {
            this._$_propertyKeyframeReached$_ = t;
        }
        _$GetPropertyKeyframeReached$_() {
            return this._$_propertyKeyframeReached$_;
        }
        _$SetEndState$_(t) {
            this._$_endState$_ = t;
        }
        _$GetEndState$_() {
            return this._$_endState$_;
        }
        _$Reset$_() {
            this._$_used$_ = !1, this._$_value$_ = 0, this._$_propertyKeyframeReached$_ = !1, 
            this._$_endState$_ = !1;
        }
    }
    class _n {
        constructor(t) {
            this._$_numericInterpolationAdapter$_ = t;
        }
        _$Release$_() {
            this._$_numericInterpolationAdapter$_ = null;
        }
        _$GetType$_() {
            return 0;
        }
        _$SetInitialState$_() {
            const t = this._$_numericInterpolationAdapter$_;
            this._$_numericInterpolationAdapter$_._$GetPropertyTrack$_();
            return t._$_PickResultMode$_(() => t._$_PickTimelinePlaybackMode$_(() => 0, () => t._$GetSourceAdapter$_()._$GetValueAtTime$_()), () => {});
        }
        _$SetResumeState$_() {}
        _$MayNeedBeforeAndAfterInterpolate$_() {
            this._$_numericInterpolationAdapter$_;
            const t = this._$_numericInterpolationAdapter$_._$GetPropertyTrack$_();
            switch (t._$GetResultMode$_()) {
              case "relative":
                return !1;

              case "absolute":
                return !0;
            }
        }
        _$BeforeChangeProperty$_() {
            this._$_numericInterpolationAdapter$_;
            const t = this._$_numericInterpolationAdapter$_._$GetPropertyTrack$_(), s = t._$GetPropertyName$_();
            switch (t._$GetResultMode$_()) {
              case "relative":
                break;

              case "absolute":
                if (t._$HasAbsoluteValueObject$_()) {
                    const i = t._$GetAbsoluteValueObject$_();
                    i._$Reset$_();
                } else {
                    const e = t._$GetTimeline$_(), h = t._$GetInstance$_(), r = t._$GetSourceAdapter$_(), n = e._$GetSimilarPropertyTracks$_(h, r, s, t);
                    n && 1 < n.length && new Tn(n);
                }
            }
        }
        _$ChangeProperty$_(t, s, i, e, h, r, n, o) {
            const a = this._$_numericInterpolationAdapter$_, l = this._$_numericInterpolationAdapter$_._$GetPropertyTrack$_();
            switch (l._$GetResultMode$_()) {
              case "relative":
                {
                    const u = a._$GetLastValue$_();
                    a._$_Setter$_(s - u, i, e), r && this._$_MaybeEnsureValue$_(t, i, e, h, u, s), 
                    a._$SetLastValue$_(s);
                    break;
                }

              case "absolute":
                {
                    const c = l._$GetTimeline$_(), f = l._$GetTrack$_();
                    l._$GetInstance$_(), l._$GetSourceAdapter$_();
                    if (l._$HasAbsoluteValueObject$_()) {
                        const d = l._$GetAbsoluteValueObject$_(), p = d._$GetPropertyTracks$_(), m = a._$_GetPropertyKeyframeStubs$_(p, !0), g = a._$_GetLastPropertyKeyframeStub$_(c, c._$GetTime$_(), m);
                        if (g) {
                            const y = f._$GetStartOffset$_(), w = g.time - y;
                            if (0 == w) d._$SetEndState$_(n), d._$SetPropertyKeyframeReached$_(o), 
                            d._$SetUsed$_(), d._$SetValue$_(d._$GetValue$_() + s); else {
                                if (w < 0) return;
                                const S = l._$GetInterpolatedValue$_(w);
                                d._$SetEndState$_(n), d._$SetPropertyKeyframeReached$_(o), 
                                d._$SetUsed$_(), d._$SetValue$_(d._$GetValue$_() + (s - S));
                            }
                        }
                    } else a._$_SetterAbsolute$_(s, o, n);
                    break;
                }
            }
        }
        _$AfterChangeProperty$_() {
            const t = this._$_numericInterpolationAdapter$_, s = this._$_numericInterpolationAdapter$_._$GetPropertyTrack$_();
            switch (s._$GetResultMode$_()) {
              case "relative":
                break;

              case "absolute":
                if (s._$HasAbsoluteValueObject$_()) {
                    const i = s._$GetAbsoluteValueObject$_();
                    i._$GetUsed$_() && t._$_SetterAbsolute$_(i._$GetValue$_(), i._$GetPropertyKeyframeReached$_(), i._$GetEndState$_());
                }
            }
        }
        _$_MaybeEnsureValue$_(t, s, i, e, h, r) {
            const n = this._$_numericInterpolationAdapter$_;
            e || (s && t === s._$GetTime$_() ? n._$_AddDelta$_(s._$GetValueWithResultMode$_(), s, i) : i && t === i._$GetTime$_() ? n._$_AddDelta$_(i._$GetValueWithResultMode$_(), s, i) : r - h == 0 && n._$_AddDelta$_(s._$GetValueWithResultMode$_(), s, i));
        }
    }
    Gn._$PropertyTrackState$_._$PropertyInterpolationAdapter$_._$NumericInterpolationAdapterForTimeline$_ = _n;
}

{
    const In = self._$C3$_;
    class Cn {
        constructor(t) {
            this._$_numericInterpolationAdapter$_ = t;
        }
        _$Release$_() {
            this._$_numericInterpolationAdapter$_ = null;
        }
        _$GetType$_() {
            return 1;
        }
        _$SetInitialState$_() {
            const t = this._$_numericInterpolationAdapter$_;
            return t._$SetFirstAbsoluteUpdate$_(!0), this._$_GetAbsoluteInitialValue$_(t._$_FirstKeyframeGetter$_());
        }
        _$SetResumeState$_() {
            const t = this._$_numericInterpolationAdapter$_;
            if (t._$_FirstKeyframeGetter$_() !== t._$_CurrentKeyframeGetter$_()) return t._$SetFirstAbsoluteUpdate$_(!0), 
            this._$_GetAbsoluteInitialValue$_(t._$_CurrentKeyframeGetter$_());
        }
        _$MayNeedBeforeAndAfterInterpolate$_() {
            return !1;
        }
        _$BeforeChangeProperty$_() {}
        _$ChangeProperty$_(t, s, i, e, h, r, n, o) {
            const a = this._$_numericInterpolationAdapter$_, l = a._$GetLastValue$_();
            switch (a._$GetPropertyTrack$_()._$GetResultMode$_()) {
              case "relative":
                a._$_Setter$_(s - l, i, e), r && this._$_MaybeEnsureValue$_(t, i, e, h, l, s, !1, n);
                break;

              case "absolute":
                a._$GetFirstAbsoluteUpdate$_() ? (a._$SetFirstAbsoluteUpdate$_(!1), 
                a._$_Setter$_(l, i, e)) : 0 === t && 0 === a._$GetPropertyTrack$_()._$GetTimeline$_()._$GetTotalTime$_() ? a._$_SetterAbsolute$_(s, !0, !1) : (a._$_Setter$_(s - l, i, e), 
                r && this._$_MaybeEnsureValue$_(t, i, e, h, l, s, this._$_ForceEndValue$_(), n));
            }
            a._$SetLastValue$_(s);
        }
        _$AfterChangeProperty$_() {}
        _$_GetAbsoluteInitialValue$_(t) {
            const s = this._$_numericInterpolationAdapter$_;
            return t - s._$GetCurrentState$_();
        }
        _$_ForceEndValue$_() {
            let t = this._$_numericInterpolationAdapter$_, s = t._$GetWorldInfo$_()._$GetInstance$_(), i = t._$GetPropertyTrack$_()._$GetRuntime$_(), e = i._$GetTimelineManager$_(), h = 0;
            for (const r of e._$GetPlayingTimelines$_()) 0 === r._$GetType$_() ? r._$HasTrackInstance$_(s) && h++ : 1 === r._$GetType$_() && r._$GetInstance$_() === s && h++;
            return h <= 1;
        }
        _$_MaybeEnsureValue$_(t, s, i, e, h, r, n, o) {
            const a = this._$_numericInterpolationAdapter$_;
            e ? s && t === s._$GetTime$_() ? a._$_AddDelta$_(s._$GetValueWithResultMode$_(), s, i, n, o) : i && t === i._$GetTime$_() ? a._$_AddDelta$_(i._$GetValueWithResultMode$_(), s, i, n, o) : i || a._$_AddDelta$_(s._$GetValueWithResultMode$_(), s, i, n, o) : s && t === s._$GetTime$_() ? a._$_AddDelta$_(s._$GetValueWithResultMode$_(), s, i, n, o) : i && t === i._$GetTime$_() ? a._$_AddDelta$_(i._$GetValueWithResultMode$_(), s, i, n, o) : r - h == 0 && a._$_AddDelta$_(s._$GetValueWithResultMode$_(), s, i, n, o);
        }
    }
    In._$PropertyTrackState$_._$PropertyInterpolationAdapter$_._$NumericInterpolationAdapterForTween$_ = Cn;
}

{
    const Rn = self._$C3$_, Pn = self._$Ease$_;
    Rn._$PropertyTrackState$_._$NumericTypeAdapter$_ = class {
        constructor() {}
        static _$WillChange$_(t, s, i, e) {
            let h;
            switch (e) {
              case "behavior":
                h = s._$GetPropertyValueByIndex$_(t);
                break;

              case "effect":
                h = s[t];
                break;

              case "instance-variable":
                h = s._$GetInstanceVariableValue$_(t);
                break;

              case "plugin":
                h = s._$GetPropertyValueByIndex$_(t);
            }
            return h !== i;
        }
        static _$Interpolate$_(r, n, o, a) {
            if (!o) {
                let t = a._$GetPropertyTrackDataItem$_(), s = a._$GetPropertyTrackData$_();
                return (t = s._$GetLastPropertyKeyframeDataItem$_(t))._$GetValueWithResultMode$_();
            }
            let l = a._$GetInterpolationMode$_();
            if ("default" === l && (l = "continuous"), "discrete" === (l = "combo" === a._$GetPropertyType$_() ? "discrete" : l)) return n._$GetValueWithResultMode$_();
            if ("continuous" === l || "step" === l) {
                const u = a._$GetTimeline$_()._$GetStep$_();
                if ("step" === l && 0 !== u) {
                    const g = 1 / u;
                    r = Math.floor(r * g) / g;
                }
                const c = n._$GetValueWithResultMode$_(), f = o._$GetValueWithResultMode$_(), d = n._$GetAddOn$_("cubic-bezier"), p = o._$GetAddOn$_("cubic-bezier"), m = d && d._$GetStartEnable$_() && p && p._$GetEndEnable$_();
                if (!m && c === f) return c;
                let t = n._$GetTime$_(), s = o._$GetTime$_(), i = ("step" === l && 0 !== u && (r = Rn._$clamp$_(r, t, s)), 
                Rn.normalize(r, t, s)), e = n._$GetEase$_(), h;
                if (m) {
                    const y = s - t;
                    h = Pn._$GetRuntimeEase$_(e)(y * i, 0, 1, y), h = Pn._$GetRuntimeEase$_("cubicbezier")(h, c, c + d._$GetStartAnchor$_(), f + p._$GetEndAnchor$_(), f);
                } else h = Pn._$GetRuntimeEase$_(e)((s - t) * i, c, f - c, s - t);
                return "integer" === a._$GetPropertyType$_() ? Math.floor(h) : h;
            }
        }
    };
}

{
    const En = self._$C3$_;
    En._$PropertyTrackState$_._$AngleTypeAdapter$_ = class {
        constructor() {}
        static _$WillChange$_(t, s, i, e) {
            let h;
            switch (e) {
              case "behavior":
                h = s._$GetPropertyValueByIndex$_(t);
                break;

              case "effect":
                h = s[t];
                break;

              case "instance-variable":
                h = s._$GetInstanceVariableValue$_(t);
                break;

              case "plugin":
                h = s._$GetPropertyValueByIndex$_(t);
            }
            return h !== i;
        }
        static _$Interpolate$_(t, s, i, e) {
            if (!i) {
                let t = e._$GetPropertyTrackDataItem$_(), s = e._$GetPropertyTrackData$_();
                return (t = s._$GetLastPropertyKeyframeDataItem$_(t))._$GetValueWithResultMode$_();
            }
            let h = e._$GetInterpolationMode$_();
            if ("default" === h && (h = "continuous"), "discrete" === (h = "combo" === e._$GetPropertyType$_() ? "discrete" : h)) return s._$GetValueWithResultMode$_();
            if ("continuous" === h || "step" === h) {
                const r = e._$GetTimeline$_()._$GetStep$_();
                if ("step" === h && 0 !== r) {
                    const c = 1 / r;
                    t = Math.floor(t * c) / c;
                }
                const n = s._$GetTime$_(), o = i._$GetTime$_(), a = s._$GetValueWithResultMode$_(), l = i._$GetValueWithResultMode$_(), u = ("step" === h && 0 !== r && (t = En._$clamp$_(t, n, o)), 
                s._$GetAddOn$_("angle"));
                if (!u) {
                    if (a === l) return a;
                    const f = En.normalize(t, n, o), d = self._$Ease$_._$GetRuntimeEase$_(s._$GetEase$_());
                    return En._$angleLerp$_(a, l, d(f, 0, 1, 1));
                }
                {
                    const p = u._$GetRevolutions$_();
                    if (a === l && 0 === p) return a;
                    const m = En.normalize(t, n, o), g = self._$Ease$_._$GetRuntimeEase$_(s._$GetEase$_()), y = g(m, 0, 1, 1);
                    switch (u._$GetDirection$_()) {
                      case "closest":
                        return En._$angleLerp$_(a, l, y, p);

                      case "clockwise":
                        return En._$angleLerpClockwise$_(a, l, y, p);

                      case "anti-clockwise":
                        return En._$angleLerpAntiClockwise$_(a, l, y, p);
                    }
                }
            }
        }
    };
}

{
    const An = self._$C3$_;
    An._$PropertyTrackState$_._$BooleanTypeAdapter$_ = class {
        constructor() {}
        static _$WillChange$_(t, s, i, e) {
            let h;
            switch (e) {
              case "behavior":
                h = s._$GetPropertyValueByIndex$_(t);
                break;

              case "effect":
                h = s[t];
                break;

              case "instance-variable":
                h = s._$GetInstanceVariableValue$_(t);
                break;

              case "plugin":
                h = s._$GetPropertyValueByIndex$_(t);
            }
            return !!h != !!i;
        }
        static _$Interpolate$_(t, s, i, e) {
            if (i) return s._$GetValueWithResultMode$_() ? 1 : 0;
            {
                let t = e._$GetPropertyTrackDataItem$_(), s = e._$GetPropertyTrackData$_();
                return (t = s._$GetLastPropertyKeyframeDataItem$_(t))._$GetValueWithResultMode$_() ? 1 : 0;
            }
        }
    };
}

{
    const Fn = self._$C3$_, On = [ 0, 0, 0 ], Dn = [ 0, 0, 0 ], kn = [ 0, 0, 0 ];
    Fn._$PropertyTrackState$_._$ColorTypeAdapter$_ = class {
        constructor() {}
        static _$WillChange$_(t, s, i, e) {
            let h;
            switch (e) {
              case "behavior":
                h = s._$GetPropertyValueByIndex$_(t);
                break;

              case "effect":
                h = s[t];
                break;

              case "instance-variable":
                h = s._$GetInstanceVariableValue$_(t);
                break;

              case "plugin":
                h = s._$GetPropertyValueByIndex$_(t);
            }
            return Array.isArray(i) ? (On[0] = i[0], On[1] = i[1], On[2] = i[2]) : (kn._$parseCommaSeparatedRgb$_(i), 
            On[0] = Math.floor(255 * kn._$getR$_()), On[1] = Math.floor(255 * kn._$getG$_()), 
            On[2] = Math.floor(255 * kn._$getB$_())), Array.isArray(h) ? (Dn[0] = h[0], 
            Dn[1] = h[1], Dn[2] = h[2]) : (kn._$parseCommaSeparatedRgb$_(h), Dn[0] = Math.floor(255 * kn._$getR$_()), 
            Dn[1] = Math.floor(255 * kn._$getG$_()), Dn[2] = Math.floor(255 * kn._$getB$_())), 
            On[0] !== Dn[0] || On[1] !== Dn[1] || On[2] !== Dn[2];
        }
        static _$Interpolate$_(t, s, i, e) {
            if (!i) {
                let t = e._$GetPropertyTrackDataItem$_(), s = e._$GetPropertyTrackData$_(), i = (t = s._$GetLastPropertyKeyframeDataItem$_(t))._$GetValueWithResultMode$_();
                return On[0] = i[0], On[1] = i[1], On[2] = i[2], On;
            }
            let h = e._$GetInterpolationMode$_();
            if ("discrete" === (h = "default" === h ? "continuous" : h)) {
                const r = s._$GetValueWithResultMode$_();
                return On[0] = r[0], On[1] = r[1], On[2] = r[2], On;
            }
            if ("continuous" === h || "step" === h) {
                const n = e._$GetTimeline$_()._$GetStep$_();
                if ("step" === h && 0 !== n) {
                    const v = 1 / n;
                    t = Math.floor(t * v) / v;
                }
                const o = s._$GetTime$_(), a = i._$GetTime$_(), l = s._$GetValueWithResultMode$_(), u = i._$GetValueWithResultMode$_(), c = ("step" === h && 0 !== n && (t = Fn._$clamp$_(t, o, a)), 
                Fn.normalize(t, o, a)), f = s._$GetEase$_(), d = l[0], p = l[1], m = l[2], g = u[0], y = u[1], w = u[2], S = self._$Ease$_._$GetRuntimeEase$_(f), b = a - o, M = b * c;
                return On[0] = d === g ? d : S(M, d, g - d, b), On[1] = p === y ? p : S(M, p, y - p, b), 
                On[2] = m === w ? m : S(M, m, w - m, b), On;
            }
        }
    };
}

{
    const Ln = self._$C3$_;
    Ln._$PropertyTrackState$_._$TextTypeAdapter$_ = class {
        constructor() {}
        static _$WillChange$_(t, s, i, e) {
            let h;
            switch (e) {
              case "behavior":
                h = s._$GetPropertyValueByIndex$_(t);
                break;

              case "effect":
                h = s[t];
                break;

              case "instance-variable":
                h = s._$GetInstanceVariableValue$_(t);
                break;

              case "plugin":
                h = s._$GetPropertyValueByIndex$_(t);
            }
            return h !== i;
        }
        static _$Interpolate$_(t, s, i, e) {
            if (i) return s._$GetValueWithResultMode$_();
            {
                let t = e._$GetPropertyTrackDataItem$_(), s = e._$GetPropertyTrackData$_();
                return (t = s._$GetLastPropertyKeyframeDataItem$_(t))._$GetValueWithResultMode$_();
            }
        }
    };
}

{
    const Bn = self._$C3$_;
    Bn._$TimelineDataManager$_ = class {
        constructor() {
            this._$_timelineDataItems$_ = new Map();
        }
        _$Release$_() {
            for (const t of this._$_timelineDataItems$_.values()) t._$Release$_();
            this._$_timelineDataItems$_.clear(), this._$_timelineDataItems$_ = null;
        }
        _$Add$_(t) {
            const s = new Bn._$TimelineDataItem$_(t), i = s._$GetName$_();
            this._$_timelineDataItems$_.set(i, s);
        }
        _$Get$_(t) {
            return this._$_timelineDataItems$_.get(t);
        }
        _$GetNameId$_() {
            return 0;
        }
        static _$_CreateDataItems$_(t, s, i, e) {
            if (s) for (const h of s) Bn._$TimelineDataManager$_._$_CreateDataItem$_("create", h, t, i, e);
        }
        static _$_CreateDataItemsIncludingDisabled$_(t, s, i, e) {
            if (s) for (const h of s) Bn._$TimelineDataManager$_._$_CreateDataItem$_("create-including-disabled", h, t, i, e);
        }
        static _$_LoadDataItemsFromJson$_(i, t, s, e) {
            i.length ? t.forEach((t, s) => {
                i[s]._$_LoadFromJson$_(t);
            }) : t.forEach(t => {
                Bn._$TimelineDataManager$_._$_CreateDataItem$_("load", t, i, s, e);
            });
        }
        static _$_CreateDataItem$_(t, s, i, e, h) {
            let r;
            if ("function" == typeof e) switch (t) {
              case "load":
                r = new e(null, h);
                break;

              case "create":
              case "create-including-disabled":
                r = new e(s, h);
            } else if ("object" == typeof e) {
                const n = e.prop, o = s[n], a = e.map.get(o);
                switch (t) {
                  case "load":
                    r = new a(null, h);
                    break;

                  case "create":
                  case "create-including-disabled":
                    r = new a(s, h);
                }
            }
            switch (t) {
              case "load":
                r._$_LoadFromJson$_(s), i.push(r);
                break;

              case "create":
                if ("function" == typeof r._$GetEnable$_ && !r._$GetEnable$_()) return r._$Release$_();
                i.push(r);
                break;

              case "create-including-disabled":
                i.push(r);
            }
        }
    };
}

{
    const Nn = self._$C3$_;
    Nn._$TimelineDataItem$_ = class {
        constructor(t) {
            this._$_name$_ = "", this._$_totalTime$_ = NaN, this._$_step$_ = 0, 
            this._$_interpolationMode$_ = "default", this._$_resultMode$_ = "default", 
            this._$_loop$_ = !1, this._$_pingPong$_ = !1, this._$_repeatCount$_ = 1, 
            this._$_trackData$_ = null, this._$_startOnLayout$_ = "", this._$_transformWithSceneGraph$_ = !1, 
            this._$_useSystemTimescale$_ = !0, t && (this._$_name$_ = t[0], this._$_totalTime$_ = t[1], 
            this._$_step$_ = t[2], this._$_interpolationMode$_ = t[3], this._$_resultMode$_ = t[4], 
            this._$_loop$_ = !!t[6], this._$_pingPong$_ = !!t[7], this._$_repeatCount$_ = t[8], 
            this._$_startOnLayout$_ = t[9], this._$_transformWithSceneGraph$_ = !!t[10], 
            this._$_useSystemTimescale$_ = !!t[11], this._$_trackData$_ = new Nn._$TrackData$_(t[5], this));
        }
        _$Release$_() {
            this._$_trackData$_._$Release$_(), this._$_trackData$_ = null;
        }
        _$GetTrackData$_() {
            return this._$_trackData$_ || (this._$_trackData$_ = new Nn._$TrackData$_(null, this)), 
            this._$_trackData$_;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$SetName$_(t) {
            this._$_name$_ = t;
        }
        _$GetTotalTime$_() {
            return this._$_totalTime$_;
        }
        _$SetTotalTime$_(t) {
            this._$_totalTime$_ = t;
        }
        _$GetStep$_() {
            return this._$_step$_;
        }
        _$SetStep$_(t) {
            this._$_step$_ = t;
        }
        _$GetInterpolationMode$_() {
            return this._$_interpolationMode$_;
        }
        _$SetInterpolationMode$_(t) {
            this._$_interpolationMode$_ = t;
        }
        _$GetResultMode$_() {
            return this._$_resultMode$_;
        }
        _$SetResultMode$_(t) {
            this._$_resultMode$_ = t;
        }
        _$GetLoop$_() {
            return this._$_loop$_;
        }
        _$SetLoop$_(t) {
            this._$_loop$_ = t;
        }
        _$GetPingPong$_() {
            return this._$_pingPong$_;
        }
        _$SetPingPong$_(t) {
            this._$_pingPong$_ = t;
        }
        _$GetRepeatCount$_() {
            return this._$_repeatCount$_;
        }
        _$SetRepeatCount$_(t) {
            this._$_repeatCount$_ = t;
        }
        _$GetStartOnLayout$_() {
            return this._$_startOnLayout$_;
        }
        _$GetTransformWithSceneGraph$_() {
            return this._$_transformWithSceneGraph$_;
        }
        _$GetUseSystemTimescale$_() {
            return this._$_useSystemTimescale$_;
        }
        _$_SaveToJson$_() {
            return {
                trackDataJson: this._$_trackData$_._$_SaveToJson$_(),
                name: this._$_name$_,
                totalTime: this._$_totalTime$_,
                step: this._$_step$_,
                interpolationMode: this._$_interpolationMode$_,
                resultMode: this._$_resultMode$_,
                loop: this._$_loop$_,
                pingPong: this._$_pingPong$_,
                repeatCount: this._$_repeatCount$_,
                startOnLayout: this._$_startOnLayout$_,
                transformWithSceneGraph: !!this._$_transformWithSceneGraph$_,
                useSystemTimescale: this._$_useSystemTimescale$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (this._$GetTrackData$_()._$_LoadFromJson$_(t.trackDataJson), this._$_name$_ = t.name, 
            this._$_totalTime$_ = t.totalTime, this._$_step$_ = t.step, this._$_interpolationMode$_ = t.interpolationMode, 
            this._$_resultMode$_ = t.resultMode, this._$_loop$_ = t.loop, this._$_pingPong$_ = t.pingPong, 
            this._$_repeatCount$_ = t.repeatCount, this._$_startOnLayout$_ = t.startOnLayout, 
            this._$_transformWithSceneGraph$_ = !!t.transformWithSceneGraph, this._$_useSystemTimescale$_ = !!t.useSystemTimescale);
        }
    };
}

{
    const Wn = self._$C3$_;
    class jn {
        constructor(t, s) {
            this._$_trackData$_ = s, this._$_instanceData$_ = null, this._$_additionalInstanceData$_ = null, 
            this._$_instanceUid$_ = NaN, this._$_objectClassIndex$_ = NaN, this._$_interpolationMode$_ = "default", 
            this._$_resultMode$_ = "default", this._$_enabled$_ = !1, this._$_keyframeData$_ = null, 
            this._$_propertyTrackData$_ = null, this._$_id$_ = "", this._$_nestedData$_ = null, 
            this._$_startOffset$_ = 0, this._$_localTotalTime$_ = this._$_trackData$_._$GetTimelineDataItem$_()._$GetTotalTime$_(), 
            this._$_type$_ = 0, this._$_name$_ = "", t && (t[0] && (this._$_instanceData$_ = t[0], 
            this._$_instanceUid$_ = t[0][2], this._$_objectClassIndex$_ = t[0][1]), 
            this._$_interpolationMode$_ = t[1], this._$_resultMode$_ = t[2], this._$_enabled$_ = !!t[3], 
            t[6] && (this._$_id$_ = t[6]), t[7] && (this._$_nestedData$_ = t[7], 
            this._$_startOffset$_ = t[7][0], this._$_localTotalTime$_ = t[7][1]), 
            t[8] && (this._$_additionalInstanceData$_ = t[8]), t[8] && (this._$_additionalInstanceData$_ = t[8]), 
            t[9] && (this._$_type$_ = t[9]), t[10] && (this._$_name$_ = t[10]), 
            this._$_keyframeData$_ = new Wn._$KeyframeData$_(t[4], this), this._$_propertyTrackData$_ = new Wn._$PropertyTrackData$_(t[5], this));
        }
        _$Release$_() {
            this._$_instanceData$_ = null, this._$_trackData$_ = null, this._$_keyframeData$_ && (this._$_keyframeData$_._$Release$_(), 
            this._$_keyframeData$_ = null), this._$_propertyTrackData$_ && (this._$_propertyTrackData$_._$Release$_(), 
            this._$_propertyTrackData$_ = null), this._$_nestedData$_ = null;
        }
        _$GetTrackData$_() {
            return this._$_trackData$_;
        }
        _$GetKeyframeData$_() {
            return this._$_keyframeData$_ || (this._$_keyframeData$_ = new Wn._$KeyframeData$_(null, this)), 
            this._$_keyframeData$_;
        }
        _$GetPropertyTrackData$_() {
            return this._$_propertyTrackData$_ || (this._$_propertyTrackData$_ = new Wn._$PropertyTrackData$_(null, this)), 
            this._$_propertyTrackData$_;
        }
        _$GetInstanceData$_() {
            return this._$_instanceData$_;
        }
        _$GetObjectClassIndex$_() {
            return this._$_objectClassIndex$_;
        }
        _$SetObjectClassIndex$_(t) {
            this._$_objectClassIndex$_ = t;
        }
        _$GetInstanceUID$_() {
            return this._$_instanceUid$_;
        }
        _$SetInstanceUID$_(t) {
            this._$_instanceUid$_ = t;
        }
        _$GetInterpolationMode$_() {
            return this._$_interpolationMode$_;
        }
        _$SetInterpolationMode$_(t) {
            this._$_interpolationMode$_ = t;
        }
        _$GetResultMode$_() {
            return this._$_resultMode$_;
        }
        _$SetResultMode$_(t) {
            this._$_resultMode$_ = t;
        }
        _$GetEnable$_() {
            return this._$_enabled$_;
        }
        _$SetEnable$_(t) {
            this._$_enabled$_ = !!t;
        }
        _$GetId$_() {
            return this._$_id$_;
        }
        _$GetStartOffset$_() {
            return this._$_startOffset$_;
        }
        _$GetLocalTotalTime$_() {
            return this._$_localTotalTime$_;
        }
        _$SetLocalTotalTime$_(t) {
            this._$_localTotalTime$_ = t;
        }
        _$GetOriginalWidth$_() {
            return this._$_additionalInstanceData$_[0];
        }
        _$SetOriginalWidth$_(t) {
            this._$_additionalInstanceData$_ || (this._$_additionalInstanceData$_ = []), 
            this._$_additionalInstanceData$_[0] = t;
        }
        _$GetOriginalHeight$_() {
            return this._$_additionalInstanceData$_ || (this._$_additionalInstanceData$_ = []), 
            this._$_additionalInstanceData$_[1];
        }
        _$SetOriginalHeight$_(t) {
            this._$_additionalInstanceData$_ || (this._$_additionalInstanceData$_ = []), 
            this._$_additionalInstanceData$_[1] = t;
        }
        _$GetType$_() {
            return this._$_type$_;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$_SaveToJson$_() {
            return {
                keyframeDataJson: this._$_keyframeData$_._$_SaveToJson$_(),
                propertyTrackDataJson: this._$_propertyTrackData$_._$_SaveToJson$_(),
                instanceData: this._$_instanceData$_,
                additionalInstanceData: this._$_additionalInstanceData$_,
                instanceUid: this._$_instanceUid$_,
                objectClassIndex: this._$_objectClassIndex$_,
                interpolationMode: this._$_interpolationMode$_,
                resultMode: this._$_resultMode$_,
                enabled: this._$_enabled$_,
                id: this._$_id$_,
                nestedData: this._$_nestedData$_,
                type: this._$_type$_,
                name: this._$_name$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (this._$_instanceData$_ = t.instanceData, this._$_instanceUid$_ = t.instanceUid, 
            this._$_objectClassIndex$_ = t.objectClassIndex, this._$_interpolationMode$_ = t.interpolationMode, 
            this._$_resultMode$_ = t.resultMode, this._$_enabled$_ = t.enabled, 
            this._$_id$_ = t.id, this._$_type$_ = t.type || 0, this._$_name$_ = t.name || "", 
            this._$_localTotalTime$_ = this._$_trackData$_._$GetTimelineDataItem$_()._$GetTotalTime$_(), 
            t.nestedData && (this._$_nestedData$_ = t.nestedData, this._$_startOffset$_ = this._$_nestedData$_[0], 
            this._$_localTotalTime$_ = this._$_nestedData$_[1]), t.additionalInstanceData && (this._$_additionalInstanceData$_ = t.additionalInstanceData), 
            this._$GetKeyframeData$_()._$_LoadFromJson$_(t.keyframeDataJson), this._$GetPropertyTrackData$_()._$_LoadFromJson$_(t.propertyTrackDataJson));
        }
    }
    Wn._$TrackData$_ = class {
        constructor(t, s) {
            this._$_timelineDataItem$_ = s, this._$_trackDataItems$_ = [], Wn._$TimelineDataManager$_._$_CreateDataItems$_(this._$_trackDataItems$_, t, jn, this);
        }
        _$Release$_() {
            this._$_timelineDataItem$_ = null;
            for (const t of this._$_trackDataItems$_) t._$Release$_();
            Wn._$clearArray$_(this._$_trackDataItems$_), this._$_trackDataItems$_ = null;
        }
        _$GetTimelineDataItem$_() {
            return this._$_timelineDataItem$_;
        }
        _$AddEmptyTrackDataItem$_() {
            const t = new jn(null, this);
            return this._$_trackDataItems$_.push(t), t;
        }
        _$GetFirstKeyframeDataItem$_(t) {
            return t._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_()[0];
        }
        _$GetLastKeyframeDataItem$_(t) {
            const s = t._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_();
            return s.at(-1);
        }
        _$GetKeyFrameDataItemAtTime$_(s, t) {
            const i = t._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_(), e = i.length;
            for (let t = 0; t < e; t++) {
                const h = i[t];
                if (h._$GetTime$_() === s) return h;
            }
        }
        _$GetFirstKeyFrameDataItemHigherThan$_(s, t) {
            const i = t._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_(), e = i.length;
            for (let t = 0; t < e; t++) {
                const h = i[t];
                if (h._$GetTime$_() > s) return h;
            }
        }
        _$GetFirstKeyFrameDataItemHigherOrEqualThan$_(s, t) {
            const i = t._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_(), e = i.length;
            for (let t = 0; t < e; t++) {
                const h = i[t];
                if (h._$GetTime$_() >= s) return h;
            }
        }
        _$GetFirstKeyFrameDataItemLowerOrEqualThan$_(s, t) {
            const i = t._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_();
            for (let t = i.length - 1; 0 <= t; t--) {
                const e = i[t];
                if (e._$GetTime$_() <= s) return e;
            }
        }
        *_$trackDataItems$_() {
            for (const t of this._$_trackDataItems$_) yield t;
        }
        _$_SaveToJson$_() {
            return {
                trackDataItemsJson: this._$_trackDataItems$_.map(t => t._$_SaveToJson$_())
            };
        }
        _$_LoadFromJson$_(t) {
            t && Wn._$TimelineDataManager$_._$_LoadDataItemsFromJson$_(this._$_trackDataItems$_, t.trackDataItemsJson, jn, this);
        }
    };
}

{
    const Vn = self._$C3$_;
    class Un {
        constructor(t, s) {
            this._$_propertyTrackData$_ = s, this._$_sourceAdapterId$_ = "", this._$_sourceAdapterArguments$_ = null, 
            this._$_property$_ = null, this._$_type$_ = null, this._$_min$_ = NaN, 
            this._$_max$_ = NaN, this._$_interpolationMode$_ = "default", this._$_resultMode$_ = "default", 
            this._$_enabled$_ = !1, this._$_propertyKeyframeData$_ = null, this._$_canHavePropertyKeyframes$_ = !0, 
            t && (this._$_sourceAdapterId$_ = t[0][0], this._$_sourceAdapterArguments$_ = t[0].slice(1), 
            this._$_property$_ = t[1], this._$_type$_ = t[2], this._$_min$_ = t[3], 
            this._$_max$_ = t[4], this._$_interpolationMode$_ = t[5], this._$_resultMode$_ = t[6], 
            this._$_enabled$_ = !!t[7], this._$_propertyKeyframeData$_ = new Vn._$PropertyKeyframeData$_(t[8], this), 
            this._$_canHavePropertyKeyframes$_ = t[9]);
        }
        _$Release$_() {
            this._$_propertyKeyframeData$_._$Release$_(), this._$_propertyKeyframeData$_ = null, 
            this._$_propertyTrackData$_ = null, this._$_sourceAdapterArguments$_ = null;
        }
        _$GetPropertyTrackData$_() {
            return this._$_propertyTrackData$_;
        }
        _$GetPropertyKeyframeData$_() {
            return this._$_propertyKeyframeData$_ || (this._$_propertyKeyframeData$_ = new Vn._$PropertyKeyframeData$_(null, this)), 
            this._$_propertyKeyframeData$_;
        }
        _$GetSourceAdapterId$_() {
            return this._$_sourceAdapterId$_;
        }
        _$SetSourceAdapterId$_(t) {
            this._$_sourceAdapterId$_ = t;
        }
        _$GetSourceAdapterArguments$_() {
            return this._$_sourceAdapterArguments$_;
        }
        _$SetSourceAdapterArguments$_(t) {
            this._$_sourceAdapterArguments$_ = t;
        }
        _$GetProperty$_() {
            return this._$_property$_;
        }
        _$SetProperty$_(t) {
            this._$_property$_ = t;
        }
        _$GetType$_() {
            return this._$_type$_;
        }
        _$SetType$_(t) {
            this._$_type$_ = t;
        }
        _$GetMin$_() {
            return this._$_min$_;
        }
        _$SetMin$_(t) {
            this._$_min$_ = t;
        }
        _$GetMax$_() {
            return this._$_max$_;
        }
        _$SetMax$_(t) {
            this._$_max$_ = t;
        }
        _$GetInterpolationMode$_() {
            return this._$_interpolationMode$_;
        }
        _$SetInterpolationMode$_(t) {
            this._$_interpolationMode$_ = t;
        }
        _$GetResultMode$_() {
            return this._$_resultMode$_;
        }
        _$SetResultMode$_(t) {
            this._$_resultMode$_ = t;
        }
        _$GetEnable$_() {
            return this._$_enabled$_;
        }
        _$SetEnable$_(t) {
            this._$_enabled$_ = !!t;
        }
        _$CanHavePropertyKeyframes$_() {
            return !!this._$_canHavePropertyKeyframes$_;
        }
        _$_SaveToJson$_() {
            return {
                propertyKeyframeDataJson: this._$_propertyKeyframeData$_._$_SaveToJson$_(),
                sourceAdapterId: this._$_sourceAdapterId$_,
                sourceAdapterArguments: this._$_sourceAdapterArguments$_,
                property: this._$_property$_,
                type: this._$_type$_,
                min: this._$_min$_,
                max: this._$_max$_,
                interpolationMode: this._$_interpolationMode$_,
                resultMode: this._$_resultMode$_,
                enabled: this._$_enabled$_,
                canHavePropertyKeyframes: this._$_canHavePropertyKeyframes$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (this._$_sourceAdapterId$_ = t.sourceAdapterId, this._$_sourceAdapterArguments$_ = t.sourceAdapterArguments, 
            this._$_property$_ = t.property, this._$_type$_ = t.type, this._$_min$_ = t.min, 
            this._$_max$_ = t.max, this._$_interpolationMode$_ = t.interpolationMode, 
            this._$_resultMode$_ = t.resultMode, this._$_enabled$_ = t.enabled, 
            this._$_canHavePropertyKeyframes$_ = t.canHavePropertyKeyframes, this._$GetPropertyKeyframeData$_()._$_LoadFromJson$_(t.propertyKeyframeDataJson));
        }
    }
    Vn._$PropertyTrackData$_ = class {
        constructor(t, s) {
            this._$_trackDataItem$_ = s, this._$_propertyTrackDataItems$_ = [], 
            Vn._$TimelineDataManager$_._$_CreateDataItems$_(this._$_propertyTrackDataItems$_, t, Un, this);
        }
        _$Release$_() {
            this._$_trackDataItem$_ = null;
            for (const t of this._$_propertyTrackDataItems$_) t._$Release$_();
            Vn._$clearArray$_(this._$_propertyTrackDataItems$_), this._$_propertyTrackDataItems$_ = null;
        }
        _$GetTrackDataItem$_() {
            return this._$_trackDataItem$_;
        }
        _$AddEmptyPropertyTrackDataItem$_() {
            const t = new Un(null, this);
            return this._$_propertyTrackDataItems$_.push(t), t;
        }
        _$GetFirstPropertyKeyframeDataItem$_(t) {
            const s = t._$GetPropertyKeyframeData$_();
            return s._$GetPropertyKeyframeDataItemArray$_()[0];
        }
        _$GetLastPropertyKeyframeDataItem$_(t) {
            const s = t._$GetPropertyKeyframeData$_(), i = s._$GetPropertyKeyframeDataItemArray$_();
            return i.at(-1);
        }
        _$GetPropertyKeyFrameDataItemAtTime$_(s, t) {
            const i = t._$GetPropertyKeyframeData$_(), e = i._$GetPropertyKeyframeDataItemArray$_(), h = e.length;
            for (let t = 0; t < h; t++) {
                const r = e[t];
                if (r._$GetTime$_() === s) return r;
            }
        }
        _$GetFirstPropertyKeyFrameDataItemHigherThan$_(s, t) {
            const i = t._$GetPropertyKeyframeData$_(), e = i._$GetPropertyKeyframeDataItemArray$_(), h = e.length;
            for (let t = 0; t < h; t++) {
                const r = e[t];
                if (r._$GetTime$_() > s) return r;
            }
        }
        _$GetFirstPropertyKeyFrameDataItemHigherOrEqualThan$_(s, t) {
            const i = t._$GetPropertyKeyframeData$_(), e = i._$GetPropertyKeyframeDataItemArray$_(), h = e.length;
            for (let t = 0; t < h; t++) {
                const r = e[t];
                if (r._$GetTime$_() >= s) return r;
            }
        }
        _$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(s, t) {
            const i = t._$GetPropertyKeyframeData$_(), e = i._$GetPropertyKeyframeDataItemArray$_();
            for (let t = e.length - 1; 0 <= t; t--) {
                const h = e[t];
                if (h._$GetTime$_() <= s) return h;
            }
        }
        *_$propertyTrackDataItems$_() {
            for (const t of this._$_propertyTrackDataItems$_) yield t;
        }
        _$_SaveToJson$_() {
            return {
                propertyTrackDataItemsJson: this._$_propertyTrackDataItems$_.map(t => t._$_SaveToJson$_())
            };
        }
        _$_LoadFromJson$_(t) {
            t && Vn._$TimelineDataManager$_._$_LoadDataItemsFromJson$_(this._$_propertyTrackDataItems$_, t.propertyTrackDataItemsJson, Un, this);
        }
    };
}

{
    const Hn = self._$C3$_;
    class zn {
        constructor(t, s) {
            if (this._$_keyframeData$_ = s, this._$_time$_ = -1, this._$_ease$_ = "noease", 
            this._$_enable$_ = !1, this._$_tags$_ = null, this._$_lowerTags$_ = null, 
            t) {
                this._$_time$_ = t[0], this._$_ease$_ = t[1], this._$_enable$_ = !!t[2];
                const i = t[3];
                this._$_tags$_ = i ? i.split(" ") : [], this._$_lowerTags$_ = new Set(this._$_tags$_.map(t => t.toLowerCase())), 
                this._$_next$_ = null;
            }
        }
        _$Release$_() {
            this._$_keyframeData$_ = null, Hn._$clearArray$_(this._$_tags$_), this._$_tags$_ = null, 
            this._$_lowerTags$_.clear(), this._$_lowerTags$_ = null, this._$_next$_ = null;
        }
        _$GetKeyframeData$_() {
            return this._$_keyframeData$_;
        }
        _$GetNext$_() {
            return this._$_next$_;
        }
        _$SetNext$_(t) {
            this._$_next$_ = t;
        }
        _$GetTime$_() {
            return this._$_time$_;
        }
        _$SetTime$_(t) {
            this._$_time$_ = t, this._$_keyframeData$_._$_LinkKeyframeDataItems$_();
        }
        _$GetEase$_() {
            return this._$_ease$_;
        }
        _$SetEase$_(t) {
            this._$_ease$_ = t;
        }
        _$GetEnable$_() {
            return this._$_enable$_;
        }
        _$SetEnable$_(t) {
            this._$_enable$_ = !!t;
        }
        _$GetTags$_() {
            return this._$_tags$_;
        }
        _$SetTags$_(t) {
            this._$_tags$_ = t ? t.split(" ") : [], this._$_lowerTags$_ = new Set(this._$_tags$_.map(t => t.toLowerCase()));
        }
        _$GetLowerTags$_() {
            return this._$_lowerTags$_;
        }
        _$HasTag$_(t) {
            return this._$_lowerTags$_.has(t.toLowerCase());
        }
        _$_SaveToJson$_() {
            return {
                time: this._$_time$_,
                ease: this._$_ease$_,
                enable: this._$_enable$_,
                tags: this._$_tags$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (this._$_time$_ = t.time, this._$_ease$_ = t.ease, this._$_enable$_ = t.enable, 
            this._$_tags$_ = t.tags, this._$_lowerTags$_ = new Set(this._$_tags$_.map(t => t.toLowerCase())));
        }
    }
    Hn._$KeyframeData$_ = class {
        constructor(t, s) {
            this._$_trackDataItem$_ = s, this._$_keyframeDataItems$_ = [], Hn._$TimelineDataManager$_._$_CreateDataItems$_(this._$_keyframeDataItems$_, t, zn, this), 
            this._$_LinkKeyframeDataItems$_();
        }
        _$Release$_() {
            this._$_trackDataItem$_ = null;
            for (const t of this._$_keyframeDataItems$_) t._$Release$_();
            Hn._$clearArray$_(this._$_keyframeDataItems$_), this._$_keyframeDataItems$_ = null;
        }
        _$_LinkKeyframeDataItems$_() {
            this._$_keyframeDataItems$_.sort((t, s) => t._$GetTime$_() - s._$GetTime$_());
            for (let t = 0; t < this._$_keyframeDataItems$_.length; t++) {
                const s = this._$_keyframeDataItems$_[t];
                s._$SetNext$_(this._$_keyframeDataItems$_[t + 1]);
            }
        }
        _$GetTrackDataItem$_() {
            return this._$_trackDataItem$_;
        }
        _$GetKeyframeDataItemCount$_() {
            return this._$_keyframeDataItems$_.length;
        }
        _$GetKeyframeDataItemArray$_() {
            return this._$_keyframeDataItems$_;
        }
        _$AddEmptyKeyframeDataItem$_() {
            const t = new zn(null, this);
            return this._$_keyframeDataItems$_.push(t), this._$_LinkKeyframeDataItems$_(), 
            t;
        }
        _$DeleteKeyframeDataItems$_(t) {
            for (const s of this._$_keyframeDataItems$_) if (t(s)) {
                const i = this._$_keyframeDataItems$_.indexOf(s);
                -1 !== i && (s._$Release$_(), this._$_keyframeDataItems$_.splice(i, 1));
            }
            this._$SortKeyframeDataItems$_(), this._$_LinkKeyframeDataItems$_();
        }
        _$SortKeyframeDataItems$_() {
            this._$_keyframeDataItems$_.sort((t, s) => t._$GetTime$_() - s._$GetTime$_());
        }
        _$GetKeyframeDataItemIndex$_(t) {
            return this._$_keyframeDataItems$_.indexOf(t);
        }
        _$GetKeyframeDataItemFromIndex$_(t) {
            return this._$_keyframeDataItems$_[t];
        }
        *_$keyframeDataItems$_() {
            for (const t of this._$_keyframeDataItems$_) yield t;
        }
        *_$keyframeDataItemsReverse$_() {
            for (let t = this._$_keyframeDataItems$_.length - 1; 0 <= t; t--) yield this._$_keyframeDataItems$_[t];
        }
        _$_SaveToJson$_() {
            return {
                keyframeDataItemsJson: this._$_keyframeDataItems$_.map(t => t._$_SaveToJson$_())
            };
        }
        _$_LoadFromJson$_(t) {
            t && (Hn._$TimelineDataManager$_._$_LoadDataItemsFromJson$_(this._$_keyframeDataItems$_, t.keyframeDataItemsJson, zn, this), 
            this._$_LinkKeyframeDataItems$_());
        }
    };
}

{
    const Jn = self._$C3$_;
    class qn {
        constructor(t, s) {
            this._$_propertyKeyframeData$_ = s, this._$_value$_ = null, this._$_aValue$_ = null, 
            this._$_type$_ = "", this._$_time$_ = NaN, this._$_ease$_ = "noease", 
            this._$_enable$_ = !1, this._$_addonData$_ = null, this._$_addonInstance$_ = void 0, 
            this._$_pathMode$_ = "line", t && (this._$_value$_ = t[0][0], this._$_aValue$_ = t[0][1], 
            this._$_type$_ = t[0][2], this._$_time$_ = t[1], this._$_ease$_ = t[2], 
            this._$_enable$_ = !!t[3], this._$_pathMode$_ = t[5], this._$_addonData$_ = null, 
            t[4] && (this._$_addonData$_ = new Jn._$AddonData$_(t[4], this)), this._$_next$_ = null, 
            this._$_prev$_ = null);
        }
        _$Release$_() {
            this._$_propertyKeyframeData$_ = null, this._$_addonData$_ && (this._$_addonData$_._$Release$_(), 
            this._$_addonData$_ = null), this._$_next$_ = null, this._$_prev$_ = null;
        }
        _$GetAddonData$_() {
            return this._$_addonData$_;
        }
        _$SetNext$_(t) {
            this._$_next$_ = t;
        }
        _$GetNext$_() {
            return this._$_next$_;
        }
        _$SetPrevious$_(t) {
            this._$_prev$_ = t;
        }
        _$GetPrevious$_() {
            return this._$_prev$_;
        }
        _$GetValue$_() {
            return this._$_value$_;
        }
        _$SetValue$_(t) {
            "color" === this._$_type$_ && Jn._$IsFiniteNumber$_(t) ? (this._$_value$_[0] = Jn._$GetRValue$_(t), 
            this._$_value$_[1] = Jn._$GetGValue$_(t), this._$_value$_[2] = Jn._$GetBValue$_(t)) : this._$_value$_ = t;
        }
        _$GetAbsoluteValue$_() {
            return this._$_aValue$_;
        }
        _$SetAbsoluteValue$_(t) {
            "color" === this._$_type$_ && Jn._$IsFiniteNumber$_(t) ? (this._$_aValue$_[0] = Jn._$GetRValue$_(t), 
            this._$_aValue$_[1] = Jn._$GetGValue$_(t), this._$_aValue$_[2] = Jn._$GetBValue$_(t)) : this._$_aValue$_ = t;
        }
        _$GetValueWithResultMode$_() {
            const t = this._$_propertyKeyframeData$_._$GetPropertyTrackDataItem$_()._$GetResultMode$_();
            return "relative" === t ? this._$GetValue$_() : "absolute" === t ? this._$GetAbsoluteValue$_() : void 0;
        }
        _$GetType$_() {
            return this._$_type$_;
        }
        _$SetType$_(t) {
            this._$_type$_ = t;
        }
        _$GetTime$_() {
            return this._$_time$_;
        }
        _$SetTime$_(t) {
            this._$_time$_ = t, this._$_propertyKeyframeData$_._$_LinkPropertyKeyframeDataItems$_();
        }
        _$GetEase$_() {
            return this._$_ease$_;
        }
        _$SetEase$_(t) {
            this._$_ease$_ = t;
        }
        _$GetEnable$_() {
            return this._$_enable$_;
        }
        _$SetEnable$_(t) {
            this._$_enable$_ = !!t;
        }
        _$GetPathMode$_() {
            return this._$_pathMode$_;
        }
        _$GetAddOn$_(s) {
            if (this._$_addonData$_) {
                if (!this._$_addonInstance$_ && null !== this._$_addonInstance$_) {
                    const i = this._$_addonData$_._$GetAddDataItemArray$_();
                    if (i) {
                        const e = i.length;
                        for (let t = 0; t < e; t++) {
                            const h = i[t];
                            if (h._$GetId$_() === s) return this._$_addonInstance$_ = h, 
                            this._$_addonInstance$_;
                        }
                    }
                    this._$_addonInstance$_ = null;
                }
                return this._$_addonInstance$_;
            }
        }
        _$_SaveToJson$_() {
            const t = this._$_addonData$_;
            return {
                addonDataJson: t && t._$_SaveToJson$_(),
                value: this._$_value$_,
                aValue: this._$_aValue$_,
                type: this._$_type$_,
                time: this._$_time$_,
                ease: this._$_ease$_,
                enable: this._$_enable$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (t.addonDataJson && this._$_addonData$_._SetFromJson(t.addonDataJson), 
            this._$_value$_ = t.value, this._$_aValue$_ = t.aValue, this._$_type$_ = t.type, 
            this._$_time$_ = t.time, this._$_ease$_ = t.ease, this._$_enable$_ = t.enable);
        }
    }
    Jn._$PropertyKeyframeData$_ = class {
        constructor(t, s) {
            this._$_propertyTrackDataItem$_ = s, this._$_propertyKeyframeDataItems$_ = [], 
            this._$_propertyKeyframeDataItemsIncludingDisabled$_ = [], Jn._$TimelineDataManager$_._$_CreateDataItems$_(this._$_propertyKeyframeDataItems$_, t, qn, this), 
            Jn._$TimelineDataManager$_._$_CreateDataItemsIncludingDisabled$_(this._$_propertyKeyframeDataItemsIncludingDisabled$_, t, qn, this), 
            this._$_LinkPropertyKeyframeDataItems$_();
        }
        _$Release$_() {
            this._$_propertyTrackDataItem$_ = null;
            for (const t of this._$_propertyKeyframeDataItems$_) t._$Release$_();
            Jn._$clearArray$_(this._$_propertyKeyframeDataItems$_), this._$_propertyKeyframeDataItems$_ = null;
            for (const s of this._$_propertyKeyframeDataItemsIncludingDisabled$_) s._$Release$_();
            Jn._$clearArray$_(this._$_propertyKeyframeDataItemsIncludingDisabled$_), 
            this._$_propertyKeyframeDataItemsIncludingDisabled$_ = null;
        }
        _$_LinkPropertyKeyframeDataItems$_() {
            let s = this._$_propertyKeyframeDataItems$_;
            s.sort((t, s) => t._$GetTime$_() - s._$GetTime$_());
            for (let t = 0; t < s.length; t++) {
                const i = s[t];
                t + 1 < s.length && i._$SetNext$_(s[t + 1]), 0 <= t - 1 && i._$SetPrevious$_(s[t - 1]);
            }
            (s = this._$_propertyKeyframeDataItemsIncludingDisabled$_).sort((t, s) => t._$GetTime$_() - s._$GetTime$_());
            for (let t = 0; t < s.length; t++) {
                const e = s[t];
                t + 1 < s.length && e._$SetNext$_(s[t + 1]), 0 <= t - 1 && e._$SetPrevious$_(s[t - 1]);
            }
        }
        _$AddEmptyPropertyKeyframeDataItem$_() {
            const t = new qn(null, this);
            return this._$_propertyKeyframeDataItems$_.push(t), this._$_LinkPropertyKeyframeDataItems$_(), 
            t;
        }
        _$DeletePropertyKeyframeDataItems$_(t) {
            for (const s of this._$_propertyKeyframeDataItems$_) if (t(s)) {
                const i = this._$_propertyKeyframeDataItems$_.indexOf(s);
                -1 !== i && (s._$Release$_(), this._$_propertyKeyframeDataItems$_.splice(i, 1));
            }
            this._$SortPropertyKeyFrameDataItems$_(), this._$_LinkPropertyKeyframeDataItems$_();
        }
        _$SortPropertyKeyFrameDataItems$_() {
            this._$_propertyKeyframeDataItems$_.sort((t, s) => t._$GetTime$_() - s._$GetTime$_());
        }
        _$GetPropertyTrackDataItem$_() {
            return this._$_propertyTrackDataItem$_;
        }
        _$GetPropertyKeyframeDataItemCount$_() {
            return this._$_propertyKeyframeDataItems$_.length;
        }
        _$GetLastPropertyKeyframeDataItem$_() {
            return this._$_propertyKeyframeDataItems$_[this._$_propertyKeyframeDataItems$_.length - 1];
        }
        _$GetPropertyKeyframeDataItemArray$_() {
            return this._$_propertyKeyframeDataItems$_;
        }
        _$GetPropertyKeyframeDataItemArrayIncludingDisabled$_() {
            return this._$_propertyKeyframeDataItemsIncludingDisabled$_;
        }
        *_$propertyKeyframeDataItems$_() {
            for (const t of this._$_propertyKeyframeDataItems$_) yield t;
        }
        *_$propertyKeyframeDataItemsReverse$_() {
            for (let t = this._$_propertyKeyframeDataItems$_.length - 1; 0 <= t; t--) yield this._$_propertyKeyframeDataItems$_[t];
        }
        _$_SaveToJson$_() {
            const t = this._$_propertyKeyframeDataItems$_, s = this._$_propertyKeyframeDataItemsIncludingDisabled$_;
            return {
                propertyKeyframeDataItemsJson: t.map(t => t._$_SaveToJson$_()),
                propertyKeyframeDataItemsIncludingDisabledJson: s.map(t => t._$_SaveToJson$_())
            };
        }
        _$_LoadFromJson$_(t) {
            t && (Jn._$TimelineDataManager$_._$_LoadDataItemsFromJson$_(this._$_propertyKeyframeDataItems$_, t.propertyKeyframeDataItemsJson, qn, this), 
            Jn._$TimelineDataManager$_._$_LoadDataItemsFromJson$_(this._$_propertyKeyframeDataItemsIncludingDisabled$_, t.propertyKeyframeDataItemsIncludingDisabledJson, qn, this), 
            this._$_LinkPropertyKeyframeDataItems$_());
        }
    };
}

{
    const Xn = self._$C3$_;
    class Yn {
        constructor(t, s) {
            this._$_addonData$_ = s, this._$_id$_ = t[0], this._$_data$_ = t[1];
        }
        _$Release$_() {
            this._$_addonData$_ = null, this._$_data$_ = null;
        }
        _$GetAddonData$_() {
            return this._$_addonData$_;
        }
        _$GetId$_() {
            return this._$_id$_;
        }
        _$_SaveToJson$_() {
            return {
                id: this._$_id$_,
                data: this._$_data$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (this._$_id$_ = t.id, this._$_data$_ = t.data);
        }
    }
    class $n extends Yn {
        constructor(t, s) {
            super(t, s), this._$_startAnchor$_ = this._$_data$_[0], this._$_startEnable$_ = !!this._$_data$_[1], 
            this._$_endAnchor$_ = this._$_data$_[2], this._$_endEnable$_ = !!this._$_data$_[3];
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$GetStartAnchor$_() {
            return this._$_startAnchor$_;
        }
        _$GetStartEnable$_() {
            return this._$_startEnable$_;
        }
        _$GetEndAnchor$_() {
            return this._$_endAnchor$_;
        }
        _$GetEndEnable$_() {
            return this._$_endEnable$_;
        }
        _$_SaveToJson$_() {
            return Object.assign(super._$_SaveToJson$_(), {
                startAnchor: this._$_startAnchor$_,
                startEnable: !!this._$_startEnable$_,
                endAnchor: this._$_endAnchor$_,
                endEnable: !!this._$_endEnable$_
            });
        }
        _$_LoadFromJson$_(t) {
            t && (super._$_LoadFromJson$_(t), this._$_startAnchor$_ = t.startAnchor, 
            this._$_startEnable$_ = !!t.startEnable, this._$_endAnchor$_ = t.endAnchor, 
            this._$_endEnable$_ = !!t.endEnable);
        }
    }
    class Kn extends Yn {
        constructor(t, s) {
            super(t, s), this._$_direction$_ = this._$_data$_[0], this._$_revolutions$_ = this._$_data$_[1];
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$GetDirection$_() {
            return this._$_direction$_;
        }
        _$GetRevolutions$_() {
            return this._$_revolutions$_;
        }
        _$_SaveToJson$_() {
            return Object.assign(super._$_SaveToJson$_(), {
                direction: this._$_direction$_,
                revolutions: this._$_revolutions$_
            });
        }
        _$_LoadFromJson$_(t) {
            t && (super._$_LoadFromJson$_(t), this._$_direction$_ = t.direction, 
            this._$_revolutions$_ = t.revolutions);
        }
    }
    Xn._$AddonData$_ = class {
        constructor(t, s) {
            this._$_propertyKeyframeDataItem$_ = s, this._$_addonDataItems$_ = [], 
            Xn._$TimelineDataManager$_._$_CreateDataItems$_(this._$_addonDataItems$_, t, {
                prop: 0,
                map: new Map([ [ "cubic-bezier", $n ], [ "angle", Kn ] ])
            }, this);
        }
        _$Release$_() {
            this._$_propertyKeyframeDataItem$_ = null;
            for (const t of this._$_addonDataItems$_) t._$Release$_();
            Xn._$clearArray$_(this._$_addonDataItems$_), this._$_addonDataItems$_ = null;
        }
        _$GetPropertyKeyframeDataItem$_() {
            return this._$_propertyKeyframeDataItem$_;
        }
        _$GetAddDataItemArray$_() {
            return this._$_addonDataItems$_;
        }
        *_$addonDataItems$_() {
            for (const t of this._$_addonDataItems$_) yield t;
        }
        _$_SaveToJson$_() {
            return {
                addonDataItemsJson: this._$_addonDataItems$_.map(t => t._$_SaveToJson$_())
            };
        }
        _$_LoadFromJson$_(t) {
            t && Xn._$TimelineDataManager$_._$_LoadDataItemsFromJson$_(this._$_addonDataItems$_, t.addonDataItemsJson, {
                prop: "id",
                map: new Map([ [ "cubic-bezier", $n ], [ "angle", Kn ] ])
            }, this);
        }
    };
}

{
    let m = self._$C3$_, i = 0;
    m._$TweenState$_ = class extends m._$TimelineState$_ {
        constructor(t, s) {
            super("tween-" + i++, t, s), this._$_id$_ = "", this._$_destroyInstanceOnComplete$_ = !1, 
            this._$_initialValueMode$_ = "start-value", this._$_instance$_ = null, 
            this._$_on_completed_callbacks$_ = null, this._$_on_started_callbacks$_ = null, 
            this._$_track$_ = null, this._$_iTweenState$_ = null;
        }
        _$FireReleaseEvent$_(t) {
            const s = m._$New$_(m.Event, "tweenstatereleased");
            s._$tweenState$_ = this, t.dispatchEvent(s);
        }
        _$GetType$_() {
            return 1;
        }
        _$CreateTrackStates$_() {
            for (const t of this._$_timelineDataItem$_._$GetTrackData$_()._$trackDataItems$_()) this._$_tracks$_.push(m._$TweenTrackState$_._$Create$_(this, t));
            this._$_track$_ = this._$_tracks$_[0];
        }
        _$AddTrack$_() {
            const t = this._$_timelineDataItem$_._$GetTrackData$_()._$AddEmptyTrackDataItem$_(), s = m._$TweenTrackState$_._$Create$_(this, t);
            return this._$_tracks$_.push(s), this._$_CacheTrack$_(), s;
        }
        _$_CacheTrack$_() {
            this._$_track$_ = this._$_tracks$_[0];
        }
        _$GetPropertyTrack$_(t) {
            return this._$_track$_._$GetPropertyTracks$_()[0];
        }
        _$SetPropertyType$_(t) {
            this._$_propertyType$_ = t;
        }
        _$GetInstance$_() {
            const t = this._$GetTracks$_();
            if (t && t.length) {
                const s = t[0];
                if (this._$_track$_ = s) {
                    const i = s._$GetInstance$_();
                    return s._$IsInstanceValid$_() ? i : void 0;
                }
            }
        }
        _$AddStartedCallback$_(t) {
            this._$_on_started_callbacks$_ || (this._$_on_started_callbacks$_ = []), 
            this._$_on_started_callbacks$_.push(t);
        }
        _$AddCompletedCallback$_(t) {
            this._$_on_completed_callbacks$_ || (this._$_on_completed_callbacks$_ = []), 
            this._$_on_completed_callbacks$_.push(t);
        }
        _$RemoveStartedCallback$_(t) {
            if (this._$_on_started_callbacks$_) {
                const s = this._$_on_started_callbacks$_.indexOf(t);
                -1 !== s && this._$_on_started_callbacks$_.splice(s, 1);
            }
        }
        _$RemoveCompletedCallback$_(t) {
            if (this._$_on_completed_callbacks$_) {
                const s = this._$_on_completed_callbacks$_.indexOf(t);
                -1 !== s && this._$_on_completed_callbacks$_.splice(s, 1);
            }
        }
        _$SetStartValue$_(t, s) {
            for (const i of this._$_tracks$_) for (const e of i._$_propertyTracks$_) if (e._$GetPropertyName$_() === s) {
                const h = e._$GetPropertyTrackData$_(), r = e._$GetPropertyTrackDataItem$_(), n = h._$GetFirstPropertyKeyframeDataItem$_(r);
                n._$SetValue$_(t), n._$SetAbsoluteValue$_(t);
            }
        }
        _$_GetPropertyTrackState$_(t) {
            for (const s of this._$_tracks$_) for (const i of s._$_propertyTracks$_) if (i._$GetPropertyName$_() === t) return i;
        }
        _$BeforeSetEndValues$_(t) {
            for (const s of t) {
                const i = this._$_GetPropertyTrackState$_(s);
                this._$SetStartValue$_(i._$GetCurrentState$_(), s);
            }
            if (this._$IsForwardPlayBack$_()) {
                const e = this._$GetTotalTime$_() - this._$GetTime$_();
                this._$SetTotalTime$_(e);
                for (const h of this._$_tracks$_) h._$SetLocalTotalTime$_(e);
                this._$_SetTime$_(0);
            } else {
                const r = this._$GetTime$_();
                this._$SetTotalTime$_(r);
                for (const n of this._$_tracks$_) n._$SetLocalTotalTime$_(r);
                this._$_SetTime$_(r);
            }
            this._$SetInitialStateFromSetTime$_();
        }
        _$SetEndValue$_(t, s) {
            const i = this._$_GetPropertyTrackState$_(s), e = i._$GetPropertyTrackData$_(), h = i._$GetPropertyTrackDataItem$_(), r = e._$GetLastPropertyKeyframeDataItem$_(h);
            r._$SetTime$_(this._$GetTotalTime$_()), r._$SetValue$_(t), r._$SetAbsoluteValue$_(t);
        }
        _$SetId$_(t) {
            this._$_id$_ = t;
        }
        _$GetId$_() {
            return this._$_id$_;
        }
        _$SetInitialValueMode$_(t) {
            this._$_initialValueMode$_ = t;
        }
        _$GetInitialValueMode$_() {
            return this._$_initialValueMode$_;
        }
        _$SetDestroyInstanceOnComplete$_(t) {
            this._$_destroyInstanceOnComplete$_ = t;
        }
        _$GetDestroyInstanceOnComplete$_() {
            return this._$_destroyInstanceOnComplete$_;
        }
        _$OnStarted$_() {
            if (this._$_on_started_callbacks$_) for (const t of this._$_on_started_callbacks$_) t(this);
            if (!this._$IsComplete$_()) for (const s of this._$_tracks$_) s._$CompareSaveStateWithCurrent$_();
        }
        _$OnCompleted$_() {
            this._$_completedTick$_ = this._$_runtime$_._$GetTickCount$_();
        }
        _$FinishTriggers$_() {
            if (!this._$_finishedTriggers$_ && (this._$_finishedTriggers$_ = !0, 
            this._$_on_completed_callbacks$_)) for (const t of this._$_on_completed_callbacks$_) t(this);
        }
        _$SetTime$_(t) {
            this._$_DeleteIntermediateKeyframes$_(), super._$SetTime$_(t);
        }
        _$_SetTimeAndReset$_(t) {
            (t = m._$IsFiniteNumber$_(t) ? t : this._$GetTotalTime$_()) < 0 ? this._$_playheadTime$_ = 0 : t >= this._$GetTotalTime$_() ? this._$_playheadTime$_ = this._$GetTotalTime$_() : this._$_playheadTime$_ = t, 
            this._$_track$_._$SetResetState$_();
        }
        _$SetInitialState$_(t) {
            if (!this._$InitialStateSet$_() && "current-state" === this._$GetInitialValueMode$_()) for (const s of this._$_tracks$_) s._$CompareInitialStateWithCurrent$_();
            super._$SetInitialState$_(t);
        }
        _$Stop$_(t = !1) {
            if (super._$Stop$_(t), !this._$IsComplete$_()) for (const s of this._$_tracks$_) s._$SaveState$_();
        }
        _$Reset$_(t = !0, s = !1) {
            this._$_DeleteIntermediateKeyframes$_(), super._$Reset$_(t, s);
        }
        _$_DeleteIntermediateKeyframes$_() {
            for (const t of this._$_tracks$_) {
                const s = t => {
                    const s = t._$GetTime$_(), i = this._$GetTotalTime$_();
                    return 0 !== s && s !== i;
                };
                t._$DeleteKeyframes$_(s), t._$DeletePropertyKeyframes$_(s);
            }
        }
        _$_OnBeforeChangeLayout$_() {
            if (!this._$IsReleased$_()) {
                const t = this._$GetInstance$_();
                if (t && t._$GetObjectClass$_()._$IsGlobal$_()) return !1;
                this._$_timelineManager$_._$CompleteTimelineBeforeChangeOfLayout$_(this), 
                this._$ResetBeforeChangeLayout$_();
            }
            return !0;
        }
        _$Tick$_(h, t, s) {
            if (this._$_instance$_ || (this._$_instance$_ = this._$GetInstance$_()), 
            !this._$_instance$_ || this._$_instance$_._$IsDestroyed$_()) this._$Stop$_(!0), 
            this._$OnCompleted$_(); else {
                const i = this._$_instance$_._$GetTimeScale$_();
                if (0 !== (h = -1 !== i ? s * i : h) || 0 !== this._$_lastDelta$_) {
                    this._$_lastDelta$_ = h;
                    const r = this._$_playheadTime$_ + this._$_overshoot$_, n = h * this._$_playbackRate$_, o = r + n, a = this._$_timelineDataItem$_._$_totalTime$_;
                    o < 0 ? (this._$_playheadTime$_ = 0, this._$_overshoot$_ = -o) : a <= o ? (this._$_playheadTime$_ = a, 
                    this._$_overshoot$_ = this._$_playheadTime$_ - o) : (this._$_playheadTime$_ = o, 
                    this._$_overshoot$_ = 0);
                    let t = !1, s = !1, i = this._$GetLoop$_(), e = this._$GetPingPong$_();
                    i || e ? i && !e ? 0 < this._$_playbackRate$_ ? this._$_playheadTime$_ >= a && (this._$_SetTimeAndReset$_(0), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), 
                    s = !0) : this._$_playheadTime$_ <= 0 && (this._$_SetTimeAndReset$_(a), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), 
                    s = !0) : !i && e ? 0 < this._$_playbackRate$_ ? this._$_playheadTime$_ >= a && (this._$_SetTime$_(a), 
                    this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), s = !0, 
                    1 === this._$_pingPongState$_ ? this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_), 
                    this._$_pingPongState$_ = 0) : (this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_), 
                    t = !0) : 0 === this._$_pingPongState$_ && (this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_), 
                    this._$_pingPongState$_ = 1)) : this._$_playheadTime$_ <= 0 && (this._$_SetTime$_(0), 
                    this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), s = !0, 
                    1 === this._$_pingPongState$_ ? this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_), 
                    this._$_pingPongState$_ = 0) : (t = !0, this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_)) : 0 === this._$_pingPongState$_ && (this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_), 
                    this._$_pingPongState$_ = 1)) : i && e && (0 < this._$_playbackRate$_ ? this._$_playheadTime$_ >= a && (this._$_SetTime$_(a), 
                    this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), s = !0, 
                    0 === this._$_pingPongState$_ && (this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_)), 
                    1 === this._$_pingPongState$_ && (this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_)), 
                    this._$_pingPongState$_++, this._$_pingPongState$_ = m.wrap(this._$_pingPongState$_, 0, 2)) : this._$_playheadTime$_ <= 0 && (this._$_SetTime$_(0), 
                    this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), s = !0, 
                    0 === this._$_pingPongState$_ && (this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_)), 
                    1 === this._$_pingPongState$_ && (this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_)), 
                    this._$_pingPongState$_++, this._$_pingPongState$_ = m.wrap(this._$_pingPongState$_, 0, 2))) : 0 < this._$_playbackRate$_ ? this._$_playheadTime$_ >= a && (this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
                    this._$_SetTimeAndReset$_(0), this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), 
                    s = !0) : (this._$_SetTime$_(a), t = !0)) : this._$_playheadTime$_ <= 0 && (this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
                    this._$_SetTimeAndReset$_(a), this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
                    this._$_TweenTrigger$_(m._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), 
                    s = !0) : (this._$_SetTime$_(0), t = !0)), t ? (this._$_track$_._$SetEndState$_(), 
                    this._$Stop$_(!0), this._$OnCompleted$_()) : (this._$_track$_._$Interpolate$_(this._$_playheadTime$_, !0, !1, s, this._$_firstTick$_, !1), 
                    this._$_firstTick$_ && (this._$_firstTick$_ = !1));
                }
            }
        }
        _$_TweenTrigger$_(t) {
            const s = this._$GetInstance$_(), i = s._$GetBehaviorSdkInstanceFromCtor$_(m._$Behaviors$_._$Tween$_);
            i._$PushTriggerTween$_(this), this._$_runtime$_._$Trigger$_(t, s, i._$GetBehaviorType$_()), 
            i._$PopTriggerTween$_();
        }
        _$_SaveToJson$_() {
            const t = super._$_SaveToJson$_(), s = this._$GetTimelineDataItem$_();
            return Object.assign(t, {
                tweenDataItemJson: s._$_SaveToJson$_(),
                id: this._$_id$_,
                destroyInstanceOnComplete: this._$_destroyInstanceOnComplete$_,
                initialValueMode: this._$_initialValueMode$_
            });
        }
        _$_LoadFromJson$_(t) {
            if (t) {
                const s = this._$GetTimelineDataItem$_();
                s._$_LoadFromJson$_(t.tweenDataItemJson), super._$_LoadFromJson$_(t), 
                this._$_id$_ = t.id, this._$_destroyInstanceOnComplete$_ = t.destroyInstanceOnComplete, 
                this._$_initialValueMode$_ = t.initialValueMode, this._$_CacheTrack$_();
            }
        }
        static IsPlaying(t) {
            return t.IsPlaying();
        }
        static _$IsPaused$_(t) {
            return t._$IsPaused$_();
        }
        static _$IsPing$_(t) {
            return !!t._$GetPingPong$_() && 0 === t._$GetPingPongState$_();
        }
        static _$IsPong$_(t) {
            return !!t._$GetPingPong$_() && 1 === t._$GetPingPongState$_();
        }
        static _$Build$_(t) {
            const s = t.runtime._$GetTimelineManager$_(), i = new m._$TimelineDataItem$_();
            if (t.json) {
                i._$_LoadFromJson$_(t.json.tweenDataItemJson);
                const e = new m._$TweenState$_(i, s);
                return e._$_LoadFromJson$_(t.json), e;
            }
            {
                const h = new m._$TweenState$_(i, s), r = (m._$IsArray$_(t._$propertyTracksConfig$_) || (t._$propertyTracksConfig$_ = [ t._$propertyTracksConfig$_ ]), 
                h._$SetId$_(t.id), h._$SetTags$_(t.tags), h._$SetInitialValueMode$_(t.initialValueMode), 
                h._$SetDestroyInstanceOnComplete$_(t._$releaseOnComplete$_), h._$SetLoop$_(t.loop), 
                h._$SetPingPong$_(t.pingPong), h._$SetTotalTime$_(t.time), h._$SetStep$_(0), 
                h._$SetInterpolationMode$_("default"), h._$SetResultMode$_(t._$propertyTracksConfig$_[0].resultMode), 
                h._$SetRepeatCount$_(t.repeatCount), h._$AddTrack$_()), n = (r._$SetInstanceUID$_(t._$instance$_._$GetUID$_()), 
                r._$SetInterpolationMode$_("default"), r._$SetResultMode$_(t._$propertyTracksConfig$_[0].resultMode), 
                r._$SetEnable$_(!0), r._$SetObjectClassIndex$_(t._$instance$_._$GetObjectClass$_()._$GetIndex$_()), 
                t._$instance$_._$GetSdkInstance$_()), o = n._$IsOriginalSizeKnown$_() ? n._$GetOriginalWidth$_() : t._$instance$_._$GetWorldInfo$_()._$GetWidth$_(), a = n._$IsOriginalSizeKnown$_() ? n._$GetOriginalHeight$_() : t._$instance$_._$GetWorldInfo$_()._$GetHeight$_(), l = (r._$SetOriginalWidth$_(o), 
                r._$SetOriginalHeight$_(a), r._$AddKeyframe$_()), u = (l._$SetTime$_(0), 
                l._$SetEase$_("noease"), l._$SetEnable$_(!0), l._$SetTags$_(""), 
                r._$AddKeyframe$_());
                u._$SetTime$_(t.time), u._$SetEase$_("noease"), u._$SetEnable$_(!0), 
                u._$SetTags$_("");
                for (const c of t._$propertyTracksConfig$_) {
                    const f = r._$AddPropertyTrack$_(), d = (f._$SetSourceAdapterId$_(c._$sourceId$_), 
                    f._$SetSourceAdapterArgs$_(c._$sourceArgs$_), f._$SetPropertyName$_(c.property), 
                    f._$SetPropertyType$_(c.type), f._$SetMin$_(NaN), f._$SetMax$_(NaN), 
                    f._$SetInterpolationMode$_("default"), f._$SetResultMode$_(c.resultMode), 
                    f._$SetEnable$_(!0), f._$AddPropertyKeyframe$_()), p = (d._$SetType$_(c.valueType), 
                    d._$SetTime$_(0), d._$SetEase$_(c.ease), d._$SetEnable$_(!0), 
                    d._$SetValue$_(c._$startValue$_), d._$SetAbsoluteValue$_(c._$startValue$_), 
                    f._$AddPropertyKeyframe$_());
                    p._$SetType$_(c.valueType), p._$SetTime$_(t.time), p._$SetEase$_(c.ease), 
                    p._$SetEnable$_(!0), p._$SetValue$_(c._$endValue$_), p._$SetAbsoluteValue$_(c._$endValue$_), 
                    f._$GetSourceAdapter$_();
                }
                return h;
            }
        }
        static _$SetInstanceUID$_(t, s) {
            if (!isNaN(s)) for (const i of t._$GetTracks$_()) i._$SetInstanceUID$_(s);
        }
        _$GetITweenState$_(t, s) {
            return this._$_iTweenState$_ || (this._$_iTweenState$_ = m._$New$_(self._$ITweenState$_, this, t, s)), 
            this._$_iTweenState$_;
        }
    };
}

{
    const Zn = self._$C3$_;
    Zn._$TweenTrackState$_ = class extends Zn._$TrackState$_ {
        constructor(t, s) {
            super(t, s), this._$_firstPropertyTrack$_ = null, this._$_secondPropertyTrack$_ = null;
        }
        static _$Create$_(t, s) {
            return Zn._$New$_(Zn._$TweenTrackState$_, t, s);
        }
        _$_CachePropertyTracks$_() {
            1 === this._$_propertyTracks$_.length ? this._$_firstPropertyTrack$_ = this._$_propertyTracks$_[0] : (this._$_firstPropertyTrack$_ = this._$_propertyTracks$_[0], 
            this._$_secondPropertyTrack$_ = this._$_propertyTracks$_[1]);
        }
        _$CreatePropertyTrackStates$_() {
            for (const t of this._$_trackDataItem$_._$GetPropertyTrackData$_()._$propertyTrackDataItems$_()) this._$_propertyTracks$_.push(Zn._$TweenPropertyTrackState$_._$Create$_(this, t));
            this._$_CachePropertyTracks$_();
        }
        _$AddPropertyTrack$_() {
            const t = this._$_trackDataItem$_._$GetPropertyTrackData$_(), s = t._$AddEmptyPropertyTrackDataItem$_(), i = Zn._$TweenPropertyTrackState$_._$Create$_(this, s);
            return this._$_propertyTracks$_.push(i), this._$_CachePropertyTracks$_(), 
            i;
        }
        _$SetInitialState$_() {
            if (this._$MaybeGetInstance$_(), this._$IsInstanceValid$_() || !this._$IsInstanceTrack$_()) {
                const t = this._$GetTimeline$_(), s = t._$IsForwardPlayBack$_(), i = s ? 0 : this._$GetLocalTotalTime$_();
                for (const h of this._$_propertyTracks$_) h._$SetInitialState$_(i), 
                0 === this._$_worldInfoChange$_ && 1 === h._$GetWorldInfoChange$_() && (this._$_worldInfoChange$_ = 1), 
                0 === this._$_renderChange$_ && 1 === h._$GetRenderChange$_() && (this._$_renderChange$_ = 1);
                this._$_needsBeforeAndAfter$_ = 0;
                const e = this._$_propertyTracks$_.some(t => t._$GetNeedsBeforeAndAfter$_());
                e && (this._$_needsBeforeAndAfter$_ = 1), this._$_lastKeyframeDataItem$_ = this._$_GetLastKeyFrameBeforeTime$_(i), 
                this._$_initialStateOfNestedSet$_ = !1, this._$_endStateOfNestedSet$_ = !1, 
                this._$Interpolate$_(i);
            }
        }
        _$BeforeInterpolate$_() {}
        _$Interpolate$_(t, s = 0, i = !1, e = !1, h, r = !1, n = !1) {
            if (this._$_instance$_ || this._$GetInstance$_(), this._$_instance$_) {
                const o = !this._$_instance$_._$IsDestroyed$_();
                return o ? (!r || !this._$GetObjectClass$_()._$IsGlobal$_()) && ((this._$_secondPropertyTrack$_ ? (this._$_firstPropertyTrack$_._$Interpolate$_(t, i, e, n), 
                this._$_secondPropertyTrack$_) : this._$_firstPropertyTrack$_)._$Interpolate$_(t, i, e, n), 
                void (0 !== this._$_firstPropertyTrack$_._$GetWorldInfoChange$_() && (this._$_worldInfo$_ || (this._$_worldInfo$_ = this._$_instance$_._$GetWorldInfo$_()), 
                this._$_worldInfo$_) && this._$_worldInfo$_._$SetBboxChanged$_())) : !1;
            }
        }
        _$AfterInterpolate$_() {}
        _$_LoadFromJson$_(t) {
            super._$_LoadFromJson$_(t), this._$_CachePropertyTracks$_();
        }
    };
}

{
    const Qn = self._$C3$_;
    Qn._$TweenPropertyTrackState$_ = class extends Qn._$PropertyTrackState$_ {
        constructor(t, s) {
            super(t, s), this._$_basic$_ = !1;
        }
        static _$Create$_(t, s) {
            return Qn._$New$_(Qn._$TweenPropertyTrackState$_, t, s);
        }
        _$Interpolate$_(t, s = !1, i = !1, e = !1) {
            let h, r;
            if (this._$_basic$_) h = this._$_propertyKeyframeDataItems$_[0], r = this._$_propertyKeyframeDataItems$_[1]; else {
                if (s) h = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_); else {
                    if (this._$_lastPropertyKeyframeDataItem$_) {
                        const n = this._$GetTimeline$_(), o = this._$_lastPropertyKeyframeDataItem$_._$GetNext$_(), a = this._$_lastPropertyKeyframeDataItem$_._$GetTime$_(), l = o ? o._$GetTime$_() : n._$GetTotalTime$_();
                        (t <= a || l <= t) && (this._$_lastPropertyKeyframeDataItem$_ = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_));
                    } else this._$_lastPropertyKeyframeDataItem$_ = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_);
                    h = this._$_lastPropertyKeyframeDataItem$_;
                }
                r = h._$GetNext$_();
            }
            this._$_sourceAdapter$_._$Interpolate$_(t, h, r, s, i, e);
        }
        _$AddPropertyKeyframe$_() {
            const t = this._$_propertyTrackDataItem$_._$GetPropertyKeyframeData$_(), s = t._$AddEmptyPropertyKeyframeDataItem$_();
            return this._$_lastPropertyKeyframeDataItem$_ = null, this._$_basic$_ = this._$GetPropertyKeyframeDataItems$_().length <= 2, 
            s;
        }
        _$DeletePropertyKeyframes$_(t) {
            this._$_lastPropertyKeyframeDataItem$_ = null;
            const s = this._$_propertyTrackDataItem$_._$GetPropertyKeyframeData$_();
            s._$DeletePropertyKeyframeDataItems$_(t), this._$_basic$_ = this._$GetPropertyKeyframeDataItems$_().length <= 2;
        }
        _$_SaveToJson$_() {
            return {
                sourceAdapterJson: this._$GetSourceAdapter$_()._$_SaveToJson$_(),
                basic: this._$_basic$_
            };
        }
        _$_LoadFromJson$_(t) {
            t && (this._$GetSourceAdapter$_()._$_LoadFromJson$_(t.sourceAdapterJson), 
            this._$_basic$_ = t.basic);
        }
    };
}

{
    const to = self._$C3$_, so = self._$Ease$_;
    to._$Transition$_ = class extends to._$DefendedBase$_ {
        constructor(t, s = !0) {
            super(), this._$_name$_ = t[0], this._$_linear$_ = t[2], this._$_transitionKeyframes$_ = [];
            for (const i of t[1]) {
                const e = to._$TransitionKeyframe$_._$Create$_(this, i);
                this._$_transitionKeyframes$_.push(e);
            }
            for (let t = 0; t < this._$_transitionKeyframes$_.length; t++) {
                const h = this._$_transitionKeyframes$_[t], r = this._$_transitionKeyframes$_[t + 1], n = this._$_transitionKeyframes$_[t - 1];
                h._$SetNext$_(r), h._$SetPrevious$_(n);
            }
            this._$_precalculatedSamples$_ = new Map(), this._$_transitionKeyframeCache$_ = new Map(), 
            this._$_PreCalcSamples$_(), s && so._$AddCustomEase$_(this._$_name$_, (t, s, i, e) => this._$Interpolate$_(t, s, i, e), null, {
                transition: this
            });
        }
        static _$Create$_(t) {
            return to._$New$_(to._$Transition$_, t);
        }
        _$Release$_() {
            for (const t of this._$_transitionKeyframes$_) t._$Release$_();
            to._$clearArray$_(this._$_transitionKeyframes$_), this._$_transitionKeyframes$_ = null, 
            this._$_precalculatedSamples$_.clear(), this._$_precalculatedSamples$_ = null, 
            this._$_transitionKeyframeCache$_.clear(), this._$_transitionKeyframeCache$_ = null;
        }
        _$MakeLinear$_(t) {
            this._$_linear$_ = !!t;
        }
        _$GetTransitionKeyFrameAt$_(t) {
            const s = this._$_transitionKeyframeCache$_.get(t);
            if (s) return s;
            for (const i of this._$_transitionKeyframes$_) if (i._$GetValueX$_() === t) return this._$_transitionKeyframeCache$_.set(t, i), 
            i;
        }
        _$GetFirstTransitionKeyFrameLowerOrEqualThan$_(s) {
            for (let t = this._$_transitionKeyframes$_.length - 1; 0 <= t; t--) {
                const i = this._$_transitionKeyframes$_[t], e = i._$GetValueX$_();
                if (e <= s) {
                    let t = i;
                    if (e < s) return t;
                    if (e === s) {
                        for (;t; ) {
                            const h = t._$GetPrevious$_();
                            if (!h) break;
                            if (h._$GetValueX$_() !== t._$GetValueX$_()) break;
                            t = h;
                        }
                        return t;
                    }
                }
            }
        }
        _$Interpolate$_(t, s, i, e) {
            let h = t / e;
            if (this._$_linear$_) {
                const w = this._$GetTransitionKeyFrameAt$_(0), S = this._$GetTransitionKeyFrameAt$_(1), b = s + (s + i) * w._$GetValueY$_(), M = (s + i) * S._$GetValueY$_(), v = M - b;
                return 0 === e ? b + v : so._$NoEase$_(t, b, v, e);
            }
            0 === e && (h = 1);
            let r = this._$GetFirstTransitionKeyFrameLowerOrEqualThan$_(h), n = r._$GetNext$_();
            if (!n) {
                const x = r._$GetPrevious$_(), G = r;
                r = x, n = G;
            }
            const o = n._$GetValueX$_() - r._$GetValueX$_(), a = to._$mapToRange$_(h, r._$GetValueX$_(), n._$GetValueX$_(), 0, o);
            if (r._$IsSegmentLinear$_() || 0 == o) {
                const T = s + (s + i) * r._$GetValueY$_(), _ = (s + i) * n._$GetValueY$_(), I = _ - T;
                return 0 == o ? 1 === a ? T + I : T : so._$NoEase$_(a, T, I, o);
            }
            let l = r._$GetValueX$_(), u = r._$GetValueY$_(), c = r._$GetValueX$_() + r._$GetStartAnchorX$_(), f = r._$GetValueY$_() + r._$GetStartAnchorY$_(), d = n._$GetValueX$_() + n._$GetEndAnchorX$_(), p = n._$GetValueY$_() + n._$GetEndAnchorY$_(), m = n._$GetValueX$_(), g = n._$GetValueY$_(), y = so._$GetRuntimeEase$_("spline")(a, l, u, c, f, d, p, m, g, this._$_precalculatedSamples$_.get(r));
            return (1 - (y += r._$GetValueY$_())) * s + y * (s + i);
        }
        _$_PreCalcSamples$_() {
            this._$_precalculatedSamples$_.clear();
            for (let t = 0; t < this._$_transitionKeyframes$_.length - 1; t++) {
                const s = this._$_transitionKeyframes$_[t];
                if (s._$GetStartEnable$_()) {
                    const i = s, e = this._$_transitionKeyframes$_[t + 1];
                    if (e._$GetEndEnable$_()) {
                        const h = i._$GetValueX$_(), r = i._$GetValueX$_() + i._$GetStartAnchorX$_(), n = e._$GetValueX$_() + e._$GetEndAnchorX$_(), o = e._$GetValueX$_();
                        this._$_precalculatedSamples$_.set(i, so._$GetBezierSamples$_(h, r, n, o));
                    }
                }
            }
        }
    };
}

{
    const io = self._$C3$_;
    io._$TransitionKeyframe$_ = class extends io._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_transition$_ = t, this._$_valueX$_ = s[0], this._$_valueY$_ = s[1], 
            this._$_startAnchorX$_ = s[2], this._$_startAnchorY$_ = s[3], this._$_endAnchorX$_ = s[4], 
            this._$_endAnchorY$_ = s[5], this._$_startEnable$_ = s[6], this._$_endEnable$_ = s[7], 
            this._$_segmentMode$_ = s[8], this._$_next$_ = null, this._$_prev$_ = null;
        }
        _$Release$_() {
            this._$_transition$_ = null;
        }
        static _$Create$_(t, s) {
            return io._$New$_(io._$TransitionKeyframe$_, t, s);
        }
        _$SetNext$_(t) {
            this._$_next$_ = t;
        }
        _$GetNext$_() {
            return this._$_next$_;
        }
        _$SetPrevious$_(t) {
            this._$_prev$_ = t;
        }
        _$GetPrevious$_() {
            return this._$_prev$_;
        }
        _$GetValueX$_() {
            return this._$_valueX$_;
        }
        _$GetValueY$_() {
            return this._$_valueY$_;
        }
        _$GetStartAnchorX$_() {
            return this._$_startAnchorX$_;
        }
        _$GetStartAnchorY$_() {
            return this._$_startAnchorY$_;
        }
        _$GetEndAnchorX$_() {
            return this._$_endAnchorX$_;
        }
        _$GetEndAnchorY$_() {
            return this._$_endAnchorY$_;
        }
        _$GetStartEnable$_() {
            return this._$_startEnable$_;
        }
        _$GetEndEnable$_() {
            return this._$_endEnable$_;
        }
        _$IsSegmentLinear$_() {
            return "linear" === this._$_segmentMode$_;
        }
        _$IsSegmentCubic$_() {
            return "cubic" === this._$_segmentMode$_;
        }
    };
}

{
    const eo = self._$C3$_;
    eo._$TransitionManager$_ = class extends eo._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_runtime$_ = t, this._$_transitions$_ = [];
        }
        _$Release$_() {
            for (const t of this._$_transitions$_) t._$Release$_();
            eo._$clearArray$_(this._$_transitions$_), this._$_transitions$_ = null;
        }
        _$Create$_(t) {
            this._$_transitions$_.push(eo._$Transition$_._$Create$_(t));
        }
    };
}

{
    const ho = self._$C3$_;
    ho._$TemplateManager$_ = class extends ho._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_runtime$_ = t, this._$_templateDataMap$_ = null, this._$_instanceToTemplateNameMap$_ = null, 
            this._$_instanceDestroy$_ = t => this._$_OnInstanceDestroy$_(t._$instance$_);
        }
        _$Release$_() {
            if (this._$RemoveRuntimeListeners$_(), this._$_templateDataMap$_) {
                for (const t of this._$_templateDataMap$_.values()) t.clear();
                this._$_templateDataMap$_.clear();
            }
            this._$_templateDataMap$_ = null, this._$_runtime$_ = null;
        }
        _$Create$_(t) {
            if (this._$_templateDataMap$_ || (this._$_templateDataMap$_ = new Map()), 
            t) {
                const s = t[0][16], i = s[0], e = t[1], h = (this._$_templateDataMap$_.has(e) || this._$_templateDataMap$_.set(e, new Map()), 
                this._$_templateDataMap$_.get(e));
                h.set(i, t);
            }
        }
        _$AddRuntimeListeners$_() {
            const t = this._$_runtime$_._$Dispatcher$_();
            t && t.addEventListener("instancedestroy", this._$_instanceDestroy$_);
        }
        _$RemoveRuntimeListeners$_() {
            const t = this._$_runtime$_._$Dispatcher$_();
            t && t.removeEventListener("instancedestroy", this._$_instanceDestroy$_);
        }
        _$HasTemplates$_() {
            return !!this._$_templateDataMap$_ && 0 !== this._$_templateDataMap$_.size;
        }
        _$GetTemplateData$_(t, s) {
            let i = 0;
            if (i = t instanceof ho._$ObjectClass$_ ? t._$GetIndex$_() : t, this._$_templateDataMap$_.has(i)) {
                const e = this._$_templateDataMap$_.get(i).get(s);
                return e ? JSON.parse(JSON.stringify(e)) : void 0;
            }
        }
        _$MapInstanceToTemplateName$_(t, s) {
            this._$_instanceToTemplateNameMap$_ || (this._$_instanceToTemplateNameMap$_ = new WeakMap()), 
            this._$_instanceToTemplateNameMap$_.has(t) || this._$_instanceToTemplateNameMap$_.set(t, s);
        }
        _$GetInstanceTemplateName$_(t) {
            if (!this._$_instanceToTemplateNameMap$_) return "";
            const s = this._$_instanceToTemplateNameMap$_.get(t);
            return s || "";
        }
        _$_OnInstanceDestroy$_(t) {
            this._$_instanceToTemplateNameMap$_ && this._$_instanceToTemplateNameMap$_.has(t) && this._$_instanceToTemplateNameMap$_.delete(t);
        }
    };
}

{
    const ro = self._$C3$_;
    ro._$FlowchartManager$_ = class {
        constructor(t) {
            this._$_runtime$_ = t, this._$_flowchartDataManager$_ = new ro._$FlowchartDataManager$_();
        }
        _$Release$_() {
            this._$_flowchartDataManager$_._$Release$_(), this._$_flowchartDataManager$_ = null, 
            this._$_runtime$_ = null;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$Create$_(t) {
            this._$_flowchartDataManager$_._$Add$_(t);
        }
        _$GetFlowchartDataItemByName$_(t) {
            return this._$_flowchartDataManager$_._$Get$_(t);
        }
        _$HasFlowcharts$_() {
            return this._$_flowchartDataManager$_._$HasFlowcharts$_();
        }
    };
}

{
    const no = self._$C3$_;
    no._$FlowchartState$_ = class {
        constructor(t, s, i, e, h, r, n) {
            this._$_runtime$_ = h._$GetRuntime$_(), this._$_flowchartManager$_ = h, 
            this._$_flowchartName$_ = t, this._$_startNodeTag$_ = i, this._$_flowchartDataItem$_ = e, 
            this._$_tag$_ = s, this._$_pluginInstance$_ = r, this._$_pluginUID$_ = n ?? r._$GetInstance$_()._$GetUID$_(), 
            this._$_SetStartFlowchartNode$_(), this._$_currentFlowchartNodeId$_ = this._$_startFlowchartNode$_?._$GetFlowchartId$_() ?? -1, 
            this._$_previousFlowchartNodeIds$_ = [], this._$_previousFlowchartState$_ = null, 
            this._$_previousFlowchartStateStartNodeId$_ = NaN, this._$_referenceFlowchartStates$_ = null, 
            this._$_currentReferenceFlowchartState$_ = null, this._$_rootFlowchartState$_ = null, 
            this._$_previousFlowchartStateTag$_ = "", this._$_referenceFlowchartStatesJson$_ = null, 
            this._$_currentReferenceFlowchartStateTag$_ = "", this._$_rootFlowchartStateTag$_ = "", 
            this._$_triggerCount$_ = 0, this._$_markForRelease$_ = !1, this._$_released$_ = !1;
        }
        _$Release$_() {
            this._$_released$_ || (no._$clearArray$_(this._$_previousFlowchartNodeIds$_), 
            this._$_previousFlowchartNodeIds$_ = null, this._$_runtime$_ = null, 
            this._$_flowchartManager$_ = null, this._$_flowchartDataItem$_ = null, 
            this._$_pluginInstance$_ = null, this._$_previousFlowchartState$_ = null, 
            this._$_previousFlowchartStateStartNodeId$_ = NaN, this._$_referenceFlowchartStates$_ && this._$_referenceFlowchartStates$_.clear(), 
            this._$_referenceFlowchartStates$_ = null, this._$_currentReferenceFlowchartState$_ = null, 
            this._$_rootFlowchartState$_ = null, this._$_previousFlowchartStateTag$_ = "", 
            this._$_referenceFlowchartStatesJson$_ = null, this._$_currentReferenceFlowchartStateTag$_ = "", 
            this._$_rootFlowchartStateTag$_ = "", this._$_released$_ = !0);
        }
        _$WasReleased$_() {
            return this._$_released$_;
        }
        _$GetFlowchartManager$_() {
            return this._$_flowchartManager$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetName$_() {
            return this._$_flowchartName$_;
        }
        _$GetFlowchartDataItem$_() {
            return this._$_flowchartDataItem$_;
        }
        _$GetTag$_() {
            return this._$_tag$_;
        }
        _$GetPluginInstance$_() {
            return this._$_pluginInstance$_ || (this._$_pluginInstance$_ = this._$_runtime$_._$GetInstanceByUID$_(this._$_pluginUID$_)._$GetSdkInstance$_()), 
            this._$_pluginInstance$_;
        }
        _$GetCurrentNode$_() {
            return this._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_);
        }
        _$GetCurrentNodeTag$_() {
            const t = this._$GetCurrentNode$_();
            return t ? t._$GetTag$_() : "";
        }
        _$GetCurrentNodeParent$_(t) {
            const s = this._$GetCurrentNode$_();
            if (s) {
                if (no._$IsFiniteNumber$_(t)) {
                    const i = s._$GetParentFlowchartIds$_(), e = i ? i[t] : void 0;
                    if (no._$IsFiniteNumber$_(e)) return this._$GetFlowchartElementById$_(e);
                }
                if ("string" == typeof t) for (const h of s._$GetParentFlowchartIds$_()) {
                    const r = this._$GetFlowchartElementById$_(h);
                    if (r._$GetTag$_() === t) return this._$GetFlowchartElementById$_(r._$GetFlowchartId$_());
                }
            }
        }
        _$GetCurrentNodeParentTag$_(t) {
            const s = this._$GetCurrentNodeParent$_(t);
            return s ? s._$GetTag$_() : "";
        }
        _$GetCurrentNodeParentIndex$_(t) {
            const s = this._$GetCurrentNodeParent$_(t);
            if (!s) return -1;
            const i = s._$GetParentFlowchartIds$_();
            return i ? i.indexOf(s._$GetFlowchartId$_()) : -1;
        }
        _$GetCurrentNodeParentCount$_() {
            const t = this._$GetCurrentNode$_();
            if (!t) return 0;
            const s = t._$GetParentFlowchartIds$_();
            return s ? s.length : 0;
        }
        _$GetFlowchartElementById$_(t) {
            return this._$_flowchartDataItem$_._$GetFlowchartElementById$_(t);
        }
        _$Reset$_() {
            const t = this._$_GetRootFlowchartState$_();
            t._$_Reset$_(!0);
        }
        _$_Reset$_(t) {
            if (this._$_GetReferenceFlowchartStates$_()) {
                for (const [ s, i ] of this._$_GetReferenceFlowchartStates$_().entries()) i._$_Reset$_(!1);
                this._$_GetReferenceFlowchartStates$_().clear();
            }
            if (this._$_referenceFlowchartStates$_ = null, this._$_previousFlowchartState$_ = null, 
            this._$_previousFlowchartStateStartNode$_ = null, this._$_currentReferenceFlowchartState$_ = null, 
            this._$_previousFlowchartStateTag$_ = "", this._$_referenceFlowchartStatesJson$_ = null, 
            this._$_currentReferenceFlowchartStateTag$_ = "", this._$_rootFlowchartStateTag$_ = "", 
            this._$_previousFlowchartNodeIds$_ = [], t) {
                this._$_flowchartManager$_._$SetCurrentFlowchartState$_(this);
                const e = this._$_startFlowchartNode$_._$GetFlowchartId$_();
                e !== this._$_currentFlowchartNodeId$_ && this._$_GotoFlowchartNode$_(e);
            } else this._$_currentFlowchartNodeId$_ = this._$_startFlowchartNode$_._$GetFlowchartId$_();
        }
        _$GetCurrentNodeOutputCount$_() {
            const t = this._$_flowchartDataItem$_._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_);
            return t ? t._$GetFlowchartNodeOutputData$_()._$GetFlowchartNodeOutputDataItemCount$_() : 0;
        }
        _$GetCurrentNodeOutputNameAt$_(t) {
            const s = this._$_GetFlowchartNodeOutputAt$_(t);
            return s ? s._$GetName$_() : "";
        }
        _$GetCurrentNodeOutputValueAt$_(t) {
            let s;
            return no._$IsFiniteNumber$_(t) && (s = this._$_GetFlowchartNodeOutputAt$_(t)), 
            "string" == typeof t && (s = this._$_GetFlowchartNodeOutputByName$_(t)), 
            "number" != typeof t && "string" != typeof t && console.warn("[Flowcharts] unexpected argument type in GetCurrentNodeOutputValueAt expression"), 
            s ? s._$GetValue$_() : "";
        }
        _$GotoNextFlowchartNode$_(t) {
            let s;
            no._$IsFiniteNumber$_(t) && (s = this._$_GetFlowchartNodeOutputAt$_(t));
            const i = (s = "string" == typeof t ? this._$_GetFlowchartNodeOutputByName$_(t) : s)._$GetConnectedFlowchartNodeFlowchartId$_();
            no._$IsFiniteNumber$_(i) && (this._$_previousFlowchartNodeIds$_.push(this._$_currentFlowchartNodeId$_), 
            this._$_GotoFlowchartNode$_(i));
        }
        _$GotoAnyFlowchartNode$_(t) {
            const s = this._$_flowchartDataItem$_._$GetFlowchartNodeByTag$_(t);
            if (s) {
                const i = this._$_flowchartDataItem$_._$GetFlowchartElementById$_(s._$GetFlowchartId$_());
                i && (this._$_previousFlowchartNodeIds$_.push(this._$_currentFlowchartNodeId$_), 
                this._$_GotoFlowchartNode$_(i._$GetFlowchartId$_()));
            }
        }
        _$GotoPreviousFlowchartNode$_() {
            const t = this._$_previousFlowchartNodeIds$_.pop();
            no._$IsFiniteNumber$_(t) ? this._$_GotoFlowchartNode$_(t) : this._$_GetPreviousFlowchartState$_() && (this._$_flowchartManager$_._$SetCurrentFlowchartState$_(this._$_GetPreviousFlowchartState$_(), !0, !1, !1), 
            this._$_GetPreviousFlowchartState$_()._$_GotoFlowchartNode$_(this._$_GetPreviousFlowchartStateStartNodeId$_()), 
            this._$_GetRootFlowchartState$_()._$_SetCurrentReferenceFlowchart$_(this._$_GetPreviousFlowchartState$_()));
        }
        _$GotoParentFlowchartNode$_(t) {
            const s = this._$GetCurrentNode$_();
            if (s) {
                s._$GetFlowchartId$_();
                const i = this._$GetCurrentNodeParent$_(t);
                i && (this._$_previousFlowchartNodeIds$_.push(this._$_currentFlowchartNodeId$_), 
                this._$_GotoFlowchartNode$_(i._$GetFlowchartId$_()));
            }
        }
        _$HasOutput$_(s) {
            if (no._$IsFiniteNumber$_(s)) {
                const t = this._$_flowchartDataItem$_._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_), i = t._$GetFlowchartNodeOutputData$_()._$GetFlowchartNodeOutputDataItems$_();
                return !!i[s];
            }
            if ("string" == typeof s) {
                const e = this._$_flowchartDataItem$_._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_), h = e._$GetFlowchartNodeOutputData$_()._$GetFlowchartNodeOutputDataItems$_();
                for (let t = 0; t < h.length; t++) if (h[t]._$GetName$_() === s) return !0;
            }
            return !1;
        }
        _$MarkForRelease$_() {
            this._$_markForRelease$_ = !0;
        }
        _$IsInTriggerState$_() {
            return 0 < this._$_triggerCount$_;
        }
        _$PushIsTriggerState$_() {
            this._$_triggerCount$_++;
        }
        _$PopIsTriggerState$_() {
            this._$_triggerCount$_--, 0 === this._$_triggerCount$_ && this._$_markForRelease$_ && this._$_flowchartManager$_._$RemoveFlowchartState$_(this);
        }
        _$_GotoFlowchartNode$_(t) {
            const i = this._$_currentFlowchartNodeId$_, s = this._$GetPluginInstance$_()._$GetInstance$_();
            if (this._$PushIsTriggerState$_(), this._$_flowchartManager$_._$PushFlowchartState$_(this), 
            this._$_runtime$_._$Trigger$_(no._$Plugins$_.Flowchart._$Cnds$_.OnBeforeAnyNodeChange, s), 
            this._$_runtime$_._$Trigger$_(no._$Plugins$_.Flowchart._$Cnds$_.OnBeforeTaggedNodeChange, s), 
            this._$_runtime$_._$Trigger$_(no._$Plugins$_.Flowchart._$Cnds$_.OnBeforeAnyNodeChangeInFlowchart, s), 
            this._$_runtime$_._$Trigger$_(no._$Plugins$_.Flowchart._$Cnds$_.OnBeforeTaggedNodeChangeInFlowchart, s), 
            this._$_currentFlowchartNodeId$_ = t, this._$_runtime$_._$Trigger$_(no._$Plugins$_.Flowchart._$Cnds$_.OnAnyNodeChange, s), 
            this._$_runtime$_._$Trigger$_(no._$Plugins$_.Flowchart._$Cnds$_.OnTaggedNodeChange, s), 
            this._$_runtime$_._$Trigger$_(no._$Plugins$_.Flowchart._$Cnds$_.OnAnyNodeChangeInFlowchart, s), 
            this._$_runtime$_._$Trigger$_(no._$Plugins$_.Flowchart._$Cnds$_.OnTaggedNodeChangeInFlowchart, s), 
            this._$_flowchartManager$_._$PopFlowchartState$_(), this._$PopIsTriggerState$_(), 
            !this._$WasReleased$_()) {
                const e = this._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_);
                if ("reference" === e._$GetType$_()) {
                    const h = e._$GetReferenceFlowchartName$_();
                    if (this._$_HasReferenceFlowchartState$_(e)) {
                        this._$_previousFlowchartNodeIds$_.pop();
                        const r = this._$_GetReferenceFlowchartState$_(e), n = (this._$_flowchartManager$_._$SetCurrentFlowchartState$_(r, !0, !0, !1), 
                        r._$_SetPreviousFlowchart$_(this, i), this._$_GetRootFlowchartState$_());
                        n._$_SetCurrentReferenceFlowchart$_(r);
                    } else {
                        const o = e._$GetReferenceFlowchartStartNodeTag$_();
                        if (h) {
                            this._$_previousFlowchartNodeIds$_.pop();
                            let s = e._$GetReferenceFlowchartTag$_();
                            if (s) {
                                let t = this._$_flowchartManager$_._$GetFlowchartState$_(s);
                                for (;t; ) s = no._$IncrementNumberAtEndOf$_(s), 
                                t = this._$_flowchartManager$_._$GetFlowchartState$_(s);
                            } else {
                                s = h + "-ref";
                                let t = this._$_flowchartManager$_._$GetFlowchartState$_(s);
                                for (;t; ) s = no._$IncrementNumberAtEndOf$_(s), 
                                t = this._$_flowchartManager$_._$GetFlowchartState$_(s);
                            }
                            const a = this._$_flowchartManager$_._$AddFlowchartState$_(h, o, s, this._$_pluginInstance$_, !0), l = (a._$_SetPreviousFlowchart$_(this, i), 
                            this._$_SetReferenceFlowchartState$_(e, a), this._$_GetRootFlowchartState$_());
                            a._$_SetRootFlowchartState$_(l), l._$_SetCurrentReferenceFlowchart$_(a);
                        }
                    }
                }
            }
        }
        _$_GetFlowchartNodeOutputAt$_(t) {
            const s = this._$_flowchartDataItem$_._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_);
            if (!s) return null;
            const i = s._$GetFlowchartNodeOutputData$_()._$GetFlowchartNodeOutputDataItems$_();
            if (!i) return null;
            const e = i[t];
            return e || null;
        }
        _$_GetFlowchartNodeOutputByName$_(t) {
            const s = this._$_flowchartDataItem$_._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_);
            if (!s) return null;
            const i = s._$GetFlowchartNodeOutputData$_()._$GetFlowchartNodeOutputDataItemByName$_(t);
            return i || null;
        }
        _$_SetStartFlowchartNode$_(s) {
            if ("number" == typeof s) {
                let t = this._$GetFlowchartElementById$_(s);
                t = t || this._$_flowchartDataItem$_._$GetFlowchartStartNode$_(), 
                this._$_startFlowchartNode$_ = t;
            } else {
                let t = this._$_flowchartDataItem$_._$GetFlowchartNodeByTag$_(this._$_startNodeTag$_);
                t = t || this._$_flowchartDataItem$_._$GetFlowchartStartNode$_(), 
                this._$_startFlowchartNode$_ = t;
            }
        }
        _$_SaveToJson$_() {
            return this._$_markForRelease$_ ? null : {
                flowchartName: this._$_flowchartName$_,
                flowchartTag: this._$_tag$_,
                startNodeTag: this._$_startNodeTag$_,
                currentNodeId: this._$_currentFlowchartNodeId$_,
                previousNodeIds: this._$_previousFlowchartNodeIds$_,
                pluginUID: this._$_pluginInstance$_._$GetInstance$_()._$GetUID$_(),
                reference: {
                    previousFlowchartTag: this._$_GetPreviousFlowchartState$_() ? this._$_GetPreviousFlowchartState$_()._$GetTag$_() : "",
                    previousStartNodeId: no._$IsFiniteNumber$_(this._$_GetPreviousFlowchartStateStartNodeId$_()) ? this._$_GetPreviousFlowchartStateStartNodeId$_() : NaN,
                    referencesJson: this._$_GetFlowchartReferencesJson$_(),
                    currentReferenceFlowchartTag: this._$GetCurrentReferenceFlowchart$_() ? this._$GetCurrentReferenceFlowchart$_()._$GetTag$_() : "",
                    rootFlowchartTag: this._$_GetRootFlowchartState$_() ? this._$_GetRootFlowchartState$_()._$GetTag$_() : ""
                }
            };
        }
        _$_GetFlowchartReferencesJson$_() {
            if (!this._$_HasReferenceFlowchartStates$_()) return null;
            const t = [];
            for (const [ s, i ] of this._$_GetReferenceFlowchartStates$_().entries()) t.push({
                flowchartElementId: s._$GetFlowchartId$_(),
                flowchartStateTag: i._$GetTag$_()
            });
            return t.length ? t : null;
        }
        _$_LoadFromJson$_(t) {
            if (t) {
                if (this._$_flowchartName$_ = t.flowchartName, this._$_tag$_ = t.flowchartTag, 
                this._$_startNodeTag$_ = t.startNodeTag, this._$_currentFlowchartNodeId$_ = t.currentNodeId, 
                this._$_previousFlowchartNodeIds$_ = t.previousNodeIds, this._$_pluginUID$_ = t.pluginUID, 
                t.hasOwnProperty("reference")) {
                    const s = t.reference;
                    this._$_previousFlowchartStateTag$_ = s.previousFlowchartTag, 
                    this._$_previousFlowchartStateStartNodeId$_ = s.previousStartNodeId, 
                    this._$_referenceFlowchartStatesJson$_ = s.referencesJson, this._$_currentReferenceFlowchartStateTag$_ = s.currentReferenceFlowchartTag, 
                    this._$_rootFlowchartStateTag$_ = s.rootFlowchartTag;
                }
                this._$_SetStartFlowchartNode$_();
            }
        }
        _$_GetPreviousFlowchartState$_() {
            return "string" == typeof this._$_previousFlowchartStateTag$_ && this._$_previousFlowchartStateTag$_ && (this._$_previousFlowchartState$_ = this._$_flowchartManager$_._$GetFlowchartState$_(this._$_previousFlowchartStateTag$_), 
            this._$_previousFlowchartStateTag$_ = ""), this._$_previousFlowchartState$_;
        }
        _$_GetPreviousFlowchartStateStartNodeId$_() {
            return this._$_previousFlowchartStateStartNodeId$_;
        }
        _$_SetPreviousFlowchart$_(t, s) {
            this._$_previousFlowchartState$_ = t, this._$_previousFlowchartStateStartNodeId$_ = s;
        }
        _$GetCurrentReferenceFlowchart$_() {
            return "string" == typeof this._$_currentReferenceFlowchartStateTag$_ && this._$_currentReferenceFlowchartStateTag$_ && (this._$_currentReferenceFlowchartState$_ = this._$_flowchartManager$_._$GetFlowchartState$_(this._$_currentReferenceFlowchartStateTag$_), 
            this._$_currentReferenceFlowchartStateTag$_ = ""), this._$_currentReferenceFlowchartState$_;
        }
        _$_SetCurrentReferenceFlowchart$_(t) {
            this._$_currentReferenceFlowchartState$_ = t, this._$_currentReferenceFlowchartState$_ === this && (this._$_currentReferenceFlowchartState$_ = null);
        }
        _$_GetRootFlowchartState$_() {
            return "string" == typeof this._$_rootFlowchartStateTag$_ && this._$_rootFlowchartStateTag$_ && (this._$_rootFlowchartState$_ = this._$_flowchartManager$_._$GetFlowchartState$_(this._$_rootFlowchartStateTag$_), 
            this._$_rootFlowchartStateTag$_ = ""), this._$_rootFlowchartState$_ || this;
        }
        _$_SetRootFlowchartState$_(t) {
            this._$_rootFlowchartState$_ = t;
        }
        _$_HasReferenceFlowchartStates$_() {
            return this._$_RebuildReferenceFlowchartStates$_(), !!this._$_referenceFlowchartStates$_;
        }
        _$_HasReferenceFlowchartState$_(t) {
            return this._$_RebuildReferenceFlowchartStates$_(), this._$_referenceFlowchartStates$_ && this._$_referenceFlowchartStates$_.has(t);
        }
        _$_RebuildReferenceFlowchartStates$_() {
            if (this._$_referenceFlowchartStatesJson$_) {
                this._$_referenceFlowchartStates$_ && this._$_referenceFlowchartStates$_.clear(), 
                this._$_referenceFlowchartStates$_ || (this._$_referenceFlowchartStates$_ = new Map());
                for (const t of this._$_referenceFlowchartStatesJson$_) {
                    const s = this._$_flowchartManager$_._$GetFlowchartState$_(t.flowchartStateTag), i = s._$GetFlowchartElementById$_(t.flowchartElementId);
                    this._$_referenceFlowchartStates$_.set(i, s);
                }
                this._$_referenceFlowchartStatesJson$_ = null;
            }
        }
        _$_GetReferenceFlowchartStates$_() {
            return this._$_RebuildReferenceFlowchartStates$_(), this._$_referenceFlowchartStates$_;
        }
        _$_GetReferenceFlowchartState$_(t) {
            return this._$_RebuildReferenceFlowchartStates$_(), this._$_referenceFlowchartStates$_.get(t);
        }
        _$_SetReferenceFlowchartState$_(t, s) {
            this._$_referenceFlowchartStates$_ || (this._$_referenceFlowchartStates$_ = new Map()), 
            this._$_referenceFlowchartStates$_.set(t, s);
        }
    };
}

{
    const oo = self._$C3$_;
    oo._$FlowchartStateManager$_ = class {
        constructor(t) {
            this._$_runtime$_ = t, this._$_flowchartStates$_ = new Map(), this._$_currentFlowchartState$_ = null, 
            this._$_flowchartStateStack$_ = [], this._$_on_after_load$_ = () => this._$_OnAfterLoad$_(), 
            this._$_loadJson$_ = null;
        }
        _$Release$_() {
            oo._$clearArray$_(this._$_flowchartStateStack$_), this._$_flowchartStateStack$_ = null, 
            this._$_flowchartStates$_.clear(), this._$_flowchartStates$_ = null, 
            this._$_currentFlowchartState$_ = null, this._$_runtime$_ = null, this._$_loadJson$_ = null;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$AddFlowchartState$_(t, s, i, e, h, r) {
            const n = this._$_runtime$_._$GetFlowchartManager$_()._$GetFlowchartDataItemByName$_(t);
            if (n) {
                if (!this._$_flowchartStates$_.has(i)) {
                    const o = new oo._$FlowchartState$_(t, i, s, n, this, e, r);
                    return this._$_flowchartStates$_.set(i, o), h && this._$SetCurrentFlowchartState$_(o, !0), 
                    o;
                }
                console.warn(`[Flowcharts] there already is a flowchart with the tag '${i}'`);
            } else console.warn(`[Flowcharts] no flowchart found with name '${t}'`);
        }
        _$RemoveFlowchartState$_(t) {
            if (t._$MarkForRelease$_(), !t._$IsInTriggerState$_()) {
                const s = t._$GetTag$_();
                this._$_flowchartStates$_.delete(s), t._$Release$_(), this._$_currentFlowchartState$_ === t && (this._$_currentFlowchartState$_ = null);
            }
        }
        _$ResetFlowchartState$_(t) {
            t._$Reset$_();
        }
        _$GetFlowchartState$_(t) {
            return this._$_flowchartStates$_.get(t);
        }
        _$PushFlowchartState$_(t) {
            this._$_flowchartStateStack$_.push(t);
        }
        _$PopFlowchartState$_() {
            this._$_flowchartStateStack$_.pop();
        }
        _$SetCurrentFlowchartState$_(t, s = !1, i = !1, e = !0) {
            if (e) {
                const h = t._$GetCurrentReferenceFlowchart$_();
                t = h || t;
            }
            t !== this._$_currentFlowchartState$_ && (this._$_TriggerBeforeFlowchartChange$_(), 
            this._$_TriggerAfterFlowchartChange$_(t, s, i));
        }
        _$GetCurrentFlowchartState$_(t) {
            return "string" == typeof t ? this._$GetFlowchartState$_(t) : this._$_flowchartStateStack$_.length ? this._$_flowchartStateStack$_[this._$_flowchartStateStack$_.length - 1] : this._$_currentFlowchartState$_;
        }
        _$_TriggerBeforeFlowchartChange$_() {
            if (this._$_currentFlowchartState$_ && !this._$_currentFlowchartState$_._$WasReleased$_()) {
                const t = this._$_currentFlowchartState$_._$GetPluginInstance$_()._$GetInstance$_();
                this._$_currentFlowchartState$_._$PushIsTriggerState$_(), this._$PushFlowchartState$_(this._$_currentFlowchartState$_), 
                this._$_runtime$_._$Trigger$_(oo._$Plugins$_.Flowchart._$Cnds$_.OnBeforeFlowchartChange, t), 
                this._$PopFlowchartState$_(), this._$_currentFlowchartState$_._$PopIsTriggerState$_();
            }
        }
        _$_TriggerAfterFlowchartChange$_(t, s = !1, i = !1) {
            if (this._$_currentFlowchartState$_ = t, this._$_currentFlowchartState$_ && !this._$_currentFlowchartState$_._$WasReleased$_()) {
                const e = this._$_currentFlowchartState$_._$GetPluginInstance$_()._$GetInstance$_();
                this._$_currentFlowchartState$_._$PushIsTriggerState$_(), this._$PushFlowchartState$_(this._$_currentFlowchartState$_), 
                this._$_runtime$_._$Trigger$_(oo._$Plugins$_.Flowchart._$Cnds$_.OnFlowchartChange, e), 
                !0 !== i && "number" != typeof i || this._$_currentFlowchartState$_._$_SetStartFlowchartNode$_(i), 
                s && (this._$_runtime$_._$Trigger$_(oo._$Plugins$_.Flowchart._$Cnds$_.OnAnyNodeChange, e), 
                this._$_runtime$_._$Trigger$_(oo._$Plugins$_.Flowchart._$Cnds$_.OnTaggedNodeChange, e)), 
                this._$PopFlowchartState$_(), this._$_currentFlowchartState$_._$PopIsTriggerState$_();
            }
        }
        _$_SaveToJson$_() {
            return {
                flowchartJsonObjects: [ ...this._$_flowchartStates$_.values() ].map(t => t._$_SaveToJson$_()),
                currentFlowchartTag: this._$_currentFlowchartState$_ ? this._$_currentFlowchartState$_._$GetTag$_() : null
            };
        }
        _$_LoadFromJson$_(t) {
            if (t) {
                this._$_loadJson$_ = t;
                const s = new Map();
                for (const i of this._$_loadJson$_.flowchartJsonObjects) {
                    const e = i.flowchartTag;
                    if (this._$_flowchartStates$_.has(e)) {
                        const h = this._$_flowchartStates$_.get(e);
                        h._$_LoadFromJson$_(i), s.set(e, h);
                    } else {
                        const r = this._$AddFlowchartState$_(i.flowchartName, i.startNodeTag, i.flowchartTag, null, !1, i.pluginUID);
                        r._$_LoadFromJson$_(i), s.set(i.flowchartTag, r);
                    }
                }
                for (const [ n, o ] of this._$_flowchartStates$_.entries()) s.has(n) || o._$Release$_();
                this._$_flowchartStates$_.clear(), this._$_flowchartStates$_ = s, 
                this._$_runtime$_._$IsLoadingState$_() ? this._$_runtime$_._$Dispatcher$_().addEventListener("afterload", this._$_on_after_load$_) : this._$_OnAfterLoad$_();
            }
        }
        _$_OnAfterLoad$_() {
            this._$_runtime$_._$Dispatcher$_().removeEventListener("afterload", this._$_on_after_load$_);
            const t = this._$_flowchartStates$_.get(this._$_loadJson$_.currentFlowchartTag);
            t && this._$SetCurrentFlowchartState$_(t, !0), this._$_loadJson$_ = null;
        }
    };
}

{
    const ao = self._$C3$_;
    ao._$FlowchartDataManager$_ = class {
        constructor() {
            this._$_flowchartDataItems$_ = new Map();
        }
        _$Release$_() {
            for (const t of this._$_flowchartDataItems$_.values()) t._$Release$_();
            this._$_flowchartDataItems$_.clear(), this._$_flowchartDataItems$_ = null;
        }
        _$Add$_(t) {
            const s = new ao._$FlowchartDataItem$_(t), i = s._$GetName$_();
            this._$_flowchartDataItems$_.set(i, s);
        }
        _$Get$_(t) {
            return this._$_flowchartDataItems$_.get(t);
        }
        _$HasFlowcharts$_() {
            return !!this._$_flowchartDataItems$_.size;
        }
        static _$CreateDataItems$_(t, s, i, e) {
            if (s) for (const h of s) {
                const r = new i(h, e);
                t.push(r);
            }
        }
    };
}

{
    const lo = self._$C3$_;
    lo._$FlowchartDataItem$_ = class {
        constructor(t) {
            this._$_name$_ = t[0], this._$_flowchartNodeData$_ = new lo._$FlowchartNodeData$_(t[1], this);
        }
        _$Release$_() {
            this._$_flowchartNodeData$_._$Release$_(), this._$_flowchartNodeData$_ = null;
        }
        _$GetFlowchartNodeData$_() {
            return this._$_flowchartNodeData$_;
        }
        _$GetFlowchartElementById$_(t) {
            return this._$_flowchartNodeData$_._$GetFlowchartElementById$_(t);
        }
        _$GetFlowchartNodeByTag$_(t) {
            return this._$_flowchartNodeData$_._$GetFlowchartNodeByTag$_(t);
        }
        _$GetFlowchartStartNode$_() {
            return this._$_flowchartNodeData$_._$GetFlowchartStartNode$_();
        }
        _$GetName$_() {
            return this._$_name$_;
        }
    };
}

{
    const uo = self._$C3$_;
    class co {
        constructor(t, s) {
            this._$_flowchartNodeData$_ = s, this._$_type$_ = t[7], this._$_flowchartId$_ = t[0], 
            this._$_tag$_ = t[1], this._$_parentFlowchartIds$_ = t[2], this._$_parentOutputFlowchartIds$_ = null, 
            this._$_childrenFlowchartIds$_ = null, "dictionary" === this._$_type$_ && (this._$_parentOutputFlowchartIds$_ = t[3], 
            this._$_childrenFlowchartIds$_ = t[4]), this._$_isStart$_ = t[6], this._$_referenceFlowchartName$_ = null, 
            this._$_referenceFlowchartStartNodeTag$_ = null, this._$_referenceFlowchartTag$_ = null, 
            "reference" === this._$_type$_ && (this._$_referenceFlowchartName$_ = t[8], 
            this._$_referenceFlowchartStartNodeTag$_ = t[9], this._$_referenceFlowchartTag$_ = t[10]), 
            this._$_flowchartNodeOutputData$_ = new uo._$FlowchartNodeOutputData$_(t[5], this);
        }
        _$Release$_() {
            this._$_flowchartNodeData$_ = null;
        }
        _$GetFlowchartNodeData$_() {
            return this._$_flowchartNodeData$_;
        }
        _$GetFlowchartNodeOutputData$_() {
            return this._$_flowchartNodeOutputData$_;
        }
        _$GetFlowchartId$_() {
            return this._$_flowchartId$_;
        }
        _$GetTag$_() {
            return this._$_tag$_;
        }
        _$GetIsStart$_() {
            return this._$_isStart$_;
        }
        _$GetParentFlowchartIds$_() {
            return this._$_parentFlowchartIds$_;
        }
        _$GetParentOutputFlowchartIds$_() {
            return this._$_parentOutputFlowchartIds$_;
        }
        _$GetChildrenFlowchartIds$_() {
            return this._$_childrenFlowchartIds$_;
        }
        _$GetType$_() {
            return this._$_type$_;
        }
        _$GetReferenceFlowchartName$_() {
            return this._$_referenceFlowchartName$_;
        }
        _$GetReferenceFlowchartStartNodeTag$_() {
            return this._$_referenceFlowchartStartNodeTag$_;
        }
        _$GetReferenceFlowchartTag$_() {
            return this._$_referenceFlowchartTag$_;
        }
    }
    uo._$FlowchartNodeData$_ = class {
        constructor(t, s) {
            this._$_flowchartDataItem$_ = s, this._$_flowchartNodeItems$_ = [], 
            this._$_flowchartNodeItemsIdMap$_ = new Map(), this._$_flowchartNodeItemsTagMap$_ = new Map(), 
            this._$_flowchartNodeStartItem$_ = null, uo._$FlowchartDataManager$_._$CreateDataItems$_(this._$_flowchartNodeItems$_, t, co, this);
            for (const i of this._$_flowchartNodeItems$_) {
                const e = i._$GetFlowchartId$_(), h = i._$GetTag$_(), r = i._$GetIsStart$_(), n = (this._$_flowchartNodeItemsIdMap$_.set(e, i), 
                h && this._$_flowchartNodeItemsTagMap$_.set(h, i), r && (this._$_flowchartNodeStartItem$_ = i), 
                i._$GetFlowchartNodeOutputData$_());
                for (const o of n._$flowchartNodeOutputDataItems$_()) {
                    const a = o._$GetFlowchartId$_();
                    this._$_flowchartNodeItemsIdMap$_.set(a, o);
                }
            }
        }
        _$Release$_() {
            this._$_flowchartDataItem$_ = null;
            for (const t of this._$_flowchartNodeItems$_) t._$Release$_();
            uo._$clearArray$_(this._$_flowchartNodeItems$_), this._$_flowchartNodeItems$_ = null;
        }
        _$GetFlowchartDataItem$_() {
            return this._$_flowchartDataItem$_;
        }
        _$GetFlowchartElementById$_(t) {
            return this._$_flowchartNodeItemsIdMap$_.get(t);
        }
        _$GetFlowchartNodeByTag$_(t) {
            return this._$_flowchartNodeItemsTagMap$_.get(t);
        }
        _$GetFlowchartStartNode$_() {
            return this._$_flowchartNodeStartItem$_;
        }
        *_$flowchartNodeDataItems$_() {
            for (const t of this._$_flowchartNodeItems$_) yield t;
        }
    };
}

{
    const fo = self._$C3$_;
    class po {
        constructor(t, s) {
            this._$_flowchartNodeOutputData$_ = s, this._$_flowchartId$_ = t[0], 
            this._$_name$_ = t[1], this._$_value$_ = t[2], this._$_connectedFlowchartNodeFlowchartId$_ = t[3];
        }
        _$Release$_() {
            this._$_flowchartNodeOutputData$_ = null;
        }
        _$GetFlowchartNodeOutputData$_() {
            return this._$_flowchartNodeOutputData$_;
        }
        _$GetFlowchartId$_() {
            return this._$_flowchartId$_;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$GetValue$_() {
            return this._$_value$_;
        }
        _$GetConnectedFlowchartNodeFlowchartId$_() {
            return this._$_connectedFlowchartNodeFlowchartId$_;
        }
    }
    fo._$FlowchartNodeOutputData$_ = class {
        constructor(t, s) {
            this._$_flowchartDataNodeItem$_ = s, this._$_flowchartNodeOutputItems$_ = [], 
            this._$_flowchartNodeOutputItemsNameMap$_ = new Map(), fo._$FlowchartDataManager$_._$CreateDataItems$_(this._$_flowchartNodeOutputItems$_, t, po, this);
            for (const i of this._$_flowchartNodeOutputItems$_) this._$_flowchartNodeOutputItemsNameMap$_.set(i._$GetName$_(), i);
        }
        _$Release$_() {
            this._$_flowchartDataNodeItem$_ = null;
            for (const t of this._$_flowchartNodeOutputItems$_) t._$Release$_();
            fo._$clearArray$_(this._$_flowchartNodeOutputItems$_), this._$_flowchartNodeOutputItems$_ = null;
        }
        _$GetFlowchartNodeDataItem$_() {
            return this._$_flowchartDataNodeItem$_;
        }
        _$GetFlowchartNodeOutputDataItemCount$_() {
            return this._$_flowchartNodeOutputItems$_.length;
        }
        _$GetFlowchartNodeOutputDataItems$_() {
            return this._$_flowchartNodeOutputItems$_;
        }
        _$GetFlowchartNodeOutputDataItemByName$_(t) {
            return this._$_flowchartNodeOutputItemsNameMap$_.get(t);
        }
        *_$flowchartNodeOutputDataItems$_() {
            for (const t of this._$_flowchartNodeOutputItems$_) yield t;
        }
    };
}

{
    const mo = self._$C3$_;
    mo._$SolStack$_ = class extends mo._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_objectClass$_ = t, this._$_stack$_ = [], this._$_stack$_.push(mo._$New$_(mo._$Sol$_, this)), 
            this._$_index$_ = 0, this._$_current$_ = this._$_stack$_[0];
        }
        _$Release$_() {
            for (const t of this._$_stack$_) t._$Release$_();
            mo._$clearArray$_(this._$_stack$_), this._$_current$_ = null, this._$_objectClass$_ = null;
        }
        _$GetObjectClass$_() {
            return this._$_objectClass$_;
        }
        _$GetCurrentSol$_() {
            return this._$_current$_;
        }
        _$GetOneBelowCurrentSol$_() {
            return this._$_stack$_[this._$_index$_ - 1];
        }
        _$Clear$_() {
            this._$GetCurrentSol$_()._$Clear$_();
        }
        _$PushClean$_() {
            const t = this._$_stack$_, s = ++this._$_index$_;
            if (s === t.length) {
                const i = mo._$New$_(mo._$Sol$_, this);
                t.push(i), this._$_current$_ = i;
            } else {
                const e = t[s];
                e._$Reset$_(), this._$_current$_ = e;
            }
        }
        _$PushCopy$_() {
            const t = this._$_stack$_, s = ++this._$_index$_, i = (s === t.length && t.push(mo._$New$_(mo._$Sol$_, this)), 
            t[s]);
            i._$Copy$_(t[s - 1]), this._$_current$_ = i;
        }
        _$Pop$_() {
            this._$_current$_ = this._$_stack$_[--this._$_index$_];
        }
        _$RemoveInstances$_(i) {
            const e = this._$_stack$_;
            for (let t = 0, s = e.length; t < s; ++t) e[t]._$RemoveInstances$_(i);
        }
    };
}

{
    const go = self._$C3$_;
    go._$Sol$_ = class extends go._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_stack$_ = t, this._$_objectClass$_ = this._$_stack$_._$GetObjectClass$_(), 
            this._$_eventStack$_ = this._$_objectClass$_._$GetRuntime$_()._$GetEventStack$_(), 
            this._$_selectAll$_ = !0, this._$_instances$_ = [], this._$_elseInstances$_ = [];
        }
        _$Release$_() {
            this._$ClearArrays$_(), this._$_stack$_ = null, this._$_objectClass$_ = null, 
            this._$_eventStack$_ = null;
        }
        _$ClearArrays$_() {
            go._$clearArray$_(this._$_instances$_), go._$clearArray$_(this._$_elseInstances$_);
        }
        _$GetObjectClass$_() {
            return this._$_objectClass$_;
        }
        _$IsSelectAll$_() {
            return this._$_selectAll$_;
        }
        _$HasAnyInstances$_() {
            return this._$_selectAll$_ ? !!this._$_objectClass$_._$GetInstanceCount$_() : !!this._$_instances$_.length;
        }
        _$GetInstances$_() {
            return this._$_selectAll$_ ? this._$_objectClass$_._$GetInstances$_() : this._$_instances$_;
        }
        _$HasAnyElseInstances$_() {
            return !!this._$_elseInstances$_.length;
        }
        _$GetElseInstances$_() {
            return this._$_elseInstances$_;
        }
        _$GetExpressionInstances$_() {
            const t = this._$GetInstances$_();
            return t.length ? t : this._$_elseInstances$_;
        }
        _$Reset$_() {
            this._$_selectAll$_ = !0, go._$clearArray$_(this._$_elseInstances$_);
        }
        _$Clear$_() {
            this._$_selectAll$_ = !0;
        }
        _$Copy$_(t) {
            t._$IsSelectAll$_() ? this._$Reset$_() : (this._$_selectAll$_ = !1, 
            go._$shallowAssignArray$_(this._$_instances$_, t._$_instances$_), go._$clearArray$_(this._$_elseInstances$_));
        }
        _$_PushInstance$_(t) {
            this._$_instances$_.push(t);
        }
        _$_PushElseInstance$_(t) {
            this._$_elseInstances$_.push(t);
        }
        _$_SetSelectAll$_(t) {
            this._$_selectAll$_ = !!t;
        }
        _$_GetOwnInstances$_() {
            return this._$_instances$_;
        }
        _$_GetOwnElseInstances$_() {
            return this._$_elseInstances$_;
        }
        _$SetSinglePicked$_(t) {
            this._$_selectAll$_ = !1, go._$clearArray$_(this._$_instances$_), this._$_instances$_.push(t);
        }
        _$SetArrayPicked$_(t) {
            this._$_selectAll$_ = !1, go._$shallowAssignArray$_(this._$_instances$_, t);
        }
        _$SetSetPicked$_(t) {
            this._$_selectAll$_ = !1, go._$clearArray$_(this._$_instances$_);
            for (const s of t) this._$_instances$_.push(s);
        }
        _$AddElseInstances$_(t, s) {
            for (const i of s) t.has(i) || this._$_elseInstances$_.push(i);
        }
        _$TransferElseInstancesToOwn$_(t) {
            for (const s of t) this._$_instances$_.push(s);
            go._$arrayRemoveAllInSet$_(this._$_elseInstances$_, t);
        }
        _$ClearElseInstances$_() {
            go._$clearArray$_(this._$_elseInstances$_);
        }
        _$PickOne$_(t) {
            if (t) if (this._$_eventStack$_._$GetCurrentStackFrame$_()._$GetCurrentEvent$_()._$IsOrBlock$_()) {
                this._$IsSelectAll$_() && (go._$clearArray$_(this._$_instances$_), 
                go._$shallowAssignArray$_(this._$_elseInstances$_, t._$GetObjectClass$_()._$GetInstances$_()), 
                this._$_selectAll$_ = !1);
                const s = this._$_elseInstances$_.indexOf(t);
                -1 !== s && (this._$_instances$_.push(this._$_elseInstances$_[s]), 
                this._$_elseInstances$_.splice(s, 1));
            } else this._$SetSinglePicked$_(t);
        }
        _$RemoveInstances$_(t) {
            go._$arrayRemoveAllInSet$_(this._$_instances$_, t), go._$arrayRemoveAllInSet$_(this._$_elseInstances$_, t);
        }
    };
}

{
    const yo = self._$C3$_;
    yo._$EventStack$_ = class extends yo._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_eventSheetManager$_ = t, this._$_runtime$_ = this._$_eventSheetManager$_._$GetRuntime$_(), 
            this._$_stack$_ = [], this._$_stack$_.push(yo._$New$_(yo._$EventStackFrame$_, this, null)), 
            this._$_index$_ = 0, this._$_expFuncStack$_ = [];
        }
        _$Release$_() {
            for (const t of this._$_stack$_) t._$Release$_();
            yo._$clearArray$_(this._$_stack$_), yo._$clearArray$_(this._$_expFuncStack$_), 
            this._$_eventSheetManager$_ = null, this._$_runtime$_ = null;
        }
        _$GetEventSheetManager$_() {
            return this._$_eventSheetManager$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetCurrentStackFrame$_() {
            return this._$_stack$_[this._$_index$_];
        }
        _$GetAllStackFrames$_() {
            return this._$_stack$_;
        }
        _$GetCurrentStackFrameIndex$_() {
            return this._$_index$_;
        }
        _$Push$_(t) {
            const s = this._$_stack$_, i = ++this._$_index$_;
            if (i === s.length) {
                const e = yo._$New$_(yo._$EventStackFrame$_, this, t);
                return s.push(e), e;
            }
            {
                const h = s[i];
                return h._$Reset$_(t), h;
            }
        }
        _$Pop$_() {
            --this._$_index$_;
        }
        _$PushExpFunc$_(t) {
            this._$_expFuncStack$_.push(t);
        }
        _$PopExpFunc$_() {
            this._$_expFuncStack$_.pop();
        }
        _$GetCurrentExpFuncStackFrame$_() {
            const t = this._$_expFuncStack$_;
            return 0 === t.length ? null : t.at(-1);
        }
    };
}

{
    const wo = self._$C3$_;
    wo._$EventStackFrame$_ = class extends wo._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_stack$_ = t, this._$_runtime$_ = this._$_stack$_._$GetRuntime$_(), 
            this._$_currentEvent$_ = s, this._$_cndIndex$_ = 0, this._$_actIndex$_ = 0, 
            this._$_lastEventTrue$_ = !1, this._$_elseBranchRan$_ = !1, this._$_expressionObjectClass$_ = null, 
            this._$_functionReturnType$_ = 0, this._$_functionReturnValue$_ = 0, 
            this._$_dynamicSolModifiers$_ = null;
        }
        _$Release$_() {
            this._$Reset$_(null), this._$_stack$_ = null, this._$_runtime$_ = null;
        }
        _$Reset$_(t) {
            this._$_currentEvent$_ = t, this._$_cndIndex$_ = 0, this._$_actIndex$_ = 0, 
            this._$_lastEventTrue$_ = !1, this._$_elseBranchRan$_ = !1, this._$_dynamicSolModifiers$_ = null;
        }
        _$_Restore$_(t, s) {
            this._$_currentEvent$_ = t, this._$_cndIndex$_ = 0, this._$_actIndex$_ = s;
        }
        _$ResetQuick$_() {
            this._$_cndIndex$_ = 0, this._$_actIndex$_ = 0;
        }
        _$GetCurrentEvent$_() {
            return this._$_currentEvent$_;
        }
        _$SetCurrentEvent$_(t) {
            this._$_currentEvent$_ = t;
        }
        _$GetConditionIndex$_() {
            return this._$_cndIndex$_;
        }
        _$SetConditionIndex$_(t) {
            this._$_cndIndex$_ = t;
        }
        _$GetActionIndex$_() {
            return this._$_actIndex$_;
        }
        _$SetActionIndex$_(t) {
            this._$_actIndex$_ = t;
        }
        _$SetLastEventTrue$_(t) {
            this._$_lastEventTrue$_ = !!t;
        }
        _$GetLastEventTrue$_() {
            return this._$_lastEventTrue$_;
        }
        _$SetElseBranchRan$_(t) {
            this._$_elseBranchRan$_ = !!t;
        }
        _$GetElseBranchRan$_() {
            return this._$_elseBranchRan$_;
        }
        _$SetExpressionObjectClass$_(t) {
            this._$_expressionObjectClass$_ = t;
        }
        _$GetExpressionObjectClass$_() {
            return this._$_expressionObjectClass$_;
        }
        _$InitCallFunctionExpression$_(t, s) {
            this._$_functionReturnType$_ = t, this._$_functionReturnValue$_ = s;
        }
        _$GetFunctionReturnType$_() {
            return this._$_functionReturnType$_;
        }
        _$SetFunctionReturnValue$_(t) {
            this._$_functionReturnValue$_ = t;
        }
        _$GetFunctionReturnValue$_() {
            return this._$_functionReturnValue$_;
        }
        _$IsSolModifierAfterCnds$_() {
            const t = this._$_currentEvent$_;
            return !!t._$IsSolWriterAfterCnds$_() || this._$_cndIndex$_ < t._$GetConditionCount$_() - 1 && !!t._$GetSolModifiers$_().length;
        }
        _$SetDynamicSolModifiers$_(t) {
            this._$_dynamicSolModifiers$_ = t;
        }
        _$GetDynamicSolModifiers$_() {
            return this._$_dynamicSolModifiers$_;
        }
    };
}

{
    const So = self._$C3$_;
    So._$LocalVarStack$_ = class extends So._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_eventSheetManager$_ = t, this._$_runtime$_ = this._$_eventSheetManager$_._$GetRuntime$_(), 
            this._$_stack$_ = [], this._$_index$_ = -1, this._$_current$_ = null, 
            this._$_initialValues$_ = [];
        }
        _$Release$_() {
            So._$clearArray$_(this._$_stack$_), this._$_eventSheetManager$_ = null, 
            this._$_runtime$_ = null;
        }
        _$_SetInitialValues$_(t) {
            this._$_initialValues$_ = t;
            const s = this._$_initialValues$_.slice(0);
            this._$_stack$_.push(s), this._$_index$_ = 0, this._$_current$_ = s;
        }
        _$GetEventSheetManager$_() {
            return this._$_eventSheetManager$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetCurrent$_() {
            return this._$_current$_;
        }
        _$Push$_() {
            const t = ++this._$_index$_, s = this._$_stack$_;
            t === s.length ? s.push(this._$_initialValues$_.slice(0)) : So._$shallowAssignArray$_(s[t], this._$_initialValues$_), 
            this._$_current$_ = s[t];
        }
        _$Pop$_() {
            this._$_current$_ = this._$_stack$_[--this._$_index$_];
        }
    };
}

{
    const bo = self._$C3$_;
    bo._$LoopStack$_ = class extends bo._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_eventSheetManager$_ = t, this._$_runtime$_ = this._$_eventSheetManager$_._$GetRuntime$_(), 
            this._$_stack$_ = [], this._$_index$_ = -1;
        }
        _$Release$_() {
            bo._$clearArray$_(this._$_stack$_), this._$_eventSheetManager$_ = null, 
            this._$_runtime$_ = null;
        }
        _$GetEventSheetManager$_() {
            return this._$_eventSheetManager$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$IsInLoop$_() {
            return 0 <= this._$_index$_;
        }
        _$GetCurrent$_() {
            return this._$_stack$_[this._$_index$_];
        }
        _$Push$_() {
            if (++this._$_index$_, this._$_index$_ === this._$_stack$_.length) {
                const t = bo._$New$_(bo._$Loop$_, this);
                return this._$_stack$_.push(t), t;
            }
            {
                const s = this._$_stack$_[this._$_index$_];
                return s._$Reset$_(), s;
            }
        }
        _$Pop$_() {
            --this._$_index$_;
        }
        _$FindByName$_(s) {
            const i = this._$_stack$_;
            for (let t = this._$_index$_; 0 <= t; --t) {
                const e = i[t];
                if (e._$GetName$_() === s) return e;
            }
            return null;
        }
        _$_GetStack$_() {
            return this._$_stack$_.slice(0, this._$_index$_ + 1);
        }
    };
}

{
    const Mo = self._$C3$_;
    Mo._$Loop$_ = class extends Mo._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_loopStack$_ = t, this._$_name$_ = "", this._$_index$_ = 0, 
            this._$_isStopped$_ = !1, this._$_end$_ = NaN;
        }
        _$Reset$_() {
            this._$_name$_ = "", this._$_index$_ = 0, this._$_isStopped$_ = !1, 
            this._$_end$_ = NaN;
        }
        _$SetName$_(t) {
            this._$_name$_ = t;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$SetIndex$_(t) {
            this._$_index$_ = t;
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$Stop$_() {
            this._$_isStopped$_ = !0;
        }
        _$IsStopped$_() {
            return this._$_isStopped$_;
        }
        _$SetEnd$_(t) {
            this._$_end$_ = t;
        }
        _$GetEnd$_() {
            return this._$_end$_;
        }
    };
}

{
    const vo = self._$C3$_;
    vo._$ArrayStack$_ = class extends vo._$DefendedBase$_ {
        constructor() {
            super(), this._$_stack$_ = [], this._$_index$_ = -1;
        }
        _$Release$_() {
            vo._$clearArray$_(this._$_stack$_);
        }
        _$GetCurrent$_() {
            return this._$_stack$_[this._$_index$_];
        }
        _$Push$_() {
            if (++this._$_index$_, this._$_index$_ !== this._$_stack$_.length) return this._$_stack$_[this._$_index$_];
            {
                const t = [];
                return this._$_stack$_.push(t), t;
            }
        }
        _$Pop$_() {
            --this._$_index$_;
        }
    };
}

{
    let t = function(t, s) {
        return t._$GetIndex$_() - s._$GetIndex$_();
    }, r = function(i, e) {
        for (let t = 0, s = i.length; t < s; ++t) if (i[t] !== e[t]) return !1;
        return !0;
    };
    t, r;
    const xo = self._$C3$_;
    xo._$EventSheetManager$_ = class extends xo._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_runtime$_ = t, this._$_allSheets$_ = [], this._$_sheetsByName$_ = new Map(), 
            this._$_allGroups$_ = [], this._$_groupsByName$_ = new Map(), this._$_blocksBySid$_ = new Map(), 
            this._$_cndsBySid$_ = new Map(), this._$_actsBySid$_ = new Map(), this._$_allUniqueSolModifiers$_ = new Map(), 
            this._$_eventVarsBySid$_ = new Map(), this._$_nextLocalVarIndex$_ = 0, 
            this._$_allGlobalVars$_ = [], this._$_allLocalVars$_ = [], this._$_localVarInitialValues$_ = [], 
            this._$_functionBlocksByName$_ = new Map(), this._$_customActionBlocksMap$_ = new Map(), 
            this._$_eventStack$_ = xo._$New$_(xo._$EventStack$_, this), this._$_localVarStack$_ = xo._$New$_(xo._$LocalVarStack$_, this), 
            this._$_loopStack$_ = xo._$New$_(xo._$LoopStack$_, this), this._$_triggersToPostInit$_ = [], 
            this._$_queuedTriggers$_ = [], this._$_queuedDebugTriggers$_ = [], this._$_runningEventsDepth$_ = 0, 
            this._$_executingTriggerDepth$_ = 0, this._$_blockFlushingDepth$_ = 0, 
            this._$_scheduledWaits$_ = [], this._$_asyncActionPromises$_ = [], this._$_signalTags$_ = [], 
            this._$_signalPromises$_ = new Map(), this._$_instSignals$_ = new Map(), 
            self.c3_callFunction = (t, s) => this._$_InvokeFunctionFromJS$_(t, s);
        }
        _$Release$_() {
            this._$ClearAllScheduledWaits$_(), this._$_eventStack$_._$Release$_(), 
            this._$_eventStack$_ = null, this._$_localVarStack$_._$Release$_(), 
            this._$_localVarStack$_ = null, xo._$clearArray$_(this._$_queuedTriggers$_), 
            xo._$clearArray$_(this._$_queuedDebugTriggers$_), this._$_runtime$_ = null, 
            xo._$clearArray$_(this._$_allSheets$_), this._$_sheetsByName$_.clear();
        }
        _$Create$_(t) {
            const s = xo._$New$_(xo._$EventSheet$_, this, t);
            this._$_allSheets$_.push(s), this._$_sheetsByName$_.set(s._$GetName$_().toLowerCase(), s);
        }
        _$_AddTriggerToPostInit$_(t) {
            this._$_triggersToPostInit$_.push(t);
        }
        _$_PostInit$_() {
            for (const t of this._$_customActionBlocksMap$_.values()) t._$_CheckOverrideState$_();
            for (const s of this._$_functionBlocksByName$_.values()) s._$_PostInit$_();
            for (const i of this._$_customActionBlocksMap$_.values()) i._$_PostInit$_();
            for (const e of this._$_allSheets$_) e._$_PostInit$_();
            for (const h of this._$_allSheets$_) h._$_UpdateDeepIncludes$_();
            for (const r of this._$_triggersToPostInit$_) r._$_PostInit$_(!1);
            xo._$clearArray$_(this._$_triggersToPostInit$_), this._$_localVarStack$_._$_SetInitialValues$_(this._$_localVarInitialValues$_);
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetEventSheetByName$_(t) {
            return this._$_sheetsByName$_.get(t.toLowerCase()) || null;
        }
        _$_RegisterGroup$_(t) {
            this._$_allGroups$_.push(t), this._$_groupsByName$_.set(t._$GetGroupName$_(), t);
        }
        _$_RegisterEventBlock$_(t) {
            this._$_blocksBySid$_.set(t._$GetSID$_(), t);
        }
        _$_RegisterCondition$_(t) {
            this._$_cndsBySid$_.set(t._$GetSID$_(), t);
        }
        _$_RegisterAction$_(t) {
            this._$_actsBySid$_.set(t._$GetSID$_(), t);
        }
        _$_RegisterFunctionBlock$_(t) {
            switch (t._$GetFunctionType$_()) {
              case 0:
                this._$_functionBlocksByName$_.set(t._$GetFunctionName$_().toLowerCase(), t);
                break;

              case 1:
                this._$_customActionBlocksMap$_.set(t._$GetFunctionName$_().toLowerCase(), t);
            }
        }
        _$_RegisterEventVariable$_(t) {
            this._$_eventVarsBySid$_.set(t._$GetSID$_(), t), (t._$IsGlobal$_() ? this._$_allGlobalVars$_ : this._$_allLocalVars$_).push(t);
        }
        _$_DeduplicateSolModifierList$_(i) {
            2 <= i.length && i.sort(t);
            let e = this._$_allUniqueSolModifiers$_.get(i.length);
            e || (e = [], this._$_allUniqueSolModifiers$_.set(i.length, e));
            for (let t = 0, s = e.length; t < s; ++t) {
                const h = e[t];
                if (r(i, h)) return h;
            }
            return e.push(i), i;
        }
        _$_GetNextLocalVarIndex$_(t) {
            return this._$_localVarInitialValues$_.push(t._$GetInitialValue$_()), 
            this._$_nextLocalVarIndex$_++;
        }
        _$GetEventStack$_() {
            return this._$_eventStack$_;
        }
        _$GetCurrentEventStackFrame$_() {
            return this._$GetEventStack$_()._$GetCurrentStackFrame$_();
        }
        _$GetCurrentEvent$_() {
            return this._$GetCurrentEventStackFrame$_()._$GetCurrentEvent$_();
        }
        _$GetCurrentCondition$_() {
            const t = this._$GetCurrentEventStackFrame$_(), s = t._$GetCurrentEvent$_();
            return s._$GetConditionAt$_(t._$GetConditionIndex$_());
        }
        _$GetCurrentAction$_() {
            const t = this._$GetCurrentEventStackFrame$_(), s = t._$GetCurrentEvent$_();
            return s._$GetActionAt$_(t._$GetActionIndex$_());
        }
        _$GetLocalVarStack$_() {
            return this._$_localVarStack$_;
        }
        _$GetLoopStack$_() {
            return this._$_loopStack$_;
        }
        _$GetAllLocalVariablesInScope$_(t) {
            const s = [];
            for (t = t._$GetScopeParent$_(); t; ) xo._$appendArray$_(s, t._$_GetAllLocalVariablesInScope$_()), 
            t = t._$GetScopeParent$_();
            return s;
        }
        _$_GetLocalVariablesScriptInterface$_(t) {
            const s = {};
            for (const i of this._$GetAllLocalVariablesInScope$_(t)) s[i._$GetJsPropName$_()] = i._$_GetScriptInterfaceDescriptor$_();
            return Object.create(Object.prototype, s);
        }
        _$GetEventVariableBySID$_(t) {
            return this._$_eventVarsBySid$_.get(t) || null;
        }
        _$GetEventBlockBySID$_(t) {
            return this._$_blocksBySid$_.get(t) || null;
        }
        _$GetConditionBySID$_(t) {
            return this._$_cndsBySid$_.get(t) || null;
        }
        _$GetActionBySID$_(t) {
            return this._$_actsBySid$_.get(t) || null;
        }
        _$GetFunctionBlockByName$_(t) {
            return this._$_functionBlocksByName$_.get(t.toLowerCase()) || null;
        }
        _$GetCustomActionBlockByName$_(t, s) {
            let i = this._$_customActionBlocksMap$_.get((t._$GetName$_() + "." + s).toLowerCase());
            if (i) return i;
            if (!t._$IsFamily$_()) for (const e of t._$GetFamilies$_()) if (i = this._$_customActionBlocksMap$_.get((e._$GetName$_() + "." + s).toLowerCase())) return i;
            return null;
        }
        _$GetAllGlobalVariables$_() {
            return this._$_allGlobalVars$_;
        }
        _$GetAllLocalVariables$_() {
            return this._$_allLocalVars$_;
        }
        _$ResetAllGlobalsToInitialValue$_(t) {
            for (const s of this._$_allGlobalVars$_) s._$ResetToInitialValue$_();
            if (t) for (const i of this._$_allLocalVars$_) i._$IsStatic$_() && i._$ResetToInitialValue$_();
        }
        _$GetEventGroupByName$_(t) {
            return this._$_groupsByName$_.get(t.toLowerCase()) || null;
        }
        _$GetEventGroupBySID$_(t) {
            const s = this._$_blocksBySid$_.get(t);
            return s && s._$IsGroup$_() ? s : null;
        }
        _$GetAllGroups$_() {
            return this._$_allGroups$_;
        }
        _$ResetAllGroupsInitialActivation$_() {
            for (const t of this._$_allGroups$_) t._$ResetInitialActivation$_();
        }
        _$_ResetAllHasRunFlags$_() {
            for (const t of this._$_allSheets$_) t._$_ResetHasRunFlag$_();
        }
        _$RunEvents$_(t) {
            this._$_ResetAllHasRunFlags$_(), this._$_runningEventsDepth$_++;
            for (const s of t._$runningLayouts$_()) {
                const i = s._$GetEventSheet$_();
                i && (this._$_runtime$_._$PushCurrentLayout$_(s), i._$Run$_(), this._$_runtime$_._$PopCurrentLayout$_());
            }
            this._$_runningEventsDepth$_--;
        }
        async _$DebugRunEvents$_(t) {
            this._$_ResetAllHasRunFlags$_(), this._$_runningEventsDepth$_++;
            for (const s of this._$_DebugRunEventsGen$_(t)) await this._$_runtime$_._$DebugBreak$_(s);
            this._$_runningEventsDepth$_--;
        }
        *_$_DebugRunEventsGen$_(t) {
            for (const s of t._$runningLayouts$_()) {
                const i = s._$GetEventSheet$_();
                i && (this._$_runtime$_._$PushCurrentLayout$_(s), yield* i._$DebugRun$_(), 
                this._$_runtime$_._$PopCurrentLayout$_());
            }
        }
        _$_Trigger$_(t, s, i, e) {
            let h = !1;
            if (!t._$GetMainRunningLayout$_()) return this._$QueueTrigger$_(s, i, e);
            this._$_executingTriggerDepth$_++;
            for (const r of t._$runningLayouts$_()) {
                const n = r._$GetEventSheet$_();
                if (n) {
                    this._$_runtime$_._$PushCurrentLayout$_(r);
                    for (const a of n._$deepIncludes$_()) {
                        const l = a._$_Trigger$_(s, i, e);
                        h = h || l;
                    }
                    const o = n._$_Trigger$_(s, i, e);
                    h = h || o, this._$_runtime$_._$PopCurrentLayout$_();
                }
            }
            return this._$_executingTriggerDepth$_--, h;
        }
        *_$_DebugTrigger$_(t, s, i, e) {
            let h = !1;
            if (!t._$GetMainRunningLayout$_()) return this._$QueueTrigger$_(s, i, e);
            this._$_executingTriggerDepth$_++;
            for (const r of t._$runningLayouts$_()) {
                const n = r._$GetEventSheet$_();
                if (n) {
                    this._$_runtime$_._$PushCurrentLayout$_(r);
                    for (const a of n._$deepIncludes$_()) {
                        const l = yield* a._$_DebugTrigger$_(s, i, e);
                        h = h || l;
                    }
                    const o = yield* n._$_DebugTrigger$_(s, i, e);
                    h = h || o, this._$_runtime$_._$PopCurrentLayout$_();
                }
            }
            return this._$_executingTriggerDepth$_--, h;
        }
        _$QueueTrigger$_(t, s, i) {
            return this._$_queuedTriggers$_.push([ t, s, i ]), !1;
        }
        _$QueueDebugTrigger$_(t, s, i) {
            let e = null, h = new Promise(t => e = t);
            return this._$_queuedDebugTriggers$_.push([ t, s, i, e ]), h;
        }
        *_$_RunQueuedDebugTriggersGen$_() {
            if (this._$_runtime$_._$HitBreakpoint$_()) throw new Error("should not be in breakpoint");
            const t = this._$_runtime$_._$GetLayoutManager$_();
            for (;this._$_queuedDebugTriggers$_.length; ) {
                const [ s, i, e, h ] = this._$_queuedDebugTriggers$_.shift(), r = yield* this._$_DebugTrigger$_(t, s, i, e);
                h(r);
            }
        }
        async _$RunQueuedDebugTriggersAsync$_() {
            for (const t of this._$_RunQueuedDebugTriggersGen$_()) await this._$_runtime$_._$DebugBreak$_(t);
        }
        _$_FastTrigger$_(t, i, e, h) {
            let r = !1, s = t._$GetMainRunningLayout$_(), n = s._$GetEventSheet$_();
            if (n) {
                this._$_executingTriggerDepth$_++, this._$_runtime$_._$PushCurrentLayout$_(s);
                const o = n._$deepIncludes$_();
                for (let t = 0, s = o.length; t < s; ++t) {
                    const l = o[t]._$_FastTrigger$_(i, e, h);
                    r = r || l;
                }
                const a = n._$_FastTrigger$_(i, e, h);
                return r = r || a, this._$_runtime$_._$PopCurrentLayout$_(), this._$_executingTriggerDepth$_--, 
                r;
            }
        }
        *_$_DebugFastTrigger$_(t, i, e, h) {
            let r = !1, s = t._$GetMainRunningLayout$_(), n = s._$GetEventSheet$_();
            if (n) {
                this._$_executingTriggerDepth$_++, this._$_runtime$_._$PushCurrentLayout$_(s);
                const o = n._$deepIncludes$_();
                for (let t = 0, s = o.length; t < s; ++t) {
                    const l = yield* o[t]._$_DebugFastTrigger$_(i, e, h);
                    r = r || l;
                }
                const a = yield* n._$_DebugFastTrigger$_(i, e, h);
                return r = r || a, this._$_runtime$_._$PopCurrentLayout$_(), this._$_executingTriggerDepth$_--, 
                r;
            }
        }
        _$GetTriggerDepth$_() {
            return this._$_executingTriggerDepth$_;
        }
        _$IsInTrigger$_() {
            return 0 < this._$GetTriggerDepth$_();
        }
        _$_IncTriggerDepth$_() {
            return ++this._$_executingTriggerDepth$_;
        }
        _$_DecTriggerDepth$_() {
            --this._$_executingTriggerDepth$_;
        }
        _$IsRunningEvents$_() {
            return 0 < this._$_runningEventsDepth$_;
        }
        _$IsInEventEngine$_() {
            return this._$IsRunningEvents$_() || this._$IsInTrigger$_();
        }
        _$_RunQueuedTriggers$_(t) {
            for (const [ s, i, e ] of this._$_queuedTriggers$_) this._$_Trigger$_(t, s, i, e);
            xo._$clearArray$_(this._$_queuedTriggers$_);
        }
        _$BlockFlushingInstances$_(t) {
            t ? this._$_blockFlushingDepth$_++ : this._$_blockFlushingDepth$_--;
        }
        _$IsFlushingBlocked$_() {
            return 0 < this._$_blockFlushingDepth$_;
        }
        _$ClearSol$_(i) {
            for (let t = 0, s = i.length; t < s; ++t) i[t]._$GetSolStack$_()._$Clear$_();
        }
        _$PushCleanSol$_(i) {
            for (let t = 0, s = i.length; t < s; ++t) i[t]._$GetSolStack$_()._$PushClean$_();
        }
        _$PushCopySol$_(i) {
            for (let t = 0, s = i.length; t < s; ++t) i[t]._$GetSolStack$_()._$PushCopy$_();
        }
        _$PopSol$_(i) {
            for (let t = 0, s = i.length; t < s; ++t) i[t]._$GetSolStack$_()._$Pop$_();
        }
        _$GetDynamicSolModifiersSet$_(s) {
            const i = new Set(), e = this._$_eventStack$_._$GetAllStackFrames$_(), h = this._$_eventStack$_._$GetCurrentStackFrameIndex$_();
            for (let t = 0; t <= h; ++t) {
                const r = e[t]._$GetDynamicSolModifiers$_();
                if (r) for (const n of r) s && s.has(n) || i.add(n);
            }
            return i;
        }
        _$PushCleanSolDynamic$_(t) {
            const s = new Set([ ...t ]), i = this._$GetDynamicSolModifiersSet$_(s);
            if (0 < i.size) {
                for (const e of i) e._$GetSolStack$_()._$PushClean$_();
                return [ ...i ];
            }
            return null;
        }
        _$AddScheduledWait$_() {
            const t = xo._$New$_(xo._$ScheduledWait$_, this);
            return this._$_scheduledWaits$_.push(t), t;
        }
        _$scheduledWaits$_() {
            return this._$_scheduledWaits$_;
        }
        _$RunScheduledWaits$_() {
            if (this._$_scheduledWaits$_.length) {
                let i = this._$GetCurrentEventStackFrame$_(), e = !1;
                this._$_runningEventsDepth$_++;
                for (let t = 0, s = this._$_scheduledWaits$_.length; t < s; ++t) {
                    const h = this._$_scheduledWaits$_[t];
                    h._$_ShouldRun$_() && h._$_Run$_(i), h._$ShouldRelease$_() && (e = !0);
                }
                e && (this._$_FilterScheduledWaitsToRelease$_(), i._$Reset$_(null)), 
                this._$_runningEventsDepth$_--;
            }
        }
        async _$DebugRunScheduledWaits$_() {
            if (this._$_scheduledWaits$_.length) {
                let i = this._$GetCurrentEventStackFrame$_(), e = !1;
                this._$_runningEventsDepth$_++;
                for (let t = 0, s = this._$_scheduledWaits$_.length; t < s; ++t) {
                    const h = this._$_scheduledWaits$_[t];
                    h._$_ShouldRun$_() && await h._$_DebugRun$_(i), h._$ShouldRelease$_() && (e = !0);
                }
                e && (this._$_FilterScheduledWaitsToRelease$_(), i._$Reset$_(null)), 
                this._$_runningEventsDepth$_--;
            }
        }
        _$_FilterScheduledWaitsToRelease$_() {
            const t = xo._$arrayFilterOut$_(this._$_scheduledWaits$_, t => t._$ShouldRelease$_());
            for (const s of t) s._$Release$_();
        }
        _$ClearAllScheduledWaits$_() {
            for (const t of this._$_scheduledWaits$_) t._$Release$_();
            xo._$clearArray$_(this._$_scheduledWaits$_);
        }
        _$_OnInstancesReleased$_(t) {
            for (const s of this._$_scheduledWaits$_) s._$RemoveInstances$_(t);
            for (const i of t) {
                const e = this._$_instSignals$_.get(i);
                if (this._$_instSignals$_.delete(i), e) for (const {
                    resolve: h
                } of e._$signalPromises$_.values()) h(!0);
            }
        }
        _$AddAsyncActionPromise$_(t) {
            this._$_asyncActionPromises$_.push(t);
        }
        _$ClearAsyncActionPromises$_() {
            xo._$clearArray$_(this._$_asyncActionPromises$_);
        }
        _$GetPromiseForAllAsyncActions$_() {
            const t = Promise.all(this._$_asyncActionPromises$_);
            return this._$_asyncActionPromises$_ = [], t;
        }
        _$Signal$_(t) {
            const s = t.toLowerCase();
            this._$_signalTags$_.push(s), this._$_runtime$_._$Trigger$_(xo._$Plugins$_._$System$_._$Cnds$_._$OnSignal$_, null), 
            this._$_signalTags$_.pop();
            for (const e of this._$_runtime$_._$GetEventSheetManager$_()._$scheduledWaits$_()) e._$IsSignal$_() && e._$GetSignalTag$_() === s && e._$SetSignalled$_();
            const i = this._$_signalPromises$_.get(s);
            i && (i.resolve(), this._$_signalPromises$_.delete(s));
        }
        _$WaitForSignal$_(t) {
            const i = t.toLowerCase(), s = this._$_signalPromises$_.get(i);
            if (s) return s.promise;
            {
                let s = null, t = new Promise(t => s = t);
                return this._$_signalPromises$_.set(i, {
                    promise: t,
                    resolve: s
                }), t;
            }
        }
        _$GetCurrentSignalTag$_() {
            if (0 === this._$_signalTags$_.length) throw new Error("not in a signal");
            return this._$_signalTags$_.at(-1);
        }
        _$_GetInstanceSignalState$_(t) {
            let s = this._$_instSignals$_.get(t);
            return s || (s = {
                _$signalTags$_: [],
                _$signalPromises$_: new Map()
            }, this._$_instSignals$_.set(t, s)), s;
        }
        _$InstanceSignal$_(t, s) {
            const i = this._$_GetInstanceSignalState$_(t), e = s.toLowerCase();
            i._$signalTags$_.push(e), this._$_runtime$_._$Trigger$_(t._$GetPlugin$_()._$GetConstructor$_()._$Cnds$_._$OnInstanceSignal$_, t), 
            i._$signalTags$_.pop();
            for (const r of this._$_runtime$_._$GetEventSheetManager$_()._$scheduledWaits$_()) r._$IsInstanceSignals$_() && r._$GetSignalTag$_() === e && r._$SetInstanceSignalled$_(t);
            const h = i._$signalPromises$_.get(e);
            h && (h.resolve(!1), i._$signalPromises$_.delete(e)), 0 === i._$signalTags$_.length && 0 === i._$signalPromises$_.size && this._$_instSignals$_.delete(t);
        }
        _$WaitForInstanceSignal$_(t, s) {
            const i = this._$_GetInstanceSignalState$_(t), e = s.toLowerCase(), h = i._$signalPromises$_.get(e);
            if (h) return h.promise;
            {
                let s = null, t = new Promise(t => s = t);
                return i._$signalPromises$_.set(e, {
                    promise: t,
                    resolve: s
                }), t;
            }
        }
        _$GetCurrentInstanceSignalTag$_(t) {
            const s = this._$_GetInstanceSignalState$_(t);
            if (s && 0 !== s._$signalTags$_.length) return s._$signalTags$_.at(-1);
            throw new Error("not in a signal");
        }
        _$_SaveToJson$_() {
            return {
                groups: this._$_SaveGroupsToJson$_(),
                cnds: this._$_SaveCndsToJson$_(),
                acts: this._$_SaveActsToJson$_(),
                vars: this._$_SaveVarsToJson$_(),
                waits: this._$_SaveScheduledWaitsToJson$_()
            };
        }
        _$_LoadFromJson$_(t) {
            this._$_LoadGroupsFromJson$_(t.groups), this._$_LoadCndsFromJson$_(t.cnds), 
            this._$_LoadActsFromJson$_(t.acts), this._$_LoadVarsFromJson$_(t.vars), 
            this._$_LoadScheduledWaitsFromJson$_(t.waits);
        }
        _$_SaveGroupsToJson$_() {
            const t = {};
            for (const s of this._$GetAllGroups$_()) t[s._$GetSID$_().toString()] = s._$IsGroupActive$_();
            return t;
        }
        _$_LoadGroupsFromJson$_(t) {
            for (const [ s, i ] of Object.entries(t)) {
                const e = parseInt(s, 10), h = this._$GetEventGroupBySID$_(e);
                h && h._$SetGroupActive$_(i);
            }
        }
        _$_SaveCndsToJson$_() {
            const t = {};
            for (const [ s, i ] of this._$_cndsBySid$_) {
                const e = i._$_SaveToJson$_();
                e && (t[s.toString()] = e);
            }
            return t;
        }
        _$_LoadCndsFromJson$_(t) {
            const s = new Map();
            for (const [ i, e ] of Object.entries(t)) s.set(parseInt(i, 10), e);
            for (const [ h, r ] of this._$_cndsBySid$_) r._$_LoadFromJson$_(s.get(h) || null);
        }
        _$_SaveActsToJson$_() {
            const t = {};
            for (const [ s, i ] of this._$_actsBySid$_) {
                const e = i._$_SaveToJson$_();
                e && (t[s.toString()] = e);
            }
            return t;
        }
        _$_LoadActsFromJson$_(t) {
            const s = new Map();
            for (const [ i, e ] of Object.entries(t)) s.set(parseInt(i, 10), e);
            for (const [ h, r ] of this._$_actsBySid$_) r._$_LoadFromJson$_(s.get(h) || null);
        }
        _$_SaveVarsToJson$_() {
            const t = {};
            for (const [ s, i ] of this._$_eventVarsBySid$_) i._$IsConstant$_() || !i._$IsGlobal$_() && !i._$IsStatic$_() || (t[s.toString()] = i._$GetValue$_());
            return t;
        }
        _$_LoadVarsFromJson$_(t) {
            for (const [ s, i ] of Object.entries(t)) {
                const e = parseInt(s, 10), h = this._$GetEventVariableBySID$_(e);
                h && h._$SetValue$_(i);
            }
        }
        _$_SaveScheduledWaitsToJson$_() {
            return this._$_scheduledWaits$_.filter(t => !t._$IsPromise$_()).map(t => t._$_SaveToJson$_());
        }
        _$_LoadScheduledWaitsFromJson$_(t) {
            this._$ClearAllScheduledWaits$_();
            for (const s of t) {
                const i = xo._$ScheduledWait$_._$_CreateFromJson$_(this, s);
                i && this._$_scheduledWaits$_.push(i);
            }
        }
        _$_GetPerfRecords$_() {
            return [ ...this._$_runtime$_._$GetLayoutManager$_()._$runningLayouts$_() ].map(t => t._$GetEventSheet$_()).filter(t => t).map(t => t._$_GetPerfRecord$_());
        }
        _$FindFirstFunctionBlockParent$_(t) {
            for (;t; ) {
                const s = t._$GetScopeParent$_();
                if (s instanceof xo._$FunctionBlock$_) return s;
                t = s;
            }
            return null;
        }
        _$_InvokeFunctionFromJS$_(t, s) {
            Array.isArray(s) || (s = []);
            const i = this._$GetFunctionBlockByName$_(t.toLowerCase());
            if (!i) return null;
            if (!i._$IsEnabled$_()) return i._$GetDefaultReturnValue$_();
            const e = i._$GetFunctionParameters$_();
            if (s.length < e.length) for (s = s.slice(0); s.push(e[s.length]._$GetInitialValue$_()), 
            s.length < e.length; );
            const h = i._$GetEventBlock$_();
            return h._$RunAsExpressionFunctionCall$_(h._$GetSolModifiersIncludingParents$_(), !1, i._$GetReturnType$_(), i._$GetDefaultReturnValue$_(), ...s);
        }
    };
}

{
    const Go = self._$C3$_;
    Go._$EventSheet$_ = class extends Go._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_eventSheetManager$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), 
            this._$_name$_ = s[0], this._$_events$_ = [], this._$_triggers$_ = new Map(), 
            this._$_fastTriggers$_ = new Map(), this._$_eventsByDisplayNumber$_ = new Map(), 
            this._$_hasRun$_ = !1, this._$_shallowIncludes$_ = [], this._$_deepIncludes$_ = [], 
            this._$_alreadyIncludedSheets$_ = new Set();
            for (const i of s[1]) this._$_CreateEvent$_(i, null, this._$_events$_);
            this._$_perfRecord$_ = this._$_runtime$_._$IsDebug$_() ? {
                type: "sheet",
                name: this._$_name$_,
                _$totalTimeCounter$_: 0,
                children: []
            } : null;
        }
        _$Release$_() {
            this._$_eventSheetManager$_ = null, this._$_runtime$_ = null;
        }
        _$_CreateEvent$_(t, s, i) {
            switch (t[0]) {
              case 0:
              case 3:
                this._$_CreateEventBlock$_(t, s, i);
                break;

              case 1:
                this._$_CreateEventVariable$_(t, s, i);
                break;

              case 2:
                this._$_CreateInclude$_(t, s, i);
                break;

              case 4:
                this._$_CreateFunctionBlock$_(t, s);
                break;

              case 5:
                this._$_CreateScriptBlock$_(t, s, i);
                break;

              case 6:
                this._$_CreateCustomACEBlock$_(t, s);
                break;

              default:
                throw new Error("invalid event type");
            }
        }
        _$_CreateEventBlock$_(t, s, i) {
            const e = Go._$EventBlock$_._$Create$_(this, s, t);
            if (e._$IsOrBlock$_()) {
                i.push(e);
                const h = e._$GetConditions$_();
                for (let t = 0, s = h.length; t < s; ++t) h[t]._$IsTrigger$_() && this._$_InitTrigger$_(e, t);
            } else e._$IsTrigger$_() ? this._$_InitTrigger$_(e, 0) : i.push(e);
        }
        _$_CreateFunctionBlock$_(t, s) {
            const i = Go._$FunctionBlock$_._$CreateFunctionBlock$_(this, s, t);
            this._$_eventSheetManager$_._$_RegisterFunctionBlock$_(i);
        }
        _$_CreateCustomACEBlock$_(t, s) {
            const i = Go._$FunctionBlock$_._$CreateCustomACEBlock$_(this, s, t);
            this._$_eventSheetManager$_._$_RegisterFunctionBlock$_(i);
        }
        _$_CreateEventVariable$_(t, s, i) {
            const e = Go._$EventVariable$_._$Create$_(this, s, t);
            i.push(e);
        }
        _$_CreateInclude$_(t, s, i) {
            const e = Go._$EventInclude$_._$Create$_(this, s, t);
            i.push(e);
        }
        _$_CreateScriptBlock$_(t, s, i) {
            const e = Go._$EventScript$_._$Create$_(this, s, t);
            i.push(e);
        }
        _$_InitTrigger$_(h, r) {
            h._$IsOrBlock$_() || this._$_eventSheetManager$_._$_AddTriggerToPostInit$_(h);
            const n = h._$GetConditionAt$_(r), o = n._$_GetFunc$_(), a = n._$GetObjectClass$_();
            if (n._$IsFastTrigger$_()) {
                let t = this._$_fastTriggers$_.get(a), s = (t || (t = new Map(), 
                this._$_fastTriggers$_.set(a, t)), n._$GetFastTriggerValue$_().toLowerCase()), i = t.get(o), e = (i || (i = new Map(), 
                t.set(o, i)), i.get(s));
                e || (e = [], i.set(s, e)), e.push([ h, r ]);
            } else {
                let t = this._$_triggers$_.get(a), s = (t || (t = {
                    _$methodMap$_: new Map(),
                    _$behaviors$_: new Map()
                }, this._$_triggers$_.set(a, t)), n._$GetBehaviorType$_()), i, e = (s ? (i = t._$behaviors$_.get(s)) || (i = new Map(), 
                t._$behaviors$_.set(s, i)) : i = t._$methodMap$_, i.get(o));
                e || (e = [], i.set(o, e)), e.push([ h, r ]);
            }
        }
        _$_PostInit$_() {
            const i = this._$_events$_;
            for (let t = 0, s = i.length; t < s; ++t) {
                const e = t < s - 1 && i[t + 1] instanceof Go._$EventBlock$_ && i[t + 1]._$IsElseBlock$_();
                i[t]._$_PostInit$_(e);
            }
        }
        _$_AddShallowInclude$_(t) {
            this._$_shallowIncludes$_.push(t);
        }
        _$_UpdateDeepIncludes$_() {
            Go._$clearArray$_(this._$_deepIncludes$_), this._$_AddDeepIncludes$_(this), 
            this._$_alreadyIncludedSheets$_.clear();
        }
        _$_AddDeepIncludes$_(t) {
            const s = t._$_deepIncludes$_, i = t._$_alreadyIncludedSheets$_;
            for (const e of this._$_shallowIncludes$_) {
                const h = e._$GetIncludeSheet$_();
                e._$IsActive$_() && t !== h && !i.has(h) && (i.add(h), h._$_AddDeepIncludes$_(t), 
                s.push(h));
            }
        }
        _$deepIncludes$_() {
            return this._$_deepIncludes$_;
        }
        _$GetEventSheetManager$_() {
            return this._$_eventSheetManager$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$_RegisterEventByDisplayNumber$_(t, s) {
            this._$_eventsByDisplayNumber$_.set(s, t);
        }
        _$_GetEventByDisplayNumber$_(t) {
            return this._$_eventsByDisplayNumber$_.get(t) || null;
        }
        _$_ResetHasRunFlag$_() {
            this._$_hasRun$_ = !1;
        }
        _$Run$_() {
            if (!this._$_hasRun$_) {
                const t = this._$_runtime$_, s = t._$IsCPUProfiling$_(), i = s ? performance.now() : 0, e = (this._$_hasRun$_ = !0, 
                this._$GetEventSheetManager$_()), h = e._$GetCurrentEventStackFrame$_();
                for (const r of this._$_events$_) r._$Run$_(h), e._$ClearSol$_(r._$GetSolModifiers$_()), 
                e._$ClearAsyncActionPromises$_(), t._$FlushPendingInstances$_();
                h._$Reset$_(null), s && (this._$_perfRecord$_._$totalTimeCounter$_ += performance.now() - i);
            }
        }
        *_$DebugRun$_() {
            if (!this._$_hasRun$_) {
                this._$_hasRun$_ = !0;
                const t = this._$_runtime$_, s = this._$GetEventSheetManager$_(), i = s._$GetCurrentEventStackFrame$_();
                for (const e of this._$_events$_) yield* e._$DebugRun$_(i), s._$ClearSol$_(e._$GetSolModifiers$_()), 
                s._$ClearAsyncActionPromises$_(), t._$FlushPendingInstances$_();
                i._$Reset$_(null);
            }
        }
        _$_Trigger$_(e, h, r) {
            if (!h) return this._$_TriggerForClass$_(e, h, null, null);
            {
                let t = h._$GetObjectClass$_(), s = !1, i = this._$_TriggerForClass$_(e, h, t, r);
                s = s || i;
                for (const n of t._$GetFamilies$_()) i = this._$_TriggerForClass$_(e, h, n, r), 
                s = s || i;
            }
        }
        _$_TriggerForClass$_(t, s, i, e) {
            const h = this._$_triggers$_.get(i);
            if (!h) return !1;
            const r = e ? h._$behaviors$_.get(e) : h._$methodMap$_;
            if (!r) return !1;
            const n = r.get(t);
            if (!n) return !1;
            let o = !1;
            for (const [ a, l ] of n) {
                const u = this._$_ExecuteTrigger$_(s, a, l);
                o = o || u;
            }
            return o;
        }
        *_$_DebugTrigger$_(e, h, r) {
            if (!h) return yield* this._$_DebugTriggerForClass$_(e, h, null, null);
            {
                let t = h._$GetObjectClass$_(), s = !1, i = yield* this._$_DebugTriggerForClass$_(e, h, t, r);
                s = s || i;
                for (const n of t._$GetFamilies$_()) i = yield* this._$_DebugTriggerForClass$_(e, h, n, r), 
                s = s || i;
            }
        }
        *_$_DebugTriggerForClass$_(t, s, i, e) {
            const h = this._$_triggers$_.get(i);
            if (!h) return !1;
            const r = e ? h._$behaviors$_.get(e) : h._$methodMap$_;
            if (!r) return !1;
            const n = r.get(t);
            if (!n) return !1;
            let o = !1;
            for (const [ a, l ] of n) {
                let t;
                t = a._$DebugCanRunFast$_() ? this._$_ExecuteTrigger$_(s, a, l) : yield* this._$_DebugExecuteTrigger$_(s, a, l), 
                o = o || t;
            }
            return o;
        }
        _$_FastTrigger$_(t, s, i) {
            const e = s._$GetObjectClass$_(), h = this._$_fastTriggers$_.get(e);
            if (!h) return !1;
            const r = h.get(t);
            if (!r) return !1;
            const n = r.get(i);
            if (!n) return !1;
            let o = !1;
            for (let t = 0, s = n.length; t < s; ++t) {
                const a = n[t], l = this._$_ExecuteTrigger$_(null, a[0], a[1]);
                o = o || l;
            }
            return o;
        }
        *_$_DebugFastTrigger$_(t, s, i) {
            const e = s._$GetObjectClass$_(), h = this._$_fastTriggers$_.get(e);
            if (!h) return !1;
            const r = h.get(t);
            if (!r) return !1;
            const n = r.get(i);
            if (!n) return !1;
            let o = !1;
            for (let h = 0, t = n.length; h < t; ++h) {
                let t = n[h], s = t[0], i = t[1], e;
                e = s._$DebugCanRunFast$_() ? this._$_ExecuteTrigger$_(null, s, i) : yield* this._$_DebugExecuteTrigger$_(null, s, i), 
                o = o || e;
            }
            return o;
        }
        _$_ExecuteTrigger$_(t, s, i) {
            let e = this._$_runtime$_, h = this._$_eventSheetManager$_, r = h._$GetCurrentEvent$_(), n = h._$GetEventStack$_(), o = h._$GetTriggerDepth$_(), a = !1;
            r && h._$PushCleanSol$_(r._$GetSolModifiersIncludingParents$_()), h._$PushCleanSol$_(s._$GetSolModifiersIncludingParents$_());
            const l = 1 < o, u = (l && h._$GetLocalVarStack$_()._$Push$_(), n._$Push$_(s));
            if (t) {
                const f = s._$GetConditions$_()[i]._$GetObjectClass$_(), d = f._$GetCurrentSol$_();
                d._$SetSinglePicked$_(t), t._$IsInContainer$_() && t._$SetSiblingsSinglePicked$_();
            }
            let c = !0;
            if (s._$GetParent$_()) {
                const p = s._$GetTriggerParents$_();
                for (let t = 0, s = p.length; t < s; ++t) if (!p[t]._$RunPreTrigger$_(u)) {
                    c = !1;
                    break;
                }
            }
            return c && (s._$IsOrBlock$_() ? s._$RunOrBlockTrigger$_(u, i) : s._$Run$_(u), 
            a = u._$GetLastEventTrue$_()), n._$Pop$_(), l && h._$GetLocalVarStack$_()._$Pop$_(), 
            h._$PopSol$_(s._$GetSolModifiersIncludingParents$_()), r && h._$PopSol$_(r._$GetSolModifiersIncludingParents$_()), 
            r || 1 !== o || (h._$ClearAsyncActionPromises$_(), h._$IsFlushingBlocked$_()) || e._$FlushPendingInstances$_(), 
            a;
        }
        *_$_DebugExecuteTrigger$_(t, s, i) {
            let e = this._$_runtime$_, h = this._$_eventSheetManager$_, r = h._$GetCurrentEvent$_(), n = h._$GetEventStack$_(), o = h._$GetTriggerDepth$_(), a = !1;
            r && h._$PushCleanSol$_(r._$GetSolModifiersIncludingParents$_()), h._$PushCleanSol$_(s._$GetSolModifiersIncludingParents$_());
            const l = 1 < o, u = (l && h._$GetLocalVarStack$_()._$Push$_(), n._$Push$_(s));
            if (t) {
                const f = s._$GetConditions$_()[i]._$GetObjectClass$_(), d = f._$GetCurrentSol$_();
                d._$SetSinglePicked$_(t), t._$IsInContainer$_() && t._$SetSiblingsSinglePicked$_();
            }
            let c = !0;
            if (s._$GetParent$_()) {
                const p = s._$GetTriggerParents$_();
                for (let t = 0, s = p.length; t < s; ++t) if (!(yield* p[t]._$DebugRunPreTrigger$_(u))) {
                    c = !1;
                    break;
                }
            }
            return c && (s._$IsOrBlock$_() ? yield* s._$DebugRunOrBlockTrigger$_(u, i) : yield* s._$DebugRun$_(u), 
            a = u._$GetLastEventTrue$_()), n._$Pop$_(), l && h._$GetLocalVarStack$_()._$Pop$_(), 
            h._$PopSol$_(s._$GetSolModifiersIncludingParents$_()), r && h._$PopSol$_(r._$GetSolModifiersIncludingParents$_()), 
            r || 1 !== o || (h._$ClearAsyncActionPromises$_(), h._$IsFlushingBlocked$_()) || e._$FlushPendingInstances$_(), 
            a;
        }
        _$_GetPerfRecord$_() {
            return this._$_perfRecord$_;
        }
    };
}

{
    let u = function(t, s) {
        return !0;
    };
    u;
    const To = self._$C3$_, _o = [];
    function* N(t, s) {
        return !0;
    }
    To._$EventBlock$_ = class extends To._$DefendedBase$_ {
        constructor(t, s, i) {
            super(), this._$_eventSheet$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), 
            this._$_parent$_ = s, this._$_scopeParent$_ = null, this._$_eventStack$_ = this._$_runtime$_._$GetEventSheetManager$_()._$GetEventStack$_(), 
            this._$_solModifiers$_ = [], this._$_solModifiersIncludingParents$_ = [], 
            this._$_hasGotSolModifiersIncludingParents$_ = !1, this._$_isSolWriterAfterCnds$_ = !1, 
            this._$_isTopLevelGroup$_ = !1, this._$_hasElseBlock$_ = !1, this._$_isOrBlock$_ = !!i[2], 
            this._$_isElseBlock$_ = !1, this._$_triggerParents$_ = null, this._$_conditions$_ = [], 
            this._$_actions$_ = [], this._$_subEvents$_ = [], this._$_RunActions$_ = u, 
            this._$_DebugRunActions$_ = N, this._$_isGroup$_ = !1, this._$_isInitiallyActive$_ = !1, 
            this._$_groupName$_ = "", this._$_isGroupActive$_ = !1, this._$_containedIncludes$_ = null, 
            this._$_perfRecord$_ = null, this._$_sid$_ = i[4], this._$_displayNumber$_ = i[5], 
            this._$_eventSheet$_._$_RegisterEventByDisplayNumber$_(this, this._$_displayNumber$_), 
            this._$_debugData$_ = this._$_runtime$_._$IsDebug$_() ? {
                _$isBreakpoint$_: i[3][0],
                _$isBreakable$_: i[3][1],
                _$canRunAllConditionsFast$_: !1,
                _$canRunAllActionsFast$_: !1,
                _$canRunAllSubEventsFast$_: !1,
                _$canRunSelfFast$_: !1
            } : null, this._$GetEventSheetManager$_()._$_RegisterEventBlock$_(this), 
            3 === i[0] && this._$_InitGroup$_(i[1]);
            let e = 0;
            for (const h of i[6]) {
                const r = To._$Condition$_._$Create$_(this, h, e++);
                this._$_conditions$_.push(r), this._$_AddSolModifier$_(r._$GetObjectClass$_());
            }
            e = 0;
            for (const n of i[7]) {
                const o = To._$Action$_._$Create$_(this, n, e++);
                this._$_actions$_.push(o);
            }
            if (9 === i.length) {
                const a = i[8];
                for (const l of a) this._$_eventSheet$_._$_CreateEvent$_(l, this, this._$_subEvents$_);
            }
            this._$_conditions$_.length && (this._$_isElseBlock$_ = null === this._$_conditions$_[0]._$GetObjectClass$_() && this._$_conditions$_[0]._$_GetFunc$_() === To._$Plugins$_._$System$_._$Cnds$_._$Else$_), 
            0 === this._$_conditions$_.length && (this._$_conditions$_ = _o), 0 === this._$_actions$_.length && (this._$_actions$_ = _o), 
            0 === this._$_subEvents$_.length && (this._$_subEvents$_ = _o);
        }
        static _$Create$_(t, s, i) {
            return To._$New$_(To._$EventBlock$_, t, s, i);
        }
        _$_InitGroup$_(t) {
            this._$_isGroup$_ = !0, this._$_isInitiallyActive$_ = !!t[0], this._$_isGroupActive$_ = this._$_isInitiallyActive$_, 
            this._$_groupName$_ = t[1].toLowerCase(), this._$_containedIncludes$_ = [], 
            this._$GetEventSheetManager$_()._$_RegisterGroup$_(this), this._$_runtime$_._$IsDebug$_() && (this._$_perfRecord$_ = {
                type: "group",
                name: t[1],
                _$totalTimeCounter$_: 0,
                children: []
            });
        }
        _$_AddContainedInclude$_(t) {
            this._$_containedIncludes$_.push(t);
        }
        _$_AddContainerSolModifierToList$_(t, s) {
            for (const i of t._$GetContainer$_()._$objectTypes$_()) s.includes(i) || s.push(i);
        }
        _$_AddSolModifierToList$_(t, s) {
            if (t) if (s.includes(t) || s.push(t), t._$IsFamily$_()) for (const i of t._$GetFamilyMembers$_()) i._$IsInContainer$_() && this._$_AddContainerSolModifierToList$_(i, s); else t._$IsInContainer$_() && this._$_AddContainerSolModifierToList$_(t, s);
        }
        _$_AddSolModifier$_(t) {
            this._$_AddSolModifierToList$_(t, this._$_solModifiers$_);
        }
        _$_AddParentSolModifier$_(t) {
            this._$_AddSolModifierToList$_(t, this._$_solModifiersIncludingParents$_);
        }
        _$SetAllSolModifiers$_() {
            this._$_solModifiers$_ = this._$_runtime$_._$GetAllObjectClasses$_();
        }
        _$_PostInit$_(t) {
            this._$_hasElseBlock$_ = !!t, this._$_IdentifyTopLevelGroup$_(), this._$_IdentifyTriggerParents$_();
            for (const s of this._$_conditions$_) s._$_PostInit$_();
            if (0 < this._$_actions$_.length) {
                let t = !1;
                for (const e of this._$_actions$_) e._$_PostInit$_(), e._$HasReturnType$_() && (t = !0);
                t ? (this._$_RunActions$_ = this._$_RunActions_ReturnValue$_, this._$_DebugRunActions$_ = this._$_DebugRunActions_ReturnValue$_) : (this._$_RunActions$_ = this._$_RunActions_Fast$_, 
                this._$_DebugRunActions$_ = this._$_DebugRunActions_Fast$_);
            }
            const i = this._$_subEvents$_;
            for (let t = 0, s = i.length; t < s; ++t) {
                const h = t < s - 1 && i[t + 1] instanceof To._$EventBlock$_ && i[t + 1]._$IsElseBlock$_();
                i[t]._$_PostInit$_(h);
            }
            this._$_debugData$_ && this._$_UpdateCanRunFast$_(), this._$_perfRecord$_ && this._$_GetPerfRecordParent$_()._$_GetPerfRecord$_().children.push(this._$_perfRecord$_);
        }
        _$_GetPerfRecord$_() {
            return this._$_perfRecord$_;
        }
        _$_GetPerfRecordParent$_() {
            let t = this._$GetParent$_();
            for (;t; ) {
                if (t._$IsGroup$_()) return t;
                t = t._$GetParent$_();
            }
            return this._$_eventSheet$_;
        }
        _$_UpdateCanRunFast$_() {
            const t = this._$_debugData$_;
            t._$canRunAllConditionsFast$_ = this._$_conditions$_.every(t => t._$DebugCanRunFast$_()), 
            t._$canRunAllActionsFast$_ = this._$_actions$_.every(t => t._$DebugCanRunFast$_()), 
            t._$canRunAllSubEventsFast$_ = this._$_subEvents$_.every(t => t._$DebugCanRunFast$_()), 
            t._$canRunSelfFast$_ = t._$canRunAllConditionsFast$_ && t._$canRunAllActionsFast$_ && t._$canRunAllSubEventsFast$_;
        }
        _$_UpdateCanRunFastRecursive$_() {
            let t = this;
            for (;t._$_UpdateCanRunFast$_(), t = t._$GetParent$_(); );
        }
        _$_IdentifyTopLevelGroup$_() {
            if (this._$IsGroup$_()) {
                let t = this._$GetParent$_();
                for (this._$_isTopLevelGroup$_ = !0; t; ) {
                    if (!t._$IsGroup$_()) {
                        this._$_isTopLevelGroup$_ = !1;
                        break;
                    }
                    t = t._$GetParent$_();
                }
            }
        }
        _$_IdentifySolModifiersIncludingParents$_() {
            const t = this._$_runtime$_._$GetAllObjectClasses$_();
            if (this._$_solModifiers$_ === t) this._$_solModifiersIncludingParents$_ = t; else {
                this._$_solModifiersIncludingParents$_ = To._$cloneArray$_(this._$_solModifiers$_);
                let t = this._$GetParent$_();
                for (;t; ) {
                    for (const i of t._$_solModifiers$_) this._$_AddParentSolModifier$_(i);
                    t = t._$GetParent$_();
                }
                const s = this._$GetEventSheetManager$_();
                this._$_solModifiers$_ = s._$_DeduplicateSolModifierList$_(this._$_solModifiers$_), 
                this._$_solModifiersIncludingParents$_ = s._$_DeduplicateSolModifierList$_(this._$_solModifiersIncludingParents$_);
            }
        }
        _$_IdentifyTriggerParents$_() {
            if (this._$HasAnyTriggeredCondition$_()) {
                this._$_triggerParents$_ = [];
                let t = this._$GetParent$_();
                for (;t; ) this._$_triggerParents$_.push(t), t = t._$GetParent$_();
                this._$_triggerParents$_.reverse();
            }
        }
        _$SetSolWriterAfterCnds$_() {
            this._$_isSolWriterAfterCnds$_ = !0, this._$_parent$_ && this._$_parent$_._$SetSolWriterAfterCnds$_();
        }
        _$IsSolWriterAfterCnds$_() {
            return this._$_isSolWriterAfterCnds$_;
        }
        _$GetSolModifiers$_() {
            return this._$_solModifiers$_;
        }
        _$GetSolModifiersIncludingParents$_() {
            return this._$_hasGotSolModifiersIncludingParents$_ || (this._$_hasGotSolModifiersIncludingParents$_ = !0, 
            this._$_IdentifySolModifiersIncludingParents$_()), this._$_solModifiersIncludingParents$_;
        }
        _$HasSolModifier$_(t) {
            return this._$_solModifiers$_.includes(t);
        }
        _$GetTriggerParents$_() {
            return this._$_triggerParents$_;
        }
        _$GetEventSheet$_() {
            return this._$_eventSheet$_;
        }
        _$GetEventSheetManager$_() {
            return this._$_eventSheet$_._$GetEventSheetManager$_();
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetParent$_() {
            return this._$_parent$_;
        }
        _$_SetScopeParent$_(t) {
            this._$_scopeParent$_ = t;
        }
        _$GetScopeParent$_() {
            return this._$_scopeParent$_ || this._$_parent$_;
        }
        _$GetDisplayNumber$_() {
            return this._$_displayNumber$_;
        }
        _$IsDebugBreakable$_() {
            return this._$_debugData$_ && this._$_debugData$_._$isBreakable$_;
        }
        _$IsDebugBreakpoint$_() {
            return this._$IsDebugBreakable$_() && this._$_debugData$_._$isBreakpoint$_;
        }
        _$_SetDebugBreakpoint$_(t) {
            this._$_debugData$_._$isBreakpoint$_ = !!t, this._$_UpdateCanRunFastRecursive$_();
        }
        _$IsGroup$_() {
            return this._$_isGroup$_;
        }
        _$IsTopLevelGroup$_() {
            return this._$_isTopLevelGroup$_;
        }
        _$IsElseBlock$_() {
            return this._$_isElseBlock$_;
        }
        _$HasElseBlock$_() {
            return this._$_hasElseBlock$_;
        }
        _$GetGroupName$_() {
            return this._$_groupName$_;
        }
        _$IsGroupActive$_() {
            return this._$_isGroupActive$_;
        }
        _$ResetInitialActivation$_() {
            this._$SetGroupActive$_(this._$_isInitiallyActive$_);
        }
        _$SetGroupActive$_(t) {
            if (t = !!t, !this._$_isGroup$_) throw new Error("not a group");
            if (this._$_isGroupActive$_ !== t) {
                this._$_isGroupActive$_ = t;
                for (const s of this._$_containedIncludes$_) s._$UpdateActive$_();
                if (this._$_containedIncludes$_.length) {
                    const i = this._$_runtime$_._$GetCurrentLayout$_(), e = i._$GetEventSheet$_();
                    e && e._$_UpdateDeepIncludes$_();
                }
            }
        }
        _$GetSID$_() {
            return this._$_sid$_;
        }
        _$IsOrBlock$_() {
            return this._$_isOrBlock$_;
        }
        _$IsTrigger$_() {
            return this._$_conditions$_.length && this._$_conditions$_[0]._$IsTrigger$_();
        }
        _$IsForFunctionBlock$_() {
            return this._$_scopeParent$_ && this._$_scopeParent$_ instanceof To._$FunctionBlock$_;
        }
        _$HasAnyTriggeredCondition$_() {
            return this._$IsForFunctionBlock$_() || this._$_conditions$_.some(t => t._$IsTrigger$_());
        }
        _$GetConditions$_() {
            return this._$_conditions$_;
        }
        _$GetConditionCount$_() {
            return this._$_conditions$_.length;
        }
        _$GetConditionAt$_(t) {
            if ((t = Math.floor(t)) < 0 || t >= this._$_conditions$_.length) throw new RangeError("invalid condition index");
            return this._$_conditions$_[t];
        }
        _$GetConditionByDebugIndex$_(t) {
            return this._$GetConditionAt$_(t);
        }
        _$IsFirstConditionOfType$_(t) {
            let s = t._$GetIndex$_();
            if (0 !== s) {
                --s;
                const i = t._$IsSystemOrSingleGlobalCondition$_() ? t._$GetFirstObjectParameterObjectClass$_() : t._$GetObjectClass$_();
                for (;0 <= s; --s) {
                    const e = this._$_conditions$_[s];
                    if (i === e._$GetObjectClass$_() || e._$IsSystemOrSingleGlobalCondition$_() && e._$GetFirstObjectParameterObjectClass$_() === i) return !1;
                }
            }
            return !0;
        }
        _$GetActions$_() {
            return this._$_actions$_;
        }
        _$GetActionCount$_() {
            return this._$_actions$_.length;
        }
        _$GetActionAt$_(t) {
            if ((t = Math.floor(t)) < 0 || t >= this._$_actions$_.length) throw new RangeError("invalid action index");
            return this._$_actions$_[t];
        }
        _$GetActionByDebugIndex$_(s) {
            s = Math.floor(s);
            const t = this._$_actions$_.find(t => t._$GetDebugIndex$_() === s);
            if (t) return t;
            throw new RangeError("invalid action debug index");
        }
        _$_HasActionIndex$_(t) {
            return 0 <= (t = Math.floor(t)) && t < this._$_actions$_.length;
        }
        _$GetSubEvents$_() {
            return this._$_subEvents$_;
        }
        _$_GetAllLocalVariablesInScope$_() {
            return this._$_subEvents$_.filter(t => t instanceof To._$EventVariable$_);
        }
        _$RunPreTrigger$_(i) {
            i._$SetCurrentEvent$_(this);
            let e = this._$_conditions$_, h = 0 === e.length;
            for (let t = 0, s = e.length; t < s; ++t) {
                const r = e[t];
                if (i._$SetConditionIndex$_(t), r._$IsLooping$_()) throw new Error("trigger cannot be used as sub-event to a loop");
                if (r._$Run$_()) h = !0; else if (!this._$_isOrBlock$_) return !1;
            }
            return !this._$_isOrBlock$_ || h;
        }
        _$RunOrBlockTrigger$_(t, s) {
            t._$SetCurrentEvent$_(this), t._$SetConditionIndex$_(s), this._$_conditions$_[s]._$Run$_() && (this._$_RunActions$_(t, 0) && this._$_RunSubEvents$_(t), 
            t._$SetLastEventTrue$_(!0));
        }
        *_$DebugRunPreTrigger$_(i) {
            i._$SetCurrentEvent$_(this);
            let e = this._$_conditions$_, h = 0 === e.length;
            for (let s = 0, t = e.length; s < t; ++s) {
                const r = e[s];
                if (i._$SetConditionIndex$_(s), r._$IsLooping$_()) throw new Error("trigger cannot be used as sub-event to a loop");
                let t;
                if (t = r._$DebugCanRunFast$_() ? r._$Run$_() : yield* r._$DebugRun$_()) h = !0; else if (!this._$_isOrBlock$_) return !1;
            }
            return !this._$_isOrBlock$_ || h;
        }
        *_$DebugRunOrBlockTrigger$_(s, t) {
            s._$SetCurrentEvent$_(this), s._$SetConditionIndex$_(t);
            let i = this._$_conditions$_[t], e;
            if (e = i._$DebugCanRunFast$_() ? i._$Run$_() : yield* i._$DebugRun$_()) {
                let t;
                (t = this._$DebugCanRunActionsFast$_() ? this._$_RunActions$_(s, 0) : yield* this._$_DebugRunActions$_(s, 0)) && (this._$DebugCanRunSubEventsFast$_() ? this._$_RunSubEvents$_() : yield* this._$_DebugRunSubEvents$_()), 
                s._$SetLastEventTrue$_(!0);
            }
        }
        _$Run$_(t) {
            t._$SetCurrentEvent$_(this), this._$_isElseBlock$_ || t._$SetElseBranchRan$_(!1), 
            this._$_isOrBlock$_ ? this._$_RunOrBlock$_(t) : this._$_RunAndBlock$_(t);
        }
        *_$DebugRun$_(t) {
            (this._$IsDebugBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            t._$SetCurrentEvent$_(this), this._$_isElseBlock$_ || t._$SetElseBranchRan$_(!1), 
            this._$_isOrBlock$_ ? yield* this._$_DebugRunOrBlock$_(t) : yield* this._$_DebugRunAndBlock$_(t);
        }
        _$_RunOrBlock$_(i) {
            let e = this._$_conditions$_, h = 0 === e.length;
            for (let t = 0, s = e.length; t < s; ++t) {
                const r = e[t];
                if (!r._$IsTrigger$_()) {
                    i._$SetConditionIndex$_(t);
                    const n = r._$Run$_();
                    h = h || n;
                }
            }
            i._$SetLastEventTrue$_(h), h && (this._$_RunActions$_(i, 0) && this._$_RunSubEvents$_(i), 
            this._$_hasElseBlock$_) && i._$SetElseBranchRan$_(!0);
        }
        *_$_DebugRunOrBlock$_(i) {
            let e = this._$_conditions$_, h = 0 === e.length;
            for (let s = 0, t = e.length; s < t; ++s) {
                const r = e[s];
                if (!r._$IsTrigger$_()) {
                    i._$SetConditionIndex$_(s);
                    let t;
                    t = r._$DebugCanRunFast$_() ? r._$Run$_() : yield* r._$DebugRun$_(), 
                    h = h || t;
                }
            }
            if (i._$SetLastEventTrue$_(h), h) {
                let t;
                (t = this._$DebugCanRunActionsFast$_() ? this._$_RunActions$_(i, 0) : yield* this._$_DebugRunActions$_(i, 0)) && (this._$DebugCanRunSubEventsFast$_() ? this._$_RunSubEvents$_() : yield* this._$_DebugRunSubEvents$_()), 
                this._$_hasElseBlock$_ && i._$SetElseBranchRan$_(!0);
            }
        }
        _$_RunAndBlock$_(i) {
            const e = this._$_conditions$_;
            for (let t = 0, s = e.length; t < s; ++t) {
                const h = e[t], r = (i._$SetConditionIndex$_(t), h._$Run$_());
                if (!r) return void i._$SetLastEventTrue$_(!1);
            }
            i._$SetLastEventTrue$_(!0), this._$_RunActions$_(i, 0) && this._$_RunSubEvents$_(i), 
            i._$GetLastEventTrue$_() && this._$_hasElseBlock$_ && i._$SetElseBranchRan$_(!0);
        }
        *_$_DebugRunAndBlock$_(i) {
            const e = this._$_conditions$_;
            for (let s = 0, t = e.length; s < t; ++s) {
                const h = e[s];
                i._$SetConditionIndex$_(s);
                let t;
                if (!(t = h._$DebugCanRunFast$_() ? h._$Run$_() : yield* h._$DebugRun$_())) return void i._$SetLastEventTrue$_(!1);
            }
            i._$SetLastEventTrue$_(!0);
            let t;
            (t = this._$DebugCanRunActionsFast$_() ? this._$_RunActions$_(i, 0) : yield* this._$_DebugRunActions$_(i, 0)) && (this._$DebugCanRunSubEventsFast$_() ? this._$_RunSubEvents$_() : yield* this._$_DebugRunSubEvents$_()), 
            i._$GetLastEventTrue$_() && this._$_hasElseBlock$_ && i._$SetElseBranchRan$_(!0);
        }
        _$_RunActions_Fast$_(i, e) {
            const h = this._$_actions$_;
            for (let t = e, s = h.length; t < s; ++t) {
                const r = h[t];
                i._$SetActionIndex$_(t), r._$Run$_();
            }
            return !0;
        }
        *_$_DebugRunActions_Fast$_(i, e) {
            const h = this._$_actions$_;
            for (let t = e, s = h.length; t < s; ++t) {
                const r = h[t];
                i._$SetActionIndex$_(t), r._$DebugCanRunFast$_() ? r._$Run$_() : yield* r._$DebugRun$_();
            }
            return !0;
        }
        _$_RunActions_ReturnValue$_(i, e) {
            const h = this._$GetEventSheetManager$_(), r = this._$_actions$_;
            for (let t = e, s = r.length; t < s; ++t) {
                const n = r[t], o = (i._$SetActionIndex$_(t), n._$Run$_());
                if (n._$CanBailOut$_() && !0 === o) return !1;
                n._$IsAsync$_() && o instanceof Promise && h._$AddAsyncActionPromise$_(o);
            }
            return !0;
        }
        *_$_DebugRunActions_ReturnValue$_(i, e) {
            const h = this._$GetEventSheetManager$_(), r = this._$_actions$_;
            for (let s = e, t = r.length; s < t; ++s) {
                const n = r[s];
                i._$SetActionIndex$_(s);
                let t;
                if (t = n._$DebugCanRunFast$_() ? n._$Run$_() : yield* n._$DebugRun$_(), 
                n._$CanBailOut$_() && !0 === t) return !1;
                n._$IsAsync$_() && t instanceof Promise && h._$AddAsyncActionPromise$_(t);
            }
            return !0;
        }
        _$_ResumeActionsAndSubEvents$_(t) {
            this._$_RunActions$_(t, t._$GetActionIndex$_()) && this._$_RunSubEvents$_();
        }
        *_$_DebugResumeActionsAndSubEvents$_(t) {
            (yield* this._$_DebugRunActions$_(t, t._$GetActionIndex$_())) && (yield* this._$_DebugRunSubEvents$_());
        }
        _$_RunSubEvents$_() {
            if (this._$_subEvents$_.length) {
                const t = this._$IsGroup$_() && this._$_runtime$_._$IsCPUProfiling$_(), s = t ? performance.now() : 0, i = this._$_eventStack$_, e = i._$Push$_(this);
                this._$_isSolWriterAfterCnds$_ ? this._$_RunSubEvents_SolWriterAfterCnds$_(e) : this._$_RunSubEvents_Fast$_(e), 
                i._$Pop$_(), t && (this._$_perfRecord$_._$totalTimeCounter$_ += performance.now() - s);
            }
        }
        _$_RunSubEvents_SolWriterAfterCnds$_(e) {
            const h = this._$_isGroup$_, r = this._$_isTopLevelGroup$_, n = this._$GetEventSheetManager$_(), o = this._$_subEvents$_;
            for (let t = 0, s = o.length, i = s - 1; t < s; ++t) {
                const a = o[t], l = a._$GetSolModifiers$_(), u = !r || !h && t < i;
                u && n._$PushCopySol$_(l), a._$Run$_(e), u ? n._$PopSol$_(l) : n._$ClearSol$_(l);
            }
        }
        _$_RunSubEvents_Fast$_(i) {
            const e = this._$_subEvents$_;
            for (let t = 0, s = e.length; t < s; ++t) e[t]._$Run$_(i);
        }
        *_$_DebugRunSubEvents$_() {
            if (this._$_subEvents$_.length) {
                const t = this._$_eventStack$_, s = t._$Push$_(this);
                this._$_isSolWriterAfterCnds$_ ? yield* this._$_DebugRunSubEvents_SolWriterAfterCnds$_(s) : yield* this._$_DebugRunSubEvents_Fast$_(s), 
                t._$Pop$_();
            }
        }
        *_$_DebugRunSubEvents_SolWriterAfterCnds$_(e) {
            const h = this._$_isGroup$_, r = this._$_isTopLevelGroup$_, n = this._$GetEventSheetManager$_(), o = this._$_subEvents$_;
            for (let t = 0, s = o.length, i = s - 1; t < s; ++t) {
                const a = o[t], l = a._$GetSolModifiers$_(), u = !r || !h && t < i;
                u && n._$PushCopySol$_(l), yield* a._$DebugRun$_(e), u ? n._$PopSol$_(l) : n._$ClearSol$_(l);
            }
        }
        *_$_DebugRunSubEvents_Fast$_(i) {
            const e = this._$_subEvents$_;
            for (let t = 0, s = e.length; t < s; ++t) yield* e[t]._$DebugRun$_(i);
        }
        _$Retrigger$_(i, e) {
            e._$ResetQuick$_();
            const h = this._$_conditions$_;
            if (!this._$IsOrBlock$_()) for (let t = i._$GetConditionIndex$_() + 1, s = h.length; t < s; ++t) {
                const r = h[t], n = (e._$SetConditionIndex$_(t), r._$Run$_());
                if (!n) return !1;
            }
            return this._$_RunActions$_(e, 0) && this._$_RunSubEvents$_(e), !0;
        }
        *_$DebugRetrigger$_(i, e) {
            e._$ResetQuick$_();
            const h = this._$_conditions$_;
            if (!this._$IsOrBlock$_()) for (let s = i._$GetConditionIndex$_() + 1, t = h.length; s < t; ++s) {
                const r = h[s];
                e._$SetConditionIndex$_(s);
                let t;
                if (!(t = r._$DebugCanRunFast$_() ? r._$Run$_() : yield* r._$DebugRun$_())) return !1;
            }
            let t;
            return (t = this._$DebugCanRunActionsFast$_() ? this._$_RunActions$_(e, 0) : yield* this._$_DebugRunActions$_(e, 0)) && (this._$DebugCanRunSubEventsFast$_() ? this._$_RunSubEvents$_() : yield* this._$_DebugRunSubEvents$_()), 
            !0;
        }
        _$DebugCanRunFast$_() {
            return !this._$IsDebugBreakpoint$_() && !this._$_runtime$_._$DebugBreakNext$_() && this._$_debugData$_._$canRunSelfFast$_;
        }
        _$DebugCanRunActionsFast$_() {
            return !this._$_runtime$_._$DebugBreakNext$_() && this._$_debugData$_._$canRunAllActionsFast$_;
        }
        _$DebugCanRunSubEventsFast$_() {
            return !this._$_runtime$_._$DebugBreakNext$_() && this._$_debugData$_._$canRunAllSubEventsFast$_;
        }
        _$_CheckParentsOKToRun$_(i) {
            if (this._$GetParent$_()) {
                const e = this._$GetTriggerParents$_();
                for (let t = 0, s = e.length; t < s; ++t) if (!e[t]._$RunPreTrigger$_(i)) return !1;
            }
            return !0;
        }
        *_$_DebugCheckParentsOKToRun$_(i) {
            if (this._$GetParent$_()) {
                const e = this._$GetTriggerParents$_();
                for (let t = 0, s = e.length; t < s; ++t) if (!(yield* e[t]._$DebugRunPreTrigger$_(i))) return !1;
            }
            return !0;
        }
        _$_EvaluateFunctionCallParameters$_(t, s, i) {
            if (0 < s.length) if (i) {
                const e = s.map(t => t._$Get$_(0));
                t._$GetLocalVarStack$_()._$Push$_(), this._$_scopeParent$_._$SetFunctionParameters$_(e);
            } else this._$_scopeParent$_._$EvaluateFunctionParameters$_(s); else i && t._$GetLocalVarStack$_()._$Push$_();
        }
        _$RunAsFunctionCall$_(t, s, i, e) {
            let h, r, n = 0 < t.length, o = null, a = this._$_runtime$_, l = this._$_eventStack$_, u = a._$GetEventSheetManager$_(), c = u._$_IncTriggerDepth$_(), f = 1 < c;
            if (this._$_EvaluateFunctionCallParameters$_(u, s, f), n && (i ? u._$PushCopySol$_(t) : u._$PushCleanSol$_(t)), 
            null !== e) {
                if (e._$copyFromObjectClass$_) {
                    const p = i ? e._$copyFromObjectClass$_._$GetCurrentSol$_() : e._$copyFromObjectClass$_._$GetSolStack$_()._$GetOneBelowCurrentSol$_(), m = e._$copyToObjectClass$_._$GetCurrentSol$_();
                    m._$SetArrayPicked$_(p._$GetInstances$_()), m._$ClearElseInstances$_(), 
                    i || e._$copyToObjectClass$_._$ApplySolToContainer$_();
                } else if (e._$pickObjectClass$_) {
                    const g = e._$pickObjectClass$_._$GetCurrentSol$_();
                    g._$SetArrayPicked$_(e._$pickInstances$_), g._$ClearElseInstances$_();
                }
                e._$pushCleanSolDynamic$_ && (o = u._$PushCleanSolDynamic$_(t));
            }
            const d = l._$Push$_(this);
            if (i && d._$SetDynamicSolModifiers$_(t), this._$_CheckParentsOKToRun$_(d)) {
                d._$SetCurrentEvent$_(this);
                const y = this._$_scopeParent$_._$IsAsync$_();
                y && ([ r, h ] = this._$_scopeParent$_._$StartAsyncFunctionCall$_()), 
                this._$_RunAndBlock$_(d), y && this._$_scopeParent$_._$MaybeFinishAsyncFunctionCall$_(r);
            }
            return l._$Pop$_(), f && u._$GetLocalVarStack$_()._$Pop$_(), null !== o && u._$PopSol$_(o), 
            n && u._$PopSol$_(t), u._$_DecTriggerDepth$_(), h;
        }
        *_$DebugRunAsFunctionCall$_(t, s, i, e) {
            let h, r, n = ((this._$IsDebugBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            0 < t.length), o = null, a = this._$_runtime$_, l = this._$_eventStack$_, u = a._$GetEventSheetManager$_(), c = u._$_IncTriggerDepth$_(), f = 1 < c;
            if (this._$_EvaluateFunctionCallParameters$_(u, s, f), n && (i ? u._$PushCopySol$_(t) : u._$PushCleanSol$_(t)), 
            null !== e) {
                if (e._$copyFromObjectClass$_) {
                    const p = i ? e._$copyFromObjectClass$_._$GetCurrentSol$_() : e._$copyFromObjectClass$_._$GetSolStack$_()._$GetOneBelowCurrentSol$_(), m = e._$copyToObjectClass$_._$GetCurrentSol$_();
                    m._$SetArrayPicked$_(p._$GetInstances$_()), m._$ClearElseInstances$_(), 
                    i || e._$copyToObjectClass$_._$ApplySolToContainer$_();
                } else if (e._$pickObjectClass$_) {
                    const g = e._$pickObjectClass$_._$GetCurrentSol$_();
                    g._$SetArrayPicked$_(e._$pickInstances$_), g._$ClearElseInstances$_();
                }
                e._$pushCleanSolDynamic$_ && (o = u._$PushCleanSolDynamic$_(t));
            }
            const d = l._$Push$_(this);
            if (i && d._$SetDynamicSolModifiers$_(t), yield* this._$_DebugCheckParentsOKToRun$_(d)) {
                d._$SetCurrentEvent$_(this);
                const y = this._$_scopeParent$_._$IsAsync$_();
                y && ([ r, h ] = this._$_scopeParent$_._$StartAsyncFunctionCall$_()), 
                yield* this._$_DebugRunAndBlock$_(d), y && this._$_scopeParent$_._$MaybeFinishAsyncFunctionCall$_(r);
            }
            return l._$Pop$_(), f && u._$GetLocalVarStack$_()._$Pop$_(), null !== o && u._$PopSol$_(o), 
            n && u._$PopSol$_(t), u._$_DecTriggerDepth$_(), h;
        }
        _$RunAsMappedFunctionCall$_(t, s) {
            const i = this._$GetSolModifiersIncludingParents$_(), e = 0 < i.length, h = this._$_runtime$_, r = this._$_eventStack$_, n = h._$GetEventSheetManager$_(), o = n._$_IncTriggerDepth$_(), a = 1 < o, l = (a && n._$GetLocalVarStack$_()._$Push$_(), 
            this._$_scopeParent$_._$SetFunctionParameters$_(t), e && (s ? n._$PushCopySol$_(i) : n._$PushCleanSol$_(i)), 
            r._$Push$_(this));
            this._$_CheckParentsOKToRun$_(l) && (l._$SetCurrentEvent$_(this), this._$_RunAndBlock$_(l)), 
            r._$Pop$_(), a && n._$GetLocalVarStack$_()._$Pop$_(), e && n._$PopSol$_(i), 
            n._$_DecTriggerDepth$_();
        }
        *_$DebugRunAsMappedFunctionCall$_(t, s) {
            (this._$IsDebugBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this);
            const i = this._$GetSolModifiersIncludingParents$_(), e = 0 < i.length, h = this._$_runtime$_, r = this._$_eventStack$_, n = h._$GetEventSheetManager$_(), o = n._$_IncTriggerDepth$_(), a = 1 < o, l = (a && n._$GetLocalVarStack$_()._$Push$_(), 
            this._$_scopeParent$_._$SetFunctionParameters$_(t), e && (s ? n._$PushCopySol$_(i) : n._$PushCleanSol$_(i)), 
            r._$Push$_(this));
            (yield* this._$_DebugCheckParentsOKToRun$_(l)) && (l._$SetCurrentEvent$_(this), 
            yield* this._$_DebugRunAndBlock$_(l)), r._$Pop$_(), a && n._$GetLocalVarStack$_()._$Pop$_(), 
            e && n._$PopSol$_(i), n._$_DecTriggerDepth$_();
        }
        _$RunAsExpressionFunctionCall$_(t, s, i, e, ...h) {
            let r, n, o = 0 < t.length, a = this._$_runtime$_, l = this._$_eventStack$_, u = a._$GetEventSheetManager$_(), c = u._$_IncTriggerDepth$_(), f = 1 < c;
            f && u._$GetLocalVarStack$_()._$Push$_(), 0 < h.length && this._$_scopeParent$_._$SetFunctionParameters$_(h), 
            o && (s ? u._$PushCopySol$_(t) : u._$PushCleanSol$_(t));
            const d = l._$Push$_(this);
            if (d._$InitCallFunctionExpression$_(i, e), l._$PushExpFunc$_(d), a._$SetDebuggingEnabled$_(!1), 
            this._$_CheckParentsOKToRun$_(d)) {
                d._$SetCurrentEvent$_(this);
                const p = this._$_scopeParent$_._$IsAsync$_();
                p && ([ n, r ] = this._$_scopeParent$_._$StartAsyncFunctionCall$_()), 
                this._$_RunAndBlock$_(d), p && this._$_scopeParent$_._$MaybeFinishAsyncFunctionCall$_(n);
            }
            return a._$SetDebuggingEnabled$_(!0), l._$Pop$_(), l._$PopExpFunc$_(), 
            f && u._$GetLocalVarStack$_()._$Pop$_(), o && u._$PopSol$_(t), u._$_DecTriggerDepth$_(), 
            r || d._$GetFunctionReturnValue$_();
        }
    };
}

{
    let e = self._$C3$_, t = [], s = !1;
    e._$EventScript$_ = class extends e._$DefendedBase$_ {
        constructor(t, s, i) {
            super();
            const e = t._$GetRuntime$_(), h = t._$GetEventSheetManager$_(), r = (this._$_eventSheet$_ = t, 
            this._$_eventSheetManager$_ = h, this._$_runtime$_ = t._$GetRuntime$_(), 
            this._$_parent$_ = s, e._$GetObjectReference$_(i[1]));
            this._$_func$_ = r, this._$_displayNumber$_ = i[2], this._$_eventSheet$_._$_RegisterEventByDisplayNumber$_(this, this._$_displayNumber$_), 
            this._$_debugData$_ = e._$IsDebug$_() ? {
                _$isBreakpoint$_: i[3][0],
                _$isBreakable$_: i[3][1]
            } : null;
        }
        static _$Create$_(t, s, i) {
            return e._$New$_(e._$EventScript$_, t, s, i);
        }
        _$_PostInit$_() {
            const t = this._$_func$_, s = this._$_runtime$_._$GetEventSheetManager$_()._$_GetLocalVariablesScriptInterface$_(this);
            this._$_func$_ = t.bind(null, this._$_runtime$_._$GetIRuntime$_(), s);
        }
        _$GetParent$_() {
            return this._$_parent$_;
        }
        _$GetScopeParent$_() {
            return this._$_parent$_;
        }
        _$GetEventSheet$_() {
            return this._$_eventSheet$_;
        }
        _$GetDisplayNumber$_() {
            return this._$_displayNumber$_;
        }
        _$IsDebugBreakable$_() {
            return this._$_debugData$_ && this._$_debugData$_._$isBreakable$_;
        }
        _$IsDebugBreakpoint$_() {
            return this._$IsDebugBreakable$_() && this._$_debugData$_._$isBreakpoint$_;
        }
        _$_SetDebugBreakpoint$_(t) {
            this._$_debugData$_._$isBreakpoint$_ = !!t;
        }
        _$IsElseBlock$_() {
            return !1;
        }
        _$GetSolModifiers$_() {
            return t;
        }
        _$GetSolModifiersIncludingParents$_() {
            return this._$_parent$_ ? this._$_parent$_._$GetSolModifiersIncludingParents$_() : t;
        }
        _$Run$_(t) {
            t._$SetCurrentEvent$_(this), this._$_eventSheetManager$_._$AddAsyncActionPromise$_(this._$_RunUserScript$_());
        }
        async _$_RunUserScript$_() {
            try {
                await this._$_func$_();
            } catch (t) {
                console.error(`Unhandled exception running script %c${this._$GetEventSheet$_()._$GetName$_()}, event ${this._$GetDisplayNumber$_()}:`, "font-size: 1.2em; font-weight: bold;", t), 
                self.C3Debugger && self.C3Debugger._SetLastErrorScript(this), s || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), 
                s = !0);
            }
        }
        *_$DebugRun$_(t) {
            t._$SetCurrentEvent$_(this), (this._$IsDebugBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$Run$_(t);
        }
        _$DebugCanRunFast$_() {
            return !this._$IsDebugBreakpoint$_() && !this._$_runtime$_._$DebugBreakNext$_();
        }
        static _$HadUserScriptException$_() {
            return s;
        }
        static _$SetHadUserScriptException$_() {
            s = !0;
        }
    };
}

{
    const Io = self._$C3$_;
    Io._$FunctionBlock$_ = class extends Io._$DefendedBase$_ {
        constructor(t, s, i) {
            super(), this._$_eventSheet$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), 
            this._$_parent$_ = s, this._$_functionType$_ = 0, this._$_functionName$_ = "", 
            this._$_returnType$_ = 0, this._$_functionParameters$_ = [], this._$_isEnabled$_ = !0, 
            this._$_aceName$_ = "", this._$_objectClass$_ = null, this._$_hasOverrides$_ = !1, 
            this._$_innerLocalVariables$_ = [], this._$_isCopyPicked$_ = !1, this._$_isAsync$_ = !1, 
            this._$_nextAsyncId$_ = 0, this._$_currentAsyncId$_ = -1, this._$_asyncMap$_ = new Map(), 
            this._$_eventBlock$_ = Io._$EventBlock$_._$Create$_(t, s, i), this._$_eventBlock$_._$_SetScopeParent$_(this);
        }
        _$InitFunctionBlock$_(t) {
            this._$_functionType$_ = 0, this._$_functionName$_ = t[0], this._$_returnType$_ = t[1], 
            this._$_functionParameters$_ = t[2].map(t => Io._$EventVariable$_._$Create$_(this._$_eventSheet$_, this, t)), 
            this._$_isEnabled$_ = t[3], this._$_isAsync$_ = t[4], this._$_isCopyPicked$_ = t[5];
        }
        _$InitCustomACEBlock$_(t) {
            this._$_functionType$_ = 1, this._$_aceName$_ = t[1], this._$_objectClass$_ = this._$_runtime$_._$GetObjectClassByIndex$_(t[2]), 
            this._$_eventBlock$_._$_AddSolModifier$_(this._$_objectClass$_), this._$_functionName$_ = this._$_objectClass$_._$GetName$_() + "." + this._$_aceName$_, 
            this._$_returnType$_ = t[3], this._$_functionParameters$_ = t[4].map(t => Io._$EventVariable$_._$Create$_(this._$_eventSheet$_, this, t)), 
            this._$_isEnabled$_ = t[5], this._$_isAsync$_ = t[6], this._$_isCopyPicked$_ = t[7], 
            this._$_objectClass$_._$AddCustomAction$_(this);
        }
        static _$CreateFunctionBlock$_(t, s, i) {
            const e = Io._$New$_(Io._$FunctionBlock$_, t, s, i), h = i[1];
            return e._$InitFunctionBlock$_(h), e;
        }
        static _$CreateCustomACEBlock$_(t, s, i) {
            const e = Io._$New$_(Io._$FunctionBlock$_, t, s, i), h = i[1];
            return e._$InitCustomACEBlock$_(h), e;
        }
        _$_CheckOverrideState$_() {
            if (this._$_objectClass$_ && this._$_objectClass$_._$IsFamily$_()) for (const t of this._$_objectClass$_._$GetFamilyMembers$_()) if (t._$HasOwnCustomActionByName$_(this._$_aceName$_)) {
                this._$_hasOverrides$_ = !0;
                break;
            }
        }
        _$_PostInit$_() {
            for (const t of this._$_functionParameters$_) t._$_PostInit$_();
            this._$_eventBlock$_._$_PostInit$_(!1);
        }
        _$GetFunctionType$_() {
            return this._$_functionType$_;
        }
        _$_GetAllLocalVariablesInScope$_() {
            return this._$_functionParameters$_;
        }
        _$GetFunctionParameters$_() {
            return this._$_functionParameters$_;
        }
        _$GetFunctionParameterCount$_() {
            return this._$_functionParameters$_.length;
        }
        _$_RegisterLocalVariable$_(t) {
            this._$_innerLocalVariables$_.push(t);
        }
        _$_GetAllInnerLocalVariables$_() {
            return this._$_innerLocalVariables$_;
        }
        _$EvaluateFunctionParameters$_(i) {
            const e = this._$_functionParameters$_;
            for (let t = 0, s = e.length; t < s; ++t) e[t]._$SetValue$_(i[t]._$Get$_(0));
        }
        _$SetFunctionParameters$_(i) {
            const e = this._$_functionParameters$_;
            for (let t = 0, s = e.length; t < s; ++t) e[t]._$SetValue$_(i[t]);
        }
        _$CaptureFunctionParameters$_() {
            return this._$_functionParameters$_.map(t => t._$GetValue$_());
        }
        _$GetParent$_() {
            return this._$_parent$_;
        }
        _$GetScopeParent$_() {
            return this._$_parent$_;
        }
        _$GetFunctionName$_() {
            return this._$_functionName$_;
        }
        _$GetACEName$_() {
            return this._$_aceName$_;
        }
        _$HasCustomACEOverrides$_() {
            return this._$_hasOverrides$_;
        }
        _$GetReturnType$_() {
            return this._$_returnType$_;
        }
        _$GetObjectClass$_() {
            return this._$_objectClass$_;
        }
        _$IsEnabled$_() {
            return this._$_isEnabled$_;
        }
        _$GetDefaultReturnValue$_() {
            switch (this._$_returnType$_) {
              case 0:
                return null;

              case 2:
                return "";

              default:
                return 0;
            }
        }
        _$GetEventBlock$_() {
            return this._$_eventBlock$_;
        }
        _$IsCopyPicked$_() {
            return this._$_isCopyPicked$_;
        }
        _$IsAsync$_() {
            return this._$_isAsync$_;
        }
        _$StartAsyncFunctionCall$_() {
            const t = this._$_nextAsyncId$_++;
            this._$_currentAsyncId$_ = t;
            let s, i = new Promise(t => s = t);
            return this._$_asyncMap$_.set(t, {
                resolve: s,
                _$pauseCount$_: 0
            }), [ t, i ];
        }
        _$MaybeFinishAsyncFunctionCall$_(t) {
            const s = this._$_asyncMap$_.get(t);
            0 === s._$pauseCount$_ && (s.resolve(), this._$_asyncMap$_.delete(t)), 
            this._$_currentAsyncId$_ = -1;
        }
        _$PauseCurrentAsyncFunction$_() {
            const t = this._$_asyncMap$_.get(this._$_currentAsyncId$_);
            return t._$pauseCount$_++, this._$_currentAsyncId$_;
        }
        _$ResumeAsyncFunction$_(t) {
            this._$_currentAsyncId$_ = t;
            const s = this._$_asyncMap$_.get(t);
            s._$pauseCount$_--;
        }
        _$RunAsFamilyCustomActionWithOverrides$_(t, s) {
            const i = new Map(), e = [];
            for (const h of this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_()) {
                const r = h._$GetObjectClass$_();
                if (r._$HasOwnCustomActionByName$_(this._$_aceName$_)) {
                    const n = i.get(r);
                    Array.isArray(n) ? n.push(h) : i.set(r, [ h ]);
                } else e.push(h);
            }
            if (0 < e.length && this._$_eventBlock$_._$RunAsFunctionCall$_(t, s, this._$_isCopyPicked$_, {
                _$pickObjectClass$_: this._$_objectClass$_,
                _$pickInstances$_: e
            }), 0 < i.size) for (const [ o, a ] of i) {
                const l = o._$GetOwnCustomActionByName$_(this._$_aceName$_)._$GetEventBlock$_(), u = [ ...new Set([ ...t, ...l._$GetSolModifiers$_() ]) ];
                l._$RunAsFunctionCall$_(u, s, this._$_isCopyPicked$_, {
                    _$pickObjectClass$_: o,
                    _$pickInstances$_: a
                });
            }
        }
        *_$DebugRunAsFamilyCustomActionWithOverrides$_(t, s) {
            const i = new Map(), e = [];
            for (const h of this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_()) {
                const r = h._$GetObjectClass$_();
                if (r._$HasOwnCustomActionByName$_(this._$_aceName$_)) {
                    const n = i.get(r);
                    Array.isArray(n) ? n.push(h) : i.set(r, [ h ]);
                } else e.push(h);
            }
            if (0 < e.length && (yield* this._$_eventBlock$_._$DebugRunAsFunctionCall$_(t, s, this._$_isCopyPicked$_, {
                _$pickObjectClass$_: this._$_objectClass$_,
                _$pickInstances$_: e
            })), 0 < i.size) for (const [ o, a ] of i) {
                const l = o._$GetOwnCustomActionByName$_(this._$_aceName$_)._$GetEventBlock$_(), u = [ ...new Set([ ...t, ...l._$GetSolModifiers$_() ]) ];
                yield* l._$DebugRunAsFunctionCall$_(u, s, this._$_isCopyPicked$_, {
                    _$pickObjectClass$_: o,
                    _$pickInstances$_: a
                });
            }
        }
    };
}

{
    const Co = self._$C3$_, Ro = [];
    Co._$EventVariable$_ = class extends Co._$DefendedBase$_ {
        constructor(t, s, i) {
            super();
            const e = t._$GetEventSheetManager$_();
            this._$_eventSheet$_ = t, this._$_eventSheetManager$_ = e, this._$_runtime$_ = t._$GetRuntime$_(), 
            this._$_parent$_ = s, this._$_localVarStack$_ = e._$GetLocalVarStack$_(), 
            this._$_name$_ = i[1], this._$_type$_ = i[2], this._$_initialValue$_ = i[3], 
            this._$_isStatic$_ = !!i[4], this._$_isConstant$_ = !!i[5], this._$_isFunctionParameter$_ = s instanceof Co._$FunctionBlock$_, 
            this._$_sid$_ = i[6], this._$_jsPropName$_ = this._$_runtime$_._$GetJsPropName$_(i[8]), 
            this._$_scriptSetter$_ = t => this._$SetValue$_(t), this._$_scriptGetter$_ = () => this._$GetValue$_(), 
            this._$_hasSingleValue$_ = !this._$_parent$_ || this._$_isStatic$_ || this._$_isConstant$_, 
            this._$_value$_ = this._$_initialValue$_, this._$_localIndex$_ = -1, 
            this._$IsBoolean$_() && (this._$_value$_ = this._$_value$_ ? 1 : 0), 
            !this._$IsLocal$_() || this._$IsStatic$_() || this._$IsConstant$_() || (this._$_localIndex$_ = e._$_GetNextLocalVarIndex$_(this)), 
            e._$_RegisterEventVariable$_(this);
        }
        static _$Create$_(t, s, i) {
            return Co._$New$_(Co._$EventVariable$_, t, s, i);
        }
        _$_PostInit$_() {
            if (this._$IsLocal$_() && !this._$IsStatic$_() && !this._$IsConstant$_() && !this._$IsFunctionParameter$_()) {
                const t = this._$_eventSheetManager$_._$FindFirstFunctionBlockParent$_(this);
                t && t._$_RegisterLocalVariable$_(this);
            }
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$GetJsPropName$_() {
            return this._$_jsPropName$_;
        }
        _$GetParent$_() {
            return this._$_parent$_;
        }
        _$GetScopeParent$_() {
            return this._$GetParent$_();
        }
        _$IsGlobal$_() {
            return !this._$GetParent$_();
        }
        _$IsLocal$_() {
            return !this._$IsGlobal$_();
        }
        _$IsFunctionParameter$_() {
            return this._$_isFunctionParameter$_;
        }
        _$IsStatic$_() {
            return this._$_isStatic$_;
        }
        _$IsConstant$_() {
            return this._$_isConstant$_;
        }
        _$IsNumber$_() {
            return 0 === this._$_type$_;
        }
        _$IsString$_() {
            return 1 === this._$_type$_;
        }
        _$IsBoolean$_() {
            return 2 === this._$_type$_;
        }
        _$IsElseBlock$_() {
            return !1;
        }
        _$GetSID$_() {
            return this._$_sid$_;
        }
        _$GetInitialValue$_() {
            return this._$_initialValue$_;
        }
        _$GetSolModifiers$_() {
            return Ro;
        }
        _$Run$_(t) {
            !this._$IsLocal$_() || this._$IsStatic$_() || this._$IsConstant$_() || this._$SetValue$_(this._$GetInitialValue$_());
        }
        _$DebugCanRunFast$_() {
            return !0;
        }
        *_$DebugRun$_(t) {
            this._$Run$_(t);
        }
        _$SetValue$_(t) {
            this._$IsNumber$_() ? "number" != typeof t && (t = parseFloat(t)) : this._$IsString$_() ? "string" != typeof t && (t = t.toString()) : this._$IsBoolean$_() && (t = t ? 1 : 0), 
            this._$_hasSingleValue$_ ? this._$_value$_ = t : this._$_localVarStack$_._$GetCurrent$_()[this._$_localIndex$_] = t;
        }
        _$GetValue$_() {
            return this._$_hasSingleValue$_ ? this._$_value$_ : this._$_localVarStack$_._$GetCurrent$_()[this._$_localIndex$_];
        }
        _$GetTypedValue$_() {
            let t = this._$GetValue$_();
            return t = this._$IsBoolean$_() ? !!t : t;
        }
        _$ResetToInitialValue$_() {
            this._$_value$_ = this._$_initialValue$_;
        }
        _$_GetScriptInterfaceDescriptor$_() {
            return {
                configurable: !1,
                enumerable: !0,
                get: this._$_scriptGetter$_,
                set: this._$_scriptSetter$_
            };
        }
    };
}

{
    const Po = self._$C3$_, Eo = [];
    Po._$EventInclude$_ = class extends Po._$DefendedBase$_ {
        constructor(t, s, i) {
            super();
            const e = t._$GetEventSheetManager$_();
            this._$_eventSheet$_ = t, this._$_eventSheetManager$_ = e, this._$_runtime$_ = t._$GetRuntime$_(), 
            this._$_parent$_ = s, this._$_includeSheet$_ = null, this._$_includeSheetName$_ = i[1], 
            this._$_isActive$_ = !0;
        }
        static _$Create$_(t, s, i) {
            return Po._$New$_(Po._$EventInclude$_, t, s, i);
        }
        _$_PostInit$_() {
            this._$_includeSheet$_ = this._$_eventSheetManager$_._$GetEventSheetByName$_(this._$_includeSheetName$_), 
            this._$_eventSheet$_._$_AddShallowInclude$_(this);
            let t = this._$GetParent$_();
            for (;t; ) t instanceof Po._$EventBlock$_ && t._$IsGroup$_() && t._$_AddContainedInclude$_(this), 
            t = t._$GetParent$_();
            this._$UpdateActive$_(), this._$_runtime$_._$IsDebug$_() && this._$_eventSheet$_._$_GetPerfRecord$_().children.push(this._$_includeSheet$_._$_GetPerfRecord$_());
        }
        _$GetParent$_() {
            return this._$_parent$_;
        }
        _$GetSolModifiers$_() {
            return Eo;
        }
        _$GetIncludeSheet$_() {
            return this._$_includeSheet$_;
        }
        _$Run$_(t) {
            const s = !!this._$GetParent$_(), i = this._$_runtime$_._$GetAllObjectClasses$_();
            s && this._$_eventSheetManager$_._$PushCleanSol$_(i), this._$_includeSheet$_._$Run$_(), 
            s && this._$_eventSheetManager$_._$PopSol$_(i);
        }
        *_$DebugRun$_(t) {
            const s = !!this._$GetParent$_(), i = this._$_runtime$_._$GetAllObjectClasses$_();
            s && this._$_eventSheetManager$_._$PushCleanSol$_(i), yield* this._$_includeSheet$_._$DebugRun$_(), 
            s && this._$_eventSheetManager$_._$PopSol$_(i);
        }
        _$DebugCanRunFast$_() {
            return !1;
        }
        _$IsActive$_() {
            return this._$_isActive$_;
        }
        _$UpdateActive$_() {
            let t = this._$GetParent$_();
            for (;t; ) {
                if (t instanceof Po._$EventBlock$_ && t._$IsGroup$_() && !t._$IsGroupActive$_()) return void (this._$_isActive$_ = !1);
                t = t._$GetParent$_();
            }
            this._$_isActive$_ = !0;
        }
    };
}

{
    let a = function(t, s) {
        return s <= t ? t % s : (t < 0 && (t <= -s && (t %= s), t < 0) && (t += s), 
        t);
    };
    a;
    const Ao = self._$C3$_;
    Ao._$ExpNode$_ = class extends Ao._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_owner$_ = t, this._$_runtime$_ = t._$GetRuntime$_();
        }
        _$_PostInit$_() {}
        static _$CreateNode$_(t, s) {
            const i = s[0], e = [ Lo, Do, ko, Bo, Fo, Oo ];
            return Ao._$New$_(e[i], t, s);
        }
    };
    class Fo extends Ao._$ExpNode$_ {
        constructor(t, s) {
            super(t), this._$_systemPlugin$_ = this._$_runtime$_._$GetSystemPlugin$_(), 
            this._$_func$_ = this._$_runtime$_._$GetObjectReference$_(s[1]), this._$_func$_ !== Ao._$Plugins$_._$System$_._$Exps$_.random && this._$_func$_ !== Ao._$Plugins$_._$System$_._$Exps$_._$choose$_ || this._$_owner$_._$SetVariesPerInstance$_();
        }
        _$GetBoundMethod$_() {
            return this._$_systemPlugin$_._$_GetBoundACEMethod$_(this._$_func$_, this._$_systemPlugin$_);
        }
    }
    class Oo extends Ao._$ExpNode$_ {
        constructor(t, s) {
            super(t), this._$_functionBlock$_ = null, this._$_functionName$_ = s[1], 
            this._$_owner$_._$SetVariesPerInstance$_();
        }
        _$_PostInit$_() {
            const t = this._$_runtime$_._$GetEventSheetManager$_(), s = (this._$_functionBlock$_ = t._$GetFunctionBlockByName$_(this._$_functionName$_), 
            this._$_functionName$_ = null, this._$_owner$_._$GetEventBlock$_()), i = this._$_functionBlock$_._$GetEventBlock$_();
            this._$_combinedSolModifiers$_ = [ ...new Set([ ...s._$GetSolModifiersIncludingParents$_(), ...i._$GetSolModifiersIncludingParents$_() ]) ], 
            this._$_combinedSolModifiers$_ = t._$_DeduplicateSolModifierList$_(this._$_combinedSolModifiers$_);
        }
        _$GetBoundMethod$_() {
            const t = this._$_functionBlock$_;
            if (t._$IsEnabled$_()) {
                const s = t._$GetEventBlock$_();
                return Ao._$EventBlock$_.prototype._$RunAsExpressionFunctionCall$_.bind(s, this._$_combinedSolModifiers$_, t._$IsCopyPicked$_(), t._$GetReturnType$_(), t._$GetDefaultReturnValue$_());
            }
            {
                const i = t._$GetDefaultReturnValue$_();
                return () => i;
            }
        }
    }
    class Do extends Ao._$ExpNode$_ {
        constructor(t, s) {
            super(t), this._$_objectClass$_ = this._$_runtime$_._$GetObjectClassByIndex$_(s[1]), 
            this._$_func$_ = this._$_runtime$_._$GetObjectReference$_(s[2]), this._$_returnsString$_ = !!s[3], 
            this._$_eventStack$_ = this._$_runtime$_._$GetEventSheetManager$_()._$GetEventStack$_(), 
            this._$_owner$_._$_MaybeVaryFor$_(this._$_objectClass$_);
        }
        _$GetBoundMethod$_() {
            return this._$_objectClass$_._$GetPlugin$_()._$_GetBoundACEMethod$_(this._$_func$_, this._$_objectClass$_._$GetSingleGlobalInstance$_()._$GetSdkInstance$_());
        }
        _$ExpObject$_(...t) {
            const s = this._$_objectClass$_, i = s._$GetCurrentSol$_()._$GetExpressionInstances$_(), e = i.length;
            if (0 === e) return this._$_returnsString$_ ? "" : 0;
            const h = a(this._$_owner$_._$GetSolIndex$_(), e);
            return this._$_eventStack$_._$GetCurrentStackFrame$_()._$SetExpressionObjectClass$_(s), 
            this._$_func$_.apply(i[h]._$GetSdkInstance$_(), t);
        }
        _$ExpObject_InstExpr$_(t, ...s) {
            const i = this._$_objectClass$_, e = i._$GetInstances$_(), h = e.length;
            if (0 === h) return this._$_returnsString$_ ? "" : 0;
            const r = a(t, h);
            return this._$_eventStack$_._$GetCurrentStackFrame$_()._$SetExpressionObjectClass$_(i), 
            this._$_func$_.apply(e[r]._$GetSdkInstance$_(), s);
        }
    }
    class ko extends Ao._$ExpNode$_ {
        constructor(t, s) {
            super(t), this._$_objectClass$_ = this._$_runtime$_._$GetObjectClassByIndex$_(s[1]), 
            this._$_varIndex$_ = s[3], this._$_returnsString$_ = !!s[2], this._$_owner$_._$_MaybeVaryFor$_(this._$_objectClass$_);
        }
        _$ExpInstVar$_() {
            const t = this._$_objectClass$_._$GetCurrentSol$_()._$GetExpressionInstances$_(), s = t.length;
            if (0 === s) return this._$_returnsString$_ ? "" : 0;
            const i = a(this._$_owner$_._$GetSolIndex$_(), s);
            return t[i]._$_GetInstanceVariableValueUnchecked$_(this._$_varIndex$_);
        }
        _$ExpInstVar_Family$_() {
            const t = this._$_objectClass$_, s = t._$GetCurrentSol$_()._$GetExpressionInstances$_(), i = s.length;
            if (0 === i) return this._$_returnsString$_ ? "" : 0;
            const e = a(this._$_owner$_._$GetSolIndex$_(), i), h = s[e], r = h._$GetObjectClass$_()._$GetFamilyInstanceVariableOffset$_(t._$GetFamilyIndex$_());
            return h._$_GetInstanceVariableValueUnchecked$_(this._$_varIndex$_ + r);
        }
        _$ExpInstVar_InstExpr$_(t) {
            const s = this._$_objectClass$_, i = s._$GetInstances$_(), e = i.length;
            if (0 === e) return this._$_returnsString$_ ? "" : 0;
            let h = a(t, e), r = i[h], n = 0;
            return s._$IsFamily$_() && (n = r._$GetObjectClass$_()._$GetFamilyInstanceVariableOffset$_(s._$GetFamilyIndex$_())), 
            r._$_GetInstanceVariableValueUnchecked$_(this._$_varIndex$_ + n);
        }
    }
    class Lo extends Ao._$ExpNode$_ {
        constructor(t, s) {
            super(t), this._$_objectClass$_ = this._$_runtime$_._$GetObjectClassByIndex$_(s[1]), 
            this._$_behaviorType$_ = this._$_objectClass$_._$GetBehaviorTypeByName$_(s[2]), 
            this._$_behaviorIndex$_ = this._$_objectClass$_._$GetBehaviorIndexByName$_(s[2]), 
            this._$_func$_ = this._$_runtime$_._$GetObjectReference$_(s[3]), this._$_returnsString$_ = !!s[4], 
            this._$_eventStack$_ = this._$_runtime$_._$GetEventSheetManager$_()._$GetEventStack$_(), 
            this._$_owner$_._$_MaybeVaryFor$_(this._$_objectClass$_);
        }
        _$ExpBehavior$_(...t) {
            const s = this._$_objectClass$_, i = s._$GetCurrentSol$_()._$GetExpressionInstances$_(), e = i.length;
            if (0 === e) return this._$_returnsString$_ ? "" : 0;
            let h = a(this._$_owner$_._$GetSolIndex$_(), e), r = (this._$_eventStack$_._$GetCurrentStackFrame$_()._$SetExpressionObjectClass$_(s), 
            i[h]), n = 0;
            return s._$IsFamily$_() && (n = r._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(s._$GetFamilyIndex$_())), 
            this._$_func$_.apply(r._$GetBehaviorInstances$_()[this._$_behaviorIndex$_ + n]._$GetSdkInstance$_(), t);
        }
        _$ExpBehavior_InstExpr$_(t, ...s) {
            const i = this._$_objectClass$_, e = i._$GetInstances$_(), h = e.length;
            if (0 === h) return this._$_returnsString$_ ? "" : 0;
            let r = a(t, h), n = (this._$_eventStack$_._$GetCurrentStackFrame$_()._$SetExpressionObjectClass$_(i), 
            e[r]), o = 0;
            return i._$IsFamily$_() && (o = n._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(i._$GetFamilyIndex$_())), 
            this._$_func$_.apply(n._$GetBehaviorInstances$_()[this._$_behaviorIndex$_ + o]._$GetSdkInstance$_(), s);
        }
    }
    class Bo extends Ao._$ExpNode$_ {
        constructor(t, s) {
            super(t), this._$_eventVar$_ = null, this._$_eventVarSid$_ = s[1];
        }
        _$_PostInit$_() {
            this._$_eventVar$_ = this._$_runtime$_._$GetEventSheetManager$_()._$GetEventVariableBySID$_(this._$_eventVarSid$_);
        }
        _$GetVar$_() {
            return this._$_eventVar$_;
        }
    }
}

{
    let r = function(t) {
        const s = self._$C3_ExpressionFuncs$_[t];
        if (s) return s;
        throw new Error("invalid expression number");
    };
    r;
    const No = self._$C3$_;
    No._$Parameter$_ = class extends No._$DefendedBase$_ {
        constructor(t, s, i) {
            super(), this._$_owner$_ = t, this._$_index$_ = i, this._$_type$_ = s, 
            this._$Get$_ = null, this._$_variesPerInstance$_ = !1, this._$_isConstant$_ = !1;
        }
        static _$Create$_(t, s, i) {
            const e = s[0], h = [ Wo, jo, Xo, Uo, zo, Vo, Jo, Wo, Uo, Uo, Yo, $o, Xo, Zo, jo, qo, Ho, Ko, Qo, ta, sa, ia ];
            return No._$New$_(h[e], t, e, i, s);
        }
        _$_PostInit$_() {}
        _$SetVariesPerInstance$_() {
            this._$_variesPerInstance$_ = !0;
        }
        _$_MaybeVaryFor$_(t) {
            this._$_variesPerInstance$_ || !t || t._$GetPlugin$_()._$IsSingleGlobal$_() || (this._$_variesPerInstance$_ = !0);
        }
        _$VariesPerInstance$_() {
            return this._$_variesPerInstance$_;
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$GetRuntime$_() {
            return this._$_owner$_._$GetRuntime$_();
        }
        _$GetEventBlock$_() {
            return this._$_owner$_._$GetEventBlock$_();
        }
        _$IsConstant$_() {
            return this._$_isConstant$_;
        }
        _$IsObjectParameter$_() {
            return 4 === this._$_type$_;
        }
    };
    class Wo extends No._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_solIndex$_ = 0;
            const h = e[1];
            this._$_expressionNumber$_ = h[0], this._$_numberedNodes$_ = [], this._$_expressionFunc$_ = null;
            for (let t = 1, s = h.length; t < s; ++t) this._$_numberedNodes$_.push(No._$ExpNode$_._$CreateNode$_(this, h[t]));
            this._$_numberedNodes$_.length ? this._$Get$_ = this._$GetExpression$_ : (this._$Get$_ = r(this._$_expressionNumber$_), 
            this._$_isConstant$_ = !0);
        }
        _$_GetNode$_(t) {
            if (t < 0 || t >= this._$_numberedNodes$_.length) throw new RangeError("invalid numbered node");
            return this._$_numberedNodes$_[t];
        }
        _$_PostInit$_() {
            for (const s of this._$_numberedNodes$_) s._$_PostInit$_();
            const t = r(this._$_expressionNumber$_);
            this._$_numberedNodes$_.length ? this._$_expressionFunc$_ = t(this) : this._$_expressionFunc$_ = t;
        }
        _$GetSolIndex$_() {
            return this._$_solIndex$_;
        }
        _$GetExpression$_(t) {
            return this._$_solIndex$_ = t, this._$_expressionFunc$_();
        }
    }
    class jo extends Wo {
        constructor(t, s, i, e) {
            super(t, s, i, e), this._$Get$_ = this._$GetStringExpression$_, 14 === s && (this._$GetEventBlock$_()._$SetAllSolModifiers$_(), 
            this._$_owner$_ instanceof No._$Action$_) && this._$GetEventBlock$_()._$SetSolWriterAfterCnds$_();
        }
        _$GetStringExpression$_(t) {
            this._$_solIndex$_ = t;
            const s = this._$_expressionFunc$_();
            return "string" == typeof s ? s : "";
        }
        _$_GetFastTriggerValue$_() {
            return r(this._$_expressionNumber$_)();
        }
    }
    class Vo extends Wo {
        constructor(t, s, i, e) {
            super(t, s, i, e), 2 <= t._$GetImplementationSdkVersion$_() ? this._$Get$_ = this._$GetILayer$_ : this._$Get$_ = this._$GetLayer$_, 
            this._$_isConstant$_ = !1;
        }
        _$GetLayer$_(t) {
            this._$_solIndex$_ = t;
            const s = this._$_expressionFunc$_(), i = this._$GetRuntime$_()._$GetCurrentLayout$_();
            return i._$GetLayer$_(s);
        }
        _$GetILayer$_(t) {
            const s = this._$GetLayer$_(t);
            return s ? s._$GetILayer$_() : null;
        }
    }
    class Uo extends No._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_combo$_ = e[1], this._$Get$_ = this._$GetCombo$_, 
            this._$_isConstant$_ = !0;
        }
        _$GetCombo$_() {
            return this._$_combo$_;
        }
    }
    class Ho extends No._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_bool$_ = e[1], this._$Get$_ = this._$GetBoolean$_, 
            this._$_isConstant$_ = !0;
        }
        _$GetBoolean$_() {
            return this._$_bool$_;
        }
    }
    class zo extends No._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_objectClass$_ = this._$GetRuntime$_()._$GetObjectClassByIndex$_(e[1]), 
            2 <= t._$GetImplementationSdkVersion$_() ? this._$Get$_ = this._$GetIObjectClass$_ : this._$Get$_ = this._$GetObjectClass$_;
            const h = this._$GetEventBlock$_();
            h._$_AddSolModifier$_(this._$_objectClass$_), this._$_owner$_ instanceof No._$Action$_ ? h._$SetSolWriterAfterCnds$_() : h._$GetParent$_() && h._$GetParent$_()._$SetSolWriterAfterCnds$_(), 
            this._$_isConstant$_ = !0;
        }
        _$GetObjectClass$_() {
            return this._$_objectClass$_;
        }
        _$GetIObjectClass$_() {
            return this._$_objectClass$_ ? this._$_objectClass$_._$GetIObjectClass$_() : null;
        }
    }
    class Jo extends No._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_layout$_ = this._$GetRuntime$_()._$GetLayoutManager$_()._$GetLayoutByName$_(e[1]), 
            2 <= t._$GetImplementationSdkVersion$_() ? this._$Get$_ = this._$GetILayout$_ : this._$Get$_ = this._$GetLayout$_, 
            this._$_isConstant$_ = !0;
        }
        _$GetLayout$_() {
            return this._$_layout$_;
        }
        _$GetILayout$_() {
            return this._$_layout$_ ? this._$_layout$_._$GetILayout$_() : null;
        }
    }
    class qo extends No._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_timeline$_ = this._$GetRuntime$_()._$GetTimelineManager$_()._$GetTimelineByName$_(e[1]), 
            2 <= t._$GetImplementationSdkVersion$_() ? this._$Get$_ = this._$GetITimelineState$_ : this._$Get$_ = this._$GetTimeline$_, 
            this._$_isConstant$_ = !0;
        }
        _$GetTimeline$_() {
            return this._$_timeline$_;
        }
        _$GetITimelineState$_() {
            return this._$_timeline$_ ? this._$_timeline$_._$GetITimelineState$_() : null;
        }
    }
    class Xo extends No._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_fileInfo$_ = e[1], this._$Get$_ = this._$GetFile$_, 
            this._$_isConstant$_ = !0;
        }
        _$GetFile$_() {
            return this._$_fileInfo$_;
        }
    }
    class Yo extends No._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_instVarIndex$_ = e[1];
            const h = this._$_owner$_._$GetObjectClass$_();
            !(this._$_owner$_ instanceof No._$Condition$_ && this._$_owner$_._$IsStatic$_()) && h && h._$IsFamily$_() ? (this._$Get$_ = this._$GetFamilyInstanceVariable$_, 
            this._$SetVariesPerInstance$_()) : (this._$Get$_ = this._$GetInstanceVariable$_, 
            this._$_isConstant$_ = !0);
        }
        _$GetInstanceVariable$_() {
            return this._$_instVarIndex$_;
        }
        _$GetFamilyInstanceVariable$_(t) {
            t = t || 0;
            let s = this._$_owner$_._$GetObjectClass$_(), i = s._$GetCurrentSol$_(), e = i._$GetInstances$_(), h = null;
            if (e.length) h = e[t % e.length]._$GetObjectClass$_(); else if (i._$HasAnyElseInstances$_()) {
                const r = i._$GetElseInstances$_();
                h = r[t % r.length]._$GetObjectClass$_();
            } else {
                if (!(0 < s._$GetInstanceCount$_())) return 0;
                {
                    const n = s._$GetInstances$_();
                    h = n[t % n.length]._$GetObjectClass$_();
                }
            }
            return this._$_instVarIndex$_ + h._$GetFamilyInstanceVariableOffset$_(s._$GetFamilyIndex$_());
        }
    }
    class $o extends No._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_eventVarSid$_ = e[1], this._$_eventVar$_ = null, 
            2 <= t._$GetImplementationSdkVersion$_() ? this._$Get$_ = this._$GetIEventVariable$_ : this._$Get$_ = this._$GetEventVariable$_, 
            this._$_isConstant$_ = !0;
        }
        _$_PostInit$_() {
            this._$_eventVar$_ = this._$GetRuntime$_()._$GetEventSheetManager$_()._$GetEventVariableBySID$_(this._$_eventVarSid$_);
        }
        _$GetEventVariable$_() {
            return this._$_eventVar$_;
        }
        _$GetIEventVariable$_() {
            return null;
        }
    }
    class Ko extends No._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_functionBlockName$_ = e[1], this._$_functionBlock$_ = null, 
            2 <= t._$GetImplementationSdkVersion$_() ? this._$Get$_ = this._$GetIFunction$_ : this._$Get$_ = this._$GetFunction$_, 
            this._$_isConstant$_ = !0;
        }
        _$_PostInit$_() {
            this._$_functionBlock$_ = this._$GetRuntime$_()._$GetEventSheetManager$_()._$GetFunctionBlockByName$_(this._$_functionBlockName$_), 
            this._$_functionBlockName$_ = null;
        }
        _$GetFunction$_() {
            return this._$_functionBlock$_;
        }
        _$GetIFunction$_() {
            return null;
        }
    }
    class Zo extends No._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_subParams$_ = [], this._$_variadicRet$_ = [], 
            this._$_isConstant$_ = !0;
            for (let t = 1, s = e.length; t < s; ++t) {
                const h = No._$Parameter$_._$Create$_(this._$_owner$_, e[t], 0);
                this._$_subParams$_.push(h), this._$_variadicRet$_.push(0), h._$IsConstant$_() || (this._$_isConstant$_ = !1);
            }
            this._$Get$_ = this._$GetVariadic$_;
        }
        _$_PostInit$_() {
            for (const t of this._$_subParams$_) t._$_PostInit$_();
        }
        _$GetVariadic$_() {
            const i = this._$_subParams$_, e = this._$_variadicRet$_;
            for (let t = 0, s = i.length; t < s; ++t) e[t] = i[t]._$Get$_(0);
            return e;
        }
    }
    class Qo extends No._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_easeIndex$_ = e[1], this._$Get$_ = this._$GetEase$_, 
            this._$_isConstant$_ = !0;
        }
        _$GetEase$_() {
            return this._$_easeIndex$_;
        }
    }
    class ta extends No._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_brushIndex$_ = e[1], this._$Get$_ = this._$GetTilemapBrush$_, 
            this._$_isConstant$_ = !0;
        }
        _$GetTilemapBrush$_() {
            return this._$_brushIndex$_;
        }
    }
    class sa extends Wo {
        constructor(t, s, i, e) {
            super(t, s, i, e), this._$Get$_ = this._$GetTemplateName$_, this._$_isConstant$_ = !1;
        }
        _$GetTemplateName$_() {
            return this._$_expressionFunc$_();
        }
    }
    class ia extends No._$Parameter$_ {
        constructor(t, s, i, e) {
            super(t, s, i), this._$_flowchartDataItem$_ = this._$GetRuntime$_()._$GetFlowchartManager$_()._$GetFlowchartDataItemByName$_(e[1]), 
            this._$Get$_ = this._$GetFlowchartName$_, this._$_isConstant$_ = !0;
        }
        _$GetFlowchartName$_() {
            return this._$_flowchartDataItem$_._$GetName$_();
        }
    }
}

{
    let e = function(i, e) {
        for (let t = 0, s = i.length; t < s; ++t) e[t] = i[t]._$Get$_(0);
    };
    e;
    const ea = self._$C3$_, ha = [], ra = function() {};
    ea._$Condition$_ = class extends ea._$DefendedBase$_ {
        constructor(t, i, s) {
            if (super(), this._$_eventBlock$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), 
            this._$_index$_ = s, this._$_func$_ = this._$_runtime$_._$GetObjectReference$_(i[1]), 
            this._$_isTrigger$_ = 0 < i[3], this._$_isFastTrigger$_ = 2 === i[3], 
            this._$_isLooping$_ = !!i[4], this._$_isInverted$_ = !!i[5], this._$_isStatic$_ = !!i[6], 
            this._$_sid$_ = i[7], this._$_isInOrBlock$_ = this._$_eventBlock$_._$IsOrBlock$_(), 
            this._$_objectClass$_ = null, this._$_behaviorType$_ = null, this._$_behaviorIndex$_ = -1, 
            this._$_systemPlugin$_ = null, this._$Run$_ = ra, this._$DebugRun$_ = ra, 
            this._$_parameters$_ = [], this._$_results$_ = [], this._$_anyParamVariesPerInstance$_ = !1, 
            this._$_savedData$_ = null, this._$_unsavedData$_ = null, this._$_debugData$_ = this._$_runtime$_._$IsDebug$_() ? {
                _$isBreakpoint$_: i[8][0],
                _$canDebug$_: i[8][1]
            } : null, -1 === i[0] ? this._$_systemPlugin$_ = this._$_runtime$_._$GetSystemPlugin$_() : (this._$_objectClass$_ = this._$_runtime$_._$GetObjectClassByIndex$_(i[0]), 
            i[2] && (this._$_behaviorType$_ = this._$_objectClass$_._$GetBehaviorTypeByName$_(i[2]), 
            this._$_behaviorIndex$_ = this._$_objectClass$_._$GetBehaviorIndexByName$_(i[2])), 
            this._$_eventBlock$_._$GetParent$_() && this._$_eventBlock$_._$GetParent$_()._$SetSolWriterAfterCnds$_()), 
            10 === i.length) {
                let s = i[9];
                for (let t of s) this._$_parameters$_.push(ea._$Parameter$_._$Create$_(this, t, this._$_parameters$_.length)), 
                this._$_results$_.push(0);
            }
            0 === this._$_parameters$_.length && (this._$_parameters$_ = ha, this._$_results$_ = ha), 
            this._$_eventBlock$_._$GetEventSheetManager$_()._$_RegisterCondition$_(this);
        }
        static _$Create$_(t, s, i) {
            return ea._$New$_(ea._$Condition$_, t, s, i);
        }
        _$_PostInit$_() {
            for (const t of this._$_parameters$_) t._$_PostInit$_(), t._$VariesPerInstance$_() && (this._$_anyParamVariesPerInstance$_ = !0);
            this._$_isFastTrigger$_ ? (this._$Run$_ = this._$_RunFastTrigger$_, 
            this._$DebugRun$_ = this._$_DebugRunFastTrigger$_) : this._$_systemPlugin$_ ? (this._$_SetSystemRunMethod$_(), 
            this._$DebugRun$_ = this._$_DebugRunSystem$_) : this._$_objectClass$_._$GetPlugin$_()._$IsSingleGlobal$_() ? (this._$_SetSingleGlobalRunMethod$_(), 
            this._$DebugRun$_ = this._$_DebugRunSingleGlobal$_) : this._$_isStatic$_ ? (this._$Run$_ = this._$_RunStatic$_, 
            this._$DebugRun$_ = this._$_DebugRunStatic$_) : (this._$Run$_ = this._$_RunObject$_, 
            this._$DebugRun$_ = this._$_DebugRunObject$_);
        }
        _$_SetSystemRunMethod$_() {
            const t = this._$_systemPlugin$_, s = this._$_systemPlugin$_;
            this._$_SetRunMethodForBoundFunc$_(t, s, this._$_RunSystem$_);
        }
        _$_SetSingleGlobalRunMethod$_() {
            const t = this._$_objectClass$_._$GetPlugin$_(), s = this._$_objectClass$_._$GetSingleGlobalInstance$_()._$GetSdkInstance$_();
            this._$_SetRunMethodForBoundFunc$_(t, s, this._$_RunSingleGlobal$_);
        }
        _$_SetRunMethodForBoundFunc$_(t, s, i) {
            const e = this._$_func$_, h = this._$_isInverted$_, r = this._$_parameters$_;
            if (0 === r.length) {
                const n = t._$_GetBoundACEMethod$_(e, s);
                h ? this._$Run$_ = function() {
                    return ea.xor(n(), h);
                } : this._$Run$_ = n;
            } else if (1 === r.length) {
                const o = r[0];
                if (!h && o._$IsConstant$_()) this._$Run$_ = t._$_GetBoundACEMethod_1param$_(e, s, o._$Get$_(0)); else {
                    const a = t._$_GetBoundACEMethod$_(e, s);
                    this._$Run$_ = function() {
                        return ea.xor(a(o._$Get$_(0)), h);
                    };
                }
            } else if (2 === r.length) {
                const l = r[0], u = r[1];
                if (!h && l._$IsConstant$_() && u._$IsConstant$_()) this._$Run$_ = t._$_GetBoundACEMethod_2params$_(e, s, l._$Get$_(0), u._$Get$_(0)); else {
                    const c = t._$_GetBoundACEMethod$_(e, s);
                    this._$Run$_ = function() {
                        return ea.xor(c(l._$Get$_(0), u._$Get$_(0)), h);
                    };
                }
            } else if (3 === r.length) {
                const f = r[0], d = r[1], p = r[2];
                if (!h && f._$IsConstant$_() && d._$IsConstant$_() && p._$IsConstant$_()) this._$Run$_ = t._$_GetBoundACEMethod_3params$_(e, s, f._$Get$_(0), d._$Get$_(0), p._$Get$_(0)); else {
                    const m = t._$_GetBoundACEMethod$_(e, s);
                    this._$Run$_ = function() {
                        return ea.xor(m(f._$Get$_(0), d._$Get$_(0), p._$Get$_(0)), h);
                    };
                }
            } else this._$Run$_ = i;
        }
        _$GetSID$_() {
            return this._$_sid$_;
        }
        _$_GetFunc$_() {
            return this._$_func$_;
        }
        _$GetObjectClass$_() {
            return this._$_objectClass$_;
        }
        _$GetBehaviorType$_() {
            return this._$_behaviorType$_;
        }
        _$GetImplementationAddon$_() {
            return this._$_behaviorType$_ ? this._$_behaviorType$_._$GetBehavior$_() : this._$_objectClass$_ ? this._$_objectClass$_._$GetPlugin$_() : null;
        }
        _$GetImplementationSdkVersion$_() {
            const t = this._$GetImplementationAddon$_();
            return t ? t._$GetSdkVersion$_() : 1;
        }
        _$GetEventBlock$_() {
            return this._$_eventBlock$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$GetDebugIndex$_() {
            return this._$GetIndex$_();
        }
        _$IsTrigger$_() {
            return this._$_isTrigger$_;
        }
        _$IsFastTrigger$_() {
            return this._$_isFastTrigger$_;
        }
        _$IsInverted$_() {
            return this._$_isInverted$_;
        }
        _$IsLooping$_() {
            return this._$_isLooping$_;
        }
        _$IsStatic$_() {
            return this._$_isStatic$_;
        }
        _$IsBreakpoint$_() {
            return this._$_debugData$_._$isBreakpoint$_;
        }
        _$IsSystemCondition$_() {
            return !!this._$_systemPlugin$_;
        }
        _$IsSystemOrSingleGlobalCondition$_() {
            return this._$IsSystemCondition$_() || this._$_objectClass$_._$GetPlugin$_()._$IsSingleGlobal$_();
        }
        _$GetFirstObjectParameterObjectClass$_() {
            for (const t of this._$_parameters$_) if (t._$IsObjectParameter$_()) return t._$GetObjectClass$_();
            return null;
        }
        _$_SetBreakpoint$_(t) {
            this._$_debugData$_._$isBreakpoint$_ = !!t, this._$_eventBlock$_._$_UpdateCanRunFastRecursive$_();
        }
        _$_DebugReturnsGenerator$_() {
            return this._$_debugData$_._$canDebug$_;
        }
        _$DebugCanRunFast$_() {
            return !this._$IsBreakpoint$_() && !this._$_runtime$_._$DebugBreakNext$_() && !this._$_DebugReturnsGenerator$_();
        }
        _$GetSavedDataMap$_() {
            return this._$_savedData$_ || (this._$_savedData$_ = new Map()), this._$_savedData$_;
        }
        _$GetUnsavedDataMap$_() {
            return this._$_unsavedData$_ || (this._$_unsavedData$_ = new Map()), 
            this._$_unsavedData$_;
        }
        _$_RunSystem$_() {
            const t = this._$_results$_;
            return e(this._$_parameters$_, t), ea.xor(this._$_func$_.apply(this._$_systemPlugin$_, t), this._$_isInverted$_);
        }
        *_$_DebugRunSystem$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const s = this._$_results$_;
                e(this._$_parameters$_, s);
                let t = this._$_func$_.apply(this._$_systemPlugin$_, s);
                return ea._$IsIterator$_(t) && (t = yield* t), ea.xor(t, this._$_isInverted$_);
            }
            return this._$Run$_();
        }
        _$_RunSingleGlobal$_() {
            const t = this._$_results$_, s = (e(this._$_parameters$_, t), this._$_objectClass$_._$GetSingleGlobalInstance$_()._$GetSdkInstance$_());
            return ea.xor(this._$_func$_.apply(s, t), this._$_isInverted$_);
        }
        *_$_DebugRunSingleGlobal$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                let t = this._$_results$_, s = (e(this._$_parameters$_, t), this._$_objectClass$_._$GetSingleGlobalInstance$_()._$GetSdkInstance$_()), i = this._$_func$_.apply(s, t);
                return ea._$IsIterator$_(i) && (i = yield* i), ea.xor(i, this._$_isInverted$_);
            }
            return this._$Run$_();
        }
        _$_RunFastTrigger$_() {
            return !0;
        }
        *_$_DebugRunFastTrigger$_() {
            return (this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            !0;
        }
        _$_GetStaticConditionThis$_() {
            if (this._$_behaviorType$_) {
                if (2 <= this._$_behaviorType$_._$GetBehavior$_()._$GetSdkVersion$_()) throw new Error("not yet implemented");
                return this._$_behaviorType$_;
            }
            return 2 <= this._$_objectClass$_._$GetPlugin$_()._$GetSdkVersion$_() ? this._$_objectClass$_._$GetIObjectClass$_() : this._$_objectClass$_;
        }
        _$_RunStatic$_() {
            const t = this._$_results$_, s = (e(this._$_parameters$_, t), this._$_func$_.apply(this._$_GetStaticConditionThis$_(), t));
            return this._$_objectClass$_._$ApplySolToContainer$_(), s;
        }
        *_$_DebugRunStatic$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const s = this._$_results$_;
                e(this._$_parameters$_, s);
                let t = this._$_func$_.apply(this._$_GetStaticConditionThis$_(), s);
                return ea._$IsIterator$_(t) && (t = yield* t), this._$_objectClass$_._$ApplySolToContainer$_(), 
                t;
            }
            return this._$Run$_();
        }
        _$_RunObject$_() {
            const i = this._$_parameters$_, e = this._$_results$_, t = this._$_objectClass$_._$GetCurrentSol$_();
            for (let t = 0, s = i.length; t < s; ++t) {
                const h = i[t];
                h._$VariesPerInstance$_() || (e[t] = h._$Get$_(0));
            }
            return t._$IsSelectAll$_() ? this._$_RunObject_FirstFilter$_(t) : this._$_RunObject_NextFilter$_(t);
        }
        *_$_DebugRunObject$_() {
            return (this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_RunObject$_();
        }
        _$_EvaluateVaryingParameters$_(i) {
            const e = this._$_parameters$_, h = this._$_results$_;
            for (let t = 0, s = e.length; t < s; ++t) {
                const r = e[t];
                r._$VariesPerInstance$_() && (h[t] = r._$Get$_(i));
            }
        }
        _$_RunObject_FirstFilter$_(i) {
            const t = this._$_objectClass$_, e = t._$IsFamily$_(), h = t._$GetFamilyIndex$_(), r = this._$_behaviorIndex$_, n = 0 <= r, o = t._$GetInstances$_(), a = this._$_anyParamVariesPerInstance$_, l = this._$_results$_, u = this._$_func$_, c = this._$_isInverted$_, f = this._$_isInOrBlock$_ && !this._$_isTrigger$_;
            i._$ClearArrays$_();
            for (let s = 0, t = o.length; s < t; ++s) {
                const d = o[s];
                a && this._$_EvaluateVaryingParameters$_(s);
                let t;
                if (n) {
                    const p = e ? d._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(h) : 0;
                    t = u.apply(d._$GetBehaviorInstances$_()[r + p]._$GetSdkInstance$_(), l);
                } else t = u.apply(d._$GetSdkInstance$_(), l);
                ea.xor(t, c) ? i._$_PushInstance$_(d) : f && i._$_PushElseInstance$_(d);
            }
            return t._$FinishCondition$_(!0), i._$_SetSelectAll$_(!1), t._$ApplySolToContainer$_(), 
            i._$HasAnyInstances$_();
        }
        _$_RunObject_NextFilter$_(t) {
            let s = this._$_objectClass$_, i = s._$IsFamily$_(), e = s._$GetFamilyIndex$_(), h = s._$IsInContainer$_(), r = this._$_behaviorIndex$_, n = 0 <= r, o = this._$_anyParamVariesPerInstance$_, a = this._$_results$_, l = this._$_func$_, u = this._$_isInverted$_, c = this._$_isInOrBlock$_ && !this._$_isTrigger$_, f = t._$_GetOwnInstances$_(), d = t._$_GetOwnElseInstances$_(), p = c && !this._$_eventBlock$_._$IsFirstConditionOfType$_(this), m = p ? d : f, g = 0, y = !1;
            for (let s = 0, t = m.length; s < t; ++s) {
                const S = m[s];
                o && this._$_EvaluateVaryingParameters$_(s);
                let t;
                if (n) {
                    const b = i ? S._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(e) : 0;
                    t = l.apply(S._$GetBehaviorInstances$_()[r + b]._$GetSdkInstance$_(), a);
                } else t = l.apply(S._$GetSdkInstance$_(), a);
                ea.xor(t, u) ? (y = !0, p ? (f.push(S), h && S._$_PushSiblingsToSolInstances$_()) : (m[g] = S, 
                h && S._$_SetSiblingsToSolInstancesIndex$_(g), ++g)) : p ? (m[g] = S, 
                h && S._$_SetSiblingsToSolElseInstancesIndex$_(g), ++g) : c && (d.push(S), 
                h) && S._$_PushSiblingsToSolElseInstances$_();
            }
            ea._$truncateArray$_(m, g), h && s._$_TruncateContainerSols$_(p, g);
            const w = y;
            return p && !y && (y = this._$_OrBlockCheckInstances$_(f)), s._$FinishCondition$_(w || c), 
            c ? y : t._$HasAnyInstances$_();
        }
        _$_OrBlockCheckInstances$_(i) {
            const t = this._$_objectClass$_, e = t._$IsFamily$_(), h = t._$GetFamilyIndex$_(), r = this._$_anyParamVariesPerInstance$_, n = this._$_behaviorIndex$_, o = 0 <= n, a = this._$_results$_, l = this._$_func$_, u = this._$_isInverted$_;
            for (let s = 0, t = i.length; s < t; ++s) {
                const c = i[s];
                r && this._$_EvaluateVaryingParameters$_(s);
                let t;
                if (o) {
                    const f = e ? c._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(h) : 0;
                    t = l.apply(c._$GetBehaviorInstances$_()[n + f]._$GetSdkInstance$_(), a);
                } else t = l.apply(c._$GetSdkInstance$_(), a);
                if (ea.xor(t, u)) return !0;
            }
            return !1;
        }
        _$ReevaluateParameter$_(t, s) {
            return this._$_parameters$_[t]._$Get$_(s);
        }
        _$GetFastTriggerValue$_() {
            const t = this._$_parameters$_;
            if (t.length) return t[0]._$_GetFastTriggerValue$_();
            throw new Error("no parameters");
        }
        _$_SaveToJson$_() {
            if (!this._$_savedData$_ || !this._$_savedData$_.size) return null;
            const s = {};
            for (const [ i, e ] of this._$_savedData$_.entries()) {
                let t = e;
                "collmemory" === i && (t = [ ...e.entries() ].map(t => [ t[0]._$GetUID$_(), t[1]._$GetUID$_(), t[2] ])), 
                s[i] = t;
            }
            return {
                ex: s
            };
        }
        _$_LoadFromJson$_(t) {
            if (this._$_savedData$_ && (this._$_savedData$_.clear(), this._$_savedData$_ = null), 
            t) {
                const s = this._$_runtime$_, i = t.ex;
                if (i) {
                    const e = this._$GetSavedDataMap$_();
                    e.clear();
                    for (const [ h, r ] of Object.entries(i)) {
                        let t = r;
                        "collmemory" === h && (t = ea._$New$_(ea._$PairMap$_, r.map(t => [ s._$GetInstanceByUID$_(t[0]), s._$GetInstanceByUID$_(t[1]), t[2] ]).filter(t => t[0] && t[1]))), 
                        e.set(h, t);
                    }
                }
            }
        }
    };
}

{
    let h = function(i, e) {
        for (let t = 0, s = i.length; t < s; ++t) e[t] = i[t]._$Get$_(0);
    };
    h;
    const na = self._$C3$_, oa = [], aa = function() {}, la = function*() {};
    na._$Action$_ = class extends na._$DefendedBase$_ {
        constructor(t, s, i) {
            super();
            const e = (this._$_eventBlock$_ = t)._$GetRuntime$_(), h = (this._$_runtime$_ = e, 
            this._$_index$_ = i, this._$_sid$_ = 4 <= s.length ? s[3] : -1, this._$_actionType$_ = 5 <= s.length ? 255 & s[4] : 0, 
            this._$_flags$_ = 5 <= s.length ? s[4] >> 8 : 0, this._$_func$_ = null, 
            this._$_objectClass$_ = null, this._$_behaviorType$_ = null, this._$_behaviorIndex$_ = -1, 
            this._$_systemPlugin$_ = null, this._$_callFunctionName$_ = "", this._$_callCustomAceObjectClass$_ = null, 
            this._$_callEventBlock$_ = null, this._$Run$_ = aa, this._$DebugRun$_ = aa, 
            this._$_parameters$_ = [], this._$_results$_ = [], this._$_anyParamVariesPerInstance$_ = !1, 
            this._$_savedData$_ = null, this._$_unsavedData$_ = null, -3 === s[0]), r = h ? s[2] : s[5];
            if (this._$_debugData$_ = e._$IsDebug$_() || h ? {
                _$isBreakpoint$_: r[0],
                _$canDebug$_: r[1],
                index: r[2]
            } : null, -1 === s[0]) this._$_systemPlugin$_ = e._$GetSystemPlugin$_(), 
            this._$_func$_ = e._$GetObjectReference$_(s[1]); else if (-2 === s[0]) this._$_callFunctionName$_ = s[1]; else if (h) {
                const n = e._$GetObjectReference$_(s[1]);
                this._$_func$_ = n, this._$Run$_ = this._$RunUserScript$_, this._$DebugRun$_ = this._$DebugRunUserScript$_, 
                this._$_flags$_ |= 8;
            } else this._$_objectClass$_ = e._$GetObjectClassByIndex$_(s[0]), 4 & this._$_flags$_ ? (this._$_callFunctionName$_ = s[1], 
            this._$_callCustomAceObjectClass$_ = e._$GetObjectClassByIndex$_(s[2])) : (s[2] && (this._$_behaviorType$_ = this._$_objectClass$_._$GetBehaviorTypeByName$_(s[2]), 
            this._$_behaviorIndex$_ = this._$_objectClass$_._$GetBehaviorIndexByName$_(s[2])), 
            this._$_func$_ = e._$GetObjectReference$_(s[1]));
            if (7 === s.length) {
                const o = s[6];
                for (const a of o) this._$_parameters$_.push(na._$Parameter$_._$Create$_(this, a, this._$_parameters$_.length)), 
                this._$_results$_.push(0);
            }
            0 === this._$_parameters$_.length && (this._$_parameters$_ = oa, this._$_results$_ = oa), 
            this._$CanPickAnyObjectClass$_() && (this._$_eventBlock$_._$SetAllSolModifiers$_(), 
            this._$_eventBlock$_._$SetSolWriterAfterCnds$_()), this._$_eventBlock$_._$GetEventSheetManager$_()._$_RegisterAction$_(this);
        }
        static _$Create$_(t, s, i) {
            return na._$New$_(na._$Action$_, t, s, i);
        }
        _$_PostInit$_() {
            for (const t of this._$_parameters$_) t._$_PostInit$_(), t._$VariesPerInstance$_() && (this._$_anyParamVariesPerInstance$_ = !0);
            if (this._$_systemPlugin$_) this._$_SetSystemRunMethod$_(), this._$DebugRun$_ = this._$_DebugRunSystem$_; else if (this._$_callFunctionName$_) 4 & this._$_flags$_ ? this._$_SetCallCustomActionRunMethod$_() : this._$_SetCallFunctionRunMethod$_(), 
            this._$_callFunctionName$_ = "", this._$_callCustomAceObjectClass$_ = null; else if (this._$Run$_ === this._$RunUserScript$_) {
                const s = this._$_func$_, i = this._$_runtime$_._$GetEventSheetManager$_()._$_GetLocalVariablesScriptInterface$_(this._$_eventBlock$_);
                this._$_func$_ = s.bind(null, this._$_runtime$_._$GetIRuntime$_(), i);
            } else this._$_behaviorType$_ ? this._$IsAsync$_() ? (this._$Run$_ = this._$_RunBehavior_Async$_, 
            this._$DebugRun$_ = this._$_DebugRunBehavior_Async$_) : (this._$Run$_ = this._$_RunBehavior$_, 
            this._$DebugRun$_ = this._$_DebugRunBehavior$_) : this._$_objectClass$_._$GetPlugin$_()._$IsSingleGlobal$_() ? (this._$_SetSingleGlobalRunMethod$_(), 
            this._$DebugRun$_ = this._$_DebugRunSingleGlobal$_) : this._$IsStatic$_() ? (this._$Run$_ = this._$_RunObject_Static$_, 
            this._$DebugRun$_ = this._$_DebugRunObject_Static$_) : this._$IsAsync$_() ? (this._$Run$_ = this._$_RunObject_Async$_, 
            this._$DebugRun$_ = this._$_DebugRunObject_Async$_) : this._$CallBeforeAfterHooks$_() ? (this._$Run$_ = this._$_RunObject_BeforeAfterHooks$_, 
            this._$DebugRun$_ = this._$_DebugRunObject_BeforeAfterHooks$_) : this._$_parameters$_.length ? this._$_parameters$_.every(t => t._$VariesPerInstance$_()) ? (this._$Run$_ = this._$_RunObject_AllParamsVary$_, 
            this._$DebugRun$_ = this._$_DebugRunObject_AllParamsVary$_) : this._$_anyParamVariesPerInstance$_ ? (this._$Run$_ = this._$_RunObject_SomeParamsVary$_, 
            this._$DebugRun$_ = this._$_DebugRunObject_SomeParamsVary$_) : this._$_parameters$_.every(t => t._$IsConstant$_()) ? (h(this._$_parameters$_, this._$_results$_), 
            this._$Run$_ = this._$_RunObject_ParamsConst$_, this._$DebugRun$_ = this._$_DebugRunObject_ParamsConst$_) : (this._$Run$_ = this._$_RunObject_ParamsDontVary$_, 
            this._$DebugRun$_ = this._$_DebugRunObject_ParamsDontVary$_) : (this._$Run$_ = this._$_RunObject_ParamsConst$_, 
            this._$DebugRun$_ = this._$_DebugRunObject_ParamsConst$_);
        }
        _$_SetSystemRunMethod$_() {
            const t = this._$_systemPlugin$_, s = this._$_systemPlugin$_;
            this._$_SetRunMethodForBoundFunc$_(t, s, this._$_RunSystem$_);
        }
        _$_SetSingleGlobalRunMethod$_() {
            const t = this._$_objectClass$_._$GetPlugin$_(), s = this._$_objectClass$_._$GetSingleGlobalInstance$_()._$GetSdkInstance$_();
            this._$_SetRunMethodForBoundFunc$_(t, s, this._$_RunSingleGlobal$_);
        }
        _$_SetCallFunctionRunMethod$_() {
            const t = this._$_eventBlock$_._$GetEventSheetManager$_(), i = t._$GetFunctionBlockByName$_(this._$_callFunctionName$_);
            if (i._$IsEnabled$_()) {
                const e = 0 != (2 & this._$_flags$_);
                this._$_callEventBlock$_ = i._$GetEventBlock$_();
                let s = [ ...new Set([ ...this._$_eventBlock$_._$GetSolModifiersIncludingParents$_(), ...this._$_callEventBlock$_._$GetSolModifiersIncludingParents$_() ]) ];
                s = t._$_DeduplicateSolModifierList$_(s);
                const h = !i._$IsCopyPicked$_() && this._$_HasCopyPickedParent$_() ? {
                    _$pushCleanSolDynamic$_: !0
                } : null;
                if (this._$Run$_ = na._$EventBlock$_.prototype._$RunAsFunctionCall$_.bind(this._$_callEventBlock$_, s, this._$_parameters$_, e, h), 
                this._$_runtime$_._$IsDebug$_()) {
                    const r = this;
                    this._$DebugRun$_ = function*() {
                        (r._$IsBreakpoint$_() || r._$_runtime$_._$DebugBreakNext$_()) && (yield r);
                        const t = yield* r._$_callEventBlock$_._$DebugRunAsFunctionCall$_(s, r._$_parameters$_, e, h);
                        return t;
                    };
                } else this._$DebugRun$_ = la;
            } else this._$Run$_ = aa, this._$DebugRun$_ = la;
        }
        _$_SetCallCustomActionRunMethod$_() {
            const r = this._$_eventBlock$_._$GetEventSheetManager$_(), n = r._$GetCustomActionBlockByName$_(this._$_callCustomAceObjectClass$_, this._$_callFunctionName$_);
            if (n._$IsEnabled$_()) {
                const o = 0 != (2 & this._$_flags$_);
                this._$_callEventBlock$_ = n._$GetEventBlock$_();
                let s = [ ...new Set([ ...this._$_eventBlock$_._$GetSolModifiersIncludingParents$_(), ...this._$_callEventBlock$_._$GetSolModifiersIncludingParents$_(), this._$_objectClass$_, n._$GetObjectClass$_() ]) ], t = (s = r._$_DeduplicateSolModifierList$_(s), 
                !this._$_objectClass$_._$IsFamily$_() && !n._$GetObjectClass$_()._$IsFamily$_()), i = !this._$_objectClass$_._$IsFamily$_() && n._$GetObjectClass$_()._$IsFamily$_(), e = this._$_objectClass$_._$IsFamily$_(), h = null;
                if (!n._$IsCopyPicked$_() && this._$_HasCopyPickedParent$_() && ((h = h || {})._$pushCleanSolDynamic$_ = !0), 
                !i && o || ((h = h || {})._$copyFromObjectClass$_ = this._$_objectClass$_, 
                h._$copyToObjectClass$_ = n._$GetObjectClass$_()), t || i || e && !n._$HasCustomACEOverrides$_() ? this._$Run$_ = na._$EventBlock$_.prototype._$RunAsFunctionCall$_.bind(this._$_callEventBlock$_, s, this._$_parameters$_, o, h) : e && (this._$Run$_ = na._$FunctionBlock$_.prototype._$RunAsFamilyCustomActionWithOverrides$_.bind(n, s, this._$_parameters$_)), 
                this._$_runtime$_._$IsDebug$_()) {
                    const a = this;
                    t || i || e && !n._$HasCustomACEOverrides$_() ? this._$DebugRun$_ = function*() {
                        (a._$IsBreakpoint$_() || a._$_runtime$_._$DebugBreakNext$_()) && (yield a);
                        const t = yield* a._$_callEventBlock$_._$DebugRunAsFunctionCall$_(s, a._$_parameters$_, o, h);
                        return t;
                    } : e && (this._$DebugRun$_ = function*() {
                        (a._$IsBreakpoint$_() || a._$_runtime$_._$DebugBreakNext$_()) && (yield a);
                        const t = yield* n._$DebugRunAsFamilyCustomActionWithOverrides$_(s, a._$_parameters$_);
                        return t;
                    });
                } else this._$DebugRun$_ = la;
            } else this._$Run$_ = aa, this._$DebugRun$_ = la;
        }
        _$_SetRunMethodForBoundFunc$_(t, s, i) {
            const e = this._$_func$_, h = this._$_parameters$_;
            if (0 === h.length) this._$Run$_ = t._$_GetBoundACEMethod$_(e, s); else if (1 === h.length) {
                const r = h[0];
                if (r._$IsConstant$_()) this._$Run$_ = t._$_GetBoundACEMethod_1param$_(e, s, r._$Get$_(0)); else {
                    const n = t._$_GetBoundACEMethod$_(e, s);
                    this._$Run$_ = function() {
                        return n(r._$Get$_(0));
                    };
                }
            } else if (2 === h.length) {
                const o = h[0], a = h[1];
                if (o._$IsConstant$_() && a._$IsConstant$_()) this._$Run$_ = t._$_GetBoundACEMethod_2params$_(e, s, o._$Get$_(0), a._$Get$_(0)); else {
                    const l = t._$_GetBoundACEMethod$_(e, s);
                    this._$Run$_ = function() {
                        return l(o._$Get$_(0), a._$Get$_(0));
                    };
                }
            } else if (3 === h.length) {
                const u = h[0], c = h[1], f = h[2];
                if (u._$IsConstant$_() && c._$IsConstant$_() && f._$IsConstant$_()) this._$Run$_ = t._$_GetBoundACEMethod_3params$_(e, s, u._$Get$_(0), c._$Get$_(0), f._$Get$_(0)); else {
                    const d = t._$_GetBoundACEMethod$_(e, s);
                    this._$Run$_ = function() {
                        return d(u._$Get$_(0), c._$Get$_(0), f._$Get$_(0));
                    };
                }
            } else this._$Run$_ = i;
        }
        _$GetSID$_() {
            return this._$_sid$_;
        }
        _$IsAsync$_() {
            return 0 != (8 & this._$_flags$_);
        }
        _$CanBailOut$_() {
            return 0 != (16 & this._$_flags$_);
        }
        _$CallBeforeAfterHooks$_() {
            return 1 === this._$_actionType$_;
        }
        _$IsStatic$_() {
            return 2 === this._$_actionType$_;
        }
        _$CanPickAnyObjectClass$_() {
            return 0 != (1 & this._$_flags$_);
        }
        _$HasReturnType$_() {
            return this._$IsAsync$_() || this._$CanBailOut$_();
        }
        _$GetObjectClass$_() {
            return this._$_objectClass$_;
        }
        _$GetImplementationAddon$_() {
            return this._$_behaviorType$_ ? this._$_behaviorType$_._$GetBehavior$_() : this._$_objectClass$_ ? this._$_objectClass$_._$GetPlugin$_() : null;
        }
        _$GetImplementationSdkVersion$_() {
            const t = this._$GetImplementationAddon$_();
            return t ? t._$GetSdkVersion$_() : 1;
        }
        _$GetEventBlock$_() {
            return this._$_eventBlock$_;
        }
        _$_HasCopyPickedParent$_() {
            let t = this._$_eventBlock$_;
            do {
                if (t instanceof na._$FunctionBlock$_ && t._$IsCopyPicked$_()) return !0;
            } while (t = t._$GetScopeParent$_());
            return !1;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$GetDebugIndex$_() {
            return this._$_debugData$_.index;
        }
        _$IsBreakpoint$_() {
            return this._$_debugData$_._$isBreakpoint$_;
        }
        _$_SetBreakpoint$_(t) {
            this._$_debugData$_._$isBreakpoint$_ = !!t, this._$_eventBlock$_._$_UpdateCanRunFastRecursive$_();
        }
        _$_DebugReturnsGenerator$_() {
            return this._$_debugData$_._$canDebug$_;
        }
        _$DebugCanRunFast$_() {
            return !this._$IsBreakpoint$_() && !this._$_runtime$_._$DebugBreakNext$_() && !this._$_DebugReturnsGenerator$_();
        }
        _$GetSavedDataMap$_() {
            return this._$_savedData$_ || (this._$_savedData$_ = new Map()), this._$_savedData$_;
        }
        _$GetUnsavedDataMap$_() {
            return this._$_unsavedData$_ || (this._$_unsavedData$_ = new Map()), 
            this._$_unsavedData$_;
        }
        _$_RunSystem$_() {
            const t = this._$_results$_;
            return h(this._$_parameters$_, t), this._$_func$_.apply(this._$_systemPlugin$_, t);
        }
        *_$_DebugRunSystem$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const t = this._$_results$_, s = (h(this._$_parameters$_, t), yield* this._$_func$_.apply(this._$_systemPlugin$_, t));
                return s;
            }
            return this._$Run$_();
        }
        _$_RunSingleGlobal$_() {
            const t = this._$_results$_;
            return h(this._$_parameters$_, t), this._$_func$_.apply(this._$_objectClass$_._$GetSingleGlobalInstance$_()._$GetSdkInstance$_(), t);
        }
        *_$_DebugRunSingleGlobal$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const t = this._$_results$_, s = (h(this._$_parameters$_, t), yield* this._$_func$_.apply(this._$_objectClass$_._$GetSingleGlobalInstance$_()._$GetSdkInstance$_(), t));
                return s;
            }
            return this._$Run$_();
        }
        _$_RunObject_ParamsConst$_() {
            const i = this._$_results$_, e = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_();
            for (let t = 0, s = e.length; t < s; ++t) this._$_func$_.apply(e[t]._$GetSdkInstance$_(), i);
        }
        *_$_DebugRunObject_ParamsConst$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const i = this._$_results$_, e = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_();
                for (let t = 0, s = e.length; t < s; ++t) yield* this._$_func$_.apply(e[t]._$GetSdkInstance$_(), i);
            } else this._$_RunObject_ParamsConst$_();
        }
        _$_RunObject_ParamsDontVary$_() {
            const i = this._$_results$_, e = (h(this._$_parameters$_, i), this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_());
            for (let t = 0, s = e.length; t < s; ++t) this._$_func$_.apply(e[t]._$GetSdkInstance$_(), i);
        }
        *_$_DebugRunObject_ParamsDontVary$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const i = this._$_results$_, e = (h(this._$_parameters$_, i), this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_());
                for (let t = 0, s = e.length; t < s; ++t) yield* this._$_func$_.apply(e[t]._$GetSdkInstance$_(), i);
            } else this._$_RunObject_ParamsDontVary$_();
        }
        _$_RunObject_AllParamsVary$_() {
            const e = this._$_parameters$_, h = this._$_results$_, s = this._$_func$_, r = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_();
            for (let i = 0, t = r.length; i < t; ++i) {
                const n = r[i];
                for (let t = 0, s = e.length; t < s; ++t) h[t] = e[t]._$Get$_(i);
                s.apply(n._$GetSdkInstance$_(), h);
            }
        }
        *_$_DebugRunObject_AllParamsVary$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const e = this._$_parameters$_, h = this._$_results$_, s = this._$_func$_, r = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_();
                for (let i = 0, t = r.length; i < t; ++i) {
                    const n = r[i];
                    for (let t = 0, s = e.length; t < s; ++t) h[t] = e[t]._$Get$_(i);
                    yield* s.apply(n._$GetSdkInstance$_(), h);
                }
            } else this._$_RunObject_AllParamsVary$_();
        }
        _$_RunObject_SomeParamsVary$_() {
            const e = this._$_parameters$_, h = this._$_results$_, s = this._$_func$_, r = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_();
            for (let t = 0, s = e.length; t < s; ++t) {
                const i = e[t];
                i._$VariesPerInstance$_() || (h[t] = i._$Get$_(0));
            }
            for (let i = 0, t = r.length; i < t; ++i) {
                const n = r[i];
                for (let t = 0, s = e.length; t < s; ++t) {
                    const o = e[t];
                    o._$VariesPerInstance$_() && (h[t] = o._$Get$_(i));
                }
                s.apply(n._$GetSdkInstance$_(), h);
            }
        }
        *_$_DebugRunObject_SomeParamsVary$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const e = this._$_parameters$_, h = this._$_results$_, s = this._$_func$_, r = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_();
                for (let t = 0, s = e.length; t < s; ++t) {
                    const i = e[t];
                    i._$VariesPerInstance$_() || (h[t] = i._$Get$_(0));
                }
                for (let i = 0, t = r.length; i < t; ++i) {
                    const n = r[i];
                    for (let t = 0, s = e.length; t < s; ++t) {
                        const o = e[t];
                        o._$VariesPerInstance$_() && (h[t] = o._$Get$_(i));
                    }
                    yield* s.apply(n._$GetSdkInstance$_(), h);
                }
            } else this._$_RunObject_SomeParamsVary$_();
        }
        _$_RunObject_BeforeAfterHooks$_() {
            const e = this._$_parameters$_, h = this._$_results$_, s = this._$_func$_, t = this._$_objectClass$_, i = t._$GetSdkType$_(), r = t._$GetCurrentSol$_()._$GetInstances$_();
            i._$BeforeRunAction$_(s);
            for (let i = 0, t = r.length; i < t; ++i) {
                const n = r[i];
                for (let t = 0, s = e.length; t < s; ++t) h[t] = e[t]._$Get$_(i);
                s.apply(n._$GetSdkInstance$_(), h);
            }
            i._$AfterRunAction$_(s);
        }
        *_$_DebugRunObject_BeforeAfterHooks$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const e = this._$_parameters$_, h = this._$_results$_, s = this._$_func$_, t = this._$_objectClass$_, i = t._$GetSdkType$_(), r = t._$GetCurrentSol$_()._$GetInstances$_();
                i._$BeforeRunAction$_(s);
                for (let i = 0, t = r.length; i < t; ++i) {
                    const n = r[i];
                    for (let t = 0, s = e.length; t < s; ++t) h[t] = e[t]._$Get$_(i);
                    yield* s.apply(n._$GetSdkInstance$_(), h);
                }
                i._$AfterRunAction$_(s);
            } else this._$_RunObject_BeforeAfterHooks$_();
        }
        _$_RunObject_Static$_() {
            const t = this._$_results$_;
            return h(this._$_parameters$_, t), this._$_func$_.apply(this._$_behaviorType$_ || this._$_objectClass$_, t);
        }
        *_$_DebugRunObject_Static$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const s = this._$_results$_;
                h(this._$_parameters$_, s);
                let t = this._$_func$_.apply(this._$_behaviorType$_ || this._$_objectClass$_, s);
                return t = na._$IsIterator$_(t) ? yield* t : t;
            }
            return this._$_RunObject_Static$_();
        }
        _$_RunBehavior$_() {
            const t = this._$_objectClass$_, s = t._$IsFamily$_(), e = t._$GetFamilyIndex$_(), h = this._$_parameters$_, r = this._$_anyParamVariesPerInstance$_, n = this._$_results$_, o = this._$_func$_, a = this._$_behaviorIndex$_, l = t._$GetCurrentSol$_()._$GetInstances$_();
            for (let t = 0, s = h.length; t < s; ++t) {
                const i = h[t];
                i._$VariesPerInstance$_() || (n[t] = i._$Get$_(0));
            }
            for (let i = 0, t = l.length; i < t; ++i) {
                const u = l[i];
                if (r) for (let t = 0, s = h.length; t < s; ++t) {
                    const f = h[t];
                    f._$VariesPerInstance$_() && (n[t] = f._$Get$_(i));
                }
                const c = s ? u._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(e) : 0;
                o.apply(u._$GetBehaviorInstances$_()[a + c]._$GetSdkInstance$_(), n);
            }
        }
        *_$_DebugRunBehavior$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const t = this._$_objectClass$_, s = t._$IsFamily$_(), e = t._$GetFamilyIndex$_(), h = this._$_parameters$_, r = this._$_anyParamVariesPerInstance$_, n = this._$_results$_, o = this._$_func$_, a = this._$_behaviorIndex$_, l = t._$GetCurrentSol$_()._$GetInstances$_();
                for (let t = 0, s = h.length; t < s; ++t) {
                    const i = h[t];
                    i._$VariesPerInstance$_() || (n[t] = i._$Get$_(0));
                }
                for (let i = 0, t = l.length; i < t; ++i) {
                    const u = l[i];
                    if (r) for (let t = 0, s = h.length; t < s; ++t) {
                        const f = h[t];
                        f._$VariesPerInstance$_() && (n[t] = f._$Get$_(i));
                    }
                    const c = s ? u._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(e) : 0;
                    yield* o.apply(u._$GetBehaviorInstances$_()[a + c]._$GetSdkInstance$_(), n);
                }
            } else this._$_RunBehavior$_();
        }
        _$_RunObject_Async$_() {
            const e = this._$_parameters$_, h = this._$_results$_, s = this._$_func$_, r = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_(), n = [];
            for (let i = 0, t = r.length; i < t; ++i) {
                const o = r[i];
                for (let t = 0, s = e.length; t < s; ++t) h[t] = e[t]._$Get$_(i);
                n.push(s.apply(o._$GetSdkInstance$_(), h));
            }
            return Promise.all(n);
        }
        *_$_DebugRunObject_Async$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const e = this._$_parameters$_, h = this._$_results$_, s = this._$_func$_, r = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_(), n = [];
                for (let i = 0, t = r.length; i < t; ++i) {
                    const o = r[i];
                    for (let t = 0, s = e.length; t < s; ++t) h[t] = e[t]._$Get$_(i);
                    n.push(yield* s.apply(o._$GetSdkInstance$_(), h));
                }
                return Promise.all(n);
            }
            return this._$_RunObject_Async$_();
        }
        _$_RunBehavior_Async$_() {
            const t = this._$_objectClass$_, s = t._$IsFamily$_(), e = t._$GetFamilyIndex$_(), h = this._$_parameters$_, r = this._$_results$_, n = this._$_func$_, o = this._$_behaviorIndex$_, a = t._$GetCurrentSol$_()._$GetInstances$_(), l = [];
            for (let i = 0, t = a.length; i < t; ++i) {
                const u = a[i];
                for (let t = 0, s = h.length; t < s; ++t) r[t] = h[t]._$Get$_(i);
                const c = s ? u._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(e) : 0;
                l.push(n.apply(u._$GetBehaviorInstances$_()[o + c]._$GetSdkInstance$_(), r));
            }
            return Promise.all(l);
        }
        *_$_DebugRunBehavior_Async$_() {
            if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$_DebugReturnsGenerator$_()) {
                const t = this._$_objectClass$_, s = t._$IsFamily$_(), e = t._$GetFamilyIndex$_(), h = this._$_parameters$_, r = this._$_results$_, n = this._$_func$_, o = this._$_behaviorIndex$_, a = t._$GetCurrentSol$_()._$GetInstances$_(), l = [];
                for (let i = 0, t = a.length; i < t; ++i) {
                    const u = a[i];
                    for (let t = 0, s = h.length; t < s; ++t) r[t] = h[t]._$Get$_(i);
                    const c = s ? u._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(e) : 0;
                    l.push(yield* n.apply(u._$GetBehaviorInstances$_()[o + c]._$GetSdkInstance$_(), r));
                }
                return Promise.all(l);
            }
            return this._$_RunBehavior_Async$_();
        }
        async _$RunUserScript$_() {
            try {
                await this._$_func$_();
            } catch (t) {
                console.error(`Unhandled exception running script %c${this._$_eventBlock$_._$GetEventSheet$_()._$GetName$_()}, event ${this._$_eventBlock$_._$GetDisplayNumber$_()}, action ${this._$GetDebugIndex$_() + 1}:`, "font-size: 1.2em; font-weight: bold;", t), 
                self.C3Debugger && self.C3Debugger._SetLastErrorScript(this), na._$EventScript$_._$HadUserScriptException$_() || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), 
                na._$EventScript$_._$SetHadUserScriptException$_());
            }
        }
        *_$DebugRunUserScript$_() {
            return (this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
            this._$RunUserScript$_();
        }
        _$_SaveToJson$_() {
            return this._$_savedData$_ && this._$_savedData$_.size ? {
                ex: na._$ToSuperJSON$_(this._$_savedData$_)
            } : null;
        }
        _$_LoadFromJson$_(t) {
            if (this._$_savedData$_ && (this._$_savedData$_.clear(), this._$_savedData$_ = null), 
            t) {
                const s = t.ex;
                s && (this._$_savedData$_ = na._$FromSuperJSON$_(s));
            }
        }
    };
}

{
    let d = function(t) {
        return t instanceof self._$IInstance$_ ? r._$_UnwrapScriptInterface$_(t) : t._$GetInstance$_();
    }, u = function(t) {
        return d(t)._$GetWorldInfo$_();
    }, S = function(t, s) {
        return U.compare(u(this)._$GetX$_(), t, s);
    }, b = function(t, s) {
        return U.compare(u(this)._$GetY$_(), t, s);
    }, M = function() {
        return u(this)._$IsInViewport2$_();
    }, v = function() {
        const t = u(this), s = t._$GetLayout$_(), i = t._$GetBoundingBox$_();
        return i._$getRight$_() < 0 || i._$getBottom$_() < 0 || i._$getLeft$_() > s._$GetWidth$_() || i._$getTop$_() > s._$GetHeight$_();
    }, x = function(i, e, h) {
        const t = this._$GetCurrentSol$_(), r = t._$GetInstances$_();
        if (!r.length) return !1;
        let n = r[0], o = n._$GetWorldInfo$_(), a = n, l = U._$distanceSquared$_(o._$GetX$_(), o._$GetY$_(), e, h);
        for (let t = 1, s = r.length; t < s; ++t) {
            n = r[t], o = n._$GetWorldInfo$_();
            const u = U._$distanceSquared$_(o._$GetX$_(), o._$GetY$_(), e, h);
            (0 === i && u < l || 1 === i && u > l) && (l = u, a = n);
        }
        return t._$PickOne$_(a), !0;
    }, G = function(t) {
        const s = u(this);
        s._$GetX$_() !== t && (s._$SetX$_(t), s._$SetBboxChanged$_());
    }, T = function(t) {
        const s = u(this);
        s._$GetY$_() !== t && (s._$SetY$_(t), s._$SetBboxChanged$_());
    }, _ = function(t, s) {
        const i = u(this);
        i._$EqualsXY$_(t, s) || (i._$SetXY$_(t, s), i._$SetBboxChanged$_());
    }, I = function(t, s) {
        if (t) {
            const i = d(this), e = t._$GetPairedInstance$_(i);
            if (e) {
                const [ h, r ] = e._$GetImagePoint$_(s), n = i._$GetWorldInfo$_();
                n._$GetX$_() === h && n._$GetY$_() === r || (n._$SetXY$_(h, r), 
                n._$SetBboxChanged$_());
            }
        }
    }, C = function(t) {
        if (0 !== t) {
            const s = u(this);
            s._$OffsetXY$_(s._$GetCosAngle$_() * t, s._$GetSinAngle$_() * t), s._$SetBboxChanged$_();
        }
    }, R = function(t, s) {
        if (0 !== s) {
            const i = u(this);
            t = U._$toRadians$_(t), i._$OffsetXY$_(Math.cos(t) * s, Math.sin(t) * s), 
            i._$SetBboxChanged$_();
        }
    }, P = function() {
        return u(this)._$GetX$_();
    }, E = function() {
        return u(this)._$GetY$_();
    }, A = function() {
        const t = d(this);
        return t._$GetRuntime$_()._$GetDt$_(t);
    }, F = function(t, s) {
        return U.compare(u(this)._$GetWidth$_(), t, s);
    }, O = function(t, s) {
        return U.compare(u(this)._$GetHeight$_(), t, s);
    }, D = function(t) {
        const s = u(this);
        s._$GetWidth$_() !== t && (s._$SetWidth$_(t), s._$SetBboxChanged$_());
    }, k = function(t) {
        const s = u(this);
        s._$GetHeight$_() !== t && (s._$SetHeight$_(t), s._$SetBboxChanged$_());
    }, L = function(t, s) {
        const i = u(this);
        i._$GetWidth$_() === t && i._$GetHeight$_() === s || (i._$SetSize$_(t, s), 
        i._$SetBboxChanged$_());
    }, K = function() {
        return u(this)._$GetWidth$_();
    }, Z = function() {
        return u(this)._$GetHeight$_();
    }, Q = function() {
        return u(this)._$GetBoundingBox$_()._$getLeft$_();
    }, tt = function() {
        return u(this)._$GetBoundingBox$_()._$getTop$_();
    }, st = function() {
        return u(this)._$GetBoundingBox$_()._$getRight$_();
    }, it = function() {
        return u(this)._$GetBoundingBox$_()._$getBottom$_();
    }, et = function() {
        const t = u(this)._$GetBoundingBox$_();
        return (t._$getLeft$_() + t._$getRight$_()) / 2;
    }, ht = function() {
        const t = u(this)._$GetBoundingBox$_();
        return (t._$getTop$_() + t._$getBottom$_()) / 2;
    }, rt = function(t, s) {
        return U._$angleDiff$_(u(this)._$GetAngle$_(), U._$toRadians$_(s)) <= U._$toRadians$_(t);
    }, nt = function(t) {
        return U._$angleClockwise$_(u(this)._$GetAngle$_(), U._$toRadians$_(t));
    }, ot = function(t, s) {
        const i = U._$toRadians$_(t), e = U._$toRadians$_(s), h = u(this)._$GetAngle$_(), r = !U._$angleClockwise$_(e, i);
        return r ? !(!U._$angleClockwise$_(h, i) && U._$angleClockwise$_(h, e)) : U._$angleClockwise$_(h, i) && !U._$angleClockwise$_(h, e);
    }, at = function(t) {
        const s = u(this), i = U._$clampAngle$_(U._$toRadians$_(t));
        isNaN(i) || s._$GetAngle$_() === i || (s._$SetAngle$_(i), s._$SetBboxChanged$_());
    }, lt = function(t) {
        if (!isNaN(t) && 0 !== t) {
            const s = u(this);
            s._$SetAngle$_(s._$GetAngle$_() + U._$toRadians$_(t)), s._$SetBboxChanged$_();
        }
    }, ut = function(t) {
        if (!isNaN(t) && 0 !== t) {
            const s = u(this);
            s._$SetAngle$_(s._$GetAngle$_() - U._$toRadians$_(t)), s._$SetBboxChanged$_();
        }
    }, ct = function(t, s) {
        const i = u(this), e = i._$GetAngle$_(), h = U._$angleRotate$_(e, U._$toRadians$_(s), U._$toRadians$_(t));
        isNaN(h) || e === h || (i._$SetAngle$_(h), i._$SetBboxChanged$_());
    }, ft = function(t, s, i) {
        const e = u(this), h = e._$GetAngle$_(), r = s - e._$GetX$_(), n = i - e._$GetY$_(), o = Math.atan2(n, r), a = U._$angleRotate$_(h, o, U._$toRadians$_(t));
        isNaN(a) || h === a || (e._$SetAngle$_(a), e._$SetBboxChanged$_());
    }, dt = function(t, s) {
        const i = u(this), e = i._$GetAngle$_(), h = t - i._$GetX$_(), r = s - i._$GetY$_(), n = Math.atan2(r, h);
        isNaN(n) || e === n || (i._$SetAngle$_(n), i._$SetBboxChanged$_());
    }, pt = function() {
        return U._$toDegrees$_(u(this)._$GetAngle$_());
    }, mt = function(t, s) {
        return U.compare(U._$roundToDp$_(100 * u(this)._$GetOpacity$_(), 6), t, s);
    }, B = function() {
        return u(this)._$IsVisible$_();
    }, gt = function(t) {
        const s = d(this), i = s._$GetWorldInfo$_();
        t = 2 === t ? !i._$IsVisible$_() : 0 !== t, i._$IsVisible$_() !== t && (i._$SetVisible$_(t), 
        s._$GetRuntime$_()._$UpdateRender$_());
    }, yt = function(t) {
        const s = U._$clamp$_(t / 100, 0, 1), i = d(this), e = i._$GetWorldInfo$_();
        if (e._$GetTransformWithParentOpacity$_()) {
            if (e._$_GetSceneGraphInfo$_()._$GetOwnOpacity$_() === s) return;
        } else if (e._$GetOpacity$_() === s) return;
        e._$SetOpacity$_(s), i._$GetRuntime$_()._$UpdateRender$_();
    }, wt = function(t) {
        l._$setFromRgbValue$_(t);
        const s = d(this), i = s._$GetWorldInfo$_();
        i._$GetUnpremultipliedColor$_()._$equalsIgnoringAlpha$_(l) || (i._$SetUnpremultipliedColor$_(l), 
        s._$GetRuntime$_()._$UpdateRender$_());
    }, St = function() {
        const t = u(this)._$GetUnpremultipliedColor$_();
        return U._$PackRGBAEx$_(t._$getR$_(), t._$getG$_(), t._$getB$_(), t._$getA$_());
    }, bt = function() {
        return U._$roundToDp$_(100 * u(this)._$GetOpacity$_(), 6);
    }, Mt = function(t) {
        return !!t && u(this)._$GetLayer$_() === t;
    }, vt = function(i) {
        const t = this._$GetCurrentSol$_(), e = t._$GetInstances$_();
        if (!e.length) return !1;
        let s = e[0], h = s;
        for (let t = 1, s = e.length; t < s; ++t) {
            const r = e[t], n = r._$GetWorldInfo$_(), o = h._$GetWorldInfo$_(), a = n._$GetLayer$_()._$GetIndex$_(), l = o._$GetLayer$_()._$GetIndex$_();
            0 === i ? (l < a || a === l && n._$GetZIndex$_() > o._$GetZIndex$_()) && (h = r) : (a < l || a === l && n._$GetZIndex$_() < o._$GetZIndex$_()) && (h = r);
        }
        return t._$PickOne$_(h), !0;
    }, xt = function(t, s, i) {
        const e = u(this), h = 0 === t ? e._$GetZElevation$_() : e._$GetTotalZElevation$_();
        return U.compare(h, s, i);
    }, Gt = function() {
        u(this)._$ZOrderMoveToTop$_();
    }, Tt = function() {
        u(this)._$ZOrderMoveToBottom$_();
    }, _t = function(t) {
        t && u(this)._$ZOrderMoveToLayer$_(t);
    }, It = function(t, s) {
        const i = 0 === t;
        if (s) {
            const e = d(this), h = s._$GetFirstPicked$_(e);
            h && e._$GetWorldInfo$_()._$ZOrderMoveAdjacentToInstance$_(h, i);
        }
    }, Ct = function(t) {
        const s = d(this), i = s._$GetWorldInfo$_();
        i._$GetZElevation$_() !== t && (i._$SetZElevation$_(t), s._$GetRuntime$_()._$UpdateRender$_());
    }, Rt = function() {
        return u(this)._$GetLayer$_()._$GetIndex$_();
    }, Pt = function() {
        return u(this)._$GetLayer$_()._$GetName$_();
    }, Et = function() {
        return u(this)._$GetZIndex$_();
    }, At = function() {
        return u(this)._$GetZElevation$_();
    }, Ft = function() {
        return u(this)._$GetTotalZElevation$_();
    }, Ot = function(t) {
        const s = d(this), i = s._$GetObjectClass$_()._$GetEffectList$_()._$GetEffectTypeByName$_(t);
        if (i) {
            const e = i._$GetIndex$_(), h = s._$GetWorldInfo$_()._$GetInstanceEffectList$_();
            return h._$IsEffectIndexActive$_(e);
        }
    }, Dt = function(t, s) {
        const i = d(this), e = i._$GetObjectClass$_()._$GetEffectList$_()._$GetEffectTypeByName$_(s);
        if (e) {
            const h = e._$GetIndex$_(), r = 1 === t, n = i._$GetWorldInfo$_()._$GetInstanceEffectList$_();
            n._$IsEffectIndexActive$_(h) !== r && (n._$SetEffectIndexActive$_(h, r), 
            n._$UpdateActiveEffects$_(), i._$GetRuntime$_()._$UpdateRender$_());
        }
    }, kt = function(t, s, i) {
        const e = d(this), h = e._$GetObjectClass$_()._$GetEffectList$_()._$GetEffectTypeByName$_(t);
        if (h) {
            s = Math.floor(s);
            const r = h._$GetShaderProgram$_()._$GetParameterType$_(s);
            if (r) {
                "color" === r ? (l._$setFromRgbValue$_(i), i = l) : "percent" === r && (i /= 100);
                const n = h._$GetIndex$_(), o = e._$GetWorldInfo$_()._$GetInstanceEffectList$_(), a = o._$SetEffectParameter$_(n, s, i);
                a && o._$IsEffectIndexActive$_(n) && e._$GetRuntime$_()._$UpdateRender$_();
            }
        }
    }, N = function(t, s, i, e) {
        const h = s._$GetUID$_(), r = i._$GetUID$_();
        h < r ? t.Set(s, i, e) : t.Set(i, s, e);
    }, W = function(t, s, i) {
        const e = s._$GetUID$_(), h = i._$GetUID$_();
        e < h ? t._$Delete$_(s, i) : t._$Delete$_(i, s);
    }, j = function(t, s) {
        t._$DeleteEither$_(s);
    }, V = function(t, s, i) {
        const e = s._$GetUID$_(), h = i._$GetUID$_();
        return e < h ? t._$Get$_(s, i) : t._$Get$_(i, s);
    }, e = function(t, s, i, e) {
        if (!s) return !1;
        const h = 0 !== i || 0 !== e, r = t._$GetWorldInfo$_(), n = t._$GetRuntime$_(), o = n._$GetCollisionEngine$_(), a = n._$GetCurrentCondition$_(), l = a._$GetEventBlock$_()._$IsOrBlock$_(), u = a._$GetObjectClass$_(), c = a._$IsInverted$_(), f = s._$GetCurrentSol$_(), d = u !== s;
        X = s, q = d && !c;
        let p, m = 0, g = 0, y = Y = !1;
        f._$IsSelectAll$_() ? (H._$copy$_(r._$GetBoundingBox$_()), H.offset(i, e), 
        o._$GetCollisionCandidates$_(r._$GetLayer$_(), s, H, J), p = J) : !l || n._$IsCurrentConditionFirst$_() && !f._$_GetOwnElseInstances$_().length && f._$_GetOwnInstances$_().length ? p = f._$_GetOwnInstances$_() : (p = f._$_GetOwnElseInstances$_(), 
        Y = !0), h && (m = r._$GetX$_(), g = r._$GetY$_(), r._$OffsetXY$_(i, e), 
        r._$SetBboxChanged$_());
        for (const w of p) if (o._$TestOverlap$_(t, w)) {
            if (y = !0, c) break;
            d && $.add(w);
        }
        return h && (r._$SetXY$_(m, g), r._$SetBboxChanged$_()), U._$clearArray$_(J), 
        y;
    }, i = function(t) {
        const s = t._$GetRuntime$_()._$GetCurrentEvent$_()._$IsOrBlock$_(), i = X._$GetCurrentSol$_(), e = i._$_GetOwnInstances$_(), h = i._$_GetOwnElseInstances$_();
        i._$IsSelectAll$_() ? (i._$SetSetPicked$_($), s && (U._$clearArray$_(h), 
        i._$AddElseInstances$_($, X._$GetInstances$_()))) : s ? Y ? i._$TransferElseInstancesToOwn$_($) : (i._$AddElseInstances$_($, e), 
        i._$SetSetPicked$_($)) : i._$SetSetPicked$_($), X._$ApplySolToContainer$_();
    }, Lt = function(t, s) {
        q && (s && i(t), $.clear(), X = null, q = !1);
    }, Bt = function(w) {
        if (this._$_runtime$_._$IsDebugging$_()) return function*(w) {
            if (w) {
                let t = this._$_runtime$_, s = t._$GetCollisionEngine$_(), e = t._$GetEventSheetManager$_(), i = e._$GetEventStack$_(), h = e._$GetCurrentCondition$_(), r = h._$GetObjectClass$_(), n = h._$GetSavedDataMap$_(), o = h._$GetUnsavedDataMap$_(), a = i._$GetCurrentStackFrame$_(), l = t._$GetTickCount$_(), u = l - 1, c = a._$GetCurrentEvent$_(), f = i._$Push$_(c), d = n.get("collmemory"), p = (d || (d = U._$New$_(U._$PairMap$_), 
                n.set("collmemory", d)), o.get("collisionCreatedDestroyCallback") || (o.set("collisionCreatedDestroyCallback", !0), 
                t._$Dispatcher$_().addEventListener("instancedestroy", t => j(d, t._$instance$_))), 
                r._$GetCurrentSol$_()), m = w._$GetCurrentSol$_(), g = p._$GetInstances$_(), y = null;
                for (let t = 0; t < g.length; ++t) {
                    const S = g[t];
                    m._$IsSelectAll$_() ? (s._$GetCollisionCandidates$_(S._$GetWorldInfo$_()._$GetLayer$_(), w, S._$GetWorldInfo$_()._$GetBoundingBox$_(), z), 
                    y = z, s._$AddRegisteredCollisionCandidates$_(S, w, y)) : y = m._$GetInstances$_();
                    for (let t = 0; t < y.length; ++t) {
                        const b = y[t];
                        if (s._$TestOverlap$_(S, b) || s._$CheckRegisteredCollision$_(S, b)) {
                            let t = V(d, S, b), s = !1, i = -2;
                            "number" == typeof t && (s = !0, i = t);
                            const M = !s || i < u;
                            if (N(d, S, b, l), M) {
                                const v = c._$GetSolModifiers$_(), x = (e._$PushCopySol$_(v), 
                                r._$GetCurrentSol$_()), G = w._$GetCurrentSol$_();
                                if (x._$_SetSelectAll$_(!1), G._$_SetSelectAll$_(!1), 
                                r === w) {
                                    const T = x._$_GetOwnInstances$_();
                                    U._$clearArray$_(T), T.push(S), T.push(b), r._$ApplySolToContainer$_();
                                } else {
                                    const _ = x._$_GetOwnInstances$_(), I = G._$_GetOwnInstances$_();
                                    U._$clearArray$_(_), U._$clearArray$_(I), _.push(S), 
                                    I.push(b), r._$ApplySolToContainer$_(), w._$ApplySolToContainer$_();
                                }
                                yield* c._$DebugRetrigger$_(a, f), e._$PopSol$_(v);
                            }
                        } else W(d, S, b);
                    }
                    U._$clearArray$_(z);
                }
                i._$Pop$_();
            }
            return !1;
        }.call(this, w);
        if (w) {
            let t = this._$_runtime$_, s = t._$GetCollisionEngine$_(), e = t._$GetEventSheetManager$_(), i = e._$GetEventStack$_(), h = e._$GetCurrentCondition$_(), r = h._$GetObjectClass$_(), n = h._$GetSavedDataMap$_(), o = h._$GetUnsavedDataMap$_(), a = i._$GetCurrentStackFrame$_(), l = t._$GetTickCount$_(), u = l - 1, c = a._$GetCurrentEvent$_(), f = i._$Push$_(c), d = n.get("collmemory"), p = (d || (d = U._$New$_(U._$PairMap$_), 
            n.set("collmemory", d)), o.get("collisionCreatedDestroyCallback") || (o.set("collisionCreatedDestroyCallback", !0), 
            t._$Dispatcher$_().addEventListener("instancedestroy", t => j(d, t._$instance$_))), 
            r._$GetCurrentSol$_()), m = w._$GetCurrentSol$_(), g = p._$GetInstances$_(), y = null;
            for (let t = 0; t < g.length; ++t) {
                const S = g[t];
                m._$IsSelectAll$_() ? (s._$GetCollisionCandidates$_(S._$GetWorldInfo$_()._$GetLayer$_(), w, S._$GetWorldInfo$_()._$GetBoundingBox$_(), z), 
                y = z, s._$AddRegisteredCollisionCandidates$_(S, w, y)) : y = m._$GetInstances$_();
                for (let t = 0; t < y.length; ++t) {
                    const b = y[t];
                    if (s._$TestOverlap$_(S, b) || s._$CheckRegisteredCollision$_(S, b)) {
                        let t = V(d, S, b), s = !1, i = -2;
                        "number" == typeof t && (s = !0, i = t);
                        const M = !s || i < u;
                        if (N(d, S, b, l), M) {
                            const v = c._$GetSolModifiers$_(), x = (e._$PushCopySol$_(v), 
                            r._$GetCurrentSol$_()), G = w._$GetCurrentSol$_();
                            if (x._$_SetSelectAll$_(!1), G._$_SetSelectAll$_(!1), 
                            r === w) {
                                const T = x._$_GetOwnInstances$_();
                                U._$clearArray$_(T), T.push(S), T.push(b), r._$ApplySolToContainer$_();
                            } else {
                                const _ = x._$_GetOwnInstances$_(), I = G._$_GetOwnInstances$_();
                                U._$clearArray$_(_), U._$clearArray$_(I), _.push(S), 
                                I.push(b), r._$ApplySolToContainer$_(), w._$ApplySolToContainer$_();
                            }
                            c._$Retrigger$_(a, f), e._$PopSol$_(v);
                        }
                    } else W(d, S, b);
                }
                U._$clearArray$_(z);
            }
            i._$Pop$_();
        }
        return !1;
    }, Nt = function(t) {
        return e(d(this), t, 0, 0);
    }, Wt = function(t, s, i) {
        return e(d(this), t, s, i);
    }, jt = function() {
        return u(this)._$HasParent$_();
    }, Vt = function() {
        return u(this)._$HasChildren$_();
    }, Ut = function(i, e) {
        const t = this._$GetCurrentSol$_(), h = t._$GetInstances$_();
        if (0 === h.length) return !1;
        let s = i._$GetCurrentSol$_(), r = s._$GetInstances$_();
        if (s._$IsSelectAll$_()) {
            const a = [ ...this._$_runtime$_._$instancesPendingCreateForObjectClass$_(i) ];
            0 < a.length && (r = r.concat(a));
        }
        if (0 === r.length) return !1;
        const n = new Set(r), o = new Set();
        for (let t = 0, s = h.length; t < s; ++t) {
            const l = h[t];
            if (1 === e) for (const u of l._$parents$_()) u._$BelongsToObjectClass$_(i) && n.has(u) && o.add(u); else {
                let t;
                if (0 === e) {
                    if (null === (t = l._$GetParent$_())) continue;
                } else t = l._$GetTopParent$_();
                t._$BelongsToObjectClass$_(i) && n.has(t) && o.add(t);
            }
        }
        return 0 !== o.size && (s._$SetSetPicked$_(o), i._$ApplySolToContainer$_(), 
        !0);
    }, Ht = function(i, e) {
        const t = this._$GetCurrentSol$_(), h = t._$GetInstances$_();
        if (0 === h.length) return !1;
        let s = i._$GetCurrentSol$_(), r = s._$GetInstances$_();
        if (s._$IsSelectAll$_()) {
            const a = [ ...this._$_runtime$_._$instancesPendingCreateForObjectClass$_(i) ];
            0 < a.length && (r = r.concat(a));
        }
        if (0 === r.length) return !1;
        const n = new Set(r), o = new Set();
        for (let t = 0, s = h.length; t < s; ++t) {
            const l = h[t];
            2 === e && !l._$HasChildren$_() && l._$BelongsToObjectClass$_(i) && n.has(l) && o.add(l);
            for (const u of 0 === e ? l.children() : l._$allChildren$_()) 2 === e && u._$HasChildren$_() || u._$BelongsToObjectClass$_(i) && n.has(u) && o.add(u);
        }
        return 0 !== o.size && (s._$SetSetPicked$_(o), i._$ApplySolToContainer$_(), 
        !0);
    }, zt = function(i, e, h) {
        const t = this._$GetCurrentSol$_(), r = t._$GetInstances$_();
        if (0 === r.length) return !1;
        let s = i._$GetCurrentSol$_(), n = s._$GetInstances$_();
        if (s._$IsSelectAll$_()) {
            const l = [ ...this._$_runtime$_._$instancesPendingCreateForObjectClass$_(i) ];
            0 < l.length && (n = n.concat(l));
        }
        if (0 === n.length) return !1;
        const o = new Set(n), a = [];
        for (let t = 0, s = r.length; t < s; ++t) {
            const u = r[t];
            if (0 === e) {
                const c = u._$GetChildAt$_(h);
                null !== c && c._$BelongsToObjectClass$_(i) && o.has(c) && a.push(c);
            } else if (1 === e) for (const f of u.children()) if (f._$BelongsToObjectClass$_(i)) {
                if (0 === h) {
                    o.has(f) && a.push(f);
                    break;
                }
                --h;
            }
        }
        return 0 !== a.length && (s._$SetArrayPicked$_(a), i._$ApplySolToContainer$_(), 
        !0);
    }, Jt = function(t, s, i) {
        const e = d(this);
        switch (t) {
          case 0:
          default:
            return U.compare(e._$GetChildCount$_(), s, i);

          case 1:
            return U.compare(e._$GetAllChildCount$_(), s, i);
        }
    }, qt = function(t, s, i, e, h, r, n, o, a, l) {
        const u = d(this), c = u._$GetRuntime$_()._$GetCurrentAction$_()._$GetObjectClass$_();
        for (const f of t._$allCorrespondingInstances$_(u, c)) {
            if (!f._$GetPlugin$_()._$SupportsSceneGraph$_()) return;
            u._$AddChild$_(f, {
                _$transformX$_: s,
                _$transformY$_: i,
                _$transformWidth$_: e,
                _$transformHeight$_: h,
                _$transformAngle$_: r,
                _$transformOpacity$_: n,
                _$transformZElevation$_: o,
                _$transformVisibility$_: a,
                _$destroyWithParent$_: l
            });
        }
    }, Xt = function(t) {
        const s = d(this), i = s._$GetRuntime$_()._$GetCurrentAction$_()._$GetObjectClass$_();
        for (const e of t._$allCorrespondingInstances$_(s, i)) s._$RemoveChild$_(e);
    }, Yt = function() {
        const t = d(this);
        if (t._$HasParent$_()) {
            const s = t._$GetParent$_();
            s._$RemoveChild$_(t);
        }
    }, $t = function() {
        return d(this)._$GetChildCount$_();
    }, Kt = function() {
        return d(this)._$GetAllChildCount$_();
    }, Zt = function(t, s) {
        t = Math.floor(t), s = Math.floor(s);
        const i = u(this);
        t < 2 || s < 2 || !isFinite(t) || !isFinite(s) ? (i._$ReleaseMesh$_(), i._$SetBboxChanged$_()) : i._$CreateMesh$_(t, s);
    }, Qt = function(t, s, i, e, h, r, n, o) {
        const a = u(this), l = a._$SetMeshPoint$_(t, s, {
            mode: 0 === i ? "absolute" : "relative",
            x: e,
            y: h,
            _$zElevation$_: r,
            u: n,
            v: o
        });
        l && a._$SetBboxChanged$_();
    }, ts = function() {
        const t = u(this);
        return t._$HasMesh$_() ? t._$GetSourceMesh$_()._$GetHSize$_() : 0;
    }, ss = function() {
        const t = u(this);
        return t._$HasMesh$_() ? t._$GetSourceMesh$_()._$GetVSize$_() : 0;
    }, is = function(t) {
        const s = u(this);
        t = 2 === t ? !s._$IsVisible$_() : 0 !== t, s._$IsVisible$_() !== t && s._$SetVisible$_(t);
    }, es = function(t, s) {
        this instanceof self._$IInstance$_ ? this._$setElementCSSStyle$_(t, s) : this._$SetElementCSSStyle$_(t, s);
    }, hs = function(t, s) {
        this instanceof self._$IInstance$_ ? this._$setElementAttribute$_(t, "" + s) : this._$SetElementAttribute$_(t, "" + s);
    }, rs = function(t) {
        this instanceof self._$IInstance$_ ? this._$removeElementAttribute$_(t) : this._$RemoveElementAttribute$_(t);
    }, ns = function() {
        this instanceof self._$IInstance$_ ? this._$focusElement$_() : this._$FocusElement$_();
    }, os = function() {
        this instanceof self._$IInstance$_ ? this._$blurElement$_() : this._$BlurElement$_();
    }, as = function() {
        return this instanceof self._$IInstance$_ ? this._$isElementFocused$_() : this._$IsElementFocused$_();
    }, ls = function(t) {
        this instanceof self._$IInstance$_ ? this._setEnabled(0 !== t) : this._$_SetEnabled$_(0 !== t);
    }, us = function() {
        return this instanceof self._$IInstance$_ ? this._$_isEnabled$_() : this._$_IsEnabled$_();
    }, cs = function(t, s, i) {
        return U.compare(d(this)._$GetInstanceVariableValue$_(t), s, i);
    }, fs = function(t) {
        return !!d(this)._$GetInstanceVariableValue$_(t);
    }, ds = function(i, e) {
        const t = this._$GetCurrentSol$_(), h = t._$GetInstances$_();
        if (!h.length) return !1;
        let r = this._$IsFamily$_(), n = null, o = 0;
        for (let t = 0, s = h.length; t < s; ++t) {
            const a = h[t], l = r ? a._$GetObjectClass$_()._$GetFamilyInstanceVariableOffset$_(this._$GetFamilyIndex$_()) : 0, u = a._$GetInstanceVariableValue$_(l + e);
            (null === n || 0 === i && u < o || 1 === i && u > o) && (o = u, n = a);
        }
        return t._$PickOne$_(n), !0;
    }, ps = function(t) {
        return (this._$_runtime$_._$GetCurrentCondition$_()._$IsInverted$_() ? h : s)(this, t);
    }, s = function(t, s) {
        const i = t._$GetRuntime$_()._$GetInstanceByUID$_(s);
        if (i) {
            const e = t._$GetCurrentSol$_();
            if (e._$IsSelectAll$_() || e._$_GetOwnInstances$_().includes(i)) if (t._$IsFamily$_()) {
                if (i._$GetObjectClass$_()._$BelongsToFamily$_(t)) return e._$PickOne$_(i), 
                t._$ApplySolToContainer$_(), !0;
            } else if (i._$GetObjectClass$_() === t) return e._$PickOne$_(i), t._$ApplySolToContainer$_(), 
            !0;
        }
        return !1;
    }, h = function(t, h) {
        const r = t._$GetCurrentSol$_();
        if (r._$IsSelectAll$_()) {
            r._$_SetSelectAll$_(!1), r._$ClearArrays$_();
            const i = t._$GetInstances$_();
            for (let t = 0, s = i.length; t < s; ++t) {
                const e = i[t];
                e._$GetUID$_() === h ? r._$_PushElseInstance$_(e) : r._$_PushInstance$_(e);
            }
            return t._$ApplySolToContainer$_(), !!r._$_GetOwnInstances$_().length;
        }
        {
            let i = r._$_GetOwnInstances$_(), e = 0;
            for (let t = 0, s = i.length; t < s; ++t) {
                const n = i[t];
                (i[e] = n)._$GetUID$_() === h ? r._$_PushElseInstance$_(n) : ++e;
            }
            return U._$truncateArray$_(i, e), t._$ApplySolToContainer$_(), !!i.length;
        }
    }, ms = function(t) {
        const s = new Set(U._$splitStringAndNormalize$_(t)), i = d(this)._$GetTagsSet$_();
        return s._$isSubsetOf$_(i);
    }, gs = function() {
        return d(this)._$GetTagsString$_();
    }, ys = function() {
        return d(this)._$GetTagsSet$_().size;
    }, ws = function(t) {
        return d(this)._$GetTagAt$_(t);
    }, Ss = function(t, s) {
        const i = U._$splitStringAndNormalize$_(s);
        if (0 !== i.length) {
            const e = d(this), h = new Set(e._$GetTagsSet$_());
            if (0 === t) for (const r of i) h.add(r); else if (1 === t) for (const n of i) h.delete(n);
            e._$SetTagsSet$_(h);
        }
    }, bs = function() {
        const t = d(this);
        t._$GetRuntime$_()._$DestroyInstance$_(t);
    }, Ms = function() {
        return !0;
    }, vs = function() {
        return !0;
    }, xs = function(t, s) {
        d(this)._$SetInstanceVariableValue$_(t, s);
    }, Gs = function(t, s) {
        const i = d(this), e = i._$GetInstanceVariableValue$_(t);
        "number" == typeof e && "number" != typeof s ? s = parseFloat(s) : "string" == typeof e && "string" != typeof s && (s = s.toString()), 
        i._$SetInstanceVariableValue$_(t, e + s);
    }, Ts = function(t, s) {
        const i = d(this), e = i._$GetInstanceVariableValue$_(t);
        "number" == typeof e && ("number" != typeof s && (s = parseFloat(s)), i._$SetInstanceVariableValue$_(t, e - s));
    }, _s = function(t, s) {
        d(this)._$SetInstanceVariableValue$_(t, s ? 1 : 0);
    }, Is = function(t) {
        const s = d(this);
        s._$SetInstanceVariableValue$_(t, 0 === s._$GetInstanceVariableValue$_(t) ? 1 : 0);
    }, Cs = function(t) {
        let s;
        try {
            s = JSON.parse(t);
        } catch (t) {
            return void console.error("Failed to load from JSON string: ", t);
        }
        const i = d(this);
        i._$GetRuntime$_()._$ClearIntancesNeedingAfterLoad$_(), i._$_OnBeforeLoad$_("state"), 
        i._$LoadFromJson$_(s, "state"), i._$GetRuntime$_()._$DoAfterLoad$_("state", {
            _$setFromJson$_: !0
        });
    }, Rs = function() {
        return JSON.stringify(d(this)._$SaveToJson$_("state"));
    }, Ps = function() {
        return d(this)._$GetObjectClass$_()._$GetName$_();
    }, Es = function() {
        let t = d(this)._$GetRuntime$_(), s = t._$GetCurrentEventStackFrame$_()._$GetExpressionObjectClass$_(), i = s._$GetInstanceCount$_();
        for (const e of t._$instancesPendingCreateForObjectClass$_(s)) ++i;
        return i;
    }, As = function() {
        const t = d(this)._$GetRuntime$_();
        return t._$GetCurrentEventStackFrame$_()._$GetExpressionObjectClass$_()._$GetCurrentSol$_()._$GetInstances$_().length;
    }, Fs = function() {
        return d(this)._$GetIID$_();
    }, Os = function() {
        return d(this)._$GetUID$_();
    }, Ds = function(t) {
        const s = d(this);
        return t.toLowerCase() === s._$GetRuntime$_()._$GetEventSheetManager$_()._$GetCurrentInstanceSignalTag$_(s);
    }, ks = function(t) {
        const s = d(this);
        s._$GetRuntime$_()._$GetEventSheetManager$_()._$InstanceSignal$_(s, t);
    }, Ls = function(t) {
        return this._$GetRuntime$_()._$GetEventSheetManager$_()._$AddScheduledWait$_()._$InitInstanceSignals$_(this._$GetCurrentSol$_()._$GetInstances$_(), t), 
        !0;
    }, Bs = function() {
        return d(this)._$GetTemplateName$_();
    }, U = (d, u, S, b, M, v, x, G, T, _, I, C, R, P, E, A, F, O, D, k, L, K, Z, 
    Q, tt, st, it, et, ht, rt, nt, ot, at, lt, ut, ct, ft, dt, pt, mt, B, gt, yt, 
    wt, St, bt, Mt, vt, xt, Gt, Tt, _t, It, Ct, Rt, Pt, Et, At, Ft, Ot, Dt, kt, 
    N, W, j, V, e, i, Lt, Bt, Nt, Wt, jt, Vt, Ut, Ht, zt, Jt, qt, Xt, Yt, $t, Kt, 
    Zt, Qt, ts, ss, is, es, hs, rs, ns, os, as, ls, us, cs, fs, ds, ps, s, h, ms, 
    gs, ys, ws, Ss, bs, Ms, vs, xs, Gs, Ts, _s, Is, Cs, Rs, Ps, Es, As, Fs, Os, 
    Ds, ks, Ls, Bs, self._$C3$_), l = new U._$Color$_(), r = null, H = (U._$CommonACES_SetRuntime$_ = function(t) {
        r = t;
    }, U._$New$_(U.Rect)), z = [], J = [], q = !1, X = null, Y = !1, $ = new Set();
    U._$AddCommonACEs$_ = function(t, s) {
        const i = t[1], e = t[3], h = t[4], r = t[5], n = t[6], o = t[7], a = t[8], l = t[10], u = t[11], c = t[12], f = t[13], d = t[14], p = t[15], m = t[16], g = s._$Cnds$_, y = s._$Acts$_, w = s._$Exps$_;
        e && (g._$CompareX$_ = S, g._$CompareY$_ = b, g._$IsOnScreen$_ = M, g._$IsOutsideLayout$_ = v, 
        g._$PickDistance$_ = x, y._$SetX$_ = G, y._$SetY$_ = T, y._$SetPos$_ = _, 
        y._$SetPosToObject$_ = I, y._$MoveForward$_ = C, y._$MoveAtAngle$_ = R, 
        w._$X$_ = P, w._$Y$_ = E, w.dt = A), h && (g._$CompareWidth$_ = F, g._$CompareHeight$_ = O, 
        y._$SetWidth$_ = D, y._$SetHeight$_ = k, y._$SetSize$_ = L, w._$Width$_ = K, 
        w._$Height$_ = Z, w._$BBoxLeft$_ = Q, w._$BBoxTop$_ = tt, w._$BBoxRight$_ = st, 
        w._$BBoxBottom$_ = it, w._$BBoxMidX$_ = et, w._$BBoxMidY$_ = ht), r && (g._$AngleWithin$_ = rt, 
        g._$IsClockwiseFrom$_ = nt, g._$IsBetweenAngles$_ = ot, y._$SetAngle$_ = at, 
        y._$RotateClockwise$_ = lt, y._$RotateCounterclockwise$_ = ut, y._$RotateTowardAngle$_ = ct, 
        y._$RotateTowardPosition$_ = ft, y._$SetTowardPosition$_ = dt, w._$Angle$_ = pt), 
        n && (g._$IsVisible$_ = B, g._$CompareOpacity$_ = mt, y._$SetVisible$_ = gt, 
        y._$SetOpacity$_ = yt, y._$SetDefaultColor$_ = wt, w.Opacity = bt, w._$ColorValue$_ = St), 
        o && (g._$IsOnLayer$_ = Mt, g._$PickTopBottom$_ = vt, g._$CompareZElevation$_ = xt, 
        y._$MoveToTop$_ = Gt, y._$MoveToBottom$_ = Tt, y._$MoveToLayer$_ = _t, y._$ZMoveToObject$_ = It, 
        y._$SetZElevation$_ = Ct, w._$LayerNumber$_ = Rt, w._$LayerName$_ = Pt, 
        w._$ZIndex$_ = Et, w._$ZElevation$_ = At, w._$TotalZElevation$_ = Ft), a && (g._$IsEffectEnabled$_ = Ot, 
        y._$SetEffectEnabled$_ = Dt, y._$SetEffectParam$_ = kt), f && (g._$HasParent$_ = jt, 
        g._$HasChildren$_ = Vt, g._$PickParent$_ = Ut, g._$PickChildren$_ = Ht, 
        g._$PickNthChild$_ = zt, g._$CompareChildCount$_ = Jt, y._$AddChild$_ = qt, 
        y._$RemoveChild$_ = Xt, y._$RemoveFromParent$_ = Yt, w._$ChildCount$_ = $t, 
        w._$AllChildCount$_ = Kt), d && (y._$SetMeshSize$_ = Zt, y._$SetMeshPoint$_ = Qt, 
        w._$MeshColumns$_ = ts, w._$MeshRows$_ = ss), l && (g._$IsVisible$_ = B, 
        y._$SetVisible$_ = is, y._$SetCSSStyle$_ = es, y._$SetElemAttribute$_ = hs, 
        y._$RemoveElemAttribute$_ = rs), u && (g._$IsFocused$_ = as, y._$SetFocus$_ = ns, 
        y._$SetBlur$_ = os), c && (g._$IsEnabled$_ = us, y._$SetEnabled$_ = ls), 
        p && (g._$OnCollision$_ = Bt, g._$IsOverlapping$_ = Nt, g._$IsOverlappingOffset$_ = Wt, 
        s._$FinishCollisionCondition$_ = Lt), i || (g._$CompareInstanceVar$_ = cs, 
        g._$IsBoolInstanceVarSet$_ = fs, g._$PickInstVarHiLow$_ = ds, g._$PickByUID$_ = ps, 
        g._$HasTags$_ = ms, y._$SetInstanceVar$_ = xs, y._$AddInstanceVar$_ = Gs, 
        y._$SubInstanceVar$_ = Ts, y._$SetBoolInstanceVar$_ = _s, y._$ToggleBoolInstanceVar$_ = Is, 
        y._$ChangeTags$_ = Ss, g._$OnCreated$_ = Ms, g._$OnDestroyed$_ = vs, y._$Destroy$_ = bs, 
        y._$LoadFromJsonString$_ || (y._$LoadFromJsonString$_ = Cs), w._$AsJSON$_ || (w._$AsJSON$_ = Rs), 
        w._$Count$_ = Es, w._$PickedCount$_ = As, w._$IID$_ = Fs, w._$UID$_ = Os, 
        w._$ObjectTypeName$_ = Ps, w._$Tags$_ = gs, w._$TagsCount$_ = ys, w._$TagAt$_ = ws, 
        g._$OnInstanceSignal$_ = Ds, y._$InstanceSignal$_ = ks, y._$InstanceWaitForSignal$_ = Ls), 
        m && (w._$TemplateName$_ = Bs);
    };
}

{
    const ua = self._$C3$_;
    ua._$ScheduledWait$_ = class extends ua._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_eventSheetManager$_ = t, this._$_type$_ = "", this._$_time$_ = -1, 
            this._$_signalTag$_ = "", this._$_isSignalled$_ = !1, this._$_event$_ = null, 
            this._$_actIndex$_ = 0, this._$_solModifiers$_ = [], this._$_dynamicSolModifiers$_ = null, 
            this._$_sols$_ = new Map(), this._$_pendingInstances$_ = null, this._$_callingFunctionBlock$_ = null, 
            this._$_asyncId$_ = -1, this._$_functionParameters$_ = null, this._$_functionInnerLocalVars$_ = null, 
            this._$_shouldRelease$_ = !1;
        }
        _$Release$_() {
            this._$_type$_ = "", this._$_time$_ = -1, this._$_signalTag$_ = "", 
            this._$_event$_ = null, this._$_callingFunctionBlock$_ = null, this._$_functionParameters$_ = null, 
            this._$_functionInnerLocalVars$_ = null, this._$_asyncId$_ = -1, ua._$clearArray$_(this._$_solModifiers$_), 
            this._$_dynamicSolModifiers$_ && (this._$_dynamicSolModifiers$_.clear(), 
            this._$_dynamicSolModifiers$_ = null);
            for (const t of this._$_sols$_.values()) t._$Release$_();
            this._$_sols$_.clear(), this._$_pendingInstances$_ = null;
        }
        _$_Init$_() {
            const t = this._$_eventSheetManager$_, s = t._$GetRuntime$_()._$GetAllObjectClasses$_(), i = t._$GetCurrentEventStackFrame$_(), e = (this._$_event$_ = i._$GetCurrentEvent$_(), 
            this._$_actIndex$_ = i._$GetActionIndex$_() + 1, t._$FindFirstFunctionBlockParent$_(this._$_event$_));
            e && (this._$_callingFunctionBlock$_ = e, this._$_functionParameters$_ = e._$CaptureFunctionParameters$_(), 
            this._$_functionInnerLocalVars$_ = e._$_GetAllInnerLocalVariables$_().map(t => t._$GetValue$_()), 
            e._$IsAsync$_()) && (this._$_asyncId$_ = e._$PauseCurrentAsyncFunction$_());
            for (const r of s) {
                const n = r._$GetCurrentSol$_();
                n._$IsSelectAll$_() && !this._$_event$_._$HasSolModifier$_(r) || (this._$_solModifiers$_.push(r), 
                this._$_sols$_.set(r, ua._$New$_(ua._$SolState$_, n)));
            }
            const h = t._$GetDynamicSolModifiersSet$_();
            this._$_dynamicSolModifiers$_ = 0 < h.size ? h : null;
        }
        _$InitTimer$_(t) {
            this._$_type$_ = "timer", this._$_Init$_(), this._$_time$_ = this._$_eventSheetManager$_._$GetRuntime$_()._$GetGameTime$_() + t;
        }
        _$InitSignal$_(t) {
            this._$_type$_ = "signal", this._$_Init$_(), this._$_signalTag$_ = t.toLowerCase();
        }
        _$InitInstanceSignals$_(t, s) {
            this._$_type$_ = "instance-signals", this._$_Init$_(), this._$_signalTag$_ = s.toLowerCase(), 
            this._$_pendingInstances$_ = new Set(t);
        }
        _$InitPromise$_(t) {
            this._$_type$_ = "promise", this._$_Init$_(), t.then(() => this._$SetSignalled$_()).catch(t => {
                console.warn("[C3 runtime] Promise rejected in 'Wait for previous actions to complete': ", t), 
                this._$SetSignalled$_();
            });
        }
        _$IsTimer$_() {
            return "timer" === this._$_type$_;
        }
        _$IsSignal$_() {
            return "signal" === this._$_type$_;
        }
        _$IsInstanceSignals$_() {
            return "instance-signals" === this._$_type$_;
        }
        _$IsPromise$_() {
            return "promise" === this._$_type$_;
        }
        _$GetSignalTag$_() {
            return this._$_signalTag$_;
        }
        _$IsSignalled$_() {
            return this._$_isSignalled$_;
        }
        _$SetSignalled$_() {
            this._$_isSignalled$_ = !0;
        }
        _$SetInstanceSignalled$_(t) {
            this._$_pendingInstances$_.delete(t), 0 === this._$_pendingInstances$_.size && this._$SetSignalled$_();
        }
        _$_ShouldRun$_() {
            return this._$IsTimer$_() ? this._$_time$_ <= this._$_eventSheetManager$_._$GetRuntime$_()._$GetGameTime$_() : this._$IsSignalled$_();
        }
        _$_RestoreState$_(t) {
            t._$_Restore$_(this._$_event$_, this._$_actIndex$_);
            for (const [ i, e ] of this._$_sols$_.entries()) {
                const h = i._$GetCurrentSol$_();
                e._$_Restore$_(h);
            }
            this._$_dynamicSolModifiers$_ && t._$SetDynamicSolModifiers$_([ ...this._$_dynamicSolModifiers$_ ]);
            const s = this._$_callingFunctionBlock$_;
            s && (s._$SetFunctionParameters$_(this._$_functionParameters$_), s._$_GetAllInnerLocalVariables$_().map((t, s) => t._$SetValue$_(this._$_functionInnerLocalVars$_[s])), 
            s._$IsAsync$_()) && s._$ResumeAsyncFunction$_(this._$_asyncId$_);
        }
        _$_Run$_(t) {
            this._$_RestoreState$_(t), this._$_event$_._$_ResumeActionsAndSubEvents$_(t), 
            this._$_callingFunctionBlock$_ && this._$_callingFunctionBlock$_._$IsAsync$_() && this._$_callingFunctionBlock$_._$MaybeFinishAsyncFunctionCall$_(this._$_asyncId$_), 
            this._$_eventSheetManager$_._$ClearSol$_(this._$_solModifiers$_), this._$_shouldRelease$_ = !0;
        }
        async _$_DebugRun$_(t) {
            this._$_RestoreState$_(t);
            for (const s of this._$_event$_._$_DebugResumeActionsAndSubEvents$_(t)) await this._$_eventSheetManager$_._$GetRuntime$_()._$DebugBreak$_(s);
            this._$_callingFunctionBlock$_ && this._$_callingFunctionBlock$_._$IsAsync$_() && this._$_callingFunctionBlock$_._$MaybeFinishAsyncFunctionCall$_(this._$_asyncId$_), 
            this._$_eventSheetManager$_._$ClearSol$_(this._$_solModifiers$_), this._$_shouldRelease$_ = !0;
        }
        _$ShouldRelease$_() {
            return this._$_shouldRelease$_;
        }
        _$RemoveInstances$_(t) {
            for (const s of this._$_sols$_.values()) s._$RemoveInstances$_(t);
            if ("instance-signals" === this._$_type$_) {
                for (const i of t) this._$_pendingInstances$_.delete(i);
                0 === this._$_pendingInstances$_.size && this._$SetSignalled$_();
            }
        }
        _$_SaveToJson$_() {
            const t = {}, s = {
                wt: this._$_type$_,
                t: this._$_time$_,
                st: this._$_signalTag$_,
                s: this._$_isSignalled$_,
                ev: this._$_event$_._$GetSID$_(),
                sm: this._$_solModifiers$_.map(t => t._$GetSID$_()),
                dsm: this._$_dynamicSolModifiers$_ ? [ ...this._$_dynamicSolModifiers$_ ].map(t => t._$GetSID$_()) : null,
                sols: t
            };
            this._$_event$_._$_HasActionIndex$_(this._$_actIndex$_) && (s.act = this._$_event$_._$GetActionAt$_(this._$_actIndex$_)._$GetSID$_());
            for (const [ i, e ] of this._$_sols$_) t[i._$GetSID$_().toString()] = e._$_SaveToJson$_();
            return "instance-signals" === this._$_type$_ && (s.pi = [ ...this._$_pendingInstances$_ ].map(t => t._$GetUID$_())), 
            s;
        }
        static _$_CreateFromJson$_(t, s) {
            const i = t._$GetRuntime$_(), e = t._$GetEventBlockBySID$_(s.ev);
            if (!e) return null;
            let h = 0;
            if (s.hasOwnProperty("act")) {
                const n = t._$GetActionBySID$_(s.act);
                if (!n) return null;
                h = n._$GetIndex$_();
            }
            const r = ua._$New$_(ua._$ScheduledWait$_, t);
            r._$_time$_ = s.t, s.hasOwnProperty("wt") ? r._$_type$_ = s.wt : r._$_type$_ = -1 === r._$_time$_ ? "signal" : "timer", 
            r._$_signalTag$_ = s.st, r._$_isSignalled$_ = s.s, r._$_event$_ = e, 
            r._$_actIndex$_ = h;
            for (const o of s.sm) {
                const a = i._$GetObjectClassBySID$_(o);
                a && r._$_solModifiers$_.push(a);
            }
            if (Array.isArray(s.dsm)) for (const l of s.dsm) {
                const u = i._$GetObjectClassBySID$_(l);
                u && (r._$_dynamicSolModifiers$_ || (r._$_dynamicSolModifiers$_ = new Set()), 
                r._$_dynamicSolModifiers$_.add(u));
            }
            for (const [ c, f ] of Object.entries(s.sols)) {
                const d = parseInt(c, 10), p = i._$GetObjectClassBySID$_(d);
                if (p) {
                    const m = ua._$New$_(ua._$SolState$_, null);
                    m._$_LoadFromJson$_(t, f), r._$_sols$_.set(p, m);
                }
            }
            if ("instance-signals" === r._$_type$_) {
                r._$_pendingInstances$_ = new Set();
                for (const g of s.pi) {
                    const y = i._$GetInstanceByUID$_(g);
                    y && r._$_pendingInstances$_.add(y);
                }
            }
            return r;
        }
    };
}

{
    const ca = self._$C3$_;
    ca._$SolState$_ = class extends ca._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_objectClass$_ = null, this._$_isSelectAll$_ = !0, this._$_instances$_ = [], 
            t && (this._$_objectClass$_ = t._$GetObjectClass$_(), this._$_isSelectAll$_ = t._$IsSelectAll$_(), 
            ca._$shallowAssignArray$_(this._$_instances$_, t._$_GetOwnInstances$_()));
        }
        _$Release$_() {
            this._$_objectClass$_ = null, ca._$clearArray$_(this._$_instances$_);
        }
        _$_Restore$_(t) {
            t._$_SetSelectAll$_(this._$_isSelectAll$_), ca._$shallowAssignArray$_(t._$_GetOwnInstances$_(), this._$_instances$_);
        }
        _$RemoveInstances$_(t) {
            ca._$arrayRemoveAllInSet$_(this._$_instances$_, t);
        }
        _$_SaveToJson$_() {
            return {
                sa: this._$_isSelectAll$_,
                insts: this._$_instances$_.map(t => t._$GetUID$_())
            };
        }
        _$_LoadFromJson$_(t, s) {
            const i = t._$GetRuntime$_();
            this._$_isSelectAll$_ = !!s.sa, ca._$clearArray$_(this._$_instances$_);
            for (const e of s.insts) {
                const h = i._$GetInstanceByUID$_(e);
                h && this._$_instances$_.push(h);
            }
        }
    };
}

{
    let l = function(t, s) {
        let i = t.get(s);
        return i || (i = new Map(), t.set(s, i)), i;
    };
    l;
    const fa = self._$C3$_;
    fa._$SDKPluginBase$_ = class extends fa._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_runtime$_ = t.runtime, this._$_isSingleGlobal$_ = !!t._$isSingleGlobal$_, 
            this._$_isWorldType$_ = !!t._$isWorld$_, this._$_isRotatable$_ = !!t._$isRotatable$_, 
            this._$_mustPredraw$_ = !!t._$mustPredraw$_, this._$_hasEffects$_ = !!t._$hasEffects$_, 
            this._$_supportsSceneGraph$_ = !!t._$supportsSceneGraph$_, this._$_supportsMesh$_ = !!t._$supportsMesh$_, 
            this._$_isHTMLElementType$_ = !!t._$isHTMLElementType$_, this._$_is3d$_ = !!t._$is3d$_, 
            this._$_sdkVersion$_ = t._$sdkVersion$_, this._$_singleGlobalObjectClass$_ = null, 
            this._$_boundACEMethodCache$_ = new Map(), this._$_boundACEMethodCache_1param$_ = new Map(), 
            this._$_boundACEMethodCache_2params$_ = new Map(), this._$_boundACEMethodCache_3params$_ = new Map(), 
            this._$_scriptInterfaceClass$_ = t._$scriptInterfaceClass$_, this._$_iPlugin$_ = null;
        }
        _$Release$_() {
            this._$_runtime$_ = null;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$OnCreate$_() {}
        _$GetConstructor$_() {
            return (2 <= this._$GetSdkVersion$_() ? this._$_iPlugin$_ : this).constructor;
        }
        _$GetSdkVersion$_() {
            return this._$_sdkVersion$_;
        }
        _$GetScriptInterfaceClass$_(t = !1) {
            let s = this._$_scriptInterfaceClass$_;
            return s = t && "function" != typeof s && 2 <= this._$GetSdkVersion$_() ? globalThis._$ISDKPluginBase$_ : s;
        }
        _$IsSingleGlobal$_() {
            return this._$_isSingleGlobal$_;
        }
        _$IsWorldType$_() {
            return this._$_isWorldType$_;
        }
        _$IsHTMLElementType$_() {
            return this._$_isHTMLElementType$_;
        }
        _$Is3D$_() {
            return this._$_is3d$_;
        }
        _$IsRotatable$_() {
            return this._$_isRotatable$_;
        }
        _$MustPreDraw$_() {
            return this._$_mustPredraw$_;
        }
        _$HasEffects$_() {
            return this._$_hasEffects$_;
        }
        _$SupportsSceneGraph$_() {
            return this._$_supportsSceneGraph$_;
        }
        _$SupportsMesh$_() {
            return this._$_supportsMesh$_;
        }
        _$_GetBoundACEMethod$_(t, s) {
            if (!s) throw new Error("missing 'this' binding");
            let i = this._$_boundACEMethodCache$_.get(t);
            return i || (i = t.bind(s), this._$_boundACEMethodCache$_.set(t, i)), 
            i;
        }
        _$_GetBoundACEMethod_1param$_(t, s, i) {
            if (!s) throw new Error("missing 'this' binding");
            let e = l(this._$_boundACEMethodCache_1param$_, t), h = e.get(i);
            return h || (h = t.bind(s, i), e.set(i, h)), h;
        }
        _$_GetBoundACEMethod_2params$_(t, s, i, e) {
            if (!s) throw new Error("missing 'this' binding");
            let h = l(this._$_boundACEMethodCache_2params$_, t), r = l(h, i), n = r.get(e);
            return n || (n = t.bind(s, i, e), r.set(e, n)), n;
        }
        _$_GetBoundACEMethod_3params$_(t, s, i, e, h) {
            if (!s) throw new Error("missing 'this' binding");
            let r = l(this._$_boundACEMethodCache_3params$_, t), n = l(r, i), o = l(n, e), a = o.get(h);
            return a || (a = t.bind(s, i, e, h), o.set(h, a)), a;
        }
        _$_SetSingleGlobalObjectClass$_(t) {
            if (!this._$IsSingleGlobal$_()) throw new Error("must be single-global plugin");
            this._$_singleGlobalObjectClass$_ = t;
        }
        _$GetSingleGlobalObjectClass$_() {
            if (this._$IsSingleGlobal$_()) return this._$_singleGlobalObjectClass$_;
            throw new Error("must be single-global plugin");
        }
        _$GetSingleGlobalInstance$_() {
            if (this._$IsSingleGlobal$_()) return this._$_singleGlobalObjectClass$_._$GetSingleGlobalInstance$_();
            throw new Error("must be single-global plugin");
        }
        _$_InitScriptInterface$_() {
            const t = this._$GetSdkVersion$_(), s = (fa._$AddonManager$_._$_PushInitObject$_(this, t), 
            this._$GetScriptInterfaceClass$_(!0));
            if (s) {
                if (this._$_iPlugin$_ = new s(), !(this._$_iPlugin$_ instanceof self._$IPlugin$_)) throw new TypeError("plugin class must derive from IPlugin");
            } else this._$_iPlugin$_ = new self._$IPlugin$_();
            fa._$AddonManager$_._$_PopInitObject$_(t);
        }
        _$GetIPlugin$_() {
            return this._$_iPlugin$_;
        }
    };
}

{
    const da = self._$C3$_;
    da._$SDKDOMPluginBase$_ = class extends da._$SDKPluginBase$_ {
        constructor(t, s) {
            super(t), this._$_domComponentId$_ = s, this._$_nextElementId$_ = 0, 
            this._$_instMap$_ = new Map(), this._$AddElementMessageHandler$_("elem-focused", t => t._$_OnElemFocused$_()), 
            this._$AddElementMessageHandler$_("elem-blurred", t => {
                t && t._$_OnElemBlurred$_();
            });
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$_AddElement$_(t) {
            const s = this._$_nextElementId$_++;
            return this._$_instMap$_.set(s, t), s;
        }
        _$_RemoveElement$_(t) {
            this._$_instMap$_.delete(t);
        }
        _$AddElementMessageHandler$_(t, i) {
            this._$_runtime$_._$AddDOMComponentMessageHandler$_(this._$_domComponentId$_, t, t => {
                const s = this._$_instMap$_.get(t.elementId);
                i(s, t);
            });
        }
    };
}

{
    const pa = self._$C3$_;
    pa._$SDKTypeBase$_ = class extends pa._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_objectClass$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), 
            this._$_plugin$_ = t._$GetPlugin$_();
        }
        _$Release$_() {
            this._$_objectClass$_ = null, this._$_runtime$_ = null, this._$_plugin$_ = null;
        }
        _$GetObjectClass$_() {
            return this._$_objectClass$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetPlugin$_() {
            return this._$_plugin$_;
        }
        _$GetImageInfo$_() {
            return this._$_objectClass$_._$GetImageInfo$_();
        }
        _$OnCreate$_() {}
        _$FinishCondition$_(t) {}
        _$BeforeRunAction$_(t) {}
        _$AfterRunAction$_(t) {}
        _$LoadTextures$_(t) {}
        _$ReleaseTextures$_() {}
        _$OnDynamicTextureLoadComplete$_() {}
        _$PreloadTexturesWithInstances$_(t) {}
        _$LoadTilemapData$_() {}
        _$GetScriptInterfaceClass$_() {
            return null;
        }
        _$DispatchScriptEvent$_(t, s, i) {
            const e = pa._$New$_(pa.Event, t, s);
            e._$objectClass$_ = this, i && Object.assign(e, i), this._$GetObjectClass$_()._$DispatchUserScriptEvent$_(e);
        }
    };
}

{
    const ma = self._$C3$_;
    ma._$SDKInstanceBase$_ = class extends ma._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_inst$_ = t, this._$_domComponentId$_ = s, this._$_wrapperComponentId$_ = null, 
            this._$_runtime$_ = t._$GetRuntime$_(), this._$_objectClass$_ = this._$_inst$_._$GetObjectClass$_(), 
            this._$_sdkType$_ = this._$_objectClass$_._$GetSdkType$_(), this._$_tickFunc$_ = null, 
            this._$_tick2Func$_ = null, this._$_isTicking$_ = !1, this._$_isTicking2$_ = !1, 
            this._$_disposables$_ = null, this._$_wasReleased$_ = !1;
        }
        _$Release$_() {
            this._$_wasReleased$_ = !0, this._$_StopTicking$_(), this._$_StopTicking2$_(), 
            this._$_tickFunc$_ = null, this._$_tick2Func$_ = null, this._$_disposables$_ && (this._$_disposables$_._$Release$_(), 
            this._$_disposables$_ = null), this._$_inst$_ = null, this._$_runtime$_ = null, 
            this._$_objectClass$_ = null, this._$_sdkType$_ = null;
        }
        _$WasReleased$_() {
            return this._$_wasReleased$_;
        }
        _$GetInstance$_() {
            return this._$_inst$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetObjectClass$_() {
            return this._$_objectClass$_;
        }
        _$GetPlugin$_() {
            return this._$_sdkType$_._$GetPlugin$_();
        }
        _$GetSdkType$_() {
            return this._$_sdkType$_;
        }
        _$GetScriptInterface$_() {
            return this._$_inst$_._$GetInterfaceClass$_();
        }
        _$Trigger$_(t) {
            return this._$_runtime$_._$Trigger$_(t, this._$_inst$_, null);
        }
        _$DebugTrigger$_(t) {
            return this._$_runtime$_._$DebugTrigger$_(t, this._$_inst$_, null);
        }
        _$TriggerAsync$_(t) {
            return this._$_runtime$_._$TriggerAsync$_(t, this._$_inst$_, null);
        }
        _$FastTrigger$_(t, s) {
            return this._$_runtime$_._$FastTrigger$_(t, this._$_inst$_, s);
        }
        _$DebugFastTrigger$_(t, s) {
            return this._$_runtime$_._$DebugFastTrigger$_(t, this._$_inst$_, s);
        }
        _$ScheduleTriggers$_(t) {
            return this._$_runtime$_._$ScheduleTriggers$_(t);
        }
        _$AddDOMMessageHandler$_(t, s) {
            this._$_runtime$_._$AddDOMComponentMessageHandler$_(this._$_domComponentId$_, t, s);
        }
        _$AddDOMMessageHandlers$_(t) {
            for (const [ s, i ] of t) this._$AddDOMMessageHandler$_(s, i);
        }
        _$PostToDOM$_(t, s) {
            this._$_runtime$_._$PostComponentMessageToDOM$_(this._$_domComponentId$_, t, s);
        }
        _$PostToDOMAsync$_(t, s) {
            return this._$_runtime$_._$PostComponentMessageToDOMAsync$_(this._$_domComponentId$_, t, s);
        }
        _$_PostToDOMMaybeSync$_(t, s) {
            if (!this._$_runtime$_._$IsInWorker$_()) return window.c3_runtimeInterface._OnMessageFromRuntime({
                type: "event",
                component: this._$_domComponentId$_,
                handler: t,
                data: s,
                responseId: null
            });
            this._$PostToDOM$_(t, s);
        }
        _$SetWrapperExtensionComponentId$_(t) {
            if (!t) throw new Error("cannot set empty component id");
            this._$_wrapperComponentId$_ = t;
        }
        _$IsWrapperExtensionAvailable$_() {
            if (this._$_wrapperComponentId$_) return this._$_runtime$_._$HasWrapperComponentId$_(this._$_wrapperComponentId$_);
            throw new Error("wrapper extension component id not set");
        }
        _$AddWrapperExtensionMessageHandler$_(t, s) {
            if (!this._$_wrapperComponentId$_) throw new Error("wrapper extension component id not set");
            this._$_runtime$_._$AddWrapperExtensionMessageHandler$_(this._$_wrapperComponentId$_, t, s);
        }
        _$AddWrapperExtensionMessageHandlers$_(t) {
            for (const [ s, i ] of t) this._$AddWrapperExtensionMessageHandler$_(s, i);
        }
        _$SendWrapperExtensionMessage$_(t, s) {
            if (!this._$_wrapperComponentId$_) throw new Error("wrapper extension component id not set");
            this._$_runtime$_._$SendWrapperExtensionMessage$_(this._$_wrapperComponentId$_, t, s);
        }
        _$SendWrapperExtensionMessageAsync$_(t, s) {
            if (this._$_wrapperComponentId$_) return this._$_runtime$_._$SendWrapperExtensionMessageAsync$_(this._$_wrapperComponentId$_, t, s);
            throw new Error("wrapper extension component id not set");
        }
        _$Tick$_() {}
        _$Tick2$_() {}
        _$_StartTicking$_() {
            this._$_isTicking$_ || (this._$_tickFunc$_ || (this._$_tickFunc$_ = () => this._$Tick$_()), 
            this._$_runtime$_._$Dispatcher$_().addEventListener("tick", this._$_tickFunc$_), 
            this._$_isTicking$_ = !0);
        }
        _$_StopTicking$_() {
            this._$_isTicking$_ && (this._$_runtime$_._$Dispatcher$_().removeEventListener("tick", this._$_tickFunc$_), 
            this._$_isTicking$_ = !1);
        }
        _$IsTicking$_() {
            return this._$_isTicking$_;
        }
        _$_StartTicking2$_() {
            this._$_isTicking2$_ || (this._$_tick2Func$_ || (this._$_tick2Func$_ = () => this._$Tick2$_()), 
            this._$_runtime$_._$Dispatcher$_().addEventListener("tick2", this._$_tick2Func$_), 
            this._$_isTicking2$_ = !0);
        }
        _$_StopTicking2$_() {
            this._$_isTicking2$_ && (this._$_runtime$_._$Dispatcher$_().removeEventListener("tick2", this._$_tick2Func$_), 
            this._$_isTicking2$_ = !1);
        }
        _$IsTicking2$_() {
            return this._$_isTicking2$_;
        }
        _$GetDebuggerProperties$_() {
            return [];
        }
        _$SaveToJson$_() {
            return null;
        }
        _$LoadFromJson$_(t) {}
        _$GetPropertyValueByIndex$_(t) {}
        _$SetPropertyValueByIndex$_(t, s) {}
        _$OffsetPropertyValueByIndex$_(t, s, i) {
            if (0 !== s) {
                const e = this._$GetPropertyValueByIndex$_(t);
                if ("number" != typeof e) throw new Error("expected number");
                this._$SetPropertyValueByIndex$_(t, e + s, i);
            }
        }
        _$SetPropertyColorOffsetValueByIndex$_(t, s, i, e) {}
        _$CallAction$_(t, ...s) {
            t.call(this, ...s);
        }
        _$CallExpression$_(t, ...s) {
            return t.call(this, ...s);
        }
        _$GetScriptInterfaceClass$_() {
            return null;
        }
        _$DispatchScriptEvent$_(t, s, i) {
            if (this._$_inst$_._$HasScriptInterface$_()) {
                const e = this._$GetScriptInterface$_(), h = ma._$New$_(ma.Event, t, s);
                h._$instance$_ = e, i && Object.assign(h, i), e.dispatchEvent(h);
            }
        }
        _$MustPreDraw$_() {
            return !1;
        }
    };
}

{
    const ga = self._$C3$_;
    ga._$SDKWorldInstanceBase$_ = class extends ga._$SDKInstanceBase$_ {
        constructor(t, s) {
            super(t, s), this._$_worldInfo$_ = t._$GetWorldInfo$_(), this._$_renderercontextlost_handler$_ = null, 
            this._$_renderercontextrestored_handler$_ = null;
        }
        _$Release$_() {
            if (this._$_renderercontextlost_handler$_) {
                const t = this._$_runtime$_._$Dispatcher$_();
                t.removeEventListener("renderercontextlost", this._$_renderercontextlost_handler$_), 
                t.removeEventListener("renderercontextrestored", this._$_renderercontextrestored_handler$_), 
                this._$_renderercontextlost_handler$_ = null, this._$_renderercontextrestored_handler$_ = null;
            }
            this._$_worldInfo$_ = null, super._$Release$_();
        }
        _$HandleWebGLContextLoss$_() {
            this._$HandleRendererContextLoss$_();
        }
        _$OnWebGLContextLost$_() {}
        _$OnWebGLContextRestored$_() {}
        _$HandleRendererContextLoss$_() {
            if (!this._$_renderercontextlost_handler$_) {
                this._$_renderercontextlost_handler$_ = () => this._$OnRendererContextLost$_(), 
                this._$_renderercontextrestored_handler$_ = () => this._$OnRendererContextRestored$_();
                const t = this._$_runtime$_._$Dispatcher$_();
                t.addEventListener("renderercontextlost", this._$_renderercontextlost_handler$_), 
                t.addEventListener("renderercontextrestored", this._$_renderercontextrestored_handler$_);
            }
        }
        _$OnRendererContextLost$_() {
            this._$OnWebGLContextLost$_();
        }
        _$OnRendererContextRestored$_() {
            this._$OnWebGLContextRestored$_();
        }
        _$GetWorldInfo$_() {
            return this._$_worldInfo$_;
        }
        _$IsOriginalSizeKnown$_() {
            return !1;
        }
        _$GetOriginalWidth$_() {
            if (!this._$IsOriginalSizeKnown$_()) throw new Error("original size not known");
            const t = this._$GetCurrentImageInfo$_();
            if (t) return t._$GetWidth$_();
        }
        _$GetOriginalHeight$_() {
            if (!this._$IsOriginalSizeKnown$_()) throw new Error("original size not known");
            const t = this._$GetCurrentImageInfo$_();
            if (t) return t._$GetHeight$_();
        }
        _$GetCurrentImageInfo$_() {
            return null;
        }
        _$GetCurrentSurfaceSize$_() {
            const t = this._$GetCurrentImageInfo$_();
            if (t) {
                const s = t._$GetTexture$_();
                if (s) return [ s._$GetWidth$_(), s._$GetHeight$_() ];
            }
            return [ 100, 100 ];
        }
        _$GetCurrentTexRect$_() {
            const t = this._$GetCurrentImageInfo$_();
            return t ? t._$GetTexRect$_() : null;
        }
        _$GetCurrentTexQuad$_() {
            const t = this._$GetCurrentImageInfo$_();
            return t ? t._$GetTexQuad$_() : null;
        }
        _$IsCurrentTexRotated$_() {
            const t = this._$GetCurrentImageInfo$_();
            return !!t && t._$IsRotated$_();
        }
        _$GetImagePoint$_(t) {
            const s = this._$_inst$_._$GetWorldInfo$_();
            return [ s._$GetX$_(), s._$GetY$_(), s._$GetTotalZElevation$_() ];
        }
        _$LoadTilemapData$_(t, s, i) {}
        _$TestPointOverlapTile$_(t, s) {}
        _$RendersToOwnZPlane$_() {
            return !0;
        }
    };
}

{
    const ya = self._$C3$_, wa = ya._$New$_(ya.Rect);
    ya._$SDKDOMInstanceBase$_ = class extends ya._$SDKWorldInstanceBase$_ {
        constructor(t, s) {
            super(t, s), this._$_elementId$_ = this._$GetPlugin$_()._$_AddElement$_(this), 
            this._$_isElementShowing$_ = !0, this._$_elemHasFocus$_ = !1, this._$_autoFontSize$_ = !1, 
            this._$_autoFontSizeOffset$_ = -.2, this._$_lastRect$_ = ya._$New$_(ya.Rect, 0, 0, -1, -1);
            const i = this._$_runtime$_._$GetCanvasManager$_();
            this._$_lastWindowWidth$_ = i._$GetLastWidth$_(), this._$_lastWindowHeight$_ = i._$GetLastHeight$_(), 
            this._$_lastHTMLIndex$_ = -1, this._$_lastHTMLZIndex$_ = -1, this._$_isPendingUpdateState$_ = !1, 
            this._$_StartTicking$_();
        }
        _$Release$_() {
            this._$GetPlugin$_()._$_RemoveElement$_(this._$_elementId$_), this._$PostToDOMElement$_("destroy"), 
            this._$_elementId$_ = -1, super._$Release$_();
        }
        _$_GetElementInDOMMode$_() {
            if (this._$_runtime$_._$IsInWorker$_()) throw new Error("not valid in worker mode");
            return this._$_PostToDOMElementMaybeSync$_("get-element");
        }
        _$PostToDOMElement$_(t, s) {
            (s = s || {}).elementId = this._$_elementId$_, this._$PostToDOM$_(t, s);
        }
        _$_PostToDOMElementMaybeSync$_(t, s) {
            return (s = s || {}).elementId = this._$_elementId$_, this._$_PostToDOMMaybeSync$_(t, s);
        }
        _$PostToDOMElementAsync$_(t, s) {
            return (s = s || {}).elementId = this._$_elementId$_, this._$PostToDOMAsync$_(t, s);
        }
        _$CreateElement$_(t) {
            t = t || {};
            const s = this._$GetWorldInfo$_();
            t.elementId = this._$_elementId$_, t.isVisible = s._$IsVisible$_(), 
            t.htmlIndex = s._$GetLayer$_()._$GetHTMLIndex$_(), t.htmlZIndex = s._$GetHTMLZIndex$_(), 
            Object.assign(t, this._$GetElementState$_()), this._$_isElementShowing$_ = !!t.isVisible, 
            this._$_PostToDOMMaybeSync$_("create", t), this._$_UpdatePosition$_(!0);
        }
        _$SetElementVisible$_(t) {
            this._$_isElementShowing$_ !== (t = !!t) && (this._$_isElementShowing$_ = t, 
            this._$PostToDOMElement$_("set-visible", {
                isVisible: t
            }));
        }
        _$Tick$_() {
            this._$_UpdatePosition$_(!1);
        }
        _$_ShouldPreserveElement$_() {
            const t = this._$_runtime$_._$GetCanvasManager$_()._$GetFullscreenMode$_();
            return "Android" === ya._$Platform$_._$OS$_ && ("scale-inner" === t || "scale-outer" === t || "crop" === t);
        }
        _$_UpdatePosition$_(u) {
            if (!this._$GetInstance$_()._$IsDestroyed$_()) {
                let t = this._$GetWorldInfo$_(), s = t._$GetLayer$_(), i = t._$GetBoundingBox$_(), [ e, h ] = s._$LayerToCanvasCss$_(i._$getLeft$_(), i._$getTop$_()), [ r, n ] = s._$LayerToCanvasCss$_(i._$getRight$_(), i._$getBottom$_()), o = this._$_runtime$_._$GetCanvasManager$_(), a = o._$GetCssWidth$_(), l = o._$GetCssHeight$_();
                if (t._$IsVisible$_() && s._$IsVisible$_()) if (!this._$_ShouldPreserveElement$_() && (r <= 0 || n <= 0 || a <= e || l <= h)) this._$SetElementVisible$_(!1); else {
                    wa.set(e, h, r, n);
                    const c = o._$GetLastWidth$_(), f = o._$GetLastHeight$_(), d = s._$GetHTMLIndex$_(), p = t._$GetHTMLZIndex$_();
                    if (!u && wa.equals(this._$_lastRect$_) && this._$_lastWindowWidth$_ === c && this._$_lastWindowHeight$_ === f && this._$_lastHTMLIndex$_ === d && this._$_lastHTMLZIndex$_ === p) this._$SetElementVisible$_(!0); else {
                        this._$_lastRect$_._$copy$_(wa), this._$_lastWindowWidth$_ = c, 
                        this._$_lastWindowHeight$_ = f, this._$_lastHTMLIndex$_ = d, 
                        this._$_lastHTMLZIndex$_ = p, this._$SetElementVisible$_(!0);
                        let t = null;
                        this._$_autoFontSize$_ && (t = s._$GetDisplayScale$_() + this._$_autoFontSizeOffset$_), 
                        this._$PostToDOMElement$_("update-position", {
                            left: Math.round(this._$_lastRect$_._$getLeft$_()),
                            top: Math.round(this._$_lastRect$_._$getTop$_()),
                            width: Math.round(this._$_lastRect$_.width()),
                            height: Math.round(this._$_lastRect$_.height()),
                            htmlIndex: d,
                            htmlZIndex: p,
                            fontSize: t
                        });
                    }
                } else this._$SetElementVisible$_(!1);
            }
        }
        _$FocusElement$_() {
            this._$_PostToDOMElementMaybeSync$_("focus", {
                focus: !0
            });
        }
        _$BlurElement$_() {
            this._$_PostToDOMElementMaybeSync$_("focus", {
                focus: !1
            });
        }
        _$_OnElemFocused$_() {
            this._$_elemHasFocus$_ = !0;
        }
        _$_OnElemBlurred$_() {
            this._$_elemHasFocus$_ = !1;
        }
        _$IsElementFocused$_() {
            return this._$_elemHasFocus$_;
        }
        _$SetElementCSSStyle$_(t, s) {
            this._$PostToDOMElement$_("set-css-style", {
                prop: ya._$CSSToCamelCase$_(t),
                val: s
            });
        }
        _$SetElementAttribute$_(t, s) {
            this._$PostToDOMElement$_("set-attribute", {
                name: t,
                val: s
            });
        }
        _$RemoveElementAttribute$_(t) {
            this._$PostToDOMElement$_("remove-attribute", {
                name: t
            });
        }
        _$UpdateElementState$_() {
            this._$_isPendingUpdateState$_ || (this._$_isPendingUpdateState$_ = !0, 
            Promise.resolve().then(() => {
                this._$_isPendingUpdateState$_ = !1, this._$PostToDOMElement$_("update-state", this._$GetElementState$_());
            }));
        }
        _$GetElementState$_() {}
        _$GetElementId$_() {
            return this._$_elementId$_;
        }
    };
}

{
    const Sa = self._$C3$_, ba = self._$IBehavior$_;
    Sa._$SDKBehaviorBase$_ = class extends Sa._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_runtime$_ = t.runtime, this._$_myObjectClasses$_ = Sa._$New$_(Sa._$ArraySet$_), 
            this._$_myInstances$_ = Sa._$New$_(Sa._$ArraySet$_), this._$_sdkVersion$_ = t._$sdkVersion$_, 
            this._$_scriptInterfaceClass$_ = t._$scriptInterfaceClass$_, this._$_iBehavior$_ = null;
        }
        _$Release$_() {
            this._$_myInstances$_._$Release$_(), this._$_myObjectClasses$_._$Release$_(), 
            this._$_runtime$_ = null;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$OnCreate$_() {}
        _$GetSdkVersion$_() {
            return this._$_sdkVersion$_;
        }
        _$GetScriptInterfaceClass$_(t = !1) {
            let s = this._$_scriptInterfaceClass$_;
            return s = t && "function" != typeof s && 2 <= this._$GetSdkVersion$_() ? globalThis._$ISDKBehaviorBase$_ : s;
        }
        _$_AddObjectClass$_(t) {
            this._$_myObjectClasses$_._$Add$_(t);
        }
        _$GetObjectClasses$_() {
            return this._$_myObjectClasses$_._$GetArray$_();
        }
        _$_AddInstance$_(t) {
            this._$_myInstances$_._$Add$_(t);
        }
        _$_RemoveInstance$_(t) {
            this._$_myInstances$_._$Delete$_(t);
        }
        _$GetInstances$_() {
            return this._$_myInstances$_._$GetArray$_();
        }
        _$_InitScriptInterface$_() {
            const t = this._$GetSdkVersion$_(), s = (Sa._$AddonManager$_._$_PushInitObject$_(this, t), 
            this._$GetScriptInterfaceClass$_(!0));
            if (s) {
                if (this._$_iBehavior$_ = new s(), !(this._$_iBehavior$_ instanceof ba)) throw new TypeError("behavior class must derive from IBehavior");
            } else this._$_iBehavior$_ = new ba();
            Sa._$AddonManager$_._$_PopInitObject$_(t);
        }
        _$GetIBehavior$_() {
            return this._$_iBehavior$_;
        }
    };
}

{
    const Ma = self._$C3$_;
    Ma._$SDKBehaviorTypeBase$_ = class extends Ma._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_runtime$_ = t._$GetRuntime$_(), this._$_behaviorType$_ = t, 
            this._$_objectClass$_ = t._$GetObjectClass$_(), this._$_behavior$_ = t._$GetBehavior$_(), 
            this._$_behavior$_._$_AddObjectClass$_(this._$_objectClass$_);
        }
        _$Release$_() {
            this._$_runtime$_ = null, this._$_behaviorType$_ = null, this._$_objectClass$_ = null, 
            this._$_behavior$_ = null;
        }
        _$OnCreate$_() {}
        _$GetBehaviorType$_() {
            return this._$_behaviorType$_;
        }
        _$GetObjectClass$_() {
            return this._$_objectClass$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetBehavior$_() {
            return this._$_behavior$_;
        }
    };
}

{
    const va = self._$C3$_;
    va._$SDKBehaviorInstanceBase$_ = class extends va._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_behInst$_ = t, this._$_domComponentId$_ = s, this._$_inst$_ = t._$GetObjectInstance$_(), 
            this._$_runtime$_ = t._$GetRuntime$_(), this._$_behaviorType$_ = t._$GetBehaviorType$_(), 
            this._$_sdkType$_ = this._$_behaviorType$_._$GetSdkType$_(), this._$_isTicking$_ = !1, 
            this._$_isTicking2$_ = !1, this._$_isPostTicking$_ = !1, this._$_disposables$_ = null;
        }
        _$Release$_() {
            this._$_StopTicking$_(), this._$_StopTicking2$_(), this._$_StopPostTicking$_(), 
            this._$_disposables$_ && (this._$_disposables$_._$Release$_(), this._$_disposables$_ = null), 
            this._$_behInst$_ = null, this._$_inst$_ = null, this._$_runtime$_ = null, 
            this._$_behaviorType$_ = null, this._$_sdkType$_ = null;
        }
        _$GetBehavior$_() {
            return this._$_behaviorType$_._$GetBehavior$_();
        }
        _$GetBehaviorInstance$_() {
            return this._$_behInst$_;
        }
        _$GetObjectInstance$_() {
            return this._$_inst$_;
        }
        _$GetObjectClass$_() {
            return this._$_inst$_._$GetObjectClass$_();
        }
        _$GetWorldInfo$_() {
            return this._$_inst$_._$GetWorldInfo$_();
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetBehaviorType$_() {
            return this._$_behaviorType$_;
        }
        _$GetSdkType$_() {
            return this._$_sdkType$_;
        }
        _$GetScriptInterface$_() {
            return this._$_behInst$_._$GetScriptInterface$_();
        }
        _$Trigger$_(t) {
            return this._$_runtime$_._$Trigger$_(t, this._$_inst$_, this._$_behaviorType$_);
        }
        _$DebugTrigger$_(t) {
            return this._$_runtime$_._$DebugTrigger$_(t, this._$_inst$_, this._$_behaviorType$_);
        }
        _$TriggerAsync$_(t) {
            return this._$_runtime$_._$TriggerAsync$_(t, this._$_inst$_, this._$_behaviorType$_);
        }
        _$PostCreate$_() {}
        _$Tick$_() {}
        _$Tick2$_() {}
        _$PostTick$_() {}
        _$_StartTicking$_() {
            this._$_isTicking$_ || (this._$_runtime$_._$_AddBehInstToTick$_(this), 
            this._$_isTicking$_ = !0);
        }
        _$_StopTicking$_() {
            this._$_isTicking$_ && (this._$_runtime$_._$_RemoveBehInstToTick$_(this), 
            this._$_isTicking$_ = !1);
        }
        _$IsTicking$_() {
            return this._$_isTicking$_;
        }
        _$_StartTicking2$_() {
            this._$_isTicking2$_ || (this._$_runtime$_._$_AddBehInstToTick2$_(this), 
            this._$_isTicking2$_ = !0);
        }
        _$_StopTicking2$_() {
            this._$_isTicking2$_ && (this._$_runtime$_._$_RemoveBehInstToTick2$_(this), 
            this._$_isTicking2$_ = !1);
        }
        _$IsTicking2$_() {
            return this._$_isTicking2$_;
        }
        _$_StartPostTicking$_() {
            this._$_isPostTicking$_ || (this._$_runtime$_._$_AddBehInstToPostTick$_(this), 
            this._$_isPostTicking$_ = !0);
        }
        _$_StopPostTicking$_() {
            this._$_isPostTicking$_ && (this._$_runtime$_._$_RemoveBehInstToPostTick$_(this), 
            this._$_isPostTicking$_ = !1);
        }
        _$IsPostTicking$_() {
            return this._$_isPostTicking$_;
        }
        _$GetDebuggerProperties$_() {
            return [];
        }
        _$AddDOMMessageHandler$_(t, s) {
            this._$_runtime$_._$AddDOMComponentMessageHandler$_(this._$_domComponentId$_, t, s);
        }
        _$OnSpriteFrameChanged$_(t, s) {}
        _$SaveToJson$_() {
            return null;
        }
        _$LoadFromJson$_(t) {}
        _$GetPropertyValueByIndex$_(t) {}
        _$SetPropertyValueByIndex$_(t, s) {}
        _$OffsetPropertyValueByIndex$_(t, s) {
            if (0 !== s) {
                const i = this._$GetPropertyValueByIndex$_(t);
                if ("number" != typeof i) throw new Error("expected number");
                this._$SetPropertyValueByIndex$_(t, i + s);
            }
        }
        _$SetPropertyColorOffsetValueByIndex$_(t, s, i, e) {}
        _$CallAction$_(t, ...s) {
            t.call(this, ...s);
        }
        _$CallExpression$_(t, ...s) {
            return t.call(this, ...s);
        }
        _$GetScriptInterfaceClass$_() {
            return null;
        }
        _$DispatchScriptEvent$_(t, s, i) {
            if (this._$_behInst$_._$HasScriptInterface$_()) {
                const e = this._$GetScriptInterface$_(), h = va._$New$_(va.Event, t, s);
                h._$behaviorInstance$_ = e, h._$instance$_ = e._$instance$_, i && Object.assign(h, i), 
                e.dispatchEvent(h);
            }
        }
    };
}

{
    let s = function(t) {
        if (t !== i) throw new Error("invalid internal API token");
    }, r = (s, self._$C3$_), i = (r._$Plugins$_ = {}, r._$Behaviors$_ = {}, r._$_GetInternalAPIToken$_()), e = [], h = [], n = [], o = null, a = null, t = null, l = null, u = new Map(), c = new Map();
    r._$AddonManager$_ = class extends r._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_runtime$_ = t, this._$_allPlugins$_ = [], this._$_systemPlugin$_ = null, 
            this._$_allBehaviors$_ = [], this._$_delayCreateBehaviors$_ = new Map(), 
            this._$_solidBehavior$_ = null, this._$_jumpthruBehavior$_ = null, this._$_wrapperComponentIds$_ = new Set(s);
        }
        _$CreatePlugin$_(t) {
            const s = t[19], i = this._$_runtime$_._$GetObjectReference$_(t[0]);
            if (!i) throw new Error("missing plugin");
            r._$AddCommonACEs$_(t, i);
            const e = 2 <= s ? r._$SDKPluginBase$_ : i, h = r._$New$_(e, {
                runtime: this._$_runtime$_,
                _$isSingleGlobal$_: t[1],
                _$isWorld$_: t[2],
                _$isRotatable$_: t[5],
                _$hasEffects$_: t[8],
                _$mustPredraw$_: t[9],
                _$supportsSceneGraph$_: t[13],
                _$supportsMesh$_: t[14],
                _$isHTMLElementType$_: t[17],
                _$is3d$_: t[18],
                _$sdkVersion$_: s,
                _$scriptInterfaceClass$_: 2 <= s ? i : null
            });
            h._$OnCreate$_(), this._$_allPlugins$_.push(h), u.set(i, h);
        }
        _$CreateSystemPlugin$_() {
            this._$_systemPlugin$_ = r._$New$_(r._$Plugins$_._$System$_, {
                runtime: this._$_runtime$_,
                _$isSingleGlobal$_: !0
            }), this._$_systemPlugin$_._$OnCreate$_();
        }
        _$CreateBehavior$_(t) {
            const i = t[1], e = this._$_runtime$_._$GetObjectReference$_(t[0]);
            if (!e) throw new Error("missing behavior");
            this._$_delayCreateBehaviors$_.set(e, () => {
                const t = 2 <= i ? r._$SDKBehaviorBase$_ : e, s = r._$New$_(t, {
                    runtime: this._$_runtime$_,
                    _$sdkVersion$_: i,
                    _$scriptInterfaceClass$_: 2 <= i ? e : null
                });
                s._$OnCreate$_(), this._$_allBehaviors$_.push(s), c.set(e, s), !this._$_solidBehavior$_ && r._$Behaviors$_._$solid$_ && s instanceof r._$Behaviors$_._$solid$_ ? this._$_solidBehavior$_ = s : !this._$_jumpthruBehavior$_ && r._$Behaviors$_._$jumpthru$_ && s instanceof r._$Behaviors$_._$jumpthru$_ && (this._$_jumpthruBehavior$_ = s), 
                s._$_InitScriptInterface$_();
            });
        }
        _$_DelayCreateBehavior$_(t) {
            const s = this._$_delayCreateBehaviors$_.get(t);
            s && (s(), this._$_delayCreateBehaviors$_.delete(t));
        }
        static _$_PushInitObject$_(t, s = 1) {
            if (r._$AddonManager$_._$_PushInitObject$_ !== o) throw new Error("invalid method");
            1 === s && e.push(t), h.push(t);
        }
        static _$_PopInitObject$_(t = 1) {
            if (r._$AddonManager$_._$_PopInitObject$_ !== a) throw new Error("invalid method");
            1 === t && e.pop(), h.pop();
        }
        static _$_GetInitObject$_() {
            if (r._$AddonManager$_._$_GetInitObject$_ !== t) throw new Error("invalid method");
            if (0 === e.length) throw new Error("no init object set");
            return e.at(-1);
        }
        static _$_GetInitObject2$_(t) {
            if (r._$AddonManager$_._$_GetInitObject2$_ !== l) throw new Error("invalid method");
            if (s(t), 0 === h.length) throw new Error("no init object set");
            return h.at(-1);
        }
        static _$_PushInitProperties$_(t) {
            n.push(t);
        }
        static _$_PopInitProperties$_() {
            n.pop();
        }
        static _$_GetInitProperties$_() {
            if (0 === n.length) throw new Error("no init properties set");
            return n.at(-1);
        }
        _$_InitAddonScriptInterfaces$_() {
            for (const t of this._$_allPlugins$_) t._$_InitScriptInterface$_();
        }
        static _$GetPluginByConstructorFunction$_(t) {
            return u.get(t) || null;
        }
        static _$GetBehaviorByConstructorFunction$_(t) {
            return c.get(t) || null;
        }
        _$GetSystemPlugin$_() {
            return this._$_systemPlugin$_;
        }
        _$GetSolidBehavior$_() {
            return this._$_solidBehavior$_;
        }
        _$GetJumpthruBehavior$_() {
            return this._$_jumpthruBehavior$_;
        }
        _$HasWrapperComponentId$_(t) {
            return this._$_wrapperComponentIds$_.has(t);
        }
    }, o = r._$AddonManager$_._$_PushInitObject$_, a = r._$AddonManager$_._$_PopInitObject$_, 
    t = r._$AddonManager$_._$_GetInitObject$_, l = r._$AddonManager$_._$_GetInitObject2$_;
}

{
    const xa = self._$C3$_, Ga = new Set();
    xa._$ImageInfo$_ = class extends xa._$DefendedBase$_ {
        constructor() {
            super(), this._$_generation$_ = 0, this._$_url$_ = "", this._$_size$_ = 0, 
            this._$_offsetX$_ = 0, this._$_offsetY$_ = 0, this._$_width$_ = 0, this._$_height$_ = 0, 
            this._$_isRotated$_ = !1, this._$_hasMetaData$_ = !1, this._$_imageAsset$_ = null, 
            this._$_textureState$_ = "", this._$_rcTex$_ = xa._$New$_(xa.Rect), 
            this._$_quadTex$_ = xa._$New$_(xa._$Quad$_), this._$_blobUrl$_ = "", 
            this._$_iImageInfo$_ = new self._$IImageInfo$_(this), Ga.add(this);
        }
        _$Release$_() {
            this._$ReleaseTexture$_(), this._$_imageAsset$_ && 0 === this._$_imageAsset$_._$GetRefCount$_() && this._$_imageAsset$_._$Release$_(), 
            this._$_imageAsset$_ = null, Ga.delete(this), this._$ReleaseBlobURL$_();
        }
        static _$OnRendererContextLost$_() {
            for (const t of Ga) t._$_textureState$_ = "", t._$_rcTex$_.set(0, 0, 0, 0), 
            t._$_quadTex$_._$setFromRect$_(t._$_rcTex$_);
        }
        _$LoadData$_(t) {
            this._$_url$_ = t[0], this._$_size$_ = t[1], this._$_offsetX$_ = t[2], 
            this._$_offsetY$_ = t[3], this._$_width$_ = t[4], this._$_height$_ = t[5], 
            this._$_isRotated$_ = t[6], this._$_hasMetaData$_ = !0;
        }
        _$LoadDynamicAsset$_(t, s) {
            if (this._$_imageAsset$_) throw new Error("already loaded asset");
            this._$_url$_ = s;
            const i = {};
            return xa._$IsAbsoluteURL$_(s) && (i._$loadPolicy$_ = "remote"), this._$LoadAsset$_(t, i), 
            this._$_imageAsset$_._$Load$_();
        }
        _$LoadDynamicBlobAsset$_(t, s) {
            if (this._$_imageAsset$_) throw new Error("already loaded asset");
            this._$_url$_ = "", this._$_size$_ = s.size, this._$_imageAsset$_ = xa._$New$_(xa._$ImageAsset$_, t._$GetAssetManager$_(), {
                blob: s,
                size: this._$_size$_,
                _$loadPolicy$_: "local"
            });
        }
        _$ReplaceWith$_(t) {
            if (t === this) throw new Error("cannot replace with self");
            this._$_generation$_++, this._$ReleaseTexture$_(), this._$_url$_ = t._$_url$_, 
            this._$_size$_ = t._$_size$_, this._$_offsetX$_ = t._$_offsetX$_, this._$_offsetY$_ = t._$_offsetY$_, 
            this._$_width$_ = t._$_width$_, this._$_height$_ = t._$_height$_, this._$_isRotated$_ = t._$_isRotated$_, 
            this._$_hasMetaData$_ = t._$_hasMetaData$_, this._$_imageAsset$_ = t._$_imageAsset$_, 
            this._$_textureState$_ = t._$_textureState$_, this._$_rcTex$_ = t._$_rcTex$_, 
            this._$_quadTex$_ = t._$_quadTex$_, this._$ReleaseBlobURL$_();
        }
        _$GetURL$_() {
            return this._$_url$_;
        }
        _$GetSize$_() {
            return this._$_size$_;
        }
        _$GetOffsetX$_() {
            return this._$_offsetX$_;
        }
        _$GetOffsetY$_() {
            return this._$_offsetY$_;
        }
        _$IsRotated$_() {
            return this._$_isRotated$_;
        }
        _$GetWidth$_() {
            return this._$_width$_;
        }
        _$GetHeight$_() {
            return this._$_height$_;
        }
        _$GetSheetWidth$_() {
            return this._$_imageAsset$_._$GetWidth$_();
        }
        _$GetSheetHeight$_() {
            return this._$_imageAsset$_._$GetHeight$_();
        }
        _$LoadAsset$_(t, s) {
            if (this._$_imageAsset$_) throw new Error("already got asset");
            s = Object.assign({}, s, {
                url: this._$GetURL$_(),
                size: this._$GetSize$_()
            }), this._$_imageAsset$_ = t._$LoadImage$_(s);
        }
        _$IsLoaded$_() {
            return this._$_imageAsset$_ && this._$_imageAsset$_._$IsLoaded$_();
        }
        async _$LoadStaticTexture$_(t, s) {
            if (!this._$_imageAsset$_) throw new Error("no asset");
            if (this._$_textureState$_) throw new Error("already loaded texture");
            const i = this._$_generation$_, e = (this._$_textureState$_ = "loading", 
            await this._$_imageAsset$_._$LoadStaticTexture$_(t, s));
            if (this._$_generation$_ !== i) return null;
            if (!e) return this._$_textureState$_ = "", null;
            this._$_textureState$_ = "loaded", this._$_hasMetaData$_ || (this._$_width$_ = e._$GetWidth$_(), 
            this._$_height$_ = e._$GetHeight$_(), this._$_hasMetaData$_ = !0);
            const h = this._$_isRotated$_ ? this._$_height$_ : this._$_width$_, r = this._$_isRotated$_ ? this._$_width$_ : this._$_height$_;
            return this._$_rcTex$_.set(this._$_offsetX$_, this._$_offsetY$_, this._$_offsetX$_ + h, this._$_offsetY$_ + r), 
            this._$_rcTex$_._$divide$_(e._$GetWidth$_(), e._$GetHeight$_()), this._$_quadTex$_._$setFromRect$_(this._$_rcTex$_), 
            this._$_isRotated$_ && this._$_quadTex$_._$rotatePointsAnticlockwise$_(), 
            e;
        }
        _$ReleaseTexture$_() {
            this._$_textureState$_ && (this._$_imageAsset$_ && this._$_imageAsset$_._$ReleaseTexture$_(), 
            this._$_textureState$_ = "", this._$_rcTex$_.set(0, 0, 0, 0), this._$_quadTex$_._$setFromRect$_(this._$_rcTex$_));
        }
        _$GetTexture$_() {
            return this._$_imageAsset$_ && "loaded" === this._$_textureState$_ ? this._$_imageAsset$_._$GetTexture$_() : null;
        }
        _$GetTexRect$_() {
            return this._$_rcTex$_;
        }
        _$GetTexQuad$_() {
            return this._$_quadTex$_;
        }
        _$GetIImageInfo$_() {
            return this._$_iImageInfo$_;
        }
        _$GetImageAsset$_() {
            return this._$_imageAsset$_;
        }
        async _$ExtractImageToCanvas$_(t) {
            t = t || await this._$_imageAsset$_._$LoadToDrawable$_();
            const s = xa._$CreateCanvas$_(this._$_width$_, this._$_height$_), i = s.getContext("2d");
            return this._$_isRotated$_ ? (i.rotate(Math.PI / -2), i.translate(-this._$_height$_, 0), 
            i.drawImage(t, this._$_offsetX$_, this._$_offsetY$_, this._$_height$_, this._$_width$_, 0, 0, this._$_height$_, this._$_width$_)) : i.drawImage(t, this._$_offsetX$_, this._$_offsetY$_, this._$_width$_, this._$_height$_, 0, 0, this._$_width$_, this._$_height$_), 
            s;
        }
        async _$ExtractImageToBlobURL$_(t) {
            if (!this._$_blobUrl$_) {
                const s = await this._$ExtractImageToCanvas$_(t), i = await xa._$CanvasToBlob$_(s);
                this._$_blobUrl$_ = URL.createObjectURL(i);
            }
            return this._$_blobUrl$_;
        }
        _$ReleaseBlobURL$_() {
            this._$_blobUrl$_ && (URL.revokeObjectURL(this._$_blobUrl$_), this._$_blobUrl$_ = "");
        }
    };
}

{
    const Ta = self._$C3$_;
    Ta._$AnimationInfo$_ = class extends Ta._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_name$_ = t[0], this._$_speed$_ = t[1], this._$_isLooping$_ = !!t[2], 
            this._$_repeatCount$_ = t[3], this._$_repeatTo$_ = t[4], this._$_isPingPong$_ = !!t[5], 
            this._$_sid$_ = t[6], this._$_frames$_ = t[7].map(t => Ta._$New$_(Ta._$AnimationFrameInfo$_, t)), 
            this._$_iAnimation$_ = new self._$IAnimation$_(this);
        }
        static _$CreateDynamic$_(t, s) {
            const i = Ta._$New$_(Ta._$AnimationInfo$_, [ s, 0, !1, 0, 0, !1, Math.floor(1e15 * Math.random()), [] ]);
            return i._$_frames$_.push(Ta._$AnimationFrameInfo$_._$CreateDynamic$_(t)), 
            i;
        }
        _$Release$_() {
            for (const t of this._$_frames$_) t._$Release$_();
            Ta._$clearArray$_(this._$_frames$_);
        }
        _$LoadAllAssets$_(t) {
            for (const s of this._$_frames$_) s._$GetImageInfo$_()._$LoadAsset$_(t);
        }
        _$LoadAllTextures$_(s, i) {
            return Promise.all(this._$_frames$_.map(t => t._$GetImageInfo$_()._$LoadStaticTexture$_(s, i)));
        }
        _$ReleaseAllTextures$_() {
            for (const t of this._$_frames$_) t._$GetImageInfo$_()._$ReleaseTexture$_();
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$GetSID$_() {
            return this._$_sid$_;
        }
        _$GetFrameCount$_() {
            return this._$_frames$_.length;
        }
        _$GetFrames$_() {
            return this._$_frames$_;
        }
        _$GetFrameAt$_(t) {
            if ((t = Math.floor(t)) < 0 || t >= this._$_frames$_.length) throw new RangeError("invalid frame");
            return this._$_frames$_[t];
        }
        _$InsertFrameAt$_(t, s) {
            (s = Math.floor(s)) < 0 ? this._$_frames$_.unshift(t) : s >= this._$_frames$_.length ? this._$_frames$_.push(t) : this._$_frames$_.splice(s, 0, t);
        }
        _$RemoveFrameAt$_(t) {
            if ((t = Math.floor(t)) < 0 || t >= this._$_frames$_.length) throw new RangeError("invalid frame");
            this._$_frames$_[t]._$Release$_(), this._$_frames$_.splice(t, 1);
        }
        _$GetFrameIndexByTag$_(i) {
            for (let t = 0, s = this._$_frames$_.length; t < s; ++t) if (Ta._$equalsNoCase$_(this._$_frames$_[t]._$GetTag$_(), i)) return t;
            return -1;
        }
        _$FrameTagOrIndexToIndex$_(t) {
            if ("string" != typeof t) return t;
            {
                const s = this._$GetFrameIndexByTag$_(t);
                if (-1 === s) throw new Error("cannot find animation frame with tag " + t);
                return s;
            }
        }
        _$GetSpeed$_() {
            return this._$_speed$_;
        }
        _$IsLooping$_() {
            return this._$_isLooping$_;
        }
        _$GetRepeatCount$_() {
            return this._$_repeatCount$_;
        }
        _$GetRepeatTo$_() {
            return this._$_repeatTo$_;
        }
        _$IsPingPong$_() {
            return this._$_isPingPong$_;
        }
        _$GetIAnimation$_() {
            return this._$_iAnimation$_;
        }
    };
}

{
    const _a = self._$C3$_, Ia = (() => {
        const i = atob("iVBORw0KGgoAAAANSUhEUgAAAGQAAABkAQMAAABKLAcXAAAAAXNSR0IArs4c6QAAAANQTFRFAAAAp3o92gAAAAF0Uk5TAEDm2GYAAAATSURBVBgZYxgFo2AUjIJRQFcAAAV4AAHcRQIbAAAAAElFTkSuQmCC"), e = new Uint8Array(i.length);
        for (let t = 0, s = i.length; t < s; ++t) e[t] = i.charCodeAt(t);
        return new Blob([ e ], {
            type: "image/png"
        });
    })();
    _a._$AnimationFrameInfo$_ = class extends _a._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_imageInfo$_ = _a._$New$_(_a._$ImageInfo$_), this._$_imageInfo$_._$LoadData$_(t), 
            this._$_duration$_ = t[7], this._$_origin$_ = _a._$New$_(_a._$Vector2$_, t[8], t[9]), 
            this._$_imagePoints$_ = t[10].map(t => _a._$New$_(_a._$ImagePoint$_, this, t)), 
            this._$_imagePointsByName$_ = new Map();
            for (const i of this._$_imagePoints$_) this._$_imagePointsByName$_.set(i._$GetName$_().toLowerCase(), i);
            this._$_collisionPoly$_ = null;
            const s = t[11];
            6 <= s.length && (this._$_collisionPoly$_ = _a._$New$_(_a._$CollisionPoly$_, s)), 
            this._$_tag$_ = t[12] || "", this._$_iAnimationFrame$_ = new self._$IAnimationFrame$_(this);
        }
        static _$CreateDynamic$_(t) {
            const s = _a._$New$_(_a._$AnimationFrameInfo$_, [ "", 0, 0, 0, 100, 100, !1, 1, 0, 0, [], [], "" ]);
            return s._$_imageInfo$_._$LoadDynamicBlobAsset$_(t, Ia), s;
        }
        _$Release$_() {
            this._$_collisionPoly$_ && (this._$_collisionPoly$_._$Release$_(), this._$_collisionPoly$_ = null), 
            this._$_imageInfo$_._$Release$_(), this._$_imageInfo$_ = null;
        }
        _$GetImageInfo$_() {
            return this._$_imageInfo$_;
        }
        _$GetDuration$_() {
            return this._$_duration$_;
        }
        _$GetOriginX$_() {
            return this._$_origin$_._$getX$_();
        }
        _$GetOriginY$_() {
            return this._$_origin$_._$getY$_();
        }
        _$GetCollisionPoly$_() {
            return this._$_collisionPoly$_;
        }
        _$GetImagePointByName$_(t) {
            return this._$_imagePointsByName$_.get(t.toLowerCase()) || null;
        }
        _$GetImagePointByIndex$_(t) {
            return (t = Math.floor(t)) < 0 || t >= this._$_imagePoints$_.length ? null : this._$_imagePoints$_[t];
        }
        _$GetImagePointCount$_() {
            return this._$_imagePoints$_.length;
        }
        _$GetTag$_() {
            return this._$_tag$_;
        }
        _$GetIAnimationFrame$_() {
            return this._$_iAnimationFrame$_;
        }
    };
}

{
    const Ca = self._$C3$_;
    Ca._$ImagePoint$_ = class extends Ca._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_afi$_ = t, this._$_name$_ = s[0], this._$_pos$_ = Ca._$New$_(Ca._$Vector2$_, s[1], s[2]);
        }
        _$Release$_() {}
        _$GetName$_() {
            return this._$_name$_;
        }
        _$GetX$_() {
            return this._$_pos$_._$getX$_();
        }
        _$GetY$_() {
            return this._$_pos$_._$getY$_();
        }
        _$GetVec2$_() {
            return this._$_pos$_;
        }
    };
}

{
    const M = self._$C3$_, Ra = self.C3Debugger, Pa = self._$IObjectClass$_;
    M._$ObjectClass$_ = class extends M._$DefendedBase$_ {
        constructor(s, t, i) {
            super();
            const e = s._$GetObjectReference$_(i[1]), [ h, r ] = (this._$_runtime$_ = s, 
            this._$_plugin$_ = M._$AddonManager$_._$GetPluginByConstructorFunction$_(e), 
            this._$_sdkType$_ = null, this._$_instSdkCtor$_ = e.Instance, this._$_index$_ = t, 
            this._$_sid$_ = i[11], this._$_name$_ = i[0], this._$_jsPropName$_ = this._$_runtime$_._$GetJsPropName$_(i[14]), 
            this._$_isGlobal$_ = !!i[9], this._$_isFamily$_ = !!i[2], this._$_isOnLoaderLayout$_ = !!i[10], 
            this._$_instVars$_ = i[3].map(t => ({
                sid: t[0],
                type: t[1],
                name: t[2],
                _$jsPropName$_: s._$GetJsPropName$_(t[3])
            })), this._$_behaviorsCount$_ = i[4], this._$_effectsCount$_ = i[5], 
            this._$_isWorldType$_ = this._$_plugin$_._$IsWorldType$_(), this._$_dispatcher$_ = M._$New$_(M.Event._$Dispatcher$_), 
            this._$_effectList$_ = null, s._$GetCollisionEngine$_()._$GetCollisionCellSize$_());
            if (this._$_collisionGrid$_ = M._$New$_(M._$SparseGrid$_, h, r), this._$_anyCollisionCellChanged$_ = !0, 
            this._$_familyMembers$_ = null, this._$_familyMembersSet$_ = null, this._$_familyIndex$_ = -1, 
            this._$_families$_ = null, this._$_familiesSet$_ = null, this._$_familyInstVarMap$_ = null, 
            this._$_familyBehaviorMap$_ = null, this._$_familyEffectMap$_ = null, 
            this._$_isInContainer$_ = !1, this._$_container$_ = null, this._$_behaviorTypes$_ = i[8].map(t => M._$BehaviorType$_._$Create$_(this, t)), 
            this._$_behaviorTypesIncludingInherited$_ = [], this._$_behaviorsByName$_ = new Map(), 
            this._$_behaviorNameToIndex$_ = new Map(), this._$_usedBehaviorCtors$_ = new Set(), 
            this._$_customActionMap$_ = new Map(), this._$_solStack$_ = M._$New$_(M._$SolStack$_, this), 
            this._$_defaultInstanceData$_ = null, this._$_defaultLayerIndex$_ = 0, 
            this._$_isContained$_ = !1, this._$_container$_ = null, this._$_imageInfo$_ = null, 
            this._$_animations$_ = null, this._$_animationsByName$_ = null, this._$_animationsBySid$_ = null, 
            this._$_textureRefCount$_ = 0, this._$_savedData$_ = new Map(), this._$_unsavedData$_ = new Map(), 
            this._$_instances$_ = [], this._$_worldInfosByLayer$_ = new Map(), this._$_iidsStale$_ = !0, 
            this._$_plugin$_._$HasEffects$_() && (this._$_effectList$_ = M._$New$_(M._$EffectList$_, this, i[12])), 
            i[6] && (this._$_imageInfo$_ = M._$New$_(M._$ImageInfo$_), this._$_imageInfo$_._$LoadData$_(i[6])), 
            i[7]) {
                this._$_animations$_ = i[7].map(t => M._$New$_(M._$AnimationInfo$_, t)), 
                this._$_animationsByName$_ = new Map(), this._$_animationsBySid$_ = new Map();
                for (const a of this._$_animations$_) this._$_animationsByName$_.set(a._$GetName$_().toLowerCase(), a), 
                this._$_animationsBySid$_.set(a._$GetSID$_(), a);
            }
            this._$_isFamily$_ ? (this._$_familyMembers$_ = [], this._$_familyMembersSet$_ = new Set(), 
            this._$_familyIndex$_ = this._$_runtime$_._$_GetNextFamilyIndex$_()) : (this._$_families$_ = [], 
            this._$_familiesSet$_ = new Set(), this._$_familyInstVarMap$_ = [], 
            this._$_familyBehaviorMap$_ = [], this._$_familyEffectMap$_ = []);
            const n = this._$_plugin$_._$GetSdkVersion$_();
            if (n < 2 && (this._$_sdkType$_ = M._$New$_(e._$Type$_, this, i[15]), 
            !(this._$_sdkType$_ instanceof M._$SDKTypeBase$_))) throw new Error("v1 sdk type must derive from SDKTypeBase");
            this._$_iObjectClass$_ = null, this._$_instanceUserScriptClass$_ = null, 
            this._$_userScriptDispatcher$_ = M._$New$_(M.Event._$Dispatcher$_), 
            M._$AddonManager$_._$_PushInitObject$_(this, n);
            let o;
            if (o = 2 <= n ? (o = e._$Type$_) || globalThis._$ISDKObjectTypeBase$_ : this._$_sdkType$_._$GetScriptInterfaceClass$_()) {
                if (this._$_iObjectClass$_ = new o(n < 2 ? this : null), n < 2 && !(this._$_iObjectClass$_ instanceof Pa)) throw new TypeError("script interface class must derive from IObjectClass");
                if (2 <= n && !(this._$_iObjectClass$_ instanceof globalThis._$ISDKObjectTypeBase$_)) throw new TypeError("script interface class must derive from ISDKObjectTypeBase");
            } else this._$_iObjectClass$_ = new Pa();
            if (M._$AddonManager$_._$_PopInitObject$_(n), i[13]) {
                const l = i[13];
                if (l) {
                    const u = l[0], c = l[1], f = l[2];
                    this._$_sdkType$_._$LoadTilemapData$_(u, c, f);
                }
            }
            this._$_runtime$_._$UsesLoaderLayout$_() && !this._$_isFamily$_ && !this._$_isOnLoaderLayout$_ && this._$_isWorldType$_ || this._$OnCreate$_(), 
            this._$_plugin$_._$IsSingleGlobal$_() && (this._$_plugin$_._$_SetSingleGlobalObjectClass$_(this), 
            this._$_CreateSingleGlobalInstance$_(i)), this._$_loadInstancesJson$_ = null;
        }
        static _$Create$_(t, s, i) {
            return M._$New$_(M._$ObjectClass$_, t, s, i);
        }
        _$Release$_() {
            if (this._$_dispatcher$_._$Release$_(), this._$_dispatcher$_ = null, 
            this._$_imageInfo$_ && (this._$_imageInfo$_._$Release$_(), this._$_imageInfo$_ = null), 
            this._$_animations$_) {
                for (const t of this._$_animations$_) t._$Release$_();
                M._$clearArray$_(this._$_animations$_), this._$_animationsByName$_.clear(), 
                this._$_animationsBySid$_.clear();
            }
            this._$_loadInstancesJson$_ = null, this._$_solStack$_._$Release$_(), 
            this._$_solStack$_ = null, this._$_savedData$_.clear(), this._$_unsavedData$_.clear(), 
            this._$_container$_ = null, this._$_runtime$_ = null;
        }
        _$_LoadFamily$_(i) {
            for (let t = 1, s = i.length; t < s; ++t) {
                const e = this._$_runtime$_._$GetObjectClassByIndex$_(i[t]);
                this._$_familyMembers$_.push(e), this._$_familyMembersSet$_.add(e), 
                e._$_families$_.push(this), e._$_familiesSet$_.add(this);
            }
        }
        _$_SetContainer$_(t) {
            this._$_isInContainer$_ = !0, this._$_container$_ = t;
        }
        _$IsInContainer$_() {
            return this._$_isInContainer$_;
        }
        _$GetContainer$_() {
            return this._$_container$_;
        }
        _$_OnAfterCreate$_() {
            let t = 0;
            if (!this._$_isFamily$_) for (const s of this._$_families$_) for (const i of s._$GetBehaviorTypes$_()) {
                const e = i._$GetName$_().toLowerCase();
                this._$_behaviorsByName$_.set(e, i), this._$_behaviorNameToIndex$_.set(e, t), 
                this._$_behaviorTypesIncludingInherited$_.push(i), ++t;
            }
            for (const h of this._$GetBehaviorTypes$_()) {
                const r = h._$GetName$_().toLowerCase();
                this._$_behaviorsByName$_.set(r, h), this._$_behaviorNameToIndex$_.set(r, t), 
                this._$_behaviorTypesIncludingInherited$_.push(h), ++t;
            }
            for (const n of this._$_behaviorTypesIncludingInherited$_) this._$_usedBehaviorCtors$_.add(n._$GetBehavior$_().constructor);
            if (!this._$_isFamily$_ && this._$_families$_.length) {
                let t = this._$_runtime$_._$GetFamilyCount$_(), s = (M._$extendArray$_(this._$_familyInstVarMap$_, t, 0), 
                M._$extendArray$_(this._$_familyBehaviorMap$_, t, 0), M._$extendArray$_(this._$_familyEffectMap$_, t, 0), 
                []), i = 0, e = 0, h = 0;
                for (const o of this._$_families$_) {
                    const a = o._$GetFamilyIndex$_(), l = (this._$_familyInstVarMap$_[a] = i, 
                    i += o._$GetInstanceVariablesCount$_(), this._$_familyBehaviorMap$_[a] = e, 
                    e += o._$GetBehaviorTypesCount$_(), this._$_familyEffectMap$_[a] = h, 
                    h += o._$GetEffectTypesCount$_(), o._$GetEffectList$_());
                    if (l && this._$_effectList$_) for (const u of l._$GetAllEffectTypes$_()) s.push(u._$Clone$_(this._$_effectList$_));
                }
                this._$_effectList$_ && this._$_effectList$_._$PrependEffectTypes$_(s);
            }
        }
        _$_CreateSingleGlobalInstance$_(t) {
            const s = this._$_runtime$_._$_GetNewUID$_(), i = M._$New$_(M.Instance, {
                runtime: this._$_runtime$_,
                _$objectType$_: this,
                uid: s
            });
            i._$_CreateSdkInstance$_(t[16], []), this._$_runtime$_._$_MapInstanceByUID$_(s, i), 
            this._$_instances$_.push(i);
        }
        _$GetSdkType$_() {
            return this._$_sdkType$_;
        }
        _$IsOnLoaderLayout$_() {
            return this._$_isOnLoaderLayout$_;
        }
        _$Dispatcher$_() {
            return this._$_dispatcher$_;
        }
        _$OnCreate$_() {
            this._$_isFamily$_ || (this._$_sdkType$_ ? this._$_sdkType$_._$OnCreate$_() : this._$_iObjectClass$_._$_onCreate$_());
        }
        _$HasLoadedTextures$_() {
            return 0 < this._$_textureRefCount$_;
        }
        async _$LoadTextures$_(t) {
            this._$_isFamily$_ || (this._$_textureRefCount$_++, 1 === this._$_textureRefCount$_ && (this._$_sdkType$_ ? await this._$_sdkType$_._$LoadTextures$_(t) : await this._$_iObjectClass$_._$_loadTextures$_(this._$_runtime$_._$GetCanvasManager$_()._$GetIRenderer$_())));
        }
        _$ReleaseTextures$_() {
            if (!this._$_isFamily$_) {
                if (this._$_textureRefCount$_--, this._$_textureRefCount$_ < 0) throw new Error("released textures too many times");
                0 === this._$_textureRefCount$_ && (this._$_sdkType$_ ? this._$_sdkType$_._$ReleaseTextures$_() : this._$_iObjectClass$_._$_releaseTextures$_(this._$_runtime$_._$GetCanvasManager$_()._$GetIRenderer$_()));
            }
        }
        _$OnDynamicTextureLoadComplete$_() {
            if (this._$_isFamily$_) throw new Error("not applicable to family");
            this._$_sdkType$_ ? this._$_sdkType$_._$OnDynamicTextureLoadComplete$_() : this._$_iObjectClass$_._$_onDynamicTextureLoadComplete$_();
        }
        async _$PreloadTexturesWithInstances$_(t) {
            this._$_isFamily$_ || (this._$_sdkType$_ ? await this._$_sdkType$_._$PreloadTexturesWithInstances$_(t) : await this._$_iObjectClass$_._$_preloadTexturesWithInstances$_(this._$_runtime$_._$GetCanvasManager$_()._$GetIRenderer$_()));
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetPlugin$_() {
            return this._$_plugin$_;
        }
        _$GetInstanceSdkCtor$_() {
            return this._$_instSdkCtor$_;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$GetJsPropName$_() {
            return this._$_jsPropName$_;
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$GetSID$_() {
            return this._$_sid$_;
        }
        _$IsFamily$_() {
            return this._$_isFamily$_;
        }
        _$IsGlobal$_() {
            return this._$_isGlobal$_;
        }
        _$IsWorldType$_() {
            return this._$_isWorldType$_;
        }
        _$GetFamilyIndex$_() {
            return this._$_familyIndex$_;
        }
        _$GetBehaviorTypes$_() {
            return this._$_behaviorTypes$_;
        }
        _$GetBehaviorTypesCount$_() {
            return this._$_behaviorsCount$_;
        }
        _$UsesBehaviorByCtor$_(t) {
            return t && this._$_usedBehaviorCtors$_.has(t);
        }
        _$GetInstanceVariablesCount$_() {
            return this._$_instVars$_.length;
        }
        _$GetInstanceVariableSIDs$_() {
            return this._$_instVars$_.map(t => t.sid);
        }
        _$GetInstanceVariableIndexBySID$_(s) {
            return this._$_instVars$_.findIndex(t => t.sid === s);
        }
        _$GetInstanceVariableIndexByName$_(s) {
            return this._$_instVars$_.findIndex(t => t.name === s);
        }
        _$_GetAllInstanceVariableNames$_() {
            return this._$_instVars$_.map(t => t.name);
        }
        _$_GetAllInstanceVariableJsPropNames$_() {
            return this._$_instVars$_.map(t => t._$jsPropName$_);
        }
        _$GetInstanceVariableType$_(t) {
            if ((t = Math.floor(t)) < 0 || t >= this._$_instVars$_.length) throw new RangeError("invalid instance variable index");
            return this._$_instVars$_[t].type;
        }
        _$GetInstanceVariableName$_(t) {
            if ((t = Math.floor(t)) < 0 || t >= this._$_instVars$_.length) throw new RangeError("invalid instance variable index");
            return this._$_instVars$_[t].name;
        }
        _$GetEffectTypesCount$_() {
            return this._$_effectsCount$_;
        }
        _$GetBehaviorTypesIncludingInherited$_() {
            return this._$_behaviorTypesIncludingInherited$_;
        }
        _$GetBehaviorTypeByName$_(t) {
            return this._$_behaviorsByName$_.get(t.toLowerCase()) || null;
        }
        _$GetBehaviorIndexByName$_(t) {
            const s = this._$_behaviorNameToIndex$_.get(t.toLowerCase());
            return void 0 === s ? -1 : s;
        }
        _$GetEffectList$_() {
            return this._$_effectList$_;
        }
        _$HasEffects$_() {
            return this._$_plugin$_._$HasEffects$_();
        }
        _$UsesEffects$_() {
            return this._$_effectList$_ && this._$_effectList$_._$HasAnyEffectType$_();
        }
        _$GetSolStack$_() {
            return this._$_solStack$_;
        }
        _$GetCurrentSol$_() {
            return this._$_solStack$_._$GetCurrentSol$_();
        }
        _$GetImageInfo$_() {
            return this._$_imageInfo$_;
        }
        _$SetDefaultInstanceData$_(t) {
            this._$_defaultInstanceData$_ = t;
        }
        _$GetDefaultInstanceData$_() {
            return this._$_defaultInstanceData$_;
        }
        _$_SetDefaultLayerIndex$_(t) {
            this._$_defaultLayerIndex$_ = t;
        }
        _$GetDefaultLayerIndex$_() {
            return this._$_defaultLayerIndex$_;
        }
        _$GetAnimations$_() {
            return this._$_animations$_;
        }
        _$GetAnimationCount$_() {
            return this._$_animations$_.length;
        }
        _$GetFamilies$_() {
            return this._$_families$_;
        }
        _$BelongsToFamily$_(t) {
            return this._$_familiesSet$_.has(t);
        }
        _$GetFamilyMembers$_() {
            return this._$_familyMembers$_;
        }
        _$FamilyHasMember$_(t) {
            return this._$_familyMembersSet$_.has(t);
        }
        _$GetFamilyBehaviorOffset$_(t) {
            return this._$_familyBehaviorMap$_[t];
        }
        _$GetFamilyInstanceVariableOffset$_(t) {
            return this._$_familyInstVarMap$_[t];
        }
        _$AddCustomAction$_(t) {
            this._$_customActionMap$_.set(t._$GetACEName$_().toLowerCase(), t);
        }
        _$HasOwnCustomActionByName$_(t) {
            return !!this._$GetOwnCustomActionByName$_(t);
        }
        _$GetOwnCustomActionByName$_(t) {
            const s = this._$_customActionMap$_.get(t.toLowerCase());
            return s && s._$IsEnabled$_() ? s : null;
        }
        _$GetAllAnimations$_() {
            return this._$_animations$_;
        }
        _$GetAnimationByName$_(t) {
            if (this._$_animations$_) return this._$_animationsByName$_.get(t.toLowerCase()) || null;
            throw new Error("no animations");
        }
        _$GetAnimationBySID$_(t) {
            if (this._$_animations$_) return this._$_animationsBySid$_.get(t) || null;
            throw new Error("no animations");
        }
        _$AddAnimation$_(t) {
            if (this._$GetAnimationByName$_(t)) throw new Error(`animation name '${t}' already exists`);
            const s = M._$AnimationInfo$_._$CreateDynamic$_(this._$GetRuntime$_(), t);
            return this._$_animations$_.push(s), this._$_animationsByName$_.set(s._$GetName$_().toLowerCase(), s), 
            this._$_animationsBySid$_.set(s._$GetSID$_(), s), s;
        }
        _$RemoveAnimation$_(t) {
            const s = this._$GetAnimationByName$_(t);
            if (!s) throw new Error(`animation name '${t}' does not exist`);
            if (1 === this._$_animations$_.length) throw new Error("cannot remove last animation");
            const i = this._$_animations$_.indexOf(s);
            this._$_animations$_.splice(i, 1), this._$_animationsByName$_.delete(s._$GetName$_().toLowerCase()), 
            this._$_animationsBySid$_.delete(s._$GetSID$_()), s._$Release$_();
        }
        _$GetFirstAnimation$_() {
            if (this._$_animations$_) return this._$_animations$_[0];
            throw new Error("no animations");
        }
        _$GetFirstAnimationFrame$_() {
            return this._$GetFirstAnimation$_()._$GetFrameAt$_(0);
        }
        _$GetDefaultInstanceSize$_() {
            if (this._$_animations$_) {
                const t = this._$GetFirstAnimationFrame$_()._$GetImageInfo$_();
                return [ t._$GetWidth$_(), t._$GetHeight$_() ];
            }
            return this._$_imageInfo$_ ? [ this._$_imageInfo$_._$GetWidth$_(), this._$_imageInfo$_._$GetHeight$_() ] : [ 100, 100 ];
        }
        _$GetSingleGlobalInstance$_() {
            if (this._$_plugin$_._$IsSingleGlobal$_()) return this._$_instances$_[0];
            throw new Error("not a single-global plugin");
        }
        _$GetInstances$_() {
            return this._$_instances$_;
        }
        *instances() {
            yield* this._$_instances$_;
        }
        *_$instancesIncludingPendingCreate$_() {
            yield* this._$_instances$_, yield* this._$_runtime$_._$instancesPendingCreateForObjectClass$_(this);
        }
        _$GetInstanceCount$_() {
            return this._$_instances$_.length;
        }
        _$_AddInstance$_(t) {
            this._$_instances$_.push(t);
        }
        _$_SetIIDsStale$_() {
            this._$_iidsStale$_ = !0;
        }
        _$_UpdateIIDs$_() {
            if (this._$_iidsStale$_ && !this._$_isFamily$_) {
                let s = this._$_instances$_, i = 0;
                for (let t = s.length; i < t; ++i) s[i]._$_SetIID$_(i);
                const t = this._$_runtime$_._$_GetInstancesPendingCreate$_();
                for (const e of t) e._$GetObjectClass$_() === this && e._$_SetIID$_(i++);
                this._$_iidsStale$_ = !1;
            }
        }
        _$GetInstanceByIID$_(t) {
            const s = this._$_instances$_;
            if (t < s.length) return s[t];
            t -= s.length;
            const i = this._$_runtime$_._$_GetInstancesPendingCreate$_();
            for (const e of i) if (e._$GetObjectClass$_() === this) {
                if (0 === t) return e;
                --t;
            }
            return null;
        }
        _$GetFirstPicked$_(t) {
            if (t && t._$IsInContainer$_() && t._$GetObjectClass$_() !== this) for (const i of t._$siblings$_()) if (i._$GetObjectClass$_() === this) return i;
            const s = this._$GetCurrentSol$_()._$GetInstances$_();
            return s.length ? s[0] : null;
        }
        _$GetPairedInstance$_(t) {
            const s = this._$GetCurrentSol$_()._$GetInstances$_();
            return 0 < s.length ? s[t._$GetIID$_() % s.length] : null;
        }
        *_$allCorrespondingInstances$_(t, s) {
            let i = this._$GetCurrentSol$_()._$GetInstances$_(), e = i.length, h = s._$GetCurrentSol$_(), r = s._$GetCurrentSol$_()._$GetInstances$_(), n = r.length, o = t._$GetIID$_(), a = (!s._$IsFamily$_() && h._$IsSelectAll$_() || (o = r.indexOf(t)), 
            Math.ceil(e / n)), l = e % n, u = 0, c = 0;
            c = 0 == l || o < l ? (u = o * a, a) : (u = l * a + (o - l) * (a - 1), 
            a - 1);
            for (let t = u, s = u + c; t < s; ++t) yield i[t];
        }
        _$FinishCondition$_(t) {
            this._$_sdkType$_?._$FinishCondition$_(t);
        }
        _$ApplySolToContainer$_() {
            if (this._$_isInContainer$_ && !this._$_isFamily$_) {
                this._$_UpdateIIDs$_();
                const t = this._$GetCurrentSol$_(), s = t._$_GetOwnInstances$_(), i = t._$IsSelectAll$_(), e = this._$_runtime$_._$GetCurrentEventStackFrame$_(), h = e && e._$GetCurrentEvent$_() && e._$GetCurrentEvent$_()._$IsOrBlock$_();
                for (const r of this._$_container$_._$objectTypes$_()) if (r !== this) {
                    r._$_UpdateIIDs$_();
                    const n = r._$GetCurrentSol$_();
                    if (n._$_SetSelectAll$_(i), !i) {
                        const o = n._$_GetOwnInstances$_();
                        M._$clearArray$_(o);
                        for (const a of s) o.push(r._$GetInstanceByIID$_(a._$GetIID$_()));
                        if (h) {
                            const l = t._$_GetOwnElseInstances$_(), u = n._$_GetOwnElseInstances$_();
                            M._$clearArray$_(u);
                            for (const c of l) u.push(r._$GetInstanceByIID$_(c._$GetIID$_()));
                        }
                    }
                }
            }
        }
        _$_TruncateContainerSols$_(t, s) {
            for (const i of this._$GetContainer$_()._$objectTypes$_()) {
                const e = i._$GetCurrentSol$_();
                t ? M._$truncateArray$_(e._$_GetOwnElseInstances$_(), s) : M._$truncateArray$_(e._$_GetOwnInstances$_(), s);
            }
        }
        _$_GetCollisionCellGrid$_() {
            return this._$_collisionGrid$_;
        }
        _$_SetAnyCollisionCellChanged$_(t) {
            this._$_anyCollisionCellChanged$_ = !!t;
        }
        _$_UpdateAllCollisionCells$_() {
            if (this._$_anyCollisionCellChanged$_ && this._$_isWorldType$_) {
                for (const t of this._$_instances$_) t._$GetWorldInfo$_()._$_UpdateCollisionCell$_();
                for (const s of this._$_runtime$_._$_GetInstancesPendingCreate$_()) s._$GetObjectClass$_() === this && s._$GetWorldInfo$_()._$_UpdateCollisionCell$_();
                this._$_anyCollisionCellChanged$_ = !1;
            }
        }
        _$_OnWorldInstanceLayerChanged$_(s, t, i) {
            if (t) {
                const e = this._$_worldInfosByLayer$_.get(t);
                e && (e.delete(s), 0 === e.size) && this._$_worldInfosByLayer$_.delete(t);
            }
            if (i) {
                let t = this._$_worldInfosByLayer$_.get(i);
                t || (t = new Set(), this._$_worldInfosByLayer$_.set(i, t)), t.add(s);
            }
        }
        _$layersHasInstancesOn$_() {
            if (this._$IsFamily$_()) {
                const t = new Set();
                for (const s of this._$_familyMembers$_) for (const i of s._$layersHasInstancesOn$_()) t.add(i);
                return t.values();
            }
            return this._$_worldInfosByLayer$_.keys();
        }
        _$GetSavedDataMap$_() {
            return this._$_savedData$_ || (this._$_savedData$_ = new Map()), this._$_savedData$_;
        }
        _$GetUnsavedDataMap$_() {
            return this._$_unsavedData$_ || (this._$_unsavedData$_ = new Map()), 
            this._$_unsavedData$_;
        }
        _$HasSolidBehavior$_() {
            return this._$UsesBehaviorByCtor$_(M._$Behaviors$_._$solid$_);
        }
        _$HasJumpthruBehavior$_() {
            return this._$UsesBehaviorByCtor$_(M._$Behaviors$_._$jumpthru$_);
        }
        _$HasNoSaveBehavior$_() {
            return this._$UsesBehaviorByCtor$_(M._$Behaviors$_.NoSave);
        }
        _$HasPersistBehavior$_() {
            return this._$UsesBehaviorByCtor$_(M._$Behaviors$_.Persist);
        }
        _$_SaveToJson$_() {
            const t = {
                instances: this._$_instances$_.map(t => t._$SaveToJson$_())
            };
            return this._$_savedData$_ && this._$_savedData$_.size && (t.ex = M._$ToSuperJSON$_(this._$_savedData$_)), 
            t;
        }
        _$_LoadFromJson$_(t, e) {
            this._$_savedData$_ && (this._$_savedData$_.clear(), this._$_savedData$_ = null);
            const s = t.ex, h = (s && (this._$_savedData$_ = M._$FromSuperJSON$_(s)), 
            this._$_instances$_), r = t.instances;
            for (let t = 0, s = Math.min(h.length, r.length); t < s; ++t) h[t]._$LoadFromJson$_(r[t]);
            for (let t = r.length, s = h.length; t < s; ++t) this._$_runtime$_._$DestroyInstance$_(h[t]);
            for (let i = h.length, t = r.length; i < t; ++i) {
                let t = r[i], s = null;
                if (!this._$IsWorldType$_() || (s = this._$_runtime$_._$GetMainRunningLayout$_()._$GetLayerBySID$_(t.w.l))) {
                    const n = this._$_runtime$_._$CreateInstanceFromData$_(this._$_defaultInstanceData$_ || this, s, !1, 0, 0, !0);
                    n._$LoadFromJson$_(t), e && e.add(n);
                }
            }
            this._$_loadInstancesJson$_ = r, this._$_SetIIDsStale$_();
        }
        _$_GetLoadInstancesJson$_() {
            return this._$_loadInstancesJson$_;
        }
        _$_ClearLoadInstancesJson$_() {
            this._$_loadInstancesJson$_ = null;
        }
        _$_SetupSceneGraphConnectionsOnChangeOfLayout$_() {
            for (let t = 0, s = this._$_instances$_; t < s; ++t) this._$_instances$_[t]._$_SetupSceneGraphConnectionsOnChangeOfLayout$_();
        }
        _$GetIObjectClass$_() {
            return this._$_iObjectClass$_;
        }
        _$UserScriptDispatcher$_() {
            return this._$_userScriptDispatcher$_;
        }
        _$_GetUserScriptInstanceClass$_() {
            return this._$_instanceUserScriptClass$_;
        }
        _$_SetUserScriptInstanceClass$_(t) {
            this._$_instanceUserScriptClass$_ = t;
        }
        _$DispatchUserScriptEvent$_(t) {
            const s = this._$_runtime$_, i = s._$IsDebug$_() && !s._$GetEventSheetManager$_()._$IsInEventEngine$_();
            i && Ra.StartMeasuringScriptTime(), this._$_userScriptDispatcher$_.dispatchEvent(t), 
            i && Ra.AddScriptTime();
        }
    };
}

{
    const Ea = self._$C3$_;
    Ea._$Container$_ = class extends Ea._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_runtime$_ = t, this._$_objectTypes$_ = s;
            for (const i of this._$_objectTypes$_) i._$_SetContainer$_(this);
        }
        _$Release$_() {
            this._$_runtime$_ = null;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetObjectTypes$_() {
            return this._$_objectTypes$_;
        }
        _$objectTypes$_() {
            return this._$_objectTypes$_;
        }
        _$HasAnyWorldType$_() {
            return this._$_objectTypes$_.some(t => t._$IsWorldType$_());
        }
    };
}

{
    let S = self._$C3$_, h = self.C3Debugger, n = S._$AddonManager$_, o = [], a = 0, b = new WeakMap(), e = new WeakMap();
    S.Instance = class extends S._$DefendedBase$_ {
        constructor(t) {
            if (S._$AddonManager$_ !== n) throw new Error("invalid addon manager");
            super(), this._$_runtime$_ = t.runtime, this._$_objectType$_ = t._$objectType$_, 
            this._$_worldInfo$_ = null, this._$_sdkInst$_ = null, this._$_iScriptInterface$_ = null, 
            this._$_iid$_ = 0, this._$_uid$_ = t.uid, this._$_puid$_ = a++, this._$_flags$_ = 0, 
            this._$_tagsSet$_ = null;
            const s = S._$splitStringAndNormalize$_(t.tags), i = (0 < s.length && (this._$_tagsSet$_ = new Set(s)), 
            this._$_instVarValues$_ = o, this._$_behaviorInstances$_ = o, this._$_objectType$_._$GetBehaviorTypesIncludingInherited$_()), e = (0 < i.length && (this._$_behaviorInstances$_ = i.map((t, s) => S._$New$_(S._$BehaviorInstance$_, {
                runtime: this._$_runtime$_,
                _$behaviorType$_: t,
                _$instance$_: this,
                index: s
            }))), this._$_siblings$_ = this._$_objectType$_._$IsInContainer$_() ? [] : null, 
            this._$_timeScale$_ = -1, this._$_dispatcher$_ = null, this._$GetPlugin$_());
            if (e._$MustPreDraw$_() && (this._$_flags$_ |= 4), e._$IsWorldType$_()) if (this._$_worldInfo$_ = S._$New$_(S._$WorldInfo$_, this, t._$layer$_), 
            t._$worldData$_) this._$_worldInfo$_._$Init$_(t._$worldData$_); else {
                this._$_worldInfo$_._$InitNoData$_();
                const [ h, r ] = this._$_objectType$_._$GetDefaultInstanceSize$_();
                this._$_worldInfo$_._$SetSize$_(h, r), this._$GetObjectClass$_()._$UsesEffects$_() && this._$_worldInfo$_._$GetInstanceEffectList$_()._$LoadDefaultEffectParameters$_();
            }
            t._$instVarData$_ ? this._$_LoadInstanceVariableData$_(t._$instVarData$_) : this._$_LoadDefaultInstanceVariables$_();
        }
        _$Release$_() {
            if (this._$_iScriptInterface$_ && (this._$_iScriptInterface$_._$_release$_(), 
            this._$_iScriptInterface$_ = null), 0 < this._$_behaviorInstances$_.length) {
                for (const i of this._$_behaviorInstances$_) i._$Release$_();
                S._$clearArray$_(this._$_behaviorInstances$_);
            }
            this._$_sdkInst$_ && (this._$_sdkInst$_._$Release$_(), this._$_sdkInst$_ = null);
            const t = b.get(this), s = (t && (t.clear(), b.delete(this)), e.get(this));
            s && (s.clear(), e.delete(this)), this._$_siblings$_ && S._$clearArray$_(this._$_siblings$_), 
            this._$_dispatcher$_ && (this._$_dispatcher$_._$Release$_(), this._$_dispatcher$_ = null), 
            this._$_tagsSet$_ && this._$_tagsSet$_.clear(), this._$_tagsSet$_ = null, 
            this._$_runtime$_ = null, this._$_objectType$_ = null, 0 < this._$_instVarValues$_.length && S._$clearArray$_(this._$_instVarValues$_), 
            this._$_worldInfo$_ && (this._$_worldInfo$_._$Release$_(), this._$_worldInfo$_ = null);
        }
        _$_LoadInstanceVariableData$_(t) {
            0 < t.length && (this._$_instVarValues$_ = [], S._$shallowAssignArray$_(this._$_instVarValues$_, t));
        }
        _$_LoadDefaultInstanceVariables$_() {
            const s = this._$_objectType$_._$GetInstanceVariablesCount$_();
            if (0 !== s) {
                this._$_instVarValues$_ = [];
                const i = [ 0, 0, "" ];
                for (let t = 0; t < s; ++t) this._$_instVarValues$_.push(i[this._$_objectType$_._$GetInstanceVariableType$_(t)]);
            }
        }
        _$_CreateSdkInstance$_(t, i) {
            if (this._$_sdkInst$_) throw new Error("already got sdk instance");
            for (let t = 0, s = this._$_behaviorInstances$_.length; t < s; ++t) {
                const e = this._$_behaviorInstances$_[t];
                e._$_CreateSdkInstance$_(i ? i[t] : null);
            }
            const s = this._$GetPlugin$_()._$GetSdkVersion$_();
            if (s < 2) {
                if (this._$_sdkInst$_ = S._$New$_(this._$_objectType$_._$GetInstanceSdkCtor$_(), this, t), 
                !(this._$_sdkInst$_ instanceof S._$SDKInstanceBase$_)) throw new Error("sdk type must derive from SDKInstanceBase");
                !this._$GetPlugin$_()._$IsWorldType$_() && this._$_objectType$_._$_GetUserScriptInstanceClass$_() && this._$GetInterfaceClass$_();
            } else {
                const h = this._$GetPlugin$_()._$GetScriptInterfaceClass$_();
                this._$_InitUserScriptInterface$_(h.Instance, t);
            }
        }
        _$GetSdkInstance$_() {
            return this._$_sdkInst$_ ?? this._$_iScriptInterface$_;
        }
        _$GetWorldInfo$_() {
            return this._$_worldInfo$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetTimeScale$_() {
            return this._$_timeScale$_;
        }
        _$GetActiveTimeScale$_() {
            const t = this._$_timeScale$_;
            return -1 === t ? this._$GetRuntime$_()._$GetTimeScale$_() : t;
        }
        _$SetTimeScale$_(t) {
            ((t = +t) < 0 || !isFinite(t)) && (t = 0), this._$_timeScale$_ = t, 
            this._$GetObjectClass$_()._$UsesEffects$_() && this._$_runtime$_._$_SetTrackingInstanceTime$_(this, !0);
        }
        _$RestoreTimeScale$_() {
            this._$_timeScale$_ = -1, this._$GetObjectClass$_()._$UsesEffects$_() && this._$_runtime$_._$_SetTrackingInstanceTime$_(this, !1);
        }
        _$GetInstanceGameTime$_() {
            return this._$_runtime$_._$_GetInstanceGameTime$_(this);
        }
        _$Dispatcher$_() {
            return this._$_dispatcher$_ || (this._$_dispatcher$_ = S._$New$_(S.Event._$Dispatcher$_)), 
            this._$_dispatcher$_;
        }
        _$Draw$_(t) {
            this._$_sdkInst$_ ? this._$_sdkInst$_._$Draw$_(t) : this._$_iScriptInterface$_._$_draw$_(this._$_runtime$_._$GetCanvasManager$_()._$GetIRenderer$_());
        }
        _$OnCreate$_(t) {
            this._$_sdkInst$_._$OnCreate$_(t);
        }
        _$_SetHasTilemap$_() {
            this._$_flags$_ |= 2;
        }
        _$HasTilemap$_() {
            return 0 != (2 & this._$_flags$_);
        }
        _$_MarkDestroyed$_() {
            this._$_flags$_ |= 1;
        }
        _$IsDestroyed$_() {
            return 0 != (1 & this._$_flags$_);
        }
        _$MustPreDraw$_() {
            return 0 != (4 & this._$_flags$_) || this._$_sdkInst$_._$MustPreDraw$_();
        }
        _$SetMustMitigateZFighting$_() {
            this._$_flags$_ |= 32;
        }
        _$MustMitigateZFighting$_() {
            return 0 != (32 & this._$_flags$_);
        }
        _$_IsSolidEnabled$_() {
            return 0 != (8 & this._$_flags$_);
        }
        _$_SetSolidEnabled$_(t) {
            t ? this._$_flags$_ |= 8 : this._$_flags$_ &= -9;
        }
        _$_IsJumpthruEnabled$_() {
            return 0 != (16 & this._$_flags$_);
        }
        _$_SetJumpthruEnabled$_(t) {
            t ? this._$_flags$_ |= 16 : this._$_flags$_ &= -17;
        }
        _$_IsDrawingWithEffects$_() {
            return 0 != (64 & this._$_flags$_);
        }
        _$_SetIsDrawingWithEffects$_(t) {
            t ? this._$_flags$_ |= 64 : this._$_flags$_ &= -65;
        }
        _$SetFlag$_(t, s) {
            t <<= 16, s ? this._$_flags$_ |= t : this._$_flags$_ &= ~t;
        }
        _$GetFlag$_(t) {
            return 0 != (this._$_flags$_ & t << 16);
        }
        _$GetCurrentImageInfo$_() {
            return this._$_sdkInst$_._$GetCurrentImageInfo$_();
        }
        _$GetCurrentSurfaceSize$_() {
            return this._$_sdkInst$_._$GetCurrentSurfaceSize$_();
        }
        _$GetCurrentTexRect$_() {
            return this._$_sdkInst$_._$GetCurrentTexRect$_();
        }
        _$GetCurrentTexQuad$_() {
            return this._$_sdkInst$_._$GetCurrentTexQuad$_();
        }
        _$IsCurrentTexRotated$_() {
            return this._$_sdkInst$_._$IsCurrentTexRotated$_();
        }
        _$GetImagePoint$_(t) {
            return this._$_sdkInst$_._$GetImagePoint$_(t);
        }
        _$GetObjectClass$_() {
            return this._$_objectType$_;
        }
        _$RendersToOwnZPlane$_() {
            return this._$_sdkInst$_._$RendersToOwnZPlane$_();
        }
        _$BelongsToObjectClass$_(t) {
            return t._$IsFamily$_() ? t._$FamilyHasMember$_(this._$GetObjectClass$_()) : this._$GetObjectClass$_() === t;
        }
        _$CollectInstancesToPick$_(h, t, s) {
            const i = (t, s) => {
                const i = s || t._$GetObjectClass$_(), e = h.get(i);
                e ? e.add(t) : h.set(i, new Set([ t ]));
            };
            if (i(this, t), this._$IsInContainer$_()) for (const e of this._$siblings$_()) i(e);
            if (s) for (const r of this._$allChildren$_()) i(r);
        }
        _$VerifySupportsSceneGraph$_() {
            if (!this._$GetPlugin$_()._$SupportsSceneGraph$_()) throw new Error("object does not support scene graph");
        }
        _$HasParent$_() {
            return null !== this._$GetParent$_();
        }
        _$GetParent$_() {
            const t = this._$GetWorldInfo$_();
            if (!t) return null;
            const s = t._$GetParent$_();
            return s ? s._$GetInstance$_() : null;
        }
        _$GetTopParent$_() {
            const t = this._$GetWorldInfo$_();
            if (!t) return null;
            const s = t._$GetTopParent$_();
            return s ? s._$GetInstance$_() : null;
        }
        *_$parents$_() {
            const t = this._$GetWorldInfo$_();
            if (t) for (const s of t._$parents$_()) yield s._$GetInstance$_();
        }
        _$HasChild$_(t) {
            if (t) for (const s of this.children()) if (s === t) return !0;
            return !1;
        }
        _$HasChildren$_() {
            const t = this._$GetWorldInfo$_();
            return !!t && t._$HasChildren$_();
        }
        _$GetChildrenOfObjectClass$_(t) {
            const s = this._$GetWorldInfo$_();
            if (!s) return [];
            const i = t._$GetName$_();
            return s._$GetChildren$_().map(t => t._$GetInstance$_()).filter(t => t._$GetObjectClass$_()._$GetName$_() === i);
        }
        _$GetChildren$_() {
            const t = this._$GetWorldInfo$_();
            return t ? t._$GetChildren$_().map(t => t._$GetInstance$_()) : [];
        }
        *children() {
            const t = this._$GetWorldInfo$_();
            if (t) for (const s of t.children()) yield s._$GetInstance$_();
        }
        *_$allChildren$_() {
            const t = this._$GetWorldInfo$_();
            if (t) for (const s of t._$allChildren$_()) yield s._$GetInstance$_();
        }
        _$GetChildCount$_() {
            const t = this._$GetWorldInfo$_();
            return t ? t._$GetChildCount$_() : 0;
        }
        _$GetParentCount$_() {
            return [ ...this._$parents$_() ].length;
        }
        _$GetAllChildCount$_() {
            const t = this._$GetWorldInfo$_();
            return t ? t._$GetAllChildCount$_() : 0;
        }
        _$GetChildAt$_(t) {
            const s = this._$GetWorldInfo$_();
            if (!s) return null;
            const i = s._$GetChildAt$_(t);
            return i ? i._$GetInstance$_() : null;
        }
        _$GetIndexInParent$_() {
            const t = this._$GetWorldInfo$_();
            if (!t) return NaN;
            const s = t._$GetParent$_();
            return s ? s._$GetChildIndex$_(t) : NaN;
        }
        _$HasChildWithUID$_(t) {
            for (const s of this._$GetWorldInfo$_()._$GetChildren$_()) if (s._$GetInstance$_()._$GetUID$_() === t) return !0;
            return !1;
        }
        _$AddChild$_(t, s) {
            this._$VerifySupportsSceneGraph$_(), t._$VerifySupportsSceneGraph$_(), 
            this._$GetWorldInfo$_()._$AddChild$_(t._$GetWorldInfo$_(), s || {});
        }
        _$RemoveChild$_(t) {
            const s = this._$GetWorldInfo$_();
            s && s._$RemoveChild$_(t._$GetWorldInfo$_());
        }
        _$GetDestroyWithParent$_() {
            const t = this._$GetWorldInfo$_();
            return !!t && t._$GetDestroyWithParent$_();
        }
        _$SetupInitialSceneGraphConnections$_() {
            const t = this._$GetWorldInfo$_();
            if (t) {
                const s = t._$GetSceneGraphChildrenExportData$_();
                if (s) for (const i of s) {
                    const e = this._$_runtime$_._$GetInstanceByUID$_(i[2]);
                    if (e) {
                        const h = i[3];
                        this._$AddChild$_(e, {
                            _$transformX$_: !!(h >> 0 & 1),
                            _$transformY$_: !!(h >> 1 & 1),
                            _$transformWidth$_: !!(h >> 2 & 1),
                            _$transformHeight$_: !!(h >> 3 & 1),
                            _$transformAngle$_: !!(h >> 4 & 1),
                            _$destroyWithParent$_: !!(h >> 5 & 1),
                            _$transformZElevation$_: !!(h >> 6 & 1),
                            _$transformOpacity$_: !!(h >> 7 & 1),
                            _$transformVisibility$_: !!(h >> 8 & 1)
                        });
                    }
                }
            }
        }
        _$SetupPersistedSceneGraphConnections$_(t, s) {
            const i = t.get(this);
            if (i) for (const e of i.sceneGraphJson.children) {
                const h = s.get(e.index);
                if (h) {
                    const r = e.flags;
                    this._$AddChild$_(h, {
                        _$transformX$_: !!(r >> 0 & 1),
                        _$transformY$_: !!(r >> 1 & 1),
                        _$transformWidth$_: !!(r >> 2 & 1),
                        _$transformHeight$_: !!(r >> 3 & 1),
                        _$transformAngle$_: !!(r >> 4 & 1),
                        _$destroyWithParent$_: !!(r >> 5 & 1),
                        _$transformZElevation$_: !!(r >> 6 & 1),
                        _$transformOpacity$_: !!(r >> 7 & 1),
                        _$transformVisibility$_: !!(r >> 8 & 1)
                    });
                }
            }
        }
        _$GetTemplateName$_() {
            const t = this._$_runtime$_._$GetTemplateManager$_();
            return t ? t._$GetInstanceTemplateName$_(this) : "";
        }
        _$IsInContainer$_() {
            return null !== this._$_siblings$_;
        }
        _$_AddSibling$_(t) {
            this._$_siblings$_.push(t);
        }
        _$GetSiblings$_() {
            return this._$_siblings$_;
        }
        _$HasSibling$_(t) {
            return !!this._$GetSibling$_(t);
        }
        _$GetSibling$_(t) {
            const s = this._$siblings$_();
            if (null === s || 0 === s.length) return !1;
            for (const i of s) if (i._$GetObjectClass$_() === t) return i;
            return null;
        }
        _$siblings$_() {
            return this._$_siblings$_;
        }
        _$SetSiblingsSinglePicked$_() {
            for (const t of this._$siblings$_()) t._$GetObjectClass$_()._$GetCurrentSol$_()._$SetSinglePicked$_(t);
        }
        _$_PushSiblingsToSolInstances$_() {
            for (const t of this._$siblings$_()) t._$GetObjectClass$_()._$GetCurrentSol$_()._$_PushInstance$_(t);
        }
        _$_SetSiblingsToSolInstancesIndex$_(t) {
            for (const s of this._$siblings$_()) s._$GetObjectClass$_()._$GetCurrentSol$_()._$_GetOwnInstances$_()[t] = s;
        }
        _$_PushSiblingsToSolElseInstances$_() {
            for (const t of this._$siblings$_()) t._$GetObjectClass$_()._$GetCurrentSol$_()._$_PushElseInstance$_(t);
        }
        _$_SetSiblingsToSolElseInstancesIndex$_(t) {
            for (const s of this._$siblings$_()) s._$GetObjectClass$_()._$GetCurrentSol$_()._$_GetOwnElseInstances$_()[t] = s;
        }
        _$GetPlugin$_() {
            return this._$_objectType$_._$GetPlugin$_();
        }
        _$_SetIID$_(t) {
            this._$_iid$_ = t;
        }
        _$GetIID$_() {
            return this._$_objectType$_._$_UpdateIIDs$_(), this._$_iid$_;
        }
        _$GetUID$_() {
            return this._$_uid$_;
        }
        _$GetPUID$_() {
            return this._$_puid$_;
        }
        _$_SetTagsSetFromJson$_(t) {
            t ? this._$SetTagsSet$_(new Set(t)) : this._$_tagsSet$_ = null;
        }
        _$SetTagsSet$_(t) {
            if (0 === t.size) this._$_tagsSet$_ = null; else {
                this._$_tagsSet$_ ? this._$_tagsSet$_.clear() : this._$_tagsSet$_ = new Set();
                for (const s of t) this._$_tagsSet$_.add(s);
            }
        }
        _$GetTagsSet$_() {
            return this._$_tagsSet$_ ?? new Set();
        }
        _$GetTagsString$_() {
            return Array.from(this._$GetTagsSet$_()).join(" ");
        }
        _$GetTagAt$_(t) {
            t = Math.floor(t);
            for (const s of this._$GetTagsSet$_()) {
                if (0 === t) return s;
                --t;
            }
            return "";
        }
        _$GetBehaviorInstances$_() {
            return this._$_behaviorInstances$_;
        }
        _$GetBehaviorInstanceFromCtor$_(t) {
            if (t) for (const s of this._$_behaviorInstances$_) if (s._$GetBehavior$_() instanceof t) return s;
            return null;
        }
        _$GetBehaviorSdkInstanceFromCtor$_(t) {
            if (!t) return null;
            const s = this._$GetBehaviorInstanceFromCtor$_(t);
            return s ? s._$GetSdkInstance$_() : null;
        }
        _$GetBehaviorIndexBySID$_(i) {
            const e = this._$_behaviorInstances$_;
            for (let t = 0, s = e.length; t < s; ++t) if (e[t]._$GetBehaviorType$_()._$GetSID$_() === i) return t;
            return -1;
        }
        _$GetAllInstanceVariableValues$_() {
            return this._$_instVarValues$_;
        }
        _$_GetAllInstanceVariableNames$_() {
            return this._$_objectType$_._$_GetAllInstanceVariableNames$_();
        }
        _$GetInstanceVariableCount$_() {
            return this._$_instVarValues$_.length;
        }
        _$GetInstanceVariableValue$_(t) {
            const s = this._$_instVarValues$_;
            if ((t |= 0) < 0 || t >= s.length) throw new RangeError("invalid instance variable");
            return s[t];
        }
        _$_GetInstanceVariableValueUnchecked$_(t) {
            return this._$_instVarValues$_[t];
        }
        _$_GetInstanceVariableTypedValue$_(t) {
            const s = this._$_instVarValues$_[t];
            return 0 === this._$_objectType$_._$GetInstanceVariableType$_(t) ? !!s : s;
        }
        _$SetInstanceVariableValue$_(t, s) {
            const i = this._$_instVarValues$_;
            if ((t |= 0) < 0 || t >= i.length) throw new RangeError("invalid instance variable");
            const e = this._$_objectType$_._$GetInstanceVariableType$_(t);
            switch (e) {
              case 0:
                i[t] = s ? 1 : 0;
                break;

              case 1:
                i[t] = "number" == typeof s ? s : parseFloat(s);
                break;

              case 2:
                i[t] = "string" == typeof s ? s : s.toString();
                break;

              default:
                throw new Error("unknown instance variable type");
            }
        }
        _$SetInstanceVariableOffset$_(t, s) {
            if (0 !== s) {
                const i = this._$_instVarValues$_;
                if ((t |= 0) < 0 || t >= i.length) throw new RangeError("invalid instance variable");
                const e = i[t];
                if ("number" != typeof e) throw "boolean" == typeof e ? new Error("can not set offset of boolean variable") : "string" == typeof e ? new Error("can not set offset of string variable") : new Error("unknown instance variable type");
                i[t] += "number" == typeof s ? s : parseFloat(s);
            }
        }
        _$GetSavedDataMap$_() {
            let t = b.get(this);
            return t || (t = new Map(), b.set(this, t)), t;
        }
        _$GetUnsavedDataMap$_() {
            let t = e.get(this);
            return t || (t = new Map(), e.set(this, t)), t;
        }
        _$_HasAnyCreateDestroyHandler$_(t) {
            const s = this._$GetObjectClass$_();
            if (s._$UserScriptDispatcher$_()._$HasAnyHandlerFor$_(t)) return !0;
            for (const i of s._$GetFamilies$_()) if (i._$UserScriptDispatcher$_()._$HasAnyHandlerFor$_(t)) return !0;
            return !!this._$_runtime$_._$UserScriptDispatcher$_()._$HasAnyHandlerFor$_(t);
        }
        _$_TriggerOnCreatedOnSelfAndRelated$_() {
            const t = new Set(), s = (t.add(this), this._$GetWorldInfo$_());
            if (s && s._$HasChildren$_()) for (const i of this._$allChildren$_()) if (t.add(i), 
            i._$IsInContainer$_()) for (const e of i._$siblings$_()) t.add(e);
            if (this._$IsInContainer$_()) for (const h of this._$siblings$_()) t.add(h);
            for (const r of t.values()) r._$_TriggerOnCreated$_();
        }
        _$_OnCreatedCommon$_() {
            this._$_objectType$_._$_GetUserScriptInstanceClass$_() && this._$GetInterfaceClass$_();
            for (const t of this._$_behaviorInstances$_) t._$PostCreate$_();
        }
        _$_OnCreatedForLoadingSavegame$_() {
            this._$_OnCreatedCommon$_();
        }
        _$_TriggerOnCreated$_() {
            if (this._$_OnCreatedCommon$_(), this._$_HasAnyCreateDestroyHandler$_("instancecreate")) {
                const t = this._$GetObjectClass$_(), s = new S.Event("instancecreate");
                s._$instance$_ = this._$GetInterfaceClass$_(), t._$DispatchUserScriptEvent$_(s);
                for (const i of t._$GetFamilies$_()) i._$DispatchUserScriptEvent$_(s);
                this._$_runtime$_._$DispatchUserScriptEvent$_(s);
            }
            this._$_runtime$_._$Trigger$_(this._$GetPlugin$_()._$GetConstructor$_()._$Cnds$_._$OnCreated$_, this, null);
        }
        _$_TriggerOnDestroyed$_() {
            this._$_runtime$_._$Trigger$_(this._$GetPlugin$_()._$GetConstructor$_()._$Cnds$_._$OnDestroyed$_, this, null);
        }
        _$_FireDestroyedScriptEvents$_(t) {
            if (this._$_iScriptInterface$_) {
                const s = new S.Event("destroy");
                s._$isEndingLayout$_ = t, this._$DispatchUserScriptEvent$_(s);
            }
            if (this._$_HasAnyCreateDestroyHandler$_("instancedestroy")) {
                const i = this._$GetObjectClass$_(), e = new S.Event("instancedestroy");
                e._$instance$_ = this._$GetInterfaceClass$_(), e._$isEndingLayout$_ = t, 
                i._$DispatchUserScriptEvent$_(e);
                for (const h of i._$GetFamilies$_()) h._$DispatchUserScriptEvent$_(e);
                this._$_runtime$_._$DispatchUserScriptEvent$_(e);
            }
        }
        _$_GetDebuggerProperties$_() {
            return this._$_sdkInst$_ ? this._$_sdkInst$_._$GetDebuggerProperties$_() : this._$_iScriptInterface$_._$_getDebuggerProperties$_();
        }
        _$SaveToJson$_(t = "full", s = null) {
            const i = {}, e = ("full" === t ? i.uid = this._$GetUID$_() : i.c3 = !0, 
            this._$GetTagsSet$_());
            if (0 < e.size && (i.tags = Array.from(e)), "visual-state" !== t) {
                const r = b.get(this);
                if (r && r.size && (i.ex = S._$ToSuperJSON$_(r)), -1 !== this._$GetTimeScale$_() && (i.mts = this._$GetTimeScale$_()), 
                0 < this._$_objectType$_._$GetInstanceVariablesCount$_()) {
                    const n = {}, o = this._$_objectType$_._$GetInstanceVariableSIDs$_();
                    for (let t = 0, s = this._$_instVarValues$_.length; t < s; ++t) n[o[t].toString()] = this._$_instVarValues$_[t];
                    i.ivs = n;
                }
                if (this._$_behaviorInstances$_.length) {
                    const a = {};
                    for (const l of this._$_behaviorInstances$_) {
                        const u = l._$SaveToJson$_(t);
                        u && (a[l._$GetBehaviorType$_()._$GetSID$_().toString()] = u);
                    }
                    i.behs = a;
                }
            }
            this._$_worldInfo$_ && (i.w = this._$_worldInfo$_._$_SaveToJson$_(t, s));
            const h = this._$_sdkInst$_ ? this._$_sdkInst$_._$SaveToJson$_() : this._$_iScriptInterface$_._$_saveToJson$_();
            return h && (i.data = h), i;
        }
        _$_OnBeforeLoad$_(t = "full", s) {
            this._$_worldInfo$_ && this._$_worldInfo$_._$_OnBeforeLoad$_(t);
        }
        _$_OnAfterLoad$_(t, s = "full", i = null) {
            this._$_worldInfo$_ && this._$_worldInfo$_._$_OnAfterLoad$_(t, s, i);
        }
        _$_OnAfterLoad2$_(t, s = "full", i = null) {
            this._$_worldInfo$_ && this._$_worldInfo$_._$_OnAfterLoad2$_(t, s, i);
        }
        _$_SetupSceneGraphConnectionsOnChangeOfLayout$_() {
            this._$GetPlugin$_()._$IsWorldType$_() && this._$_worldInfo$_._$_SetupSceneGraphConnectionsOnChangeOfLayout$_();
        }
        _$LoadFromJson$_(s, t = "full", i) {
            if ("full" === t) this._$_uid$_ = s.uid; else if (!s.c3) return;
            if (this._$_SetTagsSetFromJson$_(s.tags), "visual-state" !== t) {
                let t = b.get(this);
                t && (t.clear(), b.delete(this));
                const h = s.ex, r = (h && (t = S._$FromSuperJSON$_(h), b.set(this, t)), 
                this._$_timeScale$_ = s.hasOwnProperty("mts") ? s.mts : -1, s.ivs);
                if (r) for (const [ n, o ] of Object.entries(r)) {
                    const a = parseInt(n, 10), l = this._$_objectType$_._$GetInstanceVariableIndexBySID$_(a);
                    if (!(l < 0 || l >= this._$_instVarValues$_.length)) {
                        let t = o;
                        null === t && (t = NaN), this._$_instVarValues$_[l] = t;
                    }
                }
            }
            if (this._$GetPlugin$_()._$IsWorldType$_()) {
                const u = s.w;
                if (u) {
                    const c = u.l;
                    if (this._$_worldInfo$_._$GetLayer$_()._$GetSID$_() !== c) {
                        const f = this._$_worldInfo$_._$GetLayer$_(), d = f._$GetLayout$_()._$GetLayerBySID$_(c);
                        d ? (this._$_worldInfo$_._$_SetLayer$_(d), f._$_RemoveInstance$_(this, !0), 
                        d._$_AddInstance$_(this, !0), d._$SetZIndicesChanged$_(this), 
                        this._$_worldInfo$_._$SetBboxChanged$_()) : "full" === t && this._$_runtime$_._$DestroyInstance$_(this);
                    }
                    this._$_worldInfo$_._$_LoadFromJson$_(u, t);
                }
            }
            if ("visual-state" !== t) {
                const p = s.behs;
                if (p) for (const [ m, g ] of Object.entries(p)) {
                    const y = parseInt(m, 10), w = this._$GetBehaviorIndexBySID$_(y);
                    w < 0 || w >= this._$_behaviorInstances$_.length || this._$_behaviorInstances$_[w]._$LoadFromJson$_(g, t);
                }
            }
            const e = s.data;
            e && (this._$_sdkInst$_ ? this._$_sdkInst$_._$LoadFromJson$_(e, t) : this._$_iScriptInterface$_._$_loadFromJson$_(e));
        }
        _$GetInterfaceClass$_() {
            return this._$_iScriptInterface$_ || this._$_InitUserScriptInterface$_();
        }
        _$HasScriptInterface$_() {
            return !!this._$_iScriptInterface$_;
        }
        _$_InitUserScriptInterface$_(t, s) {
            const i = this._$_worldInfo$_ ? t ? self._$ISDKWorldInstanceBase$_ : self._$IWorldInstance$_ : t ? self._$ISDKInstanceBase$_ : self._$IInstance$_, e = t || this._$_sdkInst$_._$GetScriptInterfaceClass$_(), h = this._$_objectType$_._$_GetUserScriptInstanceClass$_(), r = h || e || i, n = this._$GetPlugin$_()._$GetSdkVersion$_();
            if (S._$AddonManager$_._$_PushInitObject$_(this, n), S._$AddonManager$_._$_PushInitProperties$_(s), 
            this._$_iScriptInterface$_ = new r(), S._$AddonManager$_._$_PopInitProperties$_(), 
            S._$AddonManager$_._$_PopInitObject$_(n), e && !(this._$_iScriptInterface$_ instanceof i)) throw new TypeError(`script interface class '${e.name}' does not extend the right base class '${i.name}'`);
            if (h) {
                const o = e || i;
                if (!(this._$_iScriptInterface$_ instanceof o)) throw new TypeError(`setInstanceClass(): class '${h.name}' does not extend the right base class - check it extends the right class, e.g. globalThis.InstanceType.MyObjectName`);
            }
            return this._$_iScriptInterface$_;
        }
        _$_GetInstVarsScriptDescriptor$_(t) {
            if (0 !== this._$_instVarValues$_.length) {
                const i = {}, e = this._$_objectType$_._$_GetAllInstanceVariableJsPropNames$_();
                for (let t = 0, s = e.length; t < s; ++t) i[e[t]] = {
                    configurable: !1,
                    enumerable: !0,
                    get: S.Instance.prototype._$_GetInstanceVariableTypedValue$_.bind(this, t),
                    set: S.Instance.prototype._$SetInstanceVariableValue$_.bind(this, t)
                };
                const s = Object.create(Object.prototype, i);
                t._$instVars$_ = {
                    value: s,
                    writable: !1
                };
            }
        }
        _$_GetBehaviorsScriptDescriptor$_(t) {
            const s = this._$_behaviorInstances$_;
            if (0 !== s.length) {
                const i = {};
                for (const h of s) i[h._$GetBehaviorType$_()._$GetJsPropName$_()] = {
                    value: h._$GetScriptInterface$_(),
                    writable: !1
                };
                const e = Object.create(Object.prototype, i);
                t._$behaviors$_ = {
                    value: e,
                    writable: !1
                };
            }
        }
        _$DispatchUserScriptEvent$_(t) {
            if (this._$HasScriptInterface$_()) {
                const s = this._$GetInterfaceClass$_(), i = (t._$instance$_ = s, 
                this._$_runtime$_), e = i._$IsDebug$_() && !i._$GetEventSheetManager$_()._$IsInEventEngine$_();
                e && h.StartMeasuringScriptTime(), s.dispatchEvent(t), e && h.AddScriptTime();
            }
        }
    };
}

{
    const Aa = self._$C3$_;
    Aa._$SceneGraphInfo$_ = class extends Aa._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_owner$_ = t, this._$_parent$_ = null, this._$_children$_ = [], 
            this._$_startWidth$_ = t._$GetWidth$_(), this._$_startHeight$_ = t._$GetHeight$_(), 
            this._$_startScaleX$_ = 1, this._$_startScaleY$_ = 1, this._$_parentStartAngle$_ = 0, 
            this._$_ownOpacity$_ = 1, this._$_startOpacity$_ = t._$GetOpacity$_(), 
            this._$_tmpSceneGraphChildren$_ = null, this._$_tmpSceneGraphChildrenIndexes$_ = null, 
            this._$_indexInParent$_ = NaN;
        }
        _$Release$_() {
            this._$_parent$_ = null, this._$_tmpSceneGraphChildren$_ = null, this._$_tmpSceneGraphChildrenIndexes$_ = null, 
            this._$_indexInParent$_ = NaN, Aa._$clearArray$_(this._$_children$_);
        }
        _$SetParent$_(t) {
            this._$_ownOpacity$_ = this._$_owner$_._$GetOpacity$_(), this._$_startOpacity$_ = this._$_ownOpacity$_, 
            this._$_parent$_ = t, this._$_parentStartAngle$_ = t ? t._$GetAngle$_() : 0;
        }
        _$GetParent$_() {
            return this._$_parent$_;
        }
        _$HasChildren$_() {
            return 0 < this._$_children$_.length;
        }
        _$GetChildren$_() {
            return this._$_children$_;
        }
        _$_MaybeSortChildren$_() {
            this._$HasChildren$_() && 1 !== this._$_children$_.length && (this._$_tmpSceneGraphChildrenIndexes$_ ? this._$_children$_.sort((t, s) => {
                const i = this._$_tmpSceneGraphChildrenIndexes$_.get(t._$GetInstance$_()), e = this._$_tmpSceneGraphChildrenIndexes$_.get(s._$GetInstance$_());
                return Aa._$IsFiniteNumber$_(i) && Aa._$IsFiniteNumber$_(e) ? i - e : 0;
            }) : this._$_children$_.sort((t, s) => {
                const i = t._$_GetSceneGraphInfo$_()._$_GetIndexInParent$_(), e = s._$_GetSceneGraphInfo$_()._$_GetIndexInParent$_();
                return Aa._$IsFiniteNumber$_(i) && Aa._$IsFiniteNumber$_(e) ? i - e : 0;
            }));
        }
        _$_GetIndexInParent$_() {
            return this._$_indexInParent$_;
        }
        _$GetStartScaleX$_() {
            return this._$_startScaleX$_;
        }
        _$SetStartScaleX$_(t) {
            this._$_startScaleX$_ = t;
        }
        _$GetStartScaleY$_() {
            return this._$_startScaleY$_;
        }
        _$SetStartScaleY$_(t) {
            this._$_startScaleY$_ = t;
        }
        _$GetStartOpacity$_() {
            return this._$_startOpacity$_;
        }
        _$GetOwnOpacity$_() {
            return this._$_ownOpacity$_;
        }
        _$SetOwnOpacity$_(t) {
            this._$_ownOpacity$_ = t;
        }
        _$_GetStartWidth$_() {
            return 0 === this._$_startWidth$_ ? Number.EPSILON : this._$_startWidth$_;
        }
        _$_GetStartHeight$_() {
            return 0 === this._$_startHeight$_ ? Number.EPSILON : this._$_startHeight$_;
        }
        _$GetParentScaleX$_() {
            if (this._$_owner$_._$GetTransformWithParentWidth$_()) {
                let t = this._$_parent$_, s = t._$GetWidth$_(), i = t._$_GetSceneGraphInfo$_()._$_GetStartWidth$_();
                if (0 === s && (s = Number.EPSILON), i === Number.EPSILON && s === Number.EPSILON) return 1;
                if (i === Number.EPSILON && s !== Number.EPSILON) {
                    const e = t._$GetInstance$_()._$GetSdkInstance$_();
                    if (e._$IsOriginalSizeKnown$_()) return 1 + s / e._$GetOriginalWidth$_();
                }
                return s / i;
            }
            return 1;
        }
        _$GetParentScaleY$_() {
            if (this._$_owner$_._$GetTransformWithParentHeight$_()) {
                let t = this._$_parent$_, s = t._$GetHeight$_(), i = t._$_GetSceneGraphInfo$_()._$_GetStartHeight$_();
                if (0 === s && (s = Number.EPSILON), i === Number.EPSILON && s === Number.EPSILON) return 1;
                if (i === Number.EPSILON && s !== Number.EPSILON) {
                    const e = t._$GetInstance$_()._$GetSdkInstance$_();
                    if (e._$IsOriginalSizeKnown$_()) return 1 + s / e._$GetOriginalHeight$_();
                }
                return s / i;
            }
            return 1;
        }
        _$GetParentStartAngle$_() {
            return this._$_parentStartAngle$_;
        }
        _$_SaveToJsonProperties$_() {
            return {
                sw: this._$_startWidth$_,
                sh: this._$_startHeight$_,
                sx: this._$_startScaleX$_,
                sy: this._$_startScaleY$_,
                psa: this._$_parentStartAngle$_,
                oo: this._$_ownOpacity$_,
                so: this._$_startOpacity$_,
                pi: this._$_owner$_._$GetInstance$_()._$GetIndexInParent$_()
            };
        }
        _$_SaveToJson$_(t, s = null) {
            const i = this._$_SaveToJsonProperties$_();
            return s && s.selfOnly ? Object.assign(i, {
                p: null,
                c: []
            }) : Object.assign(i, {
                p: this._$_GetParentJson$_(t),
                c: this._$_GetChildrenJson$_(t)
            });
        }
        _$_GetFlagsString$_(t) {
            let s = "";
            return t._$GetTransformWithParentX$_() && (s += "x"), t._$GetTransformWithParentY$_() && (s += "y"), 
            t._$GetTransformWithParentWidth$_() && (s += "w"), t._$GetTransformWithParentHeight$_() && (s += "h"), 
            t._$GetTransformWithParentAngle$_() && (s += "a"), t._$GetTransformWithParentZElevation$_() && (s += "z"), 
            t._$GetDestroyWithParent$_() && (s += "d"), t._$GetTransformWithParentOpacity$_() && (s += "o"), 
            t._$GetTransformWithParentVisibility$_() && (s += "v"), s;
        }
        _$_GetParentJson$_(t) {
            return !this._$_parent$_ || !this._$_parent$_._$GetInstance$_() || this._$_parent$_._$GetInstance$_()._$IsDestroyed$_() ? null : this._$_GetInstanceJson$_(this._$_parent$_, this._$_owner$_, t);
        }
        _$_GetChildrenJson$_(s) {
            return this._$_children$_.map(t => this._$_GetInstanceJson$_(t, t, s)).filter(t => t);
        }
        _$_GetInstanceJson$_(t, s, i) {
            const e = t._$GetInstance$_();
            if (e && e._$IsDestroyed$_()) return null;
            const h = {};
            return h.uid = e._$GetUID$_(), h.f = this._$_GetFlagsString$_(s), h.offsets = s._$_SaveSceneGraphPropertiesToJson$_(), 
            h.data = Aa._$SceneGraphInfo$_._$GetSceneGraphInstanceDataFromInstance$_(e), 
            h.oci = e._$GetObjectClass$_()._$GetIndex$_(), "state" === i ? (h.inst = e._$SaveToJson$_("full", {
                selfOnly: !0
            }), h.instIndex = NaN) : (h.instIndex = e._$GetObjectClass$_()._$GetInstances$_().indexOf(e), 
            h.inst = null), h;
        }
        _$_LoadFromJson$_(t) {
            this._$_startWidth$_ = t.sw, this._$_startHeight$_ = t.sh, this._$_startScaleX$_ = t.sx, 
            this._$_startScaleY$_ = t.sy, this._$_parentStartAngle$_ = t.psa, this._$_ownOpacity$_ = t.oo, 
            this._$_startOpacity$_ = t.so, this._$_indexInParent$_ = Aa._$IsFiniteNumber$_(t.pi) ? t.pi : NaN;
        }
        _$_SetTmpSceneGraphChildren$_(t, s) {
            if (!t && !s && this._$_tmpSceneGraphChildren$_) for (const i of this._$_tmpSceneGraphChildren$_) i._$IsDestroyed$_() || i._$HasParent$_() || i._$GetRuntime$_()._$DestroyInstance$_(i);
            this._$_tmpSceneGraphChildren$_ = t, this._$_tmpSceneGraphChildrenIndexes$_ = s;
        }
        _$_OnAfterLoad$_(t, s) {
            const i = this._$_owner$_, e = i._$GetRuntime$_(), h = new Set();
            if (t.p && !this._$_parent$_) {
                const o = t.p.uid, a = e._$GetInstanceByUID$_(o);
                if (s?._$setFromJson$_, a) {
                    const l = a._$GetWorldInfo$_();
                    if (a._$HasChild$_(i._$GetInstance$_())) this._$_parent$_ = l; else {
                        a._$HasChildWithUID$_(i._$GetInstance$_()._$GetUID$_()) ? e._$DestroyInstance$_(i._$GetInstance$_()) : a._$AddChild$_(i._$GetInstance$_(), this._$_GetFlagsObj$_(t.p.f)), 
                        h.has(i) || (i._$_LoadSceneGraphPropertiesFromJson$_(t.p.offsets), 
                        this._$_LoadInstancePropertiesFromJson$_(a, t.p, s)), h.add(i);
                        const u = a._$GetWorldInfo$_();
                        u._$_GetSceneGraphInfo$_()._$_MaybeSortChildren$_();
                    }
                } else if (Aa._$IsFiniteNumber$_(t.p.oci)) {
                    const c = e._$GetObjectClassByIndex$_(t.p.oci), f = (e._$GetSystemPlugin$_(), 
                    e._$CreateInstance$_(c, i._$GetLayer$_(), 0, 0, !0));
                    if (s?._$setFromJson$_, f) {
                        const d = this._$_GetInstanceData$_(t.p, e), p = (f._$LoadFromJson$_(d), 
                        f._$GetWorldInfo$_()), m = (p._$GetLayer$_()._$SortAndAddInstancesByZIndex$_(f), 
                        f._$AddChild$_(i._$GetInstance$_(), this._$_GetFlagsObj$_(t.p.f)), 
                        f._$GetWorldInfo$_());
                        m._$_GetSceneGraphInfo$_()._$_MaybeSortChildren$_();
                    }
                }
            }
            const r = [];
            for (const g of t.c) {
                const y = g.uid, w = e._$GetInstanceByUID$_(y);
                w && r.push(w);
            }
            let n = 0;
            for (const S of t.c) {
                const b = S.uid, M = e._$GetInstanceByUID$_(b);
                if (s?._$setFromJson$_, M) {
                    if (this._$_tmpSceneGraphChildren$_) {
                        if (this._$_tmpSceneGraphChildren$_.includes(M)) {
                            const T = M;
                            if (T._$GetObjectClass$_() !== M._$GetObjectClass$_()) {
                                n++;
                                continue;
                            }
                            if (T._$IsDestroyed$_()) {
                                n++;
                                continue;
                            }
                            const _ = t.c[n];
                            if (!s?._$setFromJson$_ && this._$_HasAllChildrenOfType$_(T, r, i)) {
                                this._$_UpdateInstance$_(n, _, i, h, s), n++;
                                continue;
                            }
                            if (T._$HasParent$_() && T._$GetParent$_() !== i._$GetInstance$_()) {
                                const I = this._$_CreateNewChildInstance$_(_, s);
                                this._$_AddAndSetChildInstance$_(I, _, h, s), n++;
                                continue;
                            }
                            this._$_AddAndSetChildInstance$_(T._$GetWorldInfo$_(), _, h, s, !0), 
                            n++;
                            continue;
                        }
                        if (this._$_tmpSceneGraphChildren$_[n]) {
                            const C = this._$_tmpSceneGraphChildren$_[n];
                            if (C._$GetObjectClass$_() !== M._$GetObjectClass$_()) {
                                n++;
                                continue;
                            }
                            if (C._$IsDestroyed$_()) {
                                n++;
                                continue;
                            }
                            const R = t.c[n];
                            if (!s?._$setFromJson$_ && this._$_HasAllChildrenOfType$_(C, r, i)) {
                                this._$_UpdateInstance$_(n, R, i, h, s), n++;
                                continue;
                            }
                            if (C._$HasParent$_() && C._$GetParent$_() !== i._$GetInstance$_()) {
                                const P = this._$_CreateNewChildInstance$_(R, s);
                                this._$_AddAndSetChildInstance$_(P, R, h, s), n++;
                                continue;
                            }
                            this._$_AddAndSetChildInstance$_(C._$GetWorldInfo$_(), R, h, s, !0), 
                            n++;
                            continue;
                        }
                    }
                    const v = M._$GetObjectClass$_(), x = this._$_GetInstancesOfObjectClassCount$_(r, v), G = i._$GetInstance$_()._$GetChildrenOfObjectClass$_(v).length;
                    if (x === G) {
                        const E = i._$GetInstance$_()._$GetChildAt$_(n);
                        if (E) {
                            const A = E._$GetWorldInfo$_();
                            A && (h.has(A) || (A._$_LoadSceneGraphPropertiesFromJson$_(S.offsets), 
                            this._$_LoadInstancePropertiesFromJson$_(E, S, s)), 
                            h.add(A));
                        }
                        n++;
                        continue;
                    }
                    if (M._$HasParent$_() && M._$GetParent$_() !== i._$GetInstance$_()) {
                        const F = this._$_CreateNewChildInstance$_(S, s);
                        this._$_AddAndSetChildInstance$_(F, S, h, s), n++;
                        continue;
                    }
                    this._$_AddAndSetChildInstance$_(M._$GetWorldInfo$_(), S, h, s);
                } else if (this._$_tmpSceneGraphChildren$_ && this._$_tmpSceneGraphChildren$_[n]) {
                    const O = this._$_tmpSceneGraphChildren$_[n], k = e._$GetObjectClassByIndex$_(this._$_GetObjectClassIndex$_(S));
                    if (O._$GetObjectClass$_() !== k) {
                        n++;
                        continue;
                    }
                    if (O._$IsDestroyed$_()) {
                        n++;
                        continue;
                    }
                    const D = t.c[n];
                    if (!s?._$setFromJson$_ && this._$_HasAllChildrenOfType$_(O, r, i)) {
                        this._$_UpdateInstance$_(n, D, i, h, s), n++;
                        continue;
                    }
                    if (O._$HasParent$_() && O._$GetParent$_() !== i._$GetInstance$_()) {
                        const L = this._$_CreateNewChildInstance$_(D, s);
                        this._$_AddAndSetChildInstance$_(L, D, h, s), n++;
                        continue;
                    }
                    this._$_AddAndSetChildInstance$_(O._$GetWorldInfo$_(), D, h, s);
                } else {
                    const B = this._$_CreateNewChildInstance$_(S, s);
                    this._$_AddAndSetChildInstance$_(B, S, h, s);
                }
                n++;
            }
        }
        _$_HasAllChildrenOfType$_(t, s, i) {
            const e = t._$GetObjectClass$_(), h = this._$_GetInstancesOfObjectClassCount$_(s, e), r = i._$GetInstance$_()._$GetChildrenOfObjectClass$_(e).length;
            return h === r;
        }
        _$_UpdateInstance$_(t, s, i, e, h) {
            const r = i._$GetInstance$_()._$GetChildAt$_(t, s);
            if (r) {
                const n = r._$GetWorldInfo$_();
                n && (e.has(n) || (n._$_LoadSceneGraphPropertiesFromJson$_(s.offsets), 
                this._$_LoadInstancePropertiesFromJson$_(r, s, h)), e.add(n));
            }
        }
        _$_GetFlagsObj$_(t) {
            const s = {};
            return s._$transformX$_ = t.includes("x"), s._$transformY$_ = t.includes("y"), 
            s._$transformWidth$_ = t.includes("w"), s._$transformHeight$_ = t.includes("h"), 
            s._$transformAngle$_ = t.includes("a"), s._$transformZElevation$_ = t.includes("z"), 
            s._$destroyWithParent$_ = t.includes("d"), s._$transformOpacity$_ = t.includes("o"), 
            s._$transformVisibility$_ = t.includes("v"), s;
        }
        _$_GetObjectClassIndex$_(t) {
            return Aa._$IsFiniteNumber$_(t.oci) ? t.oci : t[1];
        }
        _$_CreateNewChildInstance$_(e, h) {
            if (Aa._$IsFiniteNumber$_(e.oci)) {
                let t = this._$_owner$_, s = t._$GetRuntime$_(), i;
                if (e.data) i = s._$CreateInstanceFromData$_(e.data, t._$GetLayer$_(), !1, 0, 0, !1, !0); else {
                    const r = s._$GetObjectClassByIndex$_(e.oci);
                    i = s._$CreateInstance$_(r, t._$GetLayer$_(), 0, 0, !0);
                }
                if (h?._$setFromJson$_, i) {
                    const n = this._$_GetInstanceData$_(e, s), o = (i._$LoadFromJson$_(n), 
                    i._$GetWorldInfo$_());
                    return o._$GetLayer$_()._$SortAndAddInstancesByZIndex$_(i, !0), 
                    o;
                }
            }
        }
        _$_AddAndSetChildInstance$_(t, s, i, e, h = !0) {
            const r = this._$_owner$_, n = r._$AddChild$_(t, this._$_GetFlagsObj$_(s.f));
            n && h && (i.has(t) || (t._$_LoadSceneGraphPropertiesFromJson$_(s.offsets), 
            this._$_LoadInstancePropertiesFromJson$_(t._$GetInstance$_(), s, e)), 
            i.add(t)), this._$_MaybeSortChildren$_();
        }
        _$_LoadInstancePropertiesFromJson$_(t, s, i) {
            let e = this._$_GetInstanceData$_(s, this._$_owner$_._$GetRuntime$_());
            e && ((e = JSON.parse(JSON.stringify(e))).w = null, t._$LoadFromJson$_(e));
        }
        _$_GetInstancesOfObjectClassCount$_(t, s) {
            return t.filter(t => t._$GetObjectClass$_()._$GetName$_() === s._$GetName$_()).length;
        }
        _$_GetInstanceData$_(t, s) {
            if (Aa._$IsFiniteNumber$_(t.instIndex)) {
                const i = s._$GetObjectClassByIndex$_(t.oci), e = i._$_GetLoadInstancesJson$_();
                return e[t.instIndex];
            }
            return Aa._$IsString$_(t.inst) ? JSON.parse(t.inst) : t.inst || void 0;
        }
        static _$GetSceneGraphInstanceDataFromInstance$_(t) {
            let s = t._$GetWorldInfo$_()._$GetLayer$_()._$GetInitialInstanceData$_(t._$GetUID$_());
            if (!s) return null;
            s = JSON.parse(JSON.stringify(s));
            const i = [];
            for (const e of [ ...t._$GetChildren$_() ]) {
                const h = e._$GetWorldInfo$_();
                i.push([ h._$GetLayout$_()._$GetSID$_(), h._$GetLayer$_()._$GetIndex$_(), e._$GetUID$_(), Aa._$SceneGraphInfo$_._$_GetFlagsNumber$_(h), e._$GetObjectClass$_()._$IsInContainer$_() ? 1 : 0, h._$GetZIndex$_(), Aa._$SceneGraphInfo$_._$GetSceneGraphInstanceDataFromInstance$_(e) ]);
            }
            return Aa._$IsArray$_(s[0][14]) ? s[0][14][1] = i : (s[0][14] = [], 
            s[0][14][0] = Aa._$SceneGraphInfo$_._$_GetDefaultFlagsNumber$_(), s[0][14][1] = i, 
            s[0][14][2] = t._$GetWorldInfo$_()._$GetZIndex$_()), s;
        }
        static _$_GetFlagsNumber$_(t) {
            let s = 0;
            return (s |= Number(t._$GetTransformWithParentVisibility$_()) << 8) | Number(t._$GetTransformWithParentOpacity$_()) << 7 | Number(t._$GetTransformWithParentZElevation$_()) << 6 | Number(t._$GetDestroyWithParent$_()) << 5 | Number(t._$GetTransformWithParentAngle$_()) << 4 | Number(t._$GetTransformWithParentHeight$_()) << 3 | Number(t._$GetTransformWithParentWidth$_()) << 2 | Number(t._$GetTransformWithParentY$_()) << 1 | Number(t._$GetTransformWithParentX$_()) << 0;
        }
        static _$_GetDefaultFlagsNumber$_(t) {
            let s = 0;
            return (s |= 256) | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1, 511;
        }
    };
}

{
    let d = self._$C3$_, t = self._$glMatrix$_, r = (t._$vec3$_, d._$New$_(d.Rect)), n = d._$New$_(d._$Quad$_), s = d._$New$_(d.Event, "bboxchange", !1), f = d._$New$_(d._$Color$_, 0, 0, 0, 0), u = d._$New$_(d._$CollisionPoly$_), i = d._$New$_(d._$Color$_, 1, 1, 1, 1), o = d._$New$_(d.Rect, 0, 0, -1, -1), h = d._$New$_(d.Rect, 0, 0, -1, -1), p = new Set([ "absolute", "relative" ]), e = [], m = !0, g = new WeakMap(), a = new WeakMap();
    d._$WorldInfo$_ = class extends d._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_inst$_ = t, this._$_objectClass$_ = t._$GetObjectClass$_(), 
            this._$_runtime$_ = t._$GetRuntime$_(), this._$_layer$_ = s, this._$_objectClass$_._$_OnWorldInstanceLayerChanged$_(this, null, s), 
            this._$_zIndex$_ = -1, this._$_htmlZIndex$_ = -1, this._$_flags$_ = 196635, 
            this._$_objectClass$_._$GetPlugin$_()._$IsRotatable$_() && (this._$_flags$_ |= 128), 
            this._$_x$_ = NaN, this._$_y$_ = NaN, this._$_zElevation$_ = NaN, this._$_w$_ = NaN, 
            this._$_h$_ = NaN, this._$_depth$_ = NaN, this._$_a$_ = NaN, this._$_sinA$_ = NaN, 
            this._$_cosA$_ = NaN, this._$_ox$_ = NaN, this._$_oy$_ = NaN, this._$_boundingBox$_ = d._$New$_(d.Rect), 
            this._$_boundingQuad$_ = d._$New$_(d._$Quad$_), this._$_collisionCells$_ = h, 
            this._$_renderCells$_ = o, this._$_sourceCollisionPoly$_ = null, this._$_transformedPolyInfo$_ = null, 
            this._$_solidFilterTags$_ = null, this._$_color$_ = i, this._$_colorPremultiplied$_ = i, 
            this._$_stateGroup$_ = null, this._$_instanceEffectList$_ = null, this._$_inst$_._$GetObjectClass$_()._$UsesEffects$_() && (this._$_instanceEffectList$_ = d._$New$_(d._$InstanceEffectList$_, this._$_inst$_, this)), 
            this._$_sceneGraphInfo$_ = null, this._$_tmpSceneGraphChildren$_ = null, 
            this._$_tmpSceneGraphChildrenIndexes$_ = null, this._$_tmpHierarchyPosition$_ = -1, 
            this._$_meshInfo$_ = null;
        }
        _$_MarkDestroyed$_() {
            this._$_flags$_ |= 256;
        }
        _$Release$_() {
            if (this._$_objectClass$_._$_OnWorldInstanceLayerChanged$_(this, this._$_layer$_, null), 
            this._$_stateGroup$_ && (this._$_runtime$_._$GetRenderer$_()._$ReleaseStateGroup$_(this._$_stateGroup$_), 
            this._$_stateGroup$_ = null), this._$_sourceCollisionPoly$_ = null, 
            this._$_transformedPolyInfo$_ && (this._$_transformedPolyInfo$_._$poly$_._$Release$_(), 
            this._$_transformedPolyInfo$_ = null), this._$_solidFilterTags$_ && (this._$_solidFilterTags$_.clear(), 
            this._$_solidFilterTags$_ = null), this._$ReleaseMesh$_(), this._$_instanceEffectList$_ && this._$_instanceEffectList$_._$Release$_(), 
            this._$HasParent$_() && this._$GetParent$_()._$RemoveChild$_(this), 
            this._$HasChildren$_()) {
                const t = [ ...this._$GetChildren$_() ];
                for (const s of t) this._$RemoveChild$_(s);
            }
            this._$_ReleaseSceneGraphInfo$_(), this._$_ReleaseTmpSceneGraphInfo$_(), 
            g.delete(this), a.delete(this), this._$_inst$_ = null, this._$_objectClass$_ = null, 
            this._$_runtime$_ = null, this._$_layer$_ = null;
        }
        _$Init$_(t) {
            if (m = !1, this._$SetXY$_(t[0], t[1]), this._$SetZElevation$_(t[2]), 
            this._$SetSize$_(t[3], t[4]), this._$_depth$_ = 0, this._$IsRotatable$_() ? this._$SetAngle$_(t[6]) : this._$_a$_ = 0, 
            f._$setFromJSON$_(t[7]), this._$_SetColor$_(f), this._$SetOriginX$_(t[8]), 
            this._$SetOriginY$_(t[9]), this._$SetBlendMode$_(t[10]), this._$_instanceEffectList$_ && this._$_instanceEffectList$_._$_LoadEffectParameters$_(t[12]), 
            t[14] && g.set(this, {
                _$childrenData$_: t[14][1],
                _$zIndexData$_: t[14][2]
            }), t[15]) {
                const s = t[15], e = (this._$CreateMesh$_(s[0], s[1]), this._$GetSourceMesh$_()), h = s[2];
                for (let i = 0, t = h.length; i < t; ++i) {
                    const r = h[i];
                    for (let t = 0, s = r.length; t < s; ++t) {
                        const n = r[t], o = e._$GetMeshPointAt$_(t, i);
                        o._$SetX$_(n[0]), o._$SetY$_(n[1]), o._$SetZElevation$_(n[2]), 
                        o._$SetU$_(n[3]), o._$SetV$_(n[4]);
                    }
                }
            }
            if (t[16]) {
                const i = t[16][0], a = t[16][1], l = !!a, u = !l, c = this._$_runtime$_._$GetTemplateManager$_();
                l && c && c._$MapInstanceToTemplateName$_(this._$GetInstance$_(), a), 
                u && c && c._$MapInstanceToTemplateName$_(this._$GetInstance$_(), i);
            }
            m = !0, this._$_UpdateRendererStateGroup$_();
        }
        _$InitNoData$_() {
            this._$_x$_ = 0, this._$_y$_ = 0, this._$_zElevation$_ = 0, this._$_w$_ = 0, 
            this._$_h$_ = 0, this._$_depth$_ = 0, this._$_a$_ = 0, this._$_sinA$_ = 0, 
            this._$_cosA$_ = 1, this._$_ox$_ = 0, this._$_oy$_ = 0, this._$_UpdateRendererStateGroup$_();
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetObjectClass$_() {
            return this._$_objectClass$_;
        }
        _$GetInstance$_() {
            return this._$_inst$_;
        }
        _$_GetParentOffsetAngle$_() {
            return this._$GetTransformWithParentAngle$_() ? this._$_MaybeReflectAngleForMirrorFlip$_(this._$GetParent$_()._$_GetAngleNoReflect$_() - this._$_sceneGraphInfo$_._$GetParentStartAngle$_()) : 0;
        }
        _$SetX$_(t) {
            if (t = +t, this._$GetTransformWithParentX$_()) {
                const s = this._$_sceneGraphInfo$_, i = t - this._$GetX$_(), e = -this._$_GetParentOffsetAngle$_();
                0 == e ? this._$_x$_ += i / s._$GetParentScaleX$_() : (this._$_x$_ += Math.cos(e) * i / s._$GetParentScaleX$_(), 
                this._$GetTransformWithParentY$_() && (this._$_y$_ += Math.sin(e) * i / s._$GetParentScaleY$_()));
            } else this._$_x$_ = t;
        }
        _$OffsetX$_(t, s = !1) {
            t = +t, !s && this._$GetTransformWithParentX$_() ? this._$SetX$_(this._$GetX$_() + t) : this._$_x$_ += t;
        }
        _$GetX$_() {
            if (this._$GetTransformWithParentX$_()) {
                let t = this._$_x$_, s = this._$_sceneGraphInfo$_, i = this._$GetParent$_(), e = this._$_GetParentOffsetAngle$_();
                return 0 === e ? t *= s._$GetParentScaleX$_() : (t = t * s._$GetParentScaleX$_() * Math.cos(e), 
                this._$GetTransformWithParentY$_() && (t -= this._$_y$_ * s._$GetParentScaleY$_() * Math.sin(e))), 
                i._$GetX$_() + t;
            }
            return this._$_x$_;
        }
        _$SetY$_(t) {
            if (t = +t, this._$GetTransformWithParentY$_()) {
                const s = this._$_sceneGraphInfo$_, i = t - this._$GetY$_(), e = -this._$_GetParentOffsetAngle$_();
                0 == e ? this._$_y$_ += i / s._$GetParentScaleY$_() : (this._$GetTransformWithParentX$_() && (this._$_x$_ -= Math.sin(e) * i / s._$GetParentScaleX$_()), 
                this._$_y$_ += Math.cos(e) * i / s._$GetParentScaleY$_());
            } else this._$_y$_ = t;
        }
        _$OffsetY$_(t, s = !1) {
            t = +t, !s && this._$GetTransformWithParentY$_() ? this._$SetY$_(this._$GetY$_() + t) : this._$_y$_ += t;
        }
        _$GetY$_() {
            if (this._$GetTransformWithParentY$_()) {
                let t = this._$_y$_, s = this._$_sceneGraphInfo$_, i = this._$GetParent$_(), e = this._$_GetParentOffsetAngle$_();
                return 0 === e ? t *= s._$GetParentScaleY$_() : (t = t * s._$GetParentScaleY$_() * Math.cos(e), 
                this._$GetTransformWithParentX$_() && (t += this._$_x$_ * s._$GetParentScaleX$_() * Math.sin(e))), 
                i._$GetY$_() + t;
            }
            return this._$_y$_;
        }
        _$SetXY$_(t, s) {
            if (t = +t, s = +s, this._$GetTransformWithParentXOrY$_()) {
                const i = this._$GetTransformWithParentX$_(), e = this._$GetTransformWithParentY$_(), h = this._$_sceneGraphInfo$_, r = t - this._$GetX$_(), n = s - this._$GetY$_(), o = -this._$_GetParentOffsetAngle$_();
                if (0 == o) i ? this._$_x$_ += r / h._$GetParentScaleX$_() : this._$_x$_ = t, 
                e ? this._$_y$_ += n / h._$GetParentScaleY$_() : this._$_y$_ = s; else {
                    const a = Math.sin(o), l = Math.cos(o);
                    i ? this._$_x$_ += e ? (l * r - a * n) / h._$GetParentScaleX$_() : l * r / h._$GetParentScaleX$_() : this._$_x$_ = t, 
                    e ? this._$_y$_ += i ? (a * r + l * n) / h._$GetParentScaleY$_() : l * n / h._$GetParentScaleY$_() : this._$_y$_ = s;
                }
            } else this._$_x$_ = t, this._$_y$_ = s;
        }
        _$GetXY$_() {
            return [ this._$GetX$_(), this._$GetY$_() ];
        }
        _$OffsetXY$_(t, s) {
            t = +t, s = +s, this._$GetTransformWithParentXOrY$_() ? this._$SetXY$_(this._$GetX$_() + t, this._$GetY$_() + s) : (this._$_x$_ += t, 
            this._$_y$_ += s);
        }
        _$EqualsXY$_(t, s) {
            return this._$GetX$_() === t && this._$GetY$_() === s;
        }
        _$SetZElevation$_(t) {
            if (t = +t, this._$GetTransformWithParentZElevation$_() && (t -= this._$GetParent$_()._$GetZElevation$_()), 
            this._$_zElevation$_ !== t) {
                this._$_zElevation$_ = t, this._$_UpdateZElevation$_();
                const s = this._$GetLayer$_();
                0 !== this._$_zElevation$_ && s._$_SetAnyInstanceZElevated$_(), 
                s._$SetZIndicesChanged$_(this);
            }
        }
        _$_UpdateZElevation$_() {
            if (this._$_UpdateRendererStateGroup$_(), this._$HasChildren$_()) {
                const i = this._$GetChildren$_();
                for (let t = 0, s = i.length; t < s; t++) {
                    const e = i[t];
                    e._$GetTransformWithParentZElevation$_() && e._$_UpdateZElevation$_();
                }
            }
        }
        _$OffsetZElevation$_(t) {
            this._$SetZElevation$_(this._$GetZElevation$_() + t);
        }
        _$GetZElevation$_() {
            return this._$GetTransformWithParentZElevation$_() ? this._$GetParent$_()._$GetZElevation$_() + this._$_zElevation$_ : this._$_zElevation$_;
        }
        _$GetTotalZElevation$_() {
            return this._$GetLayer$_()._$GetZElevation$_() + this._$GetZElevation$_();
        }
        _$SetWidth$_(t) {
            if (t = +t, this._$GetTransformWithParentWidth$_()) {
                const s = this._$GetWidth$_();
                0 === s ? this._$_w$_ = Number.EPSILON : this._$_w$_ *= t / s;
            } else this._$_w$_ = t;
            this._$_MarkSinCosAngleChanged$_();
        }
        _$OffsetWidth$_(t, s) {
            t = +t, !s && this._$GetTransformWithParentWidth$_() ? this._$SetWidth$_(this._$GetWidth$_() + t) : this._$_w$_ += t, 
            this._$_MarkSinCosAngleChanged$_();
        }
        _$GetWidth$_() {
            if (this._$GetTransformWithParentWidth$_()) {
                const t = this._$GetParent$_(), s = t._$GetWidth$_(), i = t._$_GetSceneGraphInfo$_()._$_GetStartWidth$_();
                return i === Number.EPSILON ? (this._$_GetSceneGraphInfo$_()._$_GetStartWidth$_() + s) * this._$_w$_ : s * this._$_w$_;
            }
            return this._$_w$_;
        }
        _$SetHeight$_(t) {
            if (t = +t, this._$GetTransformWithParentHeight$_()) {
                const s = this._$GetHeight$_();
                0 === s ? this._$_h$_ = Number.EPSILON : this._$_h$_ *= t / s;
            } else this._$_h$_ = t;
            this._$_MarkSinCosAngleChanged$_();
        }
        _$OffsetHeight$_(t, s) {
            t = +t, !s && this._$GetTransformWithParentHeight$_() ? this._$SetHeight$_(this._$GetHeight$_() + t) : this._$_h$_ += t, 
            this._$_MarkSinCosAngleChanged$_();
        }
        _$GetHeight$_() {
            if (this._$GetTransformWithParentHeight$_()) {
                const t = this._$GetParent$_(), s = t._$GetHeight$_(), i = t._$_GetSceneGraphInfo$_()._$_GetStartHeight$_();
                return i === Number.EPSILON ? (this._$_GetSceneGraphInfo$_()._$_GetStartHeight$_() + s) * this._$_h$_ : s * this._$_h$_;
            }
            return this._$_h$_;
        }
        _$SetSize$_(t, s) {
            if (t = +t, s = +s, this._$GetTransformWithParentWidth$_()) {
                const i = this._$GetWidth$_();
                0 === i ? this._$_w$_ = Number.EPSILON : this._$_w$_ *= t / i;
            } else this._$_w$_ = t;
            if (this._$GetTransformWithParentHeight$_()) {
                const e = this._$GetHeight$_();
                0 === e ? this._$_h$_ = Number.EPSILON : this._$_h$_ *= s / e;
            } else this._$_h$_ = s;
            this._$_MarkSinCosAngleChanged$_();
        }
        _$GetSize$_() {
            return [ this._$GetWidth$_(), this._$GetHeight$_() ];
        }
        _$GetDepth$_() {
            return this._$_depth$_;
        }
        _$SetDepth$_(t) {
            if (t < 0) throw new RangeError("invalid depth");
            this._$_depth$_ = t;
        }
        _$GetSceneGraphScale$_() {
            if (this._$HasParent$_()) {
                const t = this._$_sceneGraphInfo$_;
                return Math.min(t._$GetParentScaleX$_(), t._$GetParentScaleY$_());
            }
            return 1;
        }
        _$IsRotatable$_() {
            return 0 != (128 & this._$_flags$_);
        }
        _$SetAngle$_(t) {
            t = +t, this._$IsRotatable$_() && (this._$GetTransformWithParentAngle$_() && (t -= this._$GetParent$_()._$GetAngle$_()), 
            t = d._$clampAngle$_(t), this._$_a$_ !== t) && (this._$_a$_ = t, this._$_MarkSinCosAngleChanged$_());
        }
        _$OffsetAngle$_(t) {
            0 !== (t = +t) && this._$IsRotatable$_() && (this._$_a$_ = d._$clampAngle$_(this._$_a$_ + t), 
            this._$_MarkSinCosAngleChanged$_());
        }
        _$_MarkSinCosAngleChanged$_() {
            if (this._$_flags$_ |= 1 << 18, this._$HasChildren$_()) {
                const i = this._$GetChildren$_();
                for (let t = 0, s = i.length; t < s; t++) i[t]._$_MarkSinCosAngleChanged$_();
            }
        }
        _$GetAngle$_() {
            return this._$GetTransformWithParentAngle$_() && this._$IsRotatable$_() ? this._$_MaybeReflectAngleForMirrorFlip$_(d._$clampAngle$_(this._$GetParent$_()._$_GetAngleNoReflect$_() + this._$_a$_)) : this._$_a$_;
        }
        _$_GetAngleNoReflect$_() {
            return this._$GetTransformWithParentAngle$_() && this._$IsRotatable$_() ? d._$clampAngle$_(this._$GetParent$_()._$_GetAngleNoReflect$_() + this._$_a$_) : this._$_a$_;
        }
        _$_MaybeReflectAngleForMirrorFlip$_(t) {
            return this._$GetTransformWithParentWidth$_() && this._$GetTopParent$_()._$GetWidth$_() < 0 && (t = d._$clampAngle$_(d._$angleReflect$_(t, this._$GetTopParent$_()._$GetAngle$_() + Math.PI))), 
            t = this._$GetTransformWithParentHeight$_() && this._$GetTopParent$_()._$GetHeight$_() < 0 ? d._$angleReflect$_(t, this._$GetTopParent$_()._$GetAngle$_()) : t;
        }
        _$_NeedsReflectAngleForMirrorOrFlip$_() {
            const t = this._$GetParent$_();
            return !!(this._$GetTransformWithParentWidth$_() && t._$GetWidth$_() < 0) || !!(this._$GetTransformWithParentHeight$_() && t._$GetHeight$_() < 0);
        }
        _$_NeedsReflectAngleForMirrorAndFlip$_() {
            const t = this._$GetParent$_();
            return !!(this._$GetTransformWithParentWidth$_() && t._$GetWidth$_() < 0 && this._$GetTransformWithParentHeight$_() && t._$GetHeight$_() < 0);
        }
        _$_MaybeUpdateSinCosAngle$_() {
            const t = this._$_flags$_;
            if (0 != (t & 1 << 18)) {
                const s = this._$GetAngle$_();
                this._$_sinA$_ = Math.sin(s), this._$_cosA$_ = Math.cos(s), this._$_flags$_ = -262145 & t;
            }
        }
        _$GetSinAngle$_() {
            return this._$_MaybeUpdateSinCosAngle$_(), this._$_sinA$_;
        }
        _$GetCosAngle$_() {
            return this._$_MaybeUpdateSinCosAngle$_(), this._$_cosA$_;
        }
        _$SetOriginX$_(t) {
            this._$_ox$_ = +t;
        }
        _$OffsetOriginX$_(t) {
            this._$_ox$_ += +t;
        }
        _$GetOriginX$_() {
            return this._$_ox$_;
        }
        _$SetOriginY$_(t) {
            this._$_oy$_ = +t;
        }
        _$OffsetOriginY$_(t) {
            this._$_oy$_ += +t;
        }
        _$GetOriginY$_() {
            return this._$_oy$_;
        }
        _$_SetColor$_(t) {
            this._$_color$_.equals(t) || (this._$_color$_ === i ? (this._$_color$_ = d._$New$_(d._$Color$_, t), 
            this._$_colorPremultiplied$_ = d._$New$_(d._$Color$_, t), this._$_colorPremultiplied$_._$premultiply$_()) : t._$equalsRgba$_(1, 1, 1, 1) ? (this._$_color$_ = i, 
            this._$_colorPremultiplied$_ = i) : (this._$_color$_.set(t), this._$_colorPremultiplied$_.set(t), 
            this._$_colorPremultiplied$_._$premultiply$_()), this._$_UpdateRendererStateGroup$_());
        }
        _$SetOpacity$_(t) {
            if (t = d._$clamp$_(+t, 0, 1), this._$GetTransformWithParentOpacity$_()) {
                if (this._$_GetSceneGraphInfo$_()._$GetOwnOpacity$_() === t) return;
                this._$_GetSceneGraphInfo$_()._$SetOwnOpacity$_(t), t = this._$GetOpacity$_();
            } else if (this._$_color$_.a === t) return;
            this._$_SetColorWithOpacity$_(t);
        }
        _$_SetOpacityOfChildren$_() {
            if (this._$HasChildren$_()) {
                const i = this._$GetChildren$_();
                for (let t = 0, s = i.length; t < s; t++) {
                    const e = i[t];
                    e._$_SetColorWithOpacity$_(e._$GetOpacity$_());
                }
            }
        }
        _$_SetColorWithOpacity$_(t) {
            f._$copyRgb$_(this._$_color$_), f.a = t, this._$_SetColor$_(f), this._$_SetOpacityOfChildren$_();
        }
        _$OffsetOpacity$_(t) {
            this._$GetTransformWithParentOpacity$_() ? this._$SetOpacity$_(this._$_GetSceneGraphInfo$_()._$GetOwnOpacity$_() + t) : this._$SetOpacity$_(this._$GetOpacity$_() + t);
        }
        _$GetOpacity$_() {
            return this._$GetTransformWithParentOpacity$_() ? this._$GetParent$_()._$GetOpacity$_() * this._$_GetSceneGraphInfo$_()._$GetOwnOpacity$_() : this._$_color$_.a;
        }
        _$SetUnpremultipliedColor$_(t) {
            this._$_color$_._$equalsIgnoringAlpha$_(t) || (f._$copyRgb$_(t), f.a = this._$GetOpacity$_(), 
            this._$_SetColor$_(f));
        }
        _$SetUnpremultipliedColorRGB$_(t, s, i) {
            f._$setRgb$_(t, s, i), this._$SetUnpremultipliedColor$_(f);
        }
        _$OffsetUnpremultipliedColorRGB$_(t, s, i) {
            0 === t && 0 === s && 0 === i || (f._$copyRgb$_(this._$_color$_), f.r += t, 
            f.g += s, f.b += i, this._$SetUnpremultipliedColor$_(f));
        }
        _$GetUnpremultipliedColor$_() {
            return this._$_color$_;
        }
        _$GetPremultipliedColor$_() {
            return this._$_colorPremultiplied$_;
        }
        _$GetDestroyWithParent$_() {
            return 0 != (512 & this._$_flags$_);
        }
        _$SetDestroyWithParent$_(t) {
            this._$_SetFlag$_(512, t);
        }
        _$GetTransformWithParentX$_() {
            return 0 != (1024 & this._$_flags$_);
        }
        _$SetTransformWithParentX$_(t) {
            this._$_SetFlag$_(1024, t);
        }
        _$GetTransformWithParentY$_() {
            return 0 != (2048 & this._$_flags$_);
        }
        _$GetTransformWithParentXOrY$_() {
            return 0 != (3072 & this._$_flags$_);
        }
        _$SetTransformWithParentY$_(t) {
            this._$_SetFlag$_(2048, t);
        }
        _$GetTransformWithParentWidth$_() {
            return 0 != (4096 & this._$_flags$_);
        }
        _$SetTransformWithParentWidth$_(t) {
            this._$_SetFlag$_(4096, t);
        }
        _$GetTransformWithParentHeight$_() {
            return 0 != (8192 & this._$_flags$_);
        }
        _$SetTransformWithParentHeight$_(t) {
            this._$_SetFlag$_(8192, t);
        }
        _$GetTransformWithParentAngle$_() {
            return 0 != (16384 & this._$_flags$_);
        }
        _$SetTransformWithParentAngle$_(t) {
            this._$_SetFlag$_(16384, t);
        }
        _$GetTransformWithParentZElevation$_() {
            return 0 != (32768 & this._$_flags$_);
        }
        _$SetTransformWithParentZElevation$_(t) {
            this._$_SetFlag$_(32768, t);
        }
        _$GetTransformWithParentOpacity$_() {
            return 0 != (this._$_flags$_ & 1 << 22);
        }
        _$SetTransformWithParentOpacity$_(t) {
            this._$_SetFlag$_(1 << 22, t);
        }
        _$GetTransformWithParentVisibility$_() {
            return 0 != (this._$_flags$_ & 1 << 23);
        }
        _$SetTransformWithParentVisibility$_(t) {
            this._$_SetFlag$_(1 << 23, t);
        }
        _$_ClearAllSceneGraphFlags$_() {
            this._$_flags$_ &= -12647937;
        }
        _$AddChild$_(t, s) {
            if (t === this) return !1;
            if (t._$HasParent$_()) return !1;
            if (this._$_HasChildRecursive$_(t)) return !1;
            if (this._$_HasAnyParent$_(t)) return !1;
            const i = t._$GetX$_(), e = t._$GetY$_(), h = t._$GetWidth$_(), r = t._$GetHeight$_(), n = t._$GetAngle$_(), o = t._$GetZElevation$_(), a = t._$GetOpacity$_();
            if (t._$_SetParent$_(this), t._$SetTransformWithParentX$_(s._$transformX$_), 
            t._$SetTransformWithParentY$_(s._$transformY$_), t._$SetTransformWithParentWidth$_(s._$transformWidth$_), 
            t._$SetTransformWithParentHeight$_(s._$transformHeight$_), t._$SetTransformWithParentAngle$_(s._$transformAngle$_), 
            t._$SetTransformWithParentZElevation$_(s._$transformZElevation$_), t._$SetTransformWithParentOpacity$_(s._$transformOpacity$_), 
            t._$SetTransformWithParentVisibility$_(s._$transformVisibility$_), t._$SetDestroyWithParent$_(s._$destroyWithParent$_), 
            s._$transformX$_ && (t._$_x$_ = i - this._$GetX$_(), s._$transformWidth$_)) {
                const l = this._$GetWidth$_() / this._$_sceneGraphInfo$_._$_GetStartWidth$_();
                0 != l && (t._$_x$_ /= l);
            }
            if (s._$transformY$_ && (t._$_y$_ = e - this._$GetY$_(), s._$transformHeight$_)) {
                const u = this._$GetHeight$_() / this._$_sceneGraphInfo$_._$_GetStartHeight$_();
                0 != u && (t._$_y$_ /= u);
            }
            if (s._$transformWidth$_) {
                const c = this._$GetWidth$_();
                0 === c || c === Number.EPSILON ? (t._$_w$_ = 1, t._$_sceneGraphInfo$_._$SetStartScaleX$_(1)) : (t._$_w$_ = h / this._$GetWidth$_(), 
                t._$_sceneGraphInfo$_._$SetStartScaleX$_(t._$_w$_));
            }
            if (s._$transformHeight$_) {
                const f = this._$GetHeight$_();
                0 === f || f === Number.EPSILON ? (t._$_h$_ = 1, t._$_sceneGraphInfo$_._$SetStartScaleY$_(1)) : (t._$_h$_ = r / this._$GetHeight$_(), 
                t._$_sceneGraphInfo$_._$SetStartScaleY$_(t._$_h$_));
            }
            return s._$transformAngle$_ && (t._$_a$_ = n - this._$GetAngle$_()), 
            s._$transformZElevation$_ && (t._$_zElevation$_ = o - this._$GetZElevation$_()), 
            s._$transformOpacity$_ && t._$_sceneGraphInfo$_._$SetOwnOpacity$_(a), 
            s._$transformVisibility$_ && t._$SetVisible$_(this._$IsVisible$_()), 
            this._$_AddChildToSceneGraphInfo$_(t), this._$SetBboxChanged$_(), this._$_SetOpacityOfChildren$_(), 
            !0;
        }
        _$RemoveChild$_(t) {
            if (t._$GetParent$_() === this) {
                const s = t._$GetX$_(), i = t._$GetY$_(), e = t._$GetWidth$_(), h = t._$GetHeight$_(), r = t._$GetAngle$_(), n = t._$GetZElevation$_(), o = t._$GetOpacity$_();
                t._$_SetParent$_(null), t._$_ClearAllSceneGraphFlags$_(), t._$SetXY$_(s, i), 
                t._$SetSize$_(e, h), t._$SetAngle$_(r), t._$SetZElevation$_(n), 
                t._$SetOpacity$_(o), this._$_RemoveChildFromSceneGraphInfo$_(t), 
                this._$SetBboxChanged$_();
            }
        }
        _$GetTmpHierarchyPosition$_() {
            return this._$_tmpHierarchyPosition$_;
        }
        _$_ResetAllSceneGraphState$_() {
            this._$_BuildTmpSceneGraphData$_();
            const t = [ ...this.children() ];
            for (const i of t) this._$RemoveChild$_(i);
            const s = this._$GetParent$_();
            s && s._$RemoveChild$_(this), this._$_ClearAllSceneGraphFlags$_();
        }
        _$_BuildTmpSceneGraphData$_() {
            if (this._$_SetTmpHierarchyPosition$_(), !this._$_tmpSceneGraphChildren$_) {
                const s = [ ...this.children() ];
                s.length && (this._$_tmpSceneGraphChildren$_ = [], this._$_tmpSceneGraphChildrenIndexes$_ = new WeakMap());
                let t = 0;
                for (const i of s) {
                    const e = i._$GetInstance$_();
                    this._$_tmpSceneGraphChildren$_.push(e), this._$_tmpSceneGraphChildrenIndexes$_.set(e, t), 
                    t++;
                }
            }
            const t = this._$GetParent$_();
            t && t._$_BuildTmpSceneGraphData$_();
        }
        _$_SetTmpHierarchyPosition$_() {
            if (-1 === this._$_tmpHierarchyPosition$_) {
                const t = [ ...this._$parents$_() ];
                this._$_tmpHierarchyPosition$_ = t.length;
                for (const i of t) i._$_SetTmpHierarchyPosition$_();
                const s = [ ...this.children() ];
                for (const e of s) e._$_SetTmpHierarchyPosition$_();
            }
        }
        _$_ReleaseTmpSceneGraphInfo$_() {
            this._$_tmpSceneGraphChildren$_ && (this._$_tmpSceneGraphChildren$_.length = 0), 
            this._$_tmpSceneGraphChildren$_ = null, this._$_tmpSceneGraphChildrenIndexes$_ = null;
            const t = this._$GetParent$_();
            t && t._$_ReleaseTmpSceneGraphInfo$_(), this._$_tmpHierarchyPosition$_ = -1;
        }
        _$HasParent$_() {
            return null !== this._$GetParent$_();
        }
        _$GetParent$_() {
            const t = this._$_sceneGraphInfo$_;
            return null !== t ? t._$GetParent$_() : null;
        }
        _$GetTopParent$_() {
            let t = this;
            for (;t._$HasParent$_(); ) t = t._$GetParent$_();
            return t;
        }
        *_$parents$_() {
            let t = this._$GetParent$_();
            for (;t; ) yield t, t = t._$GetParent$_();
        }
        _$HasChild$_(t) {
            return this._$GetChildren$_().includes(t);
        }
        _$HasChildren$_() {
            const t = this._$_sceneGraphInfo$_;
            return null !== t && t._$HasChildren$_();
        }
        _$GetChildren$_() {
            const t = this._$_sceneGraphInfo$_;
            return null !== t ? t._$GetChildren$_() : e;
        }
        children() {
            return this._$GetChildren$_();
        }
        *_$allChildren$_() {
            for (const t of this.children()) yield t, yield* t._$allChildren$_();
        }
        _$GetChildCount$_() {
            return this._$GetChildren$_().length;
        }
        _$GetAllChildCount$_() {
            return [ ...this._$allChildren$_() ].length;
        }
        _$GetChildAt$_(t) {
            const s = this._$GetChildren$_();
            return (t = Math.floor(+t)) < 0 || t >= s.length ? null : s[t];
        }
        _$GetChildIndex$_(s) {
            if (s) {
                const i = this._$GetChildren$_();
                if (i) for (let t = 0; t < i.length; t++) if (s === i[t]) return t;
            }
            return NaN;
        }
        _$_CreateSceneGraphInfo$_(t) {
            this._$_sceneGraphInfo$_ || (this._$_sceneGraphInfo$_ = d._$New$_(d._$SceneGraphInfo$_, this)), 
            t && this._$_sceneGraphInfo$_._$SetParent$_(t);
        }
        _$_GetSceneGraphInfo$_() {
            return this._$_sceneGraphInfo$_;
        }
        _$_ReleaseSceneGraphInfo$_() {
            this._$_sceneGraphInfo$_ && (this._$_sceneGraphInfo$_._$Release$_(), 
            this._$_sceneGraphInfo$_ = null);
        }
        _$_SetParent$_(t) {
            t ? (t._$_CreateSceneGraphInfo$_(null), this._$_CreateSceneGraphInfo$_(t)) : (this._$_sceneGraphInfo$_ && this._$_sceneGraphInfo$_._$SetParent$_(null), 
            this._$HasChildren$_() || this._$_ReleaseSceneGraphInfo$_());
        }
        _$_HasAnyParent$_(t) {
            if (!this._$HasParent$_()) return !1;
            const s = this._$GetParent$_();
            return s === t || s._$_HasAnyParent$_(t);
        }
        _$_HasChildRecursive$_(t) {
            if (this._$HasChild$_(t)) return !0;
            for (const s of this._$GetChildren$_()) if (s._$_HasChildRecursive$_(t)) return !0;
            return !1;
        }
        _$_AddChildToSceneGraphInfo$_(t) {
            this._$_sceneGraphInfo$_._$GetChildren$_().push(t);
        }
        _$_RemoveChildFromSceneGraphInfo$_(t) {
            const s = this._$_sceneGraphInfo$_._$GetChildren$_(), i = s.indexOf(t);
            -1 !== i && s.splice(i, 1), 0 !== s.length || this._$HasParent$_() || this._$_ReleaseSceneGraphInfo$_(), 
            t._$HasChildren$_() || t._$_ReleaseSceneGraphInfo$_();
        }
        _$GetSceneGraphChildrenExportData$_() {
            const t = g.get(this);
            return t ? t._$childrenData$_ : null;
        }
        _$GetSceneGraphZIndexExportData$_() {
            const t = g.get(this);
            return t ? t._$zIndexData$_ : NaN;
        }
        _$GetSceneGraphZIndex$_() {
            const t = a.get(this);
            return d._$IsFiniteNumber$_(t) ? t : NaN;
        }
        _$SetSceneGraphZIndex$_(t) {
            a.set(this, t);
        }
        _$SetUsePointsShaderProgram$_() {
            this._$_SetFlag$_(1 << 19, !0), this._$_UpdateRendererStateGroup$_();
        }
        _$_UpdateRendererStateGroup$_() {
            if (m) {
                const s = this._$_runtime$_._$GetRenderer$_();
                this._$_stateGroup$_ && s._$ReleaseStateGroup$_(this._$_stateGroup$_);
                let t;
                t = 0 != (this._$_flags$_ & 1 << 19) ? s._$GetPointsRenderingProgram$_() || "<point>" : s._$GetTextureFillShaderProgram$_() || "<default>", 
                this._$_stateGroup$_ = s._$AcquireStateGroup$_(t, this._$GetBlendMode$_(), this._$_colorPremultiplied$_, this._$GetZElevation$_());
            }
        }
        _$GetRendererStateGroup$_() {
            return this._$_stateGroup$_;
        }
        _$HasDefaultColor$_() {
            return this._$_color$_ === i;
        }
        _$SetBlendMode$_(t) {
            if ((t |= 0) < 0 || 31 < t) throw new RangeError("invalid blend mode");
            this._$GetBlendMode$_() !== t && (this._$_flags$_ = this._$_flags$_ & ~(31 << 26) | t << 26, 
            this._$_UpdateRendererStateGroup$_());
        }
        _$GetBlendMode$_() {
            return (this._$_flags$_ & 31 << 26) >> 26;
        }
        _$_SetLayer$_(t, s) {
            const i = s && this._$_layer$_ !== t;
            i && this._$_RemoveFromRenderCells$_(), this._$_objectClass$_._$_OnWorldInstanceLayerChanged$_(this, this._$_layer$_, t), 
            this._$_layer$_ = t, i && this._$_UpdateRenderCell$_(), 0 !== this._$GetZElevation$_() && this._$_layer$_._$_SetAnyInstanceZElevated$_();
        }
        _$GetLayer$_() {
            return this._$_layer$_;
        }
        _$GetLayout$_() {
            return this._$GetLayer$_()._$GetLayout$_();
        }
        _$_SetZIndex$_(t) {
            this._$_zIndex$_ = 0 | t;
        }
        _$GetZIndex$_() {
            return this._$_layer$_._$_UpdateZIndices$_(), this._$_zIndex$_;
        }
        _$_SetHTMLZIndex$_(t) {
            this._$_htmlZIndex$_ = 0 | t;
        }
        _$GetHTMLZIndex$_() {
            return this._$_layer$_._$_UpdateHTMLZIndices$_(), this._$_htmlZIndex$_;
        }
        _$_GetLastCachedZIndex$_() {
            return this._$_zIndex$_;
        }
        _$_SetFlag$_(t, s) {
            s ? this._$_flags$_ |= t : this._$_flags$_ &= ~t;
        }
        _$IsVisible$_() {
            return 0 != (1 & this._$_flags$_);
        }
        _$SetVisible$_(t) {
            if (this._$_SetFlag$_(1, t), this._$HasChildren$_()) for (const s of this._$GetChildren$_()) s._$GetTransformWithParentVisibility$_() && s._$SetVisible$_(t);
        }
        _$IsCollisionEnabled$_() {
            return 0 != (8 & this._$_flags$_);
        }
        _$SetCollisionEnabled$_(t) {
            t = !!t, this._$IsCollisionEnabled$_() !== t && (this._$_SetFlag$_(8, t), 
            t ? this._$SetBboxChanged$_() : this._$_RemoveFromCollisionCells$_());
        }
        _$SetSolidCollisionFilter$_(t, s) {
            if (this._$_SetFlag$_(32, t), this._$_solidFilterTags$_ && this._$_solidFilterTags$_.clear(), 
            s.trim()) {
                this._$_solidFilterTags$_ || (this._$_solidFilterTags$_ = new Set());
                for (const i of s.split(" ")) i && this._$_solidFilterTags$_.add(i.toLowerCase());
            } else this._$_solidFilterTags$_ = null;
        }
        _$IsSolidCollisionAllowed$_(t) {
            const s = 0 != (32 & this._$_flags$_), i = this._$_solidFilterTags$_;
            if (t && i) for (const e of i) if (t.has(e)) return s;
            return !s;
        }
        _$SetBboxChanged$_() {
            if (this._$_flags$_ |= 65554, this._$_objectClass$_._$_SetAnyCollisionCellChanged$_(!0), 
            this._$_runtime$_._$UpdateRender$_(), this._$_layer$_._$UsesRenderCells$_() && (this._$CalculateBbox$_(this._$_boundingBox$_, this._$_boundingQuad$_, !0), 
            this._$_flags$_ &= -3, this._$_UpdateRenderCell$_()), 0 != (4 & this._$_flags$_) && this._$_inst$_._$Dispatcher$_().dispatchEvent(s), 
            null !== this._$_sceneGraphInfo$_) {
                const i = this._$_sceneGraphInfo$_._$GetChildren$_();
                for (let t = 0, s = i.length; t < s; ++t) i[t]._$SetBboxChanged$_();
            }
        }
        _$CalculateBbox$_(t, s, i) {
            const e = this._$GetX$_(), h = this._$GetY$_(), r = this._$GetWidth$_(), n = this._$GetHeight$_(), o = this._$GetAngle$_();
            t._$setWH$_(e - this._$_ox$_ * r, h - this._$_oy$_ * n, r, n), i && this._$HasMesh$_() && this._$_ExpandBboxForMesh$_(t), 
            0 === o ? s._$setFromRect$_(t) : (t.offset(-e, -h), s._$setFromRotatedRectPrecalc$_(t, this._$GetSinAngle$_(), this._$GetCosAngle$_()), 
            s.offset(e, h), s._$getBoundingBox$_(t)), t.normalize();
        }
        _$_UpdateBbox$_() {
            const t = this._$_flags$_;
            0 != (2 & t) && (this._$CalculateBbox$_(this._$_boundingBox$_, this._$_boundingQuad$_, !0), 
            this._$_flags$_ = -3 & t);
        }
        _$GetBoundingBox$_() {
            return this._$_UpdateBbox$_(), this._$_boundingBox$_;
        }
        _$GetBoundingQuad$_() {
            return this._$_UpdateBbox$_(), this._$_boundingQuad$_;
        }
        _$PixelRoundQuad$_(t) {
            const s = this._$GetX$_(), i = this._$GetY$_(), e = Math.round(s) - s, h = Math.round(i) - i;
            return 0 == e && 0 == h ? t : (n._$copy$_(t), n.offset(e, h), n);
        }
        _$OverwriteBoundingBox$_(t) {
            this._$_boundingBox$_._$copy$_(t), this._$_boundingQuad$_._$setFromRect$_(this._$_boundingBox$_), 
            this._$_flags$_ &= -3, this._$_UpdateCollisionCell$_(), this._$_UpdateRenderCell$_();
        }
        _$SetBboxChangeEventEnabled$_(t) {
            this._$_SetFlag$_(4, t);
        }
        _$IsBboxChangeEventEnabled$_() {
            return 0 != (4 & this._$_flags$_);
        }
        _$IsInViewport$_(t, s, i) {
            return s && 0 !== this._$GetDepth$_() ? this._$IsInViewport3D$_(this._$GetLayer$_()._$_GetViewFrustum$_()) : 0 === this._$GetZElevation$_() || i ? t._$intersectsRect$_(this._$GetBoundingBox$_()) : this._$_IsInViewport_ZElevated$_();
        }
        _$_IsInViewport_ZElevated$_() {
            const t = this._$GetLayer$_(), s = this._$GetTotalZElevation$_();
            return !(s >= t._$Get2DCameraZ$_()) && (t._$GetViewportForZ$_(s, r), 
            r._$intersectsRect$_(this._$GetBoundingBox$_()));
        }
        _$IsInViewport3D$_(t) {
            const s = this._$GetBoundingBox$_(), i = s._$getLeft$_(), e = s._$getRight$_(), h = s._$getTop$_(), r = s._$getBottom$_(), n = this._$GetTotalZElevation$_(), o = n + this._$GetDepth$_();
            return t._$ContainsAABB$_(i, h, n, e, r, o);
        }
        _$IsInViewport2$_() {
            const t = this._$GetLayer$_();
            if (t._$Has3DCamera$_()) return this._$IsInViewport3D$_(t._$_GetViewFrustum$_());
            {
                const s = t._$GetLayout$_();
                return this._$IsInViewport$_(t._$GetViewport$_(), s._$HasVanishingPointOutsideViewport$_(), s._$IsOrthographicProjection$_());
            }
        }
        _$_SetDrawBackFaceOnly$_(t) {
            this._$_SetFlag$_(1 << 20, t);
        }
        _$_SetDrawNonBackFacesOnly$_(t) {
            this._$_SetFlag$_(1 << 21, t);
        }
        _$IsDrawBackFaceOnly$_() {
            return 0 != (this._$_flags$_ & 1 << 20);
        }
        _$IsDrawNonBackFacesOnly$_() {
            return 0 != (this._$_flags$_ & 1 << 21);
        }
        _$SetSourceCollisionPoly$_(t) {
            this._$_sourceCollisionPoly$_ = t, this._$_DiscardTransformedCollisionPoly$_(), 
            this._$HasMesh$_() && (this._$_meshInfo$_._$meshPoly$_ = null);
        }
        _$GetSourceCollisionPoly$_() {
            return this._$_sourceCollisionPoly$_;
        }
        _$HasOwnCollisionPoly$_() {
            return null !== this._$_sourceCollisionPoly$_ || this._$HasMesh$_();
        }
        _$GetTransformedCollisionPoly$_() {
            return this._$_GetCustomTransformedCollisionPolyPrecalc$_(this._$GetWidth$_(), this._$GetHeight$_(), this._$GetAngle$_(), this._$GetSinAngle$_(), this._$GetCosAngle$_());
        }
        _$GetCustomTransformedCollisionPoly$_(t, s, i) {
            let e = 0, h = 1;
            return 0 !== i && (e = Math.sin(i), h = Math.cos(i)), this._$_GetCustomTransformedCollisionPolyPrecalc$_(t, s, i, e, h);
        }
        _$_GetCustomTransformedCollisionPolyPrecalc$_(h, r, t, n, o) {
            let s = this._$_transformedPolyInfo$_;
            null === s && (s = {
                _$poly$_: d._$New$_(d._$CollisionPoly$_),
                width: NaN,
                height: NaN,
                angle: NaN
            }, this._$_transformedPolyInfo$_ = s);
            const a = s._$poly$_;
            if (s.width !== h || s.height !== r || s.angle !== t) {
                const l = this._$_sourceCollisionPoly$_;
                if (this._$HasMesh$_()) {
                    let t = this._$GetOriginX$_(), s = this._$GetOriginY$_(), i = this._$GetSourceMesh$_(), e = this._$_meshInfo$_._$meshPoly$_;
                    e || (l ? (u._$copy$_(l), u.offset(t, s)) : u._$setDefaultPoints$_(), 
                    e = i._$InsertPolyMeshVertices$_(u), this._$_meshInfo$_._$meshPoly$_ = e), 
                    i._$TransformCollisionPoly$_(e, a), a.offset(-t, -s), a._$transformPrecalc$_(h, r, n, o);
                } else l ? (a._$copy$_(l), a._$transformPrecalc$_(h, r, n, o)) : a._$setFromQuad$_(this._$GetBoundingQuad$_(), -this._$GetX$_(), -this._$GetY$_());
                s.width = h, s.height = r, s.angle = t;
            }
            return a;
        }
        _$_DiscardTransformedCollisionPoly$_() {
            this._$SetPhysicsBodyChanged$_(!0);
            const t = this._$_transformedPolyInfo$_;
            null !== t && (t.width = NaN);
        }
        _$CreateMesh$_(t, s) {
            if (t = Math.floor(t), s = Math.floor(s), !this._$GetInstance$_()._$GetPlugin$_()._$SupportsMesh$_()) throw new Error("object does not support mesh");
            this._$ReleaseMesh$_(), this._$_meshInfo$_ = {
                _$sourceMesh$_: d._$New$_(d._$Gfx$_._$Mesh$_, t, s),
                _$transformedMesh$_: d._$New$_(d._$Gfx$_._$Mesh$_, t, s),
                _$meshPoly$_: null
            };
        }
        _$HasMesh$_() {
            return null !== this._$_meshInfo$_;
        }
        _$GetSourceMesh$_() {
            if (this._$HasMesh$_()) return this._$_meshInfo$_._$sourceMesh$_;
            throw new Error("no mesh");
        }
        _$GetTransformedMesh$_() {
            if (this._$HasMesh$_()) return this._$_meshInfo$_._$transformedMesh$_;
            throw new Error("no mesh");
        }
        _$SetMeshChanged$_(t) {
            this._$_SetFlag$_(65536, t);
        }
        _$IsMeshChanged$_() {
            return 0 != (65536 & this._$_flags$_);
        }
        _$SetPhysicsBodyChanged$_(t) {
            this._$_SetFlag$_(1 << 17, t);
        }
        _$IsPhysicsBodyChanged$_() {
            return 0 != (this._$_flags$_ & 1 << 17);
        }
        _$_ExpandBboxForMesh$_(t) {
            const s = this._$_meshInfo$_._$sourceMesh$_, i = Math.min(s._$GetMinX$_(), 0), e = Math.min(s._$GetMinY$_(), 0), h = Math.max(s._$GetMaxX$_(), 1), r = Math.max(s._$GetMaxY$_(), 1), n = t.width(), o = t.height();
            t.offsetLeft(i * n), t.offsetTop(e * o), t._$offsetRight$_((h - 1) * n), 
            t._$offsetBottom$_((r - 1) * o), this._$_depth$_ = s._$GetMaxZ$_();
        }
        _$ReleaseMesh$_() {
            this._$_meshInfo$_ && (this._$_meshInfo$_._$sourceMesh$_._$Release$_(), 
            this._$_meshInfo$_._$transformedMesh$_._$Release$_(), this._$_meshInfo$_ = null, 
            this._$_DiscardTransformedCollisionPoly$_());
        }
        _$SetMeshPoint$_(t, s, i) {
            t = Math.floor(t), s = Math.floor(s);
            const e = i.mode || "absolute";
            if (!p.has(e)) throw new Error("invalid mode");
            let h = "relative" === e, r = i.x, n = i.y, o = i._$zElevation$_, a = "number" == typeof i.u ? i.u : h ? 0 : -1, l = "number" == typeof i.v ? i.v : h ? 0 : -1;
            if (!this._$HasMesh$_()) return !1;
            const u = this._$GetSourceMesh$_(), c = u._$GetMeshPointAt$_(t, s);
            if (null === c) return !1;
            let f = !1;
            return "number" == typeof o && c._$GetZElevation$_() !== o && (c._$SetZElevation$_(o), 
            f = !0), h && (r += t / (u._$GetHSize$_() - 1), n += s / (u._$GetVSize$_() - 1)), 
            a = -1 !== a || h ? (h && (a += t / (u._$GetHSize$_() - 1)), d._$clamp$_(a, 0, 1)) : c._$GetU$_(), 
            l = -1 !== l || h ? (h && (l += s / (u._$GetVSize$_() - 1)), d._$clamp$_(l, 0, 1)) : c._$GetV$_(), 
            c._$GetX$_() === r && c._$GetY$_() === n && c._$GetU$_() === a && c._$GetV$_() === l ? f : (c._$SetX$_(r), 
            c._$SetY$_(n), c._$SetU$_(a), c._$SetV$_(l), this._$_DiscardTransformedCollisionPoly$_(), 
            !0);
        }
        _$HasTilemap$_() {
            return this._$_inst$_._$HasTilemap$_();
        }
        _$ContainsPoint$_(t, s) {
            return !!this._$GetBoundingBox$_()._$containsPoint$_(t, s) && !!this._$GetBoundingQuad$_()._$containsPoint$_(t, s) && (this._$HasTilemap$_() ? this._$_inst$_._$GetSdkInstance$_()._$TestPointOverlapTile$_(t, s) : !this._$HasOwnCollisionPoly$_() || this._$GetTransformedCollisionPoly$_()._$containsPoint$_(t - this._$GetX$_(), s - this._$GetY$_()));
        }
        _$_IsCollisionCellChanged$_() {
            return 0 != (16 & this._$_flags$_);
        }
        _$_UpdateCollisionCell$_() {
            if (this._$_IsCollisionCellChanged$_() && this._$IsCollisionEnabled$_() && 0 == (256 & this._$_flags$_)) {
                const t = this._$GetBoundingBox$_(), s = this._$_objectClass$_._$_GetCollisionCellGrid$_(), i = this._$_collisionCells$_;
                if (r.set(s._$XToCell$_(t._$getLeft$_()), s._$YToCell$_(t._$getTop$_()), s._$XToCell$_(t._$getRight$_()), s._$YToCell$_(t._$getBottom$_())), 
                !i.equals(r)) {
                    const e = this._$_inst$_;
                    i === h ? (s._$Update$_(e, null, r), this._$_collisionCells$_ = d._$New$_(d.Rect, r)) : (s._$Update$_(e, i, r), 
                    i._$copy$_(r)), this._$_flags$_ &= -17;
                }
            }
        }
        _$_SetCollisionCellChanged$_() {
            this._$_flags$_ |= 16;
        }
        _$_RemoveFromCollisionCells$_() {
            const t = this._$_collisionCells$_;
            t !== h && (this._$_objectClass$_._$_GetCollisionCellGrid$_()._$Update$_(this._$_inst$_, t, null), 
            this._$_collisionCells$_ = h);
        }
        _$_UpdateRenderCell$_() {
            const t = this._$GetLayer$_();
            if (t._$UsesRenderCells$_() && 0 == (256 & this._$_flags$_)) {
                const s = t._$GetRenderGrid$_(), i = this._$GetBoundingBox$_(), e = this._$_renderCells$_;
                if (r.set(s._$XToCell$_(i._$getLeft$_()), s._$YToCell$_(i._$getTop$_()), s._$XToCell$_(i._$getRight$_()), s._$YToCell$_(i._$getBottom$_())), 
                !e.equals(r)) {
                    const h = this._$_inst$_;
                    e === o ? (s._$Update$_(h, null, r), this._$_renderCells$_ = d._$New$_(d.Rect, r)) : (s._$Update$_(h, e, r), 
                    e._$copy$_(r)), t._$SetRenderListStale$_();
                }
            }
        }
        _$_RemoveFromRenderCells$_() {
            const t = this._$_renderCells$_;
            t !== o && (this._$GetLayer$_()._$GetRenderGrid$_()._$Update$_(this._$_inst$_, t, null), 
            this._$_renderCells$_ = o);
        }
        _$GetRenderCellRange$_() {
            return this._$_renderCells$_;
        }
        _$ZOrderMoveToTop$_() {
            const t = this._$_inst$_, s = this._$_layer$_, i = s._$_GetInstances$_();
            i.length && i.at(-1) === t || (s._$_RemoveInstance$_(t, !1), s._$_AddInstance$_(t, !1), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$ZOrderMoveToBottom$_() {
            const t = this._$_inst$_, s = this._$_layer$_, i = s._$_GetInstances$_();
            i.length && i[0] === t || (s._$_RemoveInstance$_(t, !1), s._$_PrependInstance$_(t, !1), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$ZOrderMoveToLayer$_(t) {
            const s = this._$_inst$_, i = this._$_layer$_;
            if (i._$GetLayout$_() !== t._$GetLayout$_()) throw new Error("layer from different layout");
            t !== i && (i._$_RemoveInstance$_(s, !0), this._$_SetLayer$_(t), t._$_AddInstance$_(s, !0), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$ZOrderMoveAdjacentToInstance$_(t, s) {
            let i = this._$_inst$_, e = !1, h = this._$_layer$_;
            if (t._$GetUID$_() !== i._$GetUID$_()) {
                const r = t._$GetWorldInfo$_();
                if (!r) throw new Error("expected world instance");
                const n = r._$GetLayer$_(), o = (h._$GetIndex$_() !== n._$GetIndex$_() && (h._$_RemoveInstance$_(i, !0), 
                this._$_SetLayer$_(n), n._$_AddInstance$_(i, !0), e = !0), n._$MoveInstanceAdjacent$_(i, t, !!s));
                (e || o) && this._$_runtime$_._$UpdateRender$_();
            }
        }
        _$GetInstanceEffectList$_() {
            return this._$_instanceEffectList$_;
        }
        _$_SetHasAnyActiveEffect$_(t) {
            this._$_SetFlag$_(64, t);
        }
        _$HasAnyActiveEffect$_() {
            return 0 != (64 & this._$_flags$_);
        }
        _$_SaveToJson$_(t, s = null) {
            const i = {
                x: this._$GetX$_(),
                y: this._$GetY$_(),
                w: this._$GetWidth$_(),
                h: this._$GetHeight$_(),
                l: this._$GetLayer$_()._$GetSID$_(),
                zi: this._$GetZIndex$_()
            }, e = (0 !== this._$GetZElevation$_() && (i.ze = this._$GetZElevation$_()), 
            0 !== this._$GetAngle$_() && (i.a = this._$_GetAngleNoReflect$_()), 
            this._$HasDefaultColor$_() || (i.c = this._$_color$_.toJSON()), .5 !== this._$GetOriginX$_() && (i.oX = this._$GetOriginX$_()), 
            .5 !== this._$GetOriginY$_() && (i.oY = this._$GetOriginY$_()), 0 !== this._$GetBlendMode$_() && (i.bm = this._$GetBlendMode$_()), 
            this._$IsVisible$_() || (i.v = this._$IsVisible$_()), this._$IsCollisionEnabled$_() || (i.ce = this._$IsCollisionEnabled$_()), 
            this._$IsBboxChangeEventEnabled$_() && (i.be = this._$IsBboxChangeEventEnabled$_()), 
            this._$_instanceEffectList$_ && (i.fx = this._$_instanceEffectList$_._$_SaveToJson$_()), 
            0 != (32 & this._$_flags$_));
            return e && (i.sfi = e), this._$_solidFilterTags$_ && (i.sft = [ ...this._$_solidFilterTags$_ ].join(" ")), 
            this._$_sceneGraphInfo$_ && "visual-state" !== t && (i.sgi = this._$_sceneGraphInfo$_._$_SaveToJson$_(t, s), 
            g.has(this)) && (i.sgcd = g.get(this)._$childrenData$_, i.sgzid = g.get(this)._$zIndexData$_), 
            this._$HasMesh$_() && (i.mesh = this._$GetSourceMesh$_()._$SaveToJson$_()), 
            i;
        }
        _$_SaveSceneGraphPropertiesToJson$_() {
            return {
                x: this._$_x$_,
                y: this._$_y$_,
                z: this._$_zElevation$_,
                w: this._$_w$_,
                h: this._$_h$_,
                a: this._$_a$_,
                sgi: this._$_GetSceneGraphInfo$_() ? this._$_GetSceneGraphInfo$_()._$_SaveToJsonProperties$_() : null
            };
        }
        _$_LoadSceneGraphPropertiesFromJson$_(t) {
            t && (this._$_x$_ = t.x, this._$_y$_ = t.y, this._$_zElevation$_ = t.z, 
            this._$_w$_ = t.w, this._$_h$_ = t.h, this._$_a$_ = t.a, t.sgi && this._$_GetSceneGraphInfo$_() && this._$_GetSceneGraphInfo$_()._$_LoadFromJson$_(t.sgi), 
            this._$_MarkSinCosAngleChanged$_(), this._$SetBboxChanged$_());
        }
        _$_SetupSceneGraphConnectionsOnChangeOfLayout$_() {
            this._$_ReleaseTmpSceneGraphInfo$_(), this._$_ResetAllSceneGraphState$_(), 
            this._$_CreateSceneGraphInfo$_(null), this._$_sceneGraphInfo$_ && this._$_sceneGraphInfo$_._$_SetTmpSceneGraphChildren$_(this._$_tmpSceneGraphChildren$_, this._$_tmpSceneGraphChildrenIndexes$_);
        }
        _$_OnBeforeLoad$_(t) {
            "visual-state" !== t && this._$_ResetAllSceneGraphState$_();
        }
        _$_OnAfterLoad$_(t, s = "full", i = null) {
            t.hasOwnProperty("sgi") && "visual-state" !== s && 0 == (256 & this._$_flags$_) && this._$_sceneGraphInfo$_._$_OnAfterLoad$_(t.sgi, i);
        }
        _$_OnAfterLoad2$_(t, s = "full", i) {
            t.hasOwnProperty("sgi") && "visual-state" !== s && 0 == (256 & this._$_flags$_) && (this._$_sceneGraphInfo$_._$_SetTmpSceneGraphChildren$_(null, null), 
            this._$_ReleaseTmpSceneGraphInfo$_(), this._$SetBboxChanged$_());
        }
        _$_LoadFromJson$_(t, s) {
            if (m = !1, this._$SetX$_(t.x), this._$SetY$_(t.y), this._$SetWidth$_(t.w), 
            this._$SetHeight$_(t.h), this._$_SetZIndex$_(t.zi), this._$SetZElevation$_(t.hasOwnProperty("ze") ? t.ze : 0), 
            this._$SetAngle$_(t.hasOwnProperty("a") ? t.a : 0), t.hasOwnProperty("c") ? f._$setFromJSON$_(t.c) : t.hasOwnProperty("o") ? (f._$copyRgb$_(this._$_color$_), 
            f.a = t.o) : f._$setRgba$_(1, 1, 1, 1), this._$_SetColor$_(f), this._$SetOriginX$_(t.hasOwnProperty("oX") ? t.oX : .5), 
            this._$SetOriginY$_(t.hasOwnProperty("oY") ? t.oY : .5), this._$SetBlendMode$_(t.hasOwnProperty("bm") ? t.bm : 0), 
            this._$SetVisible$_(!t.hasOwnProperty("v") || t.v), this._$SetCollisionEnabled$_(!t.hasOwnProperty("ce") || t.ce), 
            this._$SetBboxChangeEventEnabled$_(!!t.hasOwnProperty("be") && t.be), 
            this._$SetSolidCollisionFilter$_(!!t.hasOwnProperty("sfi") && t.sfi, t.hasOwnProperty("sft") ? t.sft : ""), 
            this._$_instanceEffectList$_ && t.hasOwnProperty("fx") && this._$_instanceEffectList$_._$_LoadFromJson$_(t.fx), 
            !t.hasOwnProperty("sgi") && "visual-state" !== s && this._$_tmpSceneGraphChildren$_) for (const i of this._$_tmpSceneGraphChildren$_) i._$IsDestroyed$_() || this._$_runtime$_._$DestroyInstance$_(i);
            if (t.hasOwnProperty("sgi") && "visual-state" !== s) {
                this._$_CreateSceneGraphInfo$_(null);
                const e = this._$_sceneGraphInfo$_, h = t.sgi;
                e._$_LoadFromJson$_(h), e._$_SetTmpSceneGraphChildren$_(this._$_tmpSceneGraphChildren$_, this._$_tmpSceneGraphChildrenIndexes$_), 
                t.sgcd && d._$IsFiniteNumber$_(t.sgzid) && g.set(this, {
                    _$childrenData$_: t.sgcd,
                    _$zIndexData$_: t.sgzid
                });
            }
            if (t.hasOwnProperty("mesh")) {
                const r = t.mesh;
                this._$CreateMesh$_(r.cols, r.rows), this._$GetSourceMesh$_()._$LoadFromJson$_(r);
            } else this._$ReleaseMesh$_();
            this._$SetBboxChanged$_(), m = !0, this._$_UpdateRendererStateGroup$_(), 
            "visual-state" !== s && this._$_runtime$_._$AddInstanceNeedingAfterLoad$_(this._$GetInstance$_(), t);
        }
    };
}

{
    const Fa = self._$C3$_;
    Fa._$BehaviorType$_ = class extends Fa._$DefendedBase$_ {
        constructor(t, s) {
            super();
            const i = t._$GetRuntime$_(), e = i._$GetObjectReference$_(s[1]), h = (i._$GetAddonManager$_()._$_DelayCreateBehavior$_(e), 
            this._$_runtime$_ = i, this._$_objectClass$_ = t, this._$_behavior$_ = Fa._$AddonManager$_._$GetBehaviorByConstructorFunction$_(e), 
            this._$_sdkType$_ = null, this._$_iBehaviorType$_ = null, this._$_instSdkCtor$_ = e.Instance, 
            this._$_sid$_ = s[2], this._$_name$_ = s[0], this._$_jsPropName$_ = this._$_runtime$_._$GetJsPropName$_(s[3]), 
            this._$_behavior$_._$GetSdkVersion$_());
            if (h < 2 && (this._$_sdkType$_ = Fa._$New$_(e._$Type$_, this), !(this._$_sdkType$_ instanceof Fa._$SDKBehaviorTypeBase$_))) throw new Error("v1 sdk type must derive from SDKBehaviorBase");
            if (Fa._$AddonManager$_._$_PushInitObject$_(this, h), 2 <= h) {
                const r = e._$Type$_ ?? globalThis._$ISDKBehaviorTypeBase$_;
                if (this._$_iBehaviorType$_ = new r(), !(this._$_iBehaviorType$_ instanceof globalThis._$ISDKBehaviorTypeBase$_)) throw new Error("script interface class must derive from ISDKBehaviorTypeBase");
            } else this._$_iBehaviorType$_ = new globalThis._$IBehaviorType$_();
            Fa._$AddonManager$_._$_PopInitObject$_(h), this._$OnCreate$_();
        }
        static _$Create$_(t, s) {
            return Fa._$New$_(Fa._$BehaviorType$_, t, s);
        }
        _$Release$_() {
            this._$_runtime$_ = null, this._$_behavior$_ = null, this._$_sdkType$_ && (this._$_sdkType$_._$Release$_(), 
            this._$_sdkType$_ = null), this._$_instSdkCtor$_ = null;
        }
        _$GetSdkType$_() {
            return this._$_sdkType$_;
        }
        _$OnCreate$_() {
            this._$_sdkType$_ ? this._$_sdkType$_._$OnCreate$_() : this._$_iBehaviorType$_ && this._$_iBehaviorType$_._$_onCreate$_();
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetObjectClass$_() {
            return this._$_objectClass$_;
        }
        _$GetBehavior$_() {
            return this._$_behavior$_;
        }
        _$GetInstanceSdkCtor$_() {
            return this._$_instSdkCtor$_;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$GetSID$_() {
            return this._$_sid$_;
        }
        _$GetIBehaviorType$_() {
            return this._$_iBehaviorType$_;
        }
        _$GetJsPropName$_() {
            return this._$_jsPropName$_;
        }
    };
}

{
    const Oa = self._$C3$_, Da = self._$IBehaviorInstance$_;
    Oa._$BehaviorInstance$_ = class extends Oa._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_runtime$_ = t.runtime, this._$_behaviorType$_ = t._$behaviorType$_, 
            this._$_behavior$_ = this._$_behaviorType$_._$GetBehavior$_(), this._$_inst$_ = t._$instance$_, 
            this._$_index$_ = t.index, this._$_sdkInst$_ = null, this._$_iScriptInterface$_ = null, 
            this._$_behavior$_._$_AddInstance$_(this._$_inst$_);
        }
        _$Release$_() {
            this._$_iScriptInterface$_ && (this._$_iScriptInterface$_._$_release$_(), 
            this._$_iScriptInterface$_ = null), this._$_behavior$_._$_RemoveInstance$_(this._$_inst$_), 
            this._$_sdkInst$_ && (this._$_sdkInst$_._$Release$_(), this._$_sdkInst$_ = null), 
            this._$_runtime$_ = null, this._$_behaviorType$_ = null, this._$_behavior$_ = null, 
            this._$_inst$_ = null;
        }
        _$_CreateSdkInstance$_(t) {
            if (this._$_sdkInst$_) throw new Error("already got sdk instance");
            const s = this._$GetBehavior$_()._$GetSdkVersion$_();
            if (s < 2) {
                if (this._$_sdkInst$_ = Oa._$New$_(this._$_behaviorType$_._$GetInstanceSdkCtor$_(), this, t), 
                !(this._$_sdkInst$_ instanceof Oa._$SDKBehaviorInstanceBase$_)) throw new Error("v1 sdk type must derive from SDKBehaviorInstanceBase");
            } else {
                const i = this._$GetBehavior$_()._$GetScriptInterfaceClass$_();
                this._$_InitScriptInterface$_(i.Instance, t);
            }
        }
        _$GetSdkInstance$_() {
            return this._$_sdkInst$_ ?? this._$_iScriptInterface$_;
        }
        _$GetObjectInstance$_() {
            return this._$_inst$_;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetBehaviorType$_() {
            return this._$_behaviorType$_;
        }
        _$GetBehavior$_() {
            return this._$_behavior$_;
        }
        _$_GetIndex$_() {
            return this._$_index$_;
        }
        _$PostCreate$_() {
            this._$_sdkInst$_ ? this._$_sdkInst$_._$PostCreate$_() : this._$_iScriptInterface$_._$_postCreate$_();
        }
        _$OnSpriteFrameChanged$_(t, s) {
            this._$_sdkInst$_ && this._$_sdkInst$_._$OnSpriteFrameChanged$_(t, s);
        }
        _$_GetDebuggerProperties$_() {
            return this._$_sdkInst$_ ? this._$_sdkInst$_._$GetDebuggerProperties$_() : this._$_iScriptInterface$_._$_getDebuggerProperties$_();
        }
        _$SaveToJson$_(t = "full") {
            return this._$_sdkInst$_ ? this._$_sdkInst$_._$SaveToJson$_(t) : this._$_iScriptInterface$_._$_saveToJson$_(t);
        }
        _$LoadFromJson$_(t, s = "full") {
            if (this._$_sdkInst$_) return this._$_sdkInst$_._$LoadFromJson$_(t, s);
            this._$_iScriptInterface$_._$_loadFromJson$_(t, s);
        }
        static _$SortByTickSequence$_(t, s, i) {
            let e = globalThis._$ISDKBehaviorInstanceBase$_, h, r;
            h = s instanceof e ? t._$_UnwrapScriptInterface$_(s) : s._$GetBehaviorInstance$_(), 
            r = i instanceof e ? t._$_UnwrapScriptInterface$_(i) : i._$GetBehaviorInstance$_();
            const n = h._$GetObjectInstance$_(), o = r._$GetObjectInstance$_(), a = n._$GetObjectClass$_()._$GetIndex$_(), l = o._$GetObjectClass$_()._$GetIndex$_();
            if (a !== l) return a - l;
            const u = n._$GetPUID$_(), c = o._$GetPUID$_();
            return u !== c ? u - c : h._$_GetIndex$_() - r._$_GetIndex$_();
        }
        _$_InitScriptInterface$_(t, s) {
            const i = Da, e = t ?? this._$_sdkInst$_._$GetScriptInterfaceClass$_(), h = e || i, r = this._$GetBehavior$_()._$GetSdkVersion$_();
            if (Oa._$AddonManager$_._$_PushInitObject$_(this, r), Oa._$AddonManager$_._$_PushInitProperties$_(s), 
            this._$_iScriptInterface$_ = new h(), Oa._$AddonManager$_._$_PopInitProperties$_(), 
            Oa._$AddonManager$_._$_PopInitObject$_(r), !e || this._$_iScriptInterface$_ instanceof i) return this._$_iScriptInterface$_;
            throw new TypeError(`script interface class '${e.name}' does not extend the right base class '${i.name}'`);
        }
        _$GetScriptInterface$_() {
            return this._$_iScriptInterface$_ || this._$_InitScriptInterface$_();
        }
        _$HasScriptInterface$_() {
            return !!this._$_iScriptInterface$_;
        }
    };
}

{
    const ka = self._$C3$_;
    ka._$EffectList$_ = class extends ka._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_owner$_ = t, this._$_allEffectTypes$_ = [], this._$_activeEffectTypes$_ = [], 
            this._$_effectTypesByName$_ = new Map(), this._$_effectParams$_ = [], 
            this._$_effectParamBuffers$_ = [], this._$_allInstanceEffectLists$_ = new Set(), 
            this._$_preservesOpaqueness$_ = !0;
            for (const i of s) {
                const e = ka._$New$_(ka._$EffectType$_, this, i, this._$_allEffectTypes$_.length);
                this._$_allEffectTypes$_.push(e), this._$_effectTypesByName$_.set(e._$GetName$_().toLowerCase(), e), 
                3 <= i.length && this._$_effectParams$_.push(this._$_LoadSingleEffectParameters$_(e, i[2]));
            }
            this._$GetRuntime$_()._$_AddEffectList$_(this);
        }
        _$Release$_() {
            this._$GetRuntime$_()._$_RemoveEffectList$_(this);
            for (const t of this._$_effectParamBuffers$_) t._$Release$_();
            ka._$clearArray$_(this._$_effectParamBuffers$_), ka._$clearArray$_(this._$_allEffectTypes$_), 
            ka._$clearArray$_(this._$_activeEffectTypes$_), this._$_effectTypesByName$_.clear(), 
            ka._$clearArray$_(this._$_effectParams$_), this._$_owner$_ = null;
        }
        _$_AddInstanceEffectList$_(t) {
            this._$_allInstanceEffectLists$_.add(t);
        }
        _$_RemoveInstanceEffectList$_(t) {
            this._$_allInstanceEffectLists$_.delete(t);
        }
        _$_InitRenderer$_(t) {
            t._$IsWebGPU$_() && (this._$_effectParamBuffers$_ = this._$_allEffectTypes$_.map(t => {
                const s = t._$GetShaderProgram$_();
                return 0 < s.GetCustomParametersByteSize() ? ka._$New$_(ka._$Gfx$_.WebGPUEffectCustomParamsBuffer, s) : null;
            }), this._$_UpdateAllEffectParamBuffers$_());
            for (const s of this._$_allInstanceEffectLists$_) s._$_InitRenderer$_(t);
        }
        _$PrependEffectTypes$_(t) {
            if (t.length) {
                this._$_allEffectTypes$_ = t.concat(this._$_allEffectTypes$_);
                for (const s of t) this._$_effectTypesByName$_.set(s._$GetName$_().toLowerCase(), s);
                for (let t = 0, s = this._$_allEffectTypes$_.length; t < s; ++t) this._$_allEffectTypes$_[t]._$_SetIndex$_(t);
            }
        }
        _$_LoadSingleEffectParameters$_(t, s) {
            t._$SetActive$_(s[0]);
            const i = s.slice(1);
            for (let t = 0, s = i.length; t < s; ++t) {
                const e = i[t];
                if (Array.isArray(e)) {
                    const h = ka._$New$_(ka._$Color$_);
                    h._$setFromJSON$_(e), i[t] = h;
                }
            }
            return i;
        }
        _$GetOwner$_() {
            return this._$_owner$_;
        }
        _$GetRuntime$_() {
            return this._$_owner$_._$GetRuntime$_();
        }
        _$UpdateActiveEffects$_() {
            ka._$clearArray$_(this._$_activeEffectTypes$_);
            let t = !0;
            for (const s of this._$_allEffectTypes$_) s._$IsActive$_() && (this._$_activeEffectTypes$_.push(s), 
            s._$GetShaderProgram$_()._$PreservesOpaqueness$_() || (t = !1));
            this._$_preservesOpaqueness$_ = t;
        }
        _$GetAllEffectTypes$_() {
            return this._$_allEffectTypes$_;
        }
        _$HasAnyEffectType$_() {
            return 0 < this._$_allEffectTypes$_.length;
        }
        _$GetEffectTypeByName$_(t) {
            return this._$_effectTypesByName$_.get(t.toLowerCase()) || null;
        }
        _$GetEffectTypeByIndex$_(t) {
            if ((t = Math.floor(+t)) < 0 || t >= this._$_allEffectTypes$_.length) throw new RangeError("invalid effect type index");
            return this._$_allEffectTypes$_[t];
        }
        _$IsEffectIndexActive$_(t) {
            return this._$GetEffectTypeByIndex$_(t)._$IsActive$_();
        }
        _$SetEffectIndexActive$_(t, s) {
            this._$GetEffectTypeByIndex$_(t)._$SetActive$_(s);
        }
        _$GetActiveEffectTypes$_() {
            return this._$_activeEffectTypes$_;
        }
        _$HasAnyActiveEffect$_() {
            return 0 < this._$_activeEffectTypes$_.length;
        }
        _$PreservesOpaqueness$_() {
            return this._$_preservesOpaqueness$_;
        }
        _$GetEffectParametersForIndex$_(t) {
            return this._$_effectParams$_[t];
        }
        _$_GetEffectChainShaderParametersForIndex$_(t) {
            return (t < this._$_effectParamBuffers$_.length ? this._$_effectParamBuffers$_ : this._$_effectParams$_)[t];
        }
        _$GetEffectParameter$_(t, s) {
            if (t < 0 || t >= this._$_effectParams$_.length) return null;
            const i = this._$_effectParams$_[t];
            return s < 0 || s >= i.length ? null : i[s];
        }
        _$SetEffectParameter$_(t, s, i) {
            if (t < 0 || t >= this._$_effectParams$_.length) return !1;
            const e = this._$_effectParams$_[t];
            if (s < 0 || s >= e.length) return !1;
            const h = e[s];
            if (h instanceof ka._$Color$_) {
                if (h._$equalsIgnoringAlpha$_(i)) return !1;
                h._$copyRgb$_(i);
            } else {
                if (h === i) return !1;
                e[s] = i;
            }
            return t < this._$_effectParamBuffers$_.length && this._$_effectParamBuffers$_[t].SetParameterValue(s, i), 
            !0;
        }
        _$_UpdateAllEffectParamBuffers$_() {
            const i = this._$_effectParams$_, e = this._$_effectParamBuffers$_;
            for (let t = 0, s = Math.min(i.length, e.length); t < s; ++t) {
                const h = e[t], r = i[t];
                for (let t = 0, s = r.length; t < s; ++t) h.SetParameterValue(t, r[t]);
            }
        }
        static _$SaveFxParamToJson$_(t) {
            return t && t instanceof ka._$Color$_ ? {
                t: "color",
                v: t.toJSON()
            } : t;
        }
        static _$LoadFxParamFromJson$_(t) {
            if (null === t) return NaN;
            if ("object" != typeof t) return t;
            {
                const s = t.t;
                if ("color" !== s) throw new Error("invalid effect parameter type");
                {
                    const i = ka._$New$_(ka._$Color$_);
                    return i._$setFromJSON$_(t.v), i;
                }
            }
        }
        static _$SaveFxParamsToJson$_(t) {
            return t.map(ka._$EffectList$_._$SaveFxParamToJson$_);
        }
        static _$LoadFxParamsFromJson$_(t) {
            return t.map(ka._$EffectList$_._$LoadFxParamFromJson$_);
        }
        _$SaveToJson$_() {
            return this._$_allEffectTypes$_.map(t => ({
                name: t._$GetName$_(),
                active: t._$IsActive$_(),
                params: ka._$EffectList$_._$SaveFxParamsToJson$_(this._$_effectParams$_[t._$GetIndex$_()])
            }));
        }
        _$LoadFromJson$_(t) {
            for (const s of t) {
                const i = this._$GetEffectTypeByName$_(s.name);
                i && (i._$SetActive$_(s.active), this._$_effectParams$_[i._$GetIndex$_()] = ka._$EffectList$_._$LoadFxParamsFromJson$_(s.params));
            }
            this._$UpdateActiveEffects$_(), this._$_UpdateAllEffectParamBuffers$_();
        }
    };
}

{
    const La = self._$C3$_;
    La._$EffectType$_ = class extends La._$DefendedBase$_ {
        constructor(t, s, i) {
            super(), this._$_effectList$_ = t, this._$_id$_ = s[0], this._$_name$_ = s[1], 
            this._$_index$_ = i, this._$_shaderProgram$_ = null, this._$_isActive$_ = !0;
        }
        _$Release$_() {
            this._$_effectList$_ = null, this._$_shaderProgram$_ = null;
        }
        _$Clone$_(t) {
            const s = La._$New$_(La._$EffectType$_, t, [ this._$_id$_, this._$_name$_ ], -1);
            return s._$_shaderProgram$_ = this._$_shaderProgram$_, s._$_isActive$_ = this._$_isActive$_, 
            s;
        }
        _$_InitRenderer$_(t) {
            const s = t._$GetShaderProgramByName$_(this._$_id$_);
            if (!s) throw new Error("failed to find shader program '" + this._$_id$_ + "'");
            this._$_shaderProgram$_ = s;
        }
        _$GetEffectList$_() {
            return this._$_effectList$_;
        }
        _$GetName$_() {
            return this._$_name$_;
        }
        _$_SetIndex$_(t) {
            this._$_index$_ = t;
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$GetOwner$_() {
            return this._$_effectList$_._$GetOwner$_();
        }
        _$GetRuntime$_() {
            return this._$_effectList$_._$GetRuntime$_();
        }
        _$SetActive$_(t) {
            this._$_isActive$_ = !!t;
        }
        _$IsActive$_() {
            return this._$_isActive$_;
        }
        _$GetShaderProgram$_() {
            return this._$_shaderProgram$_;
        }
        _$GetDefaultParameterValues$_() {
            const i = [];
            for (let t = 0, s = this._$_shaderProgram$_._$GetParameterCount$_(); t < s; ++t) {
                const e = this._$_shaderProgram$_._$GetParameterType$_(t);
                if ("float" === e || "percent" === e) i.push(0); else {
                    if ("color" !== e) throw new TypeError("unknown effect parameter type");
                    i.push(La._$New$_(La._$Color$_, 1, 1, 1, 1));
                }
            }
            return i;
        }
    };
}

{
    const Ba = self._$C3$_;
    Ba._$InstanceEffectList$_ = class extends Ba._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_inst$_ = t, this._$_wi$_ = s, this._$_effectList$_ = t._$GetObjectClass$_()._$GetEffectList$_(), 
            this._$_needsRebuildSteps$_ = !0, this._$_wasDefaultColor$_ = !0, this._$_was3D$_ = !1, 
            this._$_wasRotatedOrNegativeSize$_ = !1, this._$_wasTexRotated$_ = !1, 
            this._$_wasMustPreDraw$_ = !1, this._$_effectChain$_ = Ba._$New$_(Ba._$Gfx$_._$EffectChain$_, t._$GetRuntime$_()._$GetCanvasManager$_()._$GetEffectChainManager$_(), {
                _$drawContent$_: (t, s) => {
                    const i = s._$GetContentObject$_(), e = i._$GetWorldInfo$_();
                    t._$SetColor$_(e._$GetPremultipliedColor$_()), t._$SetCurrentZ$_(e._$GetTotalZElevation$_()), 
                    i._$Draw$_(t), t._$SetCurrentZ$_(0);
                },
                _$getSourceTextureInfo$_: t => {
                    const s = t._$GetCurrentTexRect$_(), [ i, e ] = t._$GetCurrentSurfaceSize$_();
                    return {
                        _$srcTexRect$_: s,
                        _$srcWidth$_: i,
                        _$srcHeight$_: e
                    };
                },
                _$getShaderParameters$_: t => this._$_GetEffectChainShaderParametersForIndex$_(t)
            }), this._$_activeEffectFlags$_ = [], this._$_activeEffectTypes$_ = [], 
            this._$_preservesOpaqueness$_ = !0, this._$_effectParams$_ = [], this._$_effectParamBuffers$_ = [], 
            this._$_InitRenderer$_(t._$GetRuntime$_()._$GetRenderer$_());
            for (let t = 0, s = this._$_effectList$_._$GetAllEffectTypes$_().length; t < s; ++t) this._$_activeEffectFlags$_.push(!0);
            this._$UpdateActiveEffects$_(), this._$_effectList$_._$_AddInstanceEffectList$_(this);
        }
        _$Release$_() {
            this._$_effectList$_._$_RemoveInstanceEffectList$_(this);
            for (const t of this._$_effectParamBuffers$_) t && t._$Release$_();
            Ba._$clearArray$_(this._$_effectParamBuffers$_), this._$_effectChain$_._$Release$_(), 
            this._$_effectChain$_ = null, Ba._$clearArray$_(this._$_activeEffectFlags$_), 
            Ba._$clearArray$_(this._$_activeEffectTypes$_), Ba._$clearArray$_(this._$_effectParams$_), 
            this._$_inst$_ = null, this._$_effectList$_ = null;
        }
        _$_InitRenderer$_(t) {
            t._$IsWebGPU$_() && (this._$_effectParamBuffers$_ = this._$_effectList$_._$GetAllEffectTypes$_().map(t => {
                const s = t._$GetShaderProgram$_();
                return 0 < s.GetCustomParametersByteSize() ? Ba._$New$_(Ba._$Gfx$_.WebGPUEffectCustomParamsBuffer, s) : null;
            }));
        }
        _$_LoadEffectParameters$_(t) {
            let s = 0;
            for (const i of t) this._$_effectParams$_.push(this._$_LoadSingleEffectParameters$_(s, i)), 
            ++s;
            this._$_UpdateAllEffectParamBuffers$_(), this._$UpdateActiveEffects$_();
        }
        _$_LoadSingleEffectParameters$_(t, s) {
            this._$_activeEffectFlags$_[t] = s[0];
            const i = s.slice(1);
            for (let t = 0, s = i.length; t < s; ++t) {
                const e = i[t];
                if (Array.isArray(e)) {
                    const h = Ba._$New$_(Ba._$Color$_);
                    h._$setFromJSON$_(e), i[t] = h;
                }
            }
            return i;
        }
        _$LoadDefaultEffectParameters$_() {
            for (const t of this._$_effectList$_._$GetAllEffectTypes$_()) this._$_effectParams$_.push(t._$GetDefaultParameterValues$_());
            this._$_UpdateAllEffectParamBuffers$_();
        }
        _$GetOwner$_() {
            return this._$_owner$_;
        }
        _$GetEffectList$_() {
            return this._$_effectList$_;
        }
        _$GetEffectChain$_() {
            return this._$_MaybeRebuildEffectChainSteps$_(), this._$_effectChain$_;
        }
        _$GetRuntime$_() {
            return this._$_inst$_._$GetRuntime$_();
        }
        _$UpdateActiveEffects$_() {
            Ba._$clearArray$_(this._$_activeEffectTypes$_);
            let t = this._$_wi$_, i = this._$_effectList$_._$GetAllEffectTypes$_(), e = this._$_activeEffectTypes$_, h = this._$_activeEffectFlags$_, r = !0;
            for (let t = 0, s = i.length; t < s; ++t) if (h[t]) {
                const n = i[t];
                e.push(n), n._$GetShaderProgram$_()._$PreservesOpaqueness$_() || (r = !1);
            }
            this._$_preservesOpaqueness$_ = r, t._$_SetHasAnyActiveEffect$_(!!e.length), 
            this._$_needsRebuildSteps$_ = !0;
        }
        _$_MaybeRebuildEffectChainSteps$_() {
            const t = this._$_inst$_, s = this._$_wi$_, i = s._$HasDefaultColor$_(), e = t._$GetPlugin$_()._$Is3D$_(), h = 0 !== s._$GetAngle$_() || 0 !== s._$GetLayer$_()._$GetAngle$_() || s._$GetWidth$_() < 0 || s._$GetHeight$_() < 0, r = t._$IsCurrentTexRotated$_(), n = t._$MustPreDraw$_();
            (this._$_needsRebuildSteps$_ || i !== this._$_wasDefaultColor$_ || e !== this._$_was3D$_ || h !== this._$_wasRotatedOrNegativeSize$_ || r !== this._$_wasTexRotated$_ || n !== this._$_wasMustPreDraw$_ || this._$_effectChain$_._$NeedsRebuild$_()) && (this._$_effectChain$_._$BuildSteps$_(this._$_activeEffectTypes$_.map(t => t._$GetShaderProgram$_()), {
                _$indexMap$_: this._$_activeEffectTypes$_.map(t => t._$GetIndex$_()),
                _$forcePreDraw$_: !i || n,
                _$is3D$_: e,
                _$isSourceTextureRotated$_: r,
                _$isRotatedOrNegativeSizeInstance$_: h
            }), this._$_needsRebuildSteps$_ = !1, this._$_wasDefaultColor$_ = i, 
            this._$_was3D$_ = e, this._$_wasRotatedOrNegativeSize$_ = h, this._$_wasTexRotated$_ = r, 
            this._$_wasMustPreDraw$_ = n);
        }
        _$GetActiveEffectTypes$_() {
            return this._$_activeEffectTypes$_;
        }
        _$GetEffectParametersForIndex$_(t) {
            return this._$_effectParams$_[t];
        }
        _$_GetEffectChainShaderParametersForIndex$_(t) {
            return (t < this._$_effectParamBuffers$_.length ? this._$_effectParamBuffers$_ : this._$_effectParams$_)[t];
        }
        _$GetEffectParameter$_(t, s) {
            if (t < 0 || t >= this._$_effectParams$_.length) return null;
            const i = this._$_effectParams$_[t];
            return s < 0 || s >= i.length ? null : i[s];
        }
        _$SetEffectParameter$_(t, s, i) {
            if (t < 0 || t >= this._$_effectParams$_.length) return !1;
            const e = this._$_effectParams$_[t];
            if (s < 0 || s >= e.length) return !1;
            const h = e[s];
            if (h instanceof Ba._$Color$_) {
                if (h._$equalsIgnoringAlpha$_(i)) return !1;
                h._$copyRgb$_(i);
            } else {
                if (h === i) return !1;
                e[s] = i;
            }
            return t < this._$_effectParamBuffers$_.length && this._$_effectParamBuffers$_[t].SetParameterValue(s, i), 
            !0;
        }
        _$_UpdateAllEffectParamBuffers$_() {
            const i = this._$_effectParams$_, e = this._$_effectParamBuffers$_;
            for (let t = 0, s = e.length; t < s; ++t) {
                const h = e[t], r = i[t];
                for (let t = 0, s = r.length; t < s; ++t) h.SetParameterValue(t, r[t]);
            }
        }
        _$PreservesOpaqueness$_() {
            return this._$_preservesOpaqueness$_;
        }
        _$HasAnyActiveBackgroundBlendingEffect$_() {
            return this._$_activeEffectTypes$_.some(t => t._$GetShaderProgram$_()._$BlendsBackground$_());
        }
        _$IsEffectIndexActive$_(t) {
            return this._$_activeEffectFlags$_[t];
        }
        _$SetEffectIndexActive$_(t, s) {
            this._$_activeEffectFlags$_[t] = !!s;
        }
        _$GetAllEffectTypes$_() {
            return this._$_effectList$_._$GetAllEffectTypes$_();
        }
        _$_SaveToJson$_() {
            return this._$_effectList$_._$GetAllEffectTypes$_().map(t => ({
                name: t._$GetName$_(),
                active: this._$_activeEffectFlags$_[t._$GetIndex$_()],
                params: Ba._$EffectList$_._$SaveFxParamsToJson$_(this._$_effectParams$_[t._$GetIndex$_()])
            }));
        }
        _$_LoadFromJson$_(t) {
            for (const s of t) {
                const i = this._$_effectList$_._$GetEffectTypeByName$_(s.name);
                i && (this._$_activeEffectFlags$_[i._$GetIndex$_()] = s.active, 
                this._$_effectParams$_[i._$GetIndex$_()] = Ba._$EffectList$_._$LoadFxParamsFromJson$_(s.params));
            }
            this._$UpdateActiveEffects$_(), this._$_UpdateAllEffectParamBuffers$_();
        }
    };
}

{
    let _ = self._$C3$_, r = [], b = [], n = [], M = _._$New$_(_._$CollisionPoly$_), w = _._$New$_(_._$CollisionPoly$_), v = _._$New$_(_._$Quad$_), d = _._$New$_(_.Rect), p = _._$New$_(_.Rect), m = null, g = null, y = null;
    _._$CollisionEngine$_ = class extends _._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_runtime$_ = t, this._$_collisionCellWidth$_ = 0, this._$_collisionCellHeight$_ = 0, 
            this._$_registeredCollisions$_ = [], this._$_collisionCheckCount$_ = 0, 
            this._$_collisionCheckSec$_ = 0, this._$_polyCheckCount$_ = 0, this._$_polyCheckSec$_ = 0, 
            this._$_iCollisionEngine$_ = new self._$ICollisionEngine$_(this);
        }
        _$Release$_() {
            this._$_runtime$_ = null;
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetICollisionEngine$_() {
            return this._$_iCollisionEngine$_;
        }
        _$_Update1sStats$_() {
            this._$_collisionCheckSec$_ = this._$_collisionCheckCount$_, this._$_collisionCheckCount$_ = 0, 
            this._$_polyCheckSec$_ = this._$_polyCheckCount$_, this._$_polyCheckCount$_ = 0;
        }
        _$Get1secCollisionChecks$_() {
            return this._$_collisionCheckSec$_;
        }
        _$Get1secPolyChecks$_() {
            return this._$_polyCheckSec$_;
        }
        _$RegisterCollision$_(t, s) {
            const i = t._$GetWorldInfo$_(), e = s._$GetWorldInfo$_();
            i && e && i._$IsCollisionEnabled$_() && e._$IsCollisionEnabled$_() && this._$_registeredCollisions$_.push([ t, s ]);
        }
        _$AddRegisteredCollisionCandidates$_(s, i, e) {
            for (const [ h, r ] of this._$_registeredCollisions$_) {
                let t = null;
                if (s === h) t = r; else {
                    if (s !== r) continue;
                    t = h;
                }
                !t._$BelongsToObjectClass$_(i) || e.includes(t) || e.push(t);
            }
        }
        _$CheckRegisteredCollision$_(t, s) {
            if (this._$_registeredCollisions$_.length) for (const [ i, e ] of this._$_registeredCollisions$_) if (t === i && s === e || t === e && s === i) return !0;
            return !1;
        }
        _$ClearRegisteredCollisions$_() {
            _._$clearArray$_(this._$_registeredCollisions$_);
        }
        _$TestOverlap$_(t, s) {
            if (!t || !s || t === s) return !1;
            const i = t._$GetWorldInfo$_(), e = s._$GetWorldInfo$_();
            if (!i._$IsCollisionEnabled$_() || !e._$IsCollisionEnabled$_()) return !1;
            this._$_collisionCheckCount$_++;
            const h = i._$GetLayer$_(), r = e._$GetLayer$_(), n = h._$IsTransformCompatibleWith$_(r);
            return n ? this._$_TestOverlap_SameLayers$_(i, e) : this._$_TestOverlap_DifferentLayers$_(i, e);
        }
        _$_TestOverlap_SameLayers$_(t, s) {
            if (!t._$GetBoundingBox$_()._$intersectsRect$_(s._$GetBoundingBox$_())) return !1;
            if (this._$_polyCheckCount$_++, !t._$GetBoundingQuad$_()._$intersectsQuad$_(s._$GetBoundingQuad$_())) return !1;
            if (t._$HasTilemap$_() && s._$HasTilemap$_()) return !1;
            if (t._$HasTilemap$_()) return this._$TestTilemapOverlap$_(t, s);
            if (s._$HasTilemap$_()) return this._$TestTilemapOverlap$_(s, t);
            if (!t._$HasOwnCollisionPoly$_() && !s._$HasOwnCollisionPoly$_()) return !0;
            const i = t._$GetTransformedCollisionPoly$_(), e = s._$GetTransformedCollisionPoly$_();
            return i._$intersectsPoly$_(e, s._$GetX$_() - t._$GetX$_(), s._$GetY$_() - t._$GetY$_());
        }
        _$_TestOverlap_DifferentLayers$_(i, e) {
            const t = i._$HasTilemap$_(), s = e._$HasTilemap$_();
            if (t && !s) return this._$TestTilemapOverlapDifferentLayers$_(i, e);
            if (s && !t) return this._$TestTilemapOverlapDifferentLayers$_(e, i);
            if (s || t) return !1;
            {
                const h = i._$GetLayer$_(), r = e._$GetLayer$_(), n = (M._$copy$_(i._$GetTransformedCollisionPoly$_()), 
                w._$copy$_(e._$GetTransformedCollisionPoly$_()), M._$pointsArr$_());
                for (let t = 0, s = n.length; t < s; t += 2) {
                    const a = t + 1, l = n[t], u = n[a], [ c, f ] = h._$LayerToCanvasCss$_(l + i._$GetX$_(), u + i._$GetY$_());
                    n[t] = c, n[a] = f;
                }
                const o = w._$pointsArr$_();
                for (let t = 0, s = o.length; t < s; t += 2) {
                    const d = t + 1, p = o[t], m = o[d], [ g, y ] = r._$LayerToCanvasCss$_(p + e._$GetX$_(), m + e._$GetY$_());
                    o[t] = g, o[d] = y;
                }
                return M._$setBboxChanged$_(), w._$setBboxChanged$_(), this._$_polyCheckCount$_++, 
                M._$intersectsPoly$_(w, 0, 0);
            }
        }
        _$TestTilemapOverlapDifferentLayers$_(t, s) {
            const i = t._$GetLayer$_(), e = s._$GetLayer$_(), h = (m = m || _._$New$_(_._$CollisionPoly$_), 
            g = g || _._$New$_(_.Rect), y = y || _._$New$_(_._$Quad$_), s._$GetX$_()), r = s._$GetY$_(), [ n, o ] = e._$LayerToCanvasCss$_(h, r), [ a, l ] = i._$CanvasCssToLayer$_(n, o), u = a - h, c = l - r;
            if (g._$copy$_(s._$GetBoundingBox$_()), g.offset(u, c), !t._$GetBoundingBox$_()._$intersectsRect$_(g)) return !1;
            if (y._$copy$_(s._$GetBoundingQuad$_()), y.offset(u, c), this._$_polyCheckCount$_++, 
            !t._$GetBoundingQuad$_()._$intersectsQuad$_(y)) return !1;
            m._$copy$_(s._$GetTransformedCollisionPoly$_());
            const f = m._$pointsArr$_();
            for (let t = 0, s = f.length; t < s; t += 2) {
                const d = t + 1;
                f[t] += u, f[d] += c;
            }
            return m._$setBboxChanged$_(), this._$TestTilemapOverlap$_(t, s, a, l, m, g, y);
        }
        _$TestTilemapOverlap$_(t, e, s, i, h, r, n) {
            const o = void 0 !== r ? r : e._$GetBoundingBox$_(), a = t._$GetX$_(), l = t._$GetY$_(), u = t._$GetInstance$_()._$GetSdkInstance$_(), c = void 0 !== s ? s : e._$GetX$_(), f = void 0 !== i ? i : e._$GetY$_(), d = e._$HasOwnCollisionPoly$_(), p = void 0 !== n ? n : e._$GetBoundingQuad$_(), m = b;
            u._$GetCollisionRectCandidates$_(o, m);
            for (let t = 0, s = m.length; t < s; ++t) {
                const g = m[t], y = g._$GetRect$_();
                if (this._$_collisionCheckCount$_++, o._$intersectsRectOffset$_(y, a, l) && (v._$setFromRect$_(y), 
                v.offset(a, l), v._$intersectsQuad$_(p))) if (d) {
                    let t = void 0 !== h ? h : e._$GetTransformedCollisionPoly$_(), s = c, i = f;
                    void 0 !== h && (s = e._$GetX$_(), i = e._$GetY$_());
                    const w = g._$GetPoly$_();
                    if (w) {
                        if (this._$_polyCheckCount$_++, w._$intersectsPoly$_(t, s - (a + y._$getLeft$_()), i - (l + y._$getTop$_()))) return _._$clearArray$_(m), 
                        !0;
                    } else if (M._$setFromQuad$_(v, 0, 0), M._$intersectsPoly$_(t, s, i)) return _._$clearArray$_(m), 
                    !0;
                } else {
                    const S = g._$GetPoly$_();
                    if (!S) return _._$clearArray$_(m), !0;
                    if (M._$setFromQuad$_(p, 0, 0), S._$intersectsPoly$_(M, -(a + y._$getLeft$_()), -(l + y._$getTop$_()))) return _._$clearArray$_(m), 
                    !0;
                }
            }
            return _._$clearArray$_(m), !1;
        }
        _$TestAndSelectCanvasPointOverlap$_(t, a, l) {
            const u = t._$GetCurrentSol$_(), s = this._$_runtime$_._$GetCurrentEvent$_();
            if (!s) throw new Error("cannot call outside event");
            const c = s._$IsOrBlock$_(), i = new Map(), f = t => {
                let s = i.get(t);
                return void 0 === s && (s = t._$IsSelfAndParentsInteractive$_(), 
                i.set(t, s)), s;
            };
            if (u._$IsSelectAll$_()) {
                l || (u._$_SetSelectAll$_(!1), _._$clearArray$_(u._$_GetOwnInstances$_())), 
                c && _._$clearArray$_(u._$_GetOwnElseInstances$_());
                for (const e of t._$GetInstances$_()) {
                    let h = e._$GetWorldInfo$_(), r = h._$GetLayer$_(), t = !1;
                    if (t = f(r) && h._$IsInViewport2$_() ? a.some(([ t, s ]) => {
                        const [ i, e ] = r._$CanvasCssToLayer$_(t, s, h._$GetTotalZElevation$_());
                        return h._$ContainsPoint$_(i, e);
                    }) : t) {
                        if (l) return !1;
                        u._$_PushInstance$_(e);
                    } else c && u._$_PushElseInstance$_(e);
                }
            } else {
                let e, n = !1, o = (!c || s._$IsFirstConditionOfType$_(this._$_runtime$_._$GetCurrentCondition$_()) || this._$_runtime$_._$IsCurrentConditionFirst$_() && !u._$_GetOwnElseInstances$_().length && u._$_GetOwnInstances$_().length ? e = u._$_GetOwnInstances$_() : (e = u._$_GetOwnElseInstances$_(), 
                n = !0), 0);
                for (let i = 0, t = e.length; i < t; ++i) {
                    let t = e[i], h = t._$GetWorldInfo$_(), r = h._$GetLayer$_(), s = !1;
                    if (s = f(r) && h._$IsInViewport2$_() ? a.some(([ t, s ]) => {
                        const [ i, e ] = r._$CanvasCssToLayer$_(t, s, h._$GetTotalZElevation$_());
                        return h._$ContainsPoint$_(i, e);
                    }) : s) {
                        if (l) return !1;
                        n ? u._$_PushInstance$_(t) : e[o++] = t;
                    } else n ? e[o++] = t : c && u._$_PushElseInstance$_(t);
                }
                l || (e.length = o);
            }
            return t._$ApplySolToContainer$_(), i.clear(), !!l || u._$HasAnyInstances$_();
        }
        _$_ObjectClassCanUseCollisionCells$_(t, s) {
            if (t) for (const i of s._$layersHasInstancesOn$_()) if (!t._$IsTransformCompatibleWith$_(i)) return !1;
            return !0;
        }
        _$GetCollisionCandidates$_(t, s, i, e) {
            if (s._$IsFamily$_()) for (const h of s._$GetFamilyMembers$_()) this._$_ObjectClassCanUseCollisionCells$_(t, h) ? (h._$_UpdateAllCollisionCells$_(), 
            h._$_GetCollisionCellGrid$_()._$QueryRange$_(i, e)) : _._$appendArray$_(e, h._$GetInstances$_()); else this._$_ObjectClassCanUseCollisionCells$_(t, s) ? (s._$_UpdateAllCollisionCells$_(), 
            s._$_GetCollisionCellGrid$_()._$QueryRange$_(i, e)) : _._$appendArray$_(e, s._$GetInstances$_());
        }
        _$GetObjectClassesCollisionCandidates$_(t, s, i, e) {
            for (const h of s) this._$GetCollisionCandidates$_(t, h, i, e);
        }
        _$GetSolidCollisionCandidates$_(t, s, i) {
            const e = this._$_runtime$_._$GetSolidBehavior$_();
            e && this._$GetObjectClassesCollisionCandidates$_(t, e._$GetObjectClasses$_(), s, i);
        }
        _$GetJumpthruCollisionCandidates$_(t, s, i) {
            const e = this._$_runtime$_._$GetJumpthruBehavior$_();
            e && this._$GetObjectClassesCollisionCandidates$_(t, e._$GetObjectClasses$_(), s, i);
        }
        _$IsSolidCollisionAllowed$_(t, s) {
            return t._$_IsSolidEnabled$_() && (!s || s._$GetWorldInfo$_()._$IsSolidCollisionAllowed$_(t._$GetSavedDataMap$_().get("solidTags")));
        }
        _$TestOverlapSolid$_(t) {
            const s = t._$GetWorldInfo$_();
            this._$GetSolidCollisionCandidates$_(s._$GetLayer$_(), s._$GetBoundingBox$_(), r);
            for (const i of r) if (this._$IsSolidCollisionAllowed$_(i, t) && this._$TestOverlap$_(t, i)) return _._$clearArray$_(r), 
            i;
            return _._$clearArray$_(r), null;
        }
        _$TestRectOverlapSolid$_(t, s) {
            this._$GetSolidCollisionCandidates$_(null, t, r);
            for (const i of r) if (this._$IsSolidCollisionAllowed$_(i, s) && this._$TestRectOverlap$_(t, i)) return _._$clearArray$_(r), 
            i;
            return _._$clearArray$_(r), null;
        }
        _$TestOverlapJumpthru$_(t, s) {
            let i = null;
            s && (i = n, _._$clearArray$_(i));
            const e = t._$GetWorldInfo$_();
            this._$GetJumpthruCollisionCandidates$_(e._$GetLayer$_(), e._$GetBoundingBox$_(), r);
            for (const h of r) if (h._$_IsJumpthruEnabled$_() && this._$TestOverlap$_(t, h)) {
                if (!s) return _._$clearArray$_(r), h;
                i.push(h);
            }
            return _._$clearArray$_(r), i;
        }
        _$PushOut$_(s, i, e, h, r) {
            h = h || 50;
            const n = s._$GetWorldInfo$_(), o = n._$GetX$_(), a = n._$GetY$_();
            for (let t = 0; t < h; ++t) if (n._$SetXY$_(o + i * t, a + e * t), n._$SetBboxChanged$_(), 
            !this._$TestOverlap$_(s, r)) return !0;
            return n._$SetXY$_(o, a), n._$SetBboxChanged$_(), !1;
        }
        _$PushOutSolid$_(s, i, e, h, r, n) {
            h = h || 50;
            let o = s._$GetWorldInfo$_(), a = o._$GetX$_(), l = o._$GetY$_(), u = null, c = null;
            for (let t = 0; t < h; ++t) if (o._$SetXY$_(a + i * t, l + e * t), o._$SetBboxChanged$_(), 
            !this._$TestOverlap$_(s, u)) if (u = this._$TestOverlapSolid$_(s)) c = u; else if (r && (u = n ? this._$TestOverlap$_(s, n) ? n : null : this._$TestOverlapJumpthru$_(s)) && (c = u), 
            !u) return c && this._$PushInFractional$_(s, i, e, c, 16, !0), !0;
            return o._$SetXY$_(a, l), o._$SetBboxChanged$_(), !1;
        }
        _$PushOutSolidAxis$_(i, e, h, t) {
            t = t || 50;
            let r = i._$GetWorldInfo$_(), n = r._$GetX$_(), o = r._$GetY$_(), a = null, l = null;
            for (let s = 0; s < t; ++s) for (let t = 0; t < 2; ++t) {
                const u = 2 * t - 1;
                if (r._$SetXY$_(n + e * s * u, o + h * s * u), r._$SetBboxChanged$_(), 
                !this._$TestOverlap$_(i, a)) {
                    if (!(a = this._$TestOverlapSolid$_(i))) return l && this._$PushInFractional$_(i, e * u, h * u, l, 16, !0), 
                    !0;
                    l = a;
                }
            }
            return r._$SetXY$_(n, o), r._$SetBboxChanged$_(), !1;
        }
        _$PushInFractional$_(t, s, i, e, h, r) {
            let n = 2, o = !1, a = !1, l = t._$GetWorldInfo$_(), u = l._$GetX$_(), c = l._$GetY$_();
            for (;n <= h; ) {
                const f = 1 / n;
                n *= 2, l._$OffsetXY$_(s * f * (o ? 1 : -1), i * f * (o ? 1 : -1)), 
                l._$SetBboxChanged$_(), this._$TestOverlap$_(t, e) || r && this._$TestOverlapSolid$_(t) ? (o = !0, 
                a = !0) : (o = !1, a = !1, u = l._$GetX$_(), c = l._$GetY$_());
            }
            a && (l._$SetXY$_(u, c), l._$SetBboxChanged$_());
        }
        _$PushOutSolidNearest$_(i, t = 100) {
            let e = 0, h = i._$GetWorldInfo$_(), r = h._$GetX$_(), n = h._$GetY$_(), o = 0, a = this._$TestOverlapSolid$_(i);
            if (!a) return !0;
            for (;e <= t; ) {
                let t = 0, s = 0;
                switch (o) {
                  case 0:
                    t = 0, s = -1, e++;
                    break;

                  case 1:
                    t = 1, s = -1;
                    break;

                  case 2:
                    t = 1, s = 0;
                    break;

                  case 3:
                    t = 1, s = 1;
                    break;

                  case 4:
                    t = 0, s = 1;
                    break;

                  case 5:
                    t = -1, s = 1;
                    break;

                  case 6:
                    t = -1, s = 0;
                    break;

                  case 7:
                    t = -1, s = -1;
                }
                if (o = (o + 1) % 8, h._$SetXY$_(Math.floor(r + t * e), Math.floor(n + s * e)), 
                h._$SetBboxChanged$_(), !this._$TestOverlap$_(i, a) && !(a = this._$TestOverlapSolid$_(i))) return !0;
            }
            return h._$SetXY$_(r, n), h._$SetBboxChanged$_(), !1;
        }
        _$CalculateBounceAngle$_(t, s, i, e) {
            const h = t._$GetWorldInfo$_(), r = h._$GetX$_(), n = h._$GetY$_(), o = Math.max(10, _._$distanceTo$_(s, i, r, n)), a = _._$angleTo$_(s, i, r, n), l = e || this._$TestOverlapSolid$_(t);
            if (!l) return _._$clampAngle$_(a + Math.PI);
            let u = l, c = 0, f = 0, d = _._$toRadians$_(5), p;
            for (p = 1; p < 36; ++p) {
                const G = a - p * d;
                if (h._$SetXY$_(s + Math.cos(G) * o, i + Math.sin(G) * o), h._$SetBboxChanged$_(), 
                !this._$TestOverlap$_(t, u) && !(u = e ? null : this._$TestOverlapSolid$_(t))) {
                    c = G;
                    break;
                }
            }
            for (36 === p && (c = _._$clampAngle$_(a + Math.PI)), u = l, p = 1; p < 36; ++p) {
                const T = a + p * d;
                if (h._$SetXY$_(s + Math.cos(T) * o, i + Math.sin(T) * o), h._$SetBboxChanged$_(), 
                !this._$TestOverlap$_(t, u) && !(u = e ? null : this._$TestOverlapSolid$_(t))) {
                    f = T;
                    break;
                }
            }
            if (36 === p && (f = _._$clampAngle$_(a + Math.PI)), h._$SetXY$_(r, n), 
            h._$SetBboxChanged$_(), f === c) return f;
            let m = _._$angleDiff$_(f, c) / 2, g;
            g = _._$angleClockwise$_(f, c) ? _._$clampAngle$_(c + m + Math.PI) : _._$clampAngle$_(f + m);
            const y = Math.cos(a), w = Math.sin(a), S = Math.cos(g), b = Math.sin(g), M = y * S + w * b, v = y - 2 * M * S, x = w - 2 * M * b;
            return _._$angleTo$_(0, 0, v, x);
        }
        _$TestSegmentOverlap$_(t, s, i, e, h) {
            if (!h) return !1;
            const r = h._$GetWorldInfo$_();
            if (!r._$IsCollisionEnabled$_()) return !1;
            if (this._$_collisionCheckCount$_++, d.set(Math.min(t, i), Math.min(s, e), Math.max(t, i), Math.max(s, e)), 
            !r._$GetBoundingBox$_()._$intersectsRect$_(d)) return !1;
            if (h._$HasTilemap$_()) return this._$_TestSegmentOverlapTilemap$_(t, s, i, e, h, r);
            if (this._$_polyCheckCount$_++, !r._$GetBoundingQuad$_()._$intersectsSegment$_(t, s, i, e)) return !1;
            if (!r._$HasOwnCollisionPoly$_()) return !0;
            const n = r._$GetTransformedCollisionPoly$_();
            return n._$intersectsSegment$_(r._$GetX$_(), r._$GetY$_(), t, s, i, e);
        }
        _$_TestSegmentOverlapTilemap$_(i, e, h, r, t, s) {
            const n = s._$GetX$_(), o = s._$GetY$_(), a = t._$GetSdkInstance$_(), l = b;
            p.set(i, e, h, r), p.normalize(), a._$GetCollisionRectCandidates$_(p, l);
            for (let t = 0, s = l.length; t < s; ++t) {
                const u = l[t], c = u._$GetRect$_();
                if (this._$_collisionCheckCount$_++, d._$intersectsRectOffset$_(c, n, o) && (v._$setFromRect$_(c), 
                v.offset(n, o), v._$intersectsSegment$_(i, e, h, r))) {
                    const f = u._$GetPoly$_();
                    if (!f) return _._$clearArray$_(l), !0;
                    if (this._$_polyCheckCount$_++, f._$intersectsSegment$_(n + c._$getLeft$_(), o + c._$getTop$_(), i, e, h, r)) return _._$clearArray$_(l), 
                    !0;
                }
            }
            return _._$clearArray$_(l), !1;
        }
        _$TestRectOverlap$_(t, s) {
            if (!s) return !1;
            const i = s._$GetWorldInfo$_();
            if (!i._$IsCollisionEnabled$_()) return !1;
            if (this._$_collisionCheckCount$_++, !i._$GetBoundingBox$_()._$intersectsRect$_(t)) return !1;
            if (s._$HasTilemap$_()) return this._$_TestRectOverlapTilemap$_(t, s, i);
            if (this._$_polyCheckCount$_++, v._$setFromRect$_(t), !i._$GetBoundingQuad$_()._$intersectsQuad$_(v)) return !1;
            if (!i._$HasOwnCollisionPoly$_()) return !0;
            const e = M, h = (e._$setFromRect$_(t, i._$GetX$_(), i._$GetY$_()), 
            i._$GetTransformedCollisionPoly$_());
            return e._$intersectsPoly$_(h, 0, 0);
        }
        _$_TestRectOverlapTilemap$_(i, t, s) {
            const e = s._$GetX$_(), h = s._$GetY$_(), r = t._$GetSdkInstance$_(), n = b;
            r._$GetCollisionRectCandidates$_(i, n);
            for (let t = 0, s = n.length; t < s; ++t) {
                const o = n[t], a = o._$GetRect$_();
                if (this._$_collisionCheckCount$_++, i._$intersectsRectOffset$_(a, e, h)) {
                    const l = o._$GetPoly$_();
                    if (!l) return _._$clearArray$_(n), !0;
                    if (this._$_polyCheckCount$_++, M._$setFromRect$_(i, 0, 0), 
                    l._$intersectsPoly$_(M, -(e + a._$getLeft$_()), -(h + a._$getTop$_()))) return _._$clearArray$_(n), 
                    !0;
                }
            }
            return _._$clearArray$_(n), !1;
        }
        _$TestRayIntersectsInstance$_(t, s) {
            if (t) {
                const i = t._$GetWorldInfo$_();
                i._$IsCollisionEnabled$_() && (this._$_collisionCheckCount$_++, 
                i._$GetBoundingBox$_()._$intersectsRect$_(s.rect)) && (t._$HasTilemap$_() ? this._$_TestRayIntersectsTilemap$_(t, i, s) : (this._$_polyCheckCount$_++, 
                i._$HasOwnCollisionPoly$_() ? s._$TestInstancePoly$_(t, i._$GetX$_(), i._$GetY$_(), i._$GetTransformedCollisionPoly$_()) : s._$TestInstanceQuad$_(t, i._$GetBoundingQuad$_())));
            }
        }
        _$_TestRayIntersectsTilemap$_(i, e, h) {
            const r = e._$GetX$_(), n = e._$GetY$_(), o = b;
            i._$GetSdkInstance$_()._$GetCollisionRectCandidates$_(h.rect, o);
            for (let t = 0, s = o.length; t < s; t++) {
                const a = o[t], l = a._$GetRect$_();
                if (this._$_collisionCheckCount$_++, h.rect._$intersectsRectOffset$_(l, r, n)) {
                    const u = a._$GetPoly$_();
                    this._$_polyCheckCount$_++, u ? h._$TestInstancePoly$_(i, r + l._$getLeft$_(), n + l._$getTop$_(), u) : h._$TestInstanceRect$_(i, e._$GetX$_(), e._$GetY$_(), l);
                }
            }
            _._$clearArray$_(o);
        }
        _$SetCollisionCellSize$_(t, s) {
            if (t !== this._$_collisionCellWidth$_ || s !== this._$_collisionCellHeight$_) {
                this._$_collisionCellWidth$_ = t, this._$_collisionCellHeight$_ = s;
                const i = this._$_runtime$_._$GetAllObjectClasses$_();
                for (const e of i) if (e._$IsWorldType$_()) {
                    for (const h of e._$instancesIncludingPendingCreate$_()) h._$GetWorldInfo$_()._$_RemoveFromCollisionCells$_();
                    e._$_GetCollisionCellGrid$_()._$SetCellSize$_(t, s), e._$_SetAnyCollisionCellChanged$_();
                    for (const r of e._$instancesIncludingPendingCreate$_()) {
                        const n = r._$GetWorldInfo$_();
                        n._$_SetCollisionCellChanged$_(), n._$_UpdateCollisionCell$_();
                    }
                }
            }
        }
        _$GetCollisionCellSize$_() {
            return [ this._$_collisionCellWidth$_, this._$_collisionCellHeight$_ ];
        }
        _$_InitCollisionCellSize$_(t, s) {
            this._$_collisionCellWidth$_ = t, this._$_collisionCellHeight$_ = s;
        }
    };
}

{
    const Na = self._$C3$_;
    Na._$SparseGrid$_ = class extends Na._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_cellWidth$_ = t, this._$_cellHeight$_ = s, this._$_cells$_ = Na._$New$_(Na._$PairMap$_);
        }
        _$Release$_() {
            this._$_cells$_._$Release$_(), this._$_cells$_ = null;
        }
        _$SetCellSize$_(t, s) {
            if (!this._$_cells$_._$IsEmpty$_()) throw new Error("grid not empty");
            this._$_cellWidth$_ = t, this._$_cellHeight$_ = s;
        }
        _$GetCell$_(t, s, i) {
            let e = this._$_cells$_._$Get$_(t, s);
            return e || (i ? (e = Na._$New$_(Na._$GridCell$_, this, t, s), this._$_cells$_.Set(t, s, e), 
            e) : null);
        }
        _$XToCell$_(t) {
            const s = Math.floor(t / this._$_cellWidth$_);
            return isFinite(s) ? s : 0;
        }
        _$YToCell$_(t) {
            const s = Math.floor(t / this._$_cellHeight$_);
            return isFinite(s) ? s : 0;
        }
        _$Update$_(e, h, r) {
            if (h) for (let i = h._$getLeft$_(), t = h._$getRight$_(); i <= t; ++i) for (let t = h._$getTop$_(), s = h._$getBottom$_(); t <= s; ++t) if (!r || !r._$containsPoint$_(i, t)) {
                const n = this._$GetCell$_(i, t, !1);
                n && (n._$Remove$_(e), n._$IsEmpty$_()) && this._$_cells$_._$Delete$_(i, t);
            }
            if (r) for (let i = r._$getLeft$_(), t = r._$getRight$_(); i <= t; ++i) for (let t = r._$getTop$_(), s = r._$getBottom$_(); t <= s; ++t) h && h._$containsPoint$_(i, t) || this._$GetCell$_(i, t, !0)._$Insert$_(e);
        }
        _$QueryRange$_(t, s) {
            let i = this._$XToCell$_(t._$getLeft$_()), e = this._$YToCell$_(t._$getTop$_()), h = this._$XToCell$_(t._$getRight$_()), r = this._$YToCell$_(t._$getBottom$_());
            if (isFinite(h) && isFinite(r)) for (;i <= h; ++i) for (let t = e; t <= r; ++t) {
                const n = this._$GetCell$_(i, t, !1);
                n && n._$Dump$_(s);
            }
        }
    };
}

{
    const Wa = self._$C3$_;
    Wa._$GridCell$_ = class extends Wa._$DefendedBase$_ {
        constructor(t, s, i) {
            super(), this._$_grid$_ = t, this._$_x$_ = s, this._$_y$_ = i, this._$_instances$_ = Wa._$New$_(Wa._$ArraySet$_);
        }
        _$Release$_() {
            this._$_instances$_._$Release$_(), this._$_instances$_ = null, this._$_grid$_ = null;
        }
        _$IsEmpty$_() {
            return this._$_instances$_._$IsEmpty$_();
        }
        _$Insert$_(t) {
            this._$_instances$_._$Add$_(t);
        }
        _$Remove$_(t) {
            this._$_instances$_._$Delete$_(t);
        }
        _$Dump$_(t) {
            Wa._$appendArray$_(t, this._$_instances$_._$GetArray$_());
        }
    };
}

{
    const ja = self._$C3$_;
    ja._$Ray$_ = class {
        constructor() {
            this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.dx = 0, this.dy = 0, 
            this.rect = new ja.Rect(), this._$hitFraction$_ = 2, this._$hitUid$_ = null, 
            this._$hitNormal$_ = 0, this._$hitNormalDx$_ = 0, this._$hitNormalDy$_ = 0, 
            this._$hitX$_ = 0, this._$hitY$_ = 0, this._$distance$_ = 0, this._$normalX$_ = 1, 
            this._$normalY$_ = 0, this._$reflectionX$_ = 1, this._$reflectionY$_ = 0;
        }
        _$DidCollide$_() {
            return this._$hitFraction$_ < 1 + 1e-6;
        }
        _$Reset$_() {
            this._$hitFraction$_ = 2;
        }
        Set(t, s, i, e) {
            return this.x1 = t, this.y1 = s, this.x2 = i, this.y2 = e, this.dx = i - t, 
            this.dy = e - s, this.rect.set(t, s, i, e), this.rect.normalize(), this._$hitFraction$_ = 2, 
            this._$hitUid$_ = null, this._$hitNormal$_ = 0, this._$hitNormalDx$_ = 0, 
            this._$hitNormalDy$_ = 0, this._$hitX$_ = 0, this._$hitY$_ = 0, this._$distance$_ = 0, 
            this._$normalX$_ = 1, this._$normalY$_ = 0, this._$reflectionX$_ = 1, 
            this._$reflectionY$_ = 0, this;
        }
        _$Complete$_() {
            if (!1 !== this._$DidCollide$_()) {
                const t = this.dx * this._$hitFraction$_, s = this.dy * this._$hitFraction$_, i = Math.hypot(t, s), e = t / i, h = s / i, r = (this._$distance$_ = i - 1e-6, 
                this._$hitX$_ = this.x1 + e * this._$distance$_, this._$hitY$_ = this.y1 + h * this._$distance$_, 
                this._$hitNormal$_ = Math.atan2(this._$hitNormalDy$_, this._$hitNormalDx$_) + Math.PI / 2, 
                this._$normalX$_ = Math.cos(this._$hitNormal$_), this._$normalY$_ = Math.sin(this._$hitNormal$_), 
                e * this._$normalX$_ + h * this._$normalY$_);
                if (this._$reflectionX$_ = e - 2 * this._$normalX$_ * r, this._$reflectionY$_ = h - 2 * this._$normalY$_ * r, 
                0 < r) {
                    const n = Math.PI;
                    this._$hitNormal$_ = ja._$clampAngle$_(this._$hitNormal$_ + n), 
                    this._$normalX$_ = -this._$normalX$_, this._$normalY$_ = -this._$normalY$_;
                }
            }
        }
        _$TestInstanceSegment$_(t, s, i, e, h) {
            const r = ja._$rayIntersect$_(this.x1, this.y1, this.x2, this.y2, s, i, e, h);
            0 <= r && r < this._$hitFraction$_ && (this._$hitFraction$_ = r, this._$hitUid$_ = t._$GetUID$_(), 
            this._$hitNormalDx$_ = s - e, this._$hitNormalDy$_ = i - h);
        }
        _$TestInstanceRect$_(t, s, i, e) {
            const h = s + e._$getLeft$_(), r = s + e._$getRight$_(), n = i + e._$getTop$_(), o = i + e._$getBottom$_();
            this._$TestInstanceSegment$_(t, h, n, r, n), this._$TestInstanceSegment$_(t, r, n, r, o), 
            this._$TestInstanceSegment$_(t, r, o, h, o), this._$TestInstanceSegment$_(t, h, o, h, n);
        }
        _$TestInstanceQuad$_(t, s) {
            const i = s._$getTlx$_(), e = s._$getTly$_(), h = s._$getTrx$_(), r = s._$getTry$_(), n = s._$getBrx$_(), o = s._$getBry$_(), a = s._$getBlx$_(), l = s._$getBly$_();
            this._$TestInstanceSegment$_(t, i, e, h, r), this._$TestInstanceSegment$_(t, h, r, n, o), 
            this._$TestInstanceSegment$_(t, n, o, a, l), this._$TestInstanceSegment$_(t, a, l, i, e);
        }
        _$TestInstancePoly$_(i, e, h, t) {
            const r = t._$pointsArr$_();
            for (let t = 0, s = r.length; t < s; t += 2) {
                const n = (t + 2) % s, o = r[t] + e, a = r[t + 1] + h, l = r[n] + e, u = r[1 + n] + h;
                this._$TestInstanceSegment$_(i, o, a, l, u);
            }
        }
    };
}

{
    const v = self._$C3$_, Va = new Set([ "off", "crop", "scale-inner", "scale-outer", "letterbox-scale", "letterbox-integer-scale" ]), Ua = new Set([ "high", "low" ]), Ha = self._$glMatrix$_, xh = Ha._$mat4$_, Gh = Ha._$vec3$_, za = xh.create(), Ja = v._$New$_(v._$Quad$_), x = v._$New$_(v.Rect);
    v._$CanvasManager$_ = class extends v._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_runtime$_ = t, this._$_canvasLayers$_ = [], this._$_isWebGPUEnabled$_ = !1, 
            this._$_webglRenderer$_ = null, this._$_webgpuRenderer$_ = null, this._$_iRenderer$_ = null, 
            this._$_gpuPreference$_ = "high-performance", this._$_isLimitedToWebGL1$_ = !1, 
            this._$_windowInnerWidth$_ = 0, this._$_windowInnerHeight$_ = 0, this._$_cssDisplayMode$_ = "", 
            this._$_canvasCssWidth$_ = 0, this._$_canvasCssHeight$_ = 0, this._$_canvasDeviceWidth$_ = 0, 
            this._$_canvasDeviceHeight$_ = 0, this._$_canvasCssOffsetX$_ = 0, this._$_canvasCssOffsetY$_ = 0, 
            this._$_zAxisScale$_ = "normalized", this._$_initFieldOfView$_ = 0, 
            this._$_zNear$_ = 1, this._$_zFar$_ = 1e4, this._$_enableMipmaps$_ = !0, 
            this._$_textureAnisotropy$_ = 0, this._$_drawWidth$_ = 0, this._$_drawHeight$_ = 0, 
            this._$_fullscreenMode$_ = "letterbox-scale", this._$_documentFullscreenMode$_ = "letterbox-scale", 
            this._$_deviceTransformOffX$_ = 0, this._$_deviceTransformOffY$_ = 0, 
            this._$_defaultProjectionMatrix$_ = xh.create(), this._$_wantFullscreenScalingQuality$_ = "high", 
            this._$_fullscreenScalingQuality$_ = this._$_wantFullscreenScalingQuality$_, 
            this._$_isDocumentFullscreen$_ = !1, this._$_availableAdditionalRenderTargets$_ = [], 
            this._$_usedAdditionalRenderTargets$_ = new Set(), this._$_shaderData$_ = self.C3_Shaders, 
            this._$_effectChainManager$_ = v._$New$_(v._$Gfx$_._$EffectChainManager$_, {
                _$getDrawSize$_: () => [ this._$GetDrawWidth$_(), this._$GetDrawHeight$_() ],
                _$getRenderTarget$_: () => this._$GetEffectCompositorRenderTarget$_(),
                _$releaseRenderTarget$_: t => this._$ReleaseEffectCompositorRenderTarget$_(t),
                getTime: () => this._$GetRuntime$_()._$GetGameTime$_(),
                _$redraw$_: () => this._$GetRuntime$_()._$UpdateRender$_()
            }), this._$_gpuTimeStartFrame$_ = 0, this._$_gpuTimeEndFrame$_ = 0, 
            this._$_gpuLastUtilisation$_ = NaN, this._$_gpuFrameTimingsBuffer$_ = null, 
            this._$_layersGpuProfile$_ = new Map(), this._$_gpuCurUtilisation$_ = NaN, 
            this._$_webgpuFrameTimings$_ = new Map(), this._$_snapshotFormat$_ = "", 
            this._$_snapshotQuality$_ = 1, this._$_snapshotArea$_ = v._$New$_(v.Rect), 
            this._$_snapshotUrl$_ = "", this._$_snapshotPromise$_ = null, this._$_snapshotResolve$_ = null, 
            this._$_isPastingToDrawingCanvas$_ = 0, this._$_loaderStartTime$_ = 0, 
            this._$_rafId$_ = -1, this._$_loadingProgress$_ = 0, this._$_loadingprogress_handler$_ = t => this._$_loadingProgress$_ = t.progress, 
            this._$_percentText$_ = null, this._$_splashTextures$_ = {
                _$logo$_: null,
                _$powered$_: null,
                _$website$_: null
            }, this._$_splashFrameNumber$_ = 0, this._$_splashFadeInFinishTime$_ = 0, 
            this._$_splashFadeOutStartTime$_ = 0, this._$_splashState$_ = "fade-in", 
            this._$_splashDoneResolve$_ = null, this._$_splashDonePromise$_ = new Promise(t => this._$_splashDoneResolve$_ = t);
        }
        _$_SetGPUPowerPreference$_(t) {
            this._$_gpuPreference$_ = t;
        }
        _$_SetWebGPUEnabled$_(t) {
            this._$_isWebGPUEnabled$_ = !!t;
        }
        _$_SetZAxisScale$_(t) {
            this._$_zAxisScale$_ = t;
        }
        _$GetZAxisScale$_() {
            return this._$_zAxisScale$_;
        }
        _$_SetInitFieldOfView$_(t) {
            this._$_initFieldOfView$_ = t;
        }
        _$_SetZDistances$_(t, s) {
            this._$_zNear$_ = t, this._$_zFar$_ = s;
        }
        _$_SetLimitedToWebGL1$_(t) {
            this._$_isLimitedToWebGL1$_ = !!t;
        }
        async _$CreateCanvas$_(t) {
            let s = t.canvas, i = (this._$_canvasLayers$_.push({
                canvas: s,
                _$ctx$_: null
            }), this._$_runtime$_._$AddDOMComponentMessageHandler$_("runtime", "window-resize", t => this._$_OnWindowResize$_(t)), 
            this._$_runtime$_._$AddDOMComponentMessageHandler$_("runtime", "fullscreenchange", t => this._$_OnFullscreenChange$_(t)), 
            this._$_runtime$_._$AddDOMComponentMessageHandler$_("runtime", "fullscreenerror", t => this._$_OnFullscreenError$_(t)), 
            s.addEventListener("webglcontextlost", t => this._$_OnWebGLContextLost$_(t)), 
            s.addEventListener("webglcontextrestored", t => this._$_OnWebGLContextRestored$_(t)), 
            this._$_isDocumentFullscreen$_ = !!t.isFullscreen, this._$_cssDisplayMode$_ = t.cssDisplayMode, 
            navigator.gpu && this._$_isWebGPUEnabled$_), e = !1;
            if (i) try {
                await this._$_InitWebGPUContext$_(!0);
            } catch (t) {
                this._$_MaybeLogRendererError$_("WebGPU", t), this._$_webgpuRenderer$_ = null;
            }
            if (!this._$GetRenderer$_()) try {
                await this._$_InitWebGLContext$_(!0);
            } catch (t) {
                this._$_MaybeLogRendererError$_("WebGL", t), this._$_webglRenderer$_ = null;
            }
            if (this._$GetRenderer$_() || (e = !0), !this._$GetRenderer$_() && i) try {
                await this._$_InitWebGPUContext$_(!1);
            } catch (t) {
                this._$_MaybeLogRendererError$_("WebGPU", t), this._$_webgpuRenderer$_ = null;
            }
            if (!this._$GetRenderer$_()) try {
                await this._$_InitWebGLContext$_(!1);
            } catch (t) {
                this._$_MaybeLogRendererError$_("WebGL", t), this._$_webglRenderer$_ = null;
            }
            const h = this._$GetRenderer$_();
            if (!h) throw new Error("failed to acquire a renderer - check WebGL or WebGPU is supported");
            h._$SetHasMajorPerformanceCaveat$_(e), this._$_webgpuRenderer$_ && (this._$_webgpuRenderer$_._$ondevicelost$_ = () => this._$_OnWebGPUDeviceLost$_(), 
            this._$_webgpuRenderer$_._$ondevicerestored$_ = () => this._$_OnWebGPUDeviceRestored$_()), 
            "normalized" === this._$_zAxisScale$_ ? h._$SetZAxisScaleNormalized$_() : (h._$SetZAxisScaleRegular$_(), 
            h._$SetFovY$_(this._$_initFieldOfView$_)), this._$SetSize$_(t.windowInnerWidth, t.windowInnerHeight, !0), 
            await this._$_InitRenderer$_();
        }
        _$_MaybeLogRendererError$_(t, s) {
            s && "string" == typeof s.message && s.message.startsWith("renderer-unavailable") || console.error(`Error creating ${t} renderer: `, s);
        }
        async _$_InitWebGPUContext$_(t) {
            const s = {
                _$nearZ$_: this._$_zNear$_,
                _$farZ$_: this._$_zFar$_
            }, i = {
                powerPreference: this._$_gpuPreference$_,
                depth: this._$_runtime$_._$Uses3DFeatures$_(),
                failIfMajorPerformanceCaveat: t,
                _$usesBackgroundBlending$_: this._$_runtime$_._$UsesAnyBackgroundBlending$_(),
                _$canSampleBackbuffer$_: this._$_runtime$_._$UsesAnyCrossSampling$_(),
                _$canSampleDepth$_: this._$_runtime$_._$UsesAnyDepthSampling$_()
            };
            this._$_webgpuRenderer$_ = v._$New$_(v._$Gfx$_.WebGPURenderer, s), await this._$_webgpuRenderer$_._$Create$_(this._$_canvasLayers$_[0].canvas, i);
        }
        async _$_InitWebGLContext$_(t) {
            const s = {
                alpha: !0,
                powerPreference: this._$_gpuPreference$_,
                _$enableGpuProfiling$_: "xbox-uwp-webview2" !== this._$_runtime$_._$GetExportType$_(),
                depth: this._$_runtime$_._$Uses3DFeatures$_(),
                _$canSampleDepth$_: this._$_runtime$_._$UsesAnyDepthSampling$_(),
                failIfMajorPerformanceCaveat: t,
                _$nearZ$_: this._$_zNear$_,
                _$farZ$_: this._$_zFar$_
            };
            this._$_isLimitedToWebGL1$_ && (s._$maxWebGLVersion$_ = 1), this._$_webglRenderer$_ = v._$New$_(v._$Gfx$_._$WebGLRenderer$_, this._$_canvasLayers$_[0].canvas, s), 
            await this._$_webglRenderer$_._$InitState$_();
        }
        async _$_InitWebGPU$_() {
            if (this._$_shaderData$_) {
                const t = [];
                for (const [ s, i ] of Object.entries(this._$_shaderData$_)) {
                    i.src = i.wgsl;
                    const e = v._$Gfx$_.WebGPUShaderProgram._$GetDefaultVertexShaderSource$_();
                    t.push(this._$_webgpuRenderer$_._$CreateShaderProgram$_(Object.assign({
                        _$vertexSrc$_: e,
                        name: s
                    }, i)));
                }
                await Promise.all(t);
            }
        }
        async _$_InitWebGL$_() {
            if (this._$_shaderData$_) {
                const s = [];
                for (const [ i, e ] of Object.entries(this._$_shaderData$_)) {
                    let t;
                    if (e.glslWebGL2 && 2 <= this._$_webglRenderer$_._$GetWebGLVersionNumber$_()) e.src = e.glslWebGL2, 
                    t = v._$Gfx$_._$WebGLShaderProgram$_._$GetDefaultVertexShaderSource_WebGL2$_(); else {
                        if (!e.glsl) throw new Error(`shader '${i}' does not support WebGL 1`);
                        e.src = e.glsl, t = v._$Gfx$_._$WebGLShaderProgram$_._$GetDefaultVertexShaderSource$_();
                    }
                    s.push(this._$_webglRenderer$_._$CreateShaderProgram$_(Object.assign({
                        _$vertexSrc$_: t,
                        name: i
                    }, e)));
                }
                await Promise.all(s), this._$_webglRenderer$_._$ResetLastProgram$_(), 
                this._$_webglRenderer$_._$SetTextureFillMode$_();
            }
            this._$_webglRenderer$_._$SupportsGPUProfiling$_() && (this._$_gpuFrameTimingsBuffer$_ = v._$New$_(v._$Gfx$_._$WebGLQueryResultBuffer$_, this._$_webglRenderer$_));
        }
        async _$_InitRenderer$_() {
            this._$_webgpuRenderer$_ ? await this._$_InitWebGPU$_() : this._$_webglRenderer$_ && await this._$_InitWebGL$_();
            const t = this._$GetRenderer$_();
            t._$SetMipmapsEnabled$_(this._$_enableMipmaps$_), t._$SupportsGPUProfiling$_() && (this._$_gpuLastUtilisation$_ = 0);
            for (const s of this._$_runtime$_._$_GetAllEffectLists$_()) {
                for (const i of s._$GetAllEffectTypes$_()) i._$_InitRenderer$_(t);
                s._$_InitRenderer$_(t), s._$UpdateActiveEffects$_();
            }
            this._$_iRenderer$_ = new self._$IRenderer$_(this._$_runtime$_, t);
        }
        _$Release$_() {
            this._$_runtime$_ = null, this._$_webglRenderer$_ = null, this._$_canvasLayers$_.length = 0;
        }
        _$IsInWorker$_() {
            return this._$_runtime$_._$IsInWorker$_();
        }
        _$_OnWindowResize$_(t) {
            const s = this._$_runtime$_;
            if (!s._$IsExportToVideo$_()) {
                const i = t.devicePixelRatio, e = (this._$IsInWorker$_() && (self.devicePixelRatio = i), 
                s._$_SetDevicePixelRatio$_(i), this._$_isDocumentFullscreen$_ = !!t.isFullscreen, 
                this._$_cssDisplayMode$_ = t.cssDisplayMode, this._$SetSize$_(t.innerWidth, t.innerHeight), 
                s._$UpdateRender$_(), new v.Event("window-resize")), h = (e.data = t, 
                s._$Dispatcher$_()._$dispatchEventAndWaitAsyncSequential$_(e), new v.Event("resize"));
                h._$cssWidth$_ = this._$GetCssWidth$_(), h._$cssHeight$_ = this._$GetCssHeight$_(), 
                h._$deviceWidth$_ = this._$GetDeviceWidth$_(), h._$deviceHeight$_ = this._$GetDeviceHeight$_(), 
                s._$DispatchUserScriptEvent$_(h), s._$IsDebug$_() && (s._$HitBreakpoint$_() || self.C3Debugger.IsDebuggerPaused()) && s._$Render$_();
            }
        }
        _$_OnFullscreenChange$_(t) {
            this._$_isDocumentFullscreen$_ = !!t.isFullscreen, this._$SetSize$_(t.innerWidth, t.innerHeight, !0), 
            this._$_runtime$_._$UpdateRender$_();
        }
        _$_OnFullscreenError$_(t) {
            this._$_isDocumentFullscreen$_ = !!t.isFullscreen, this._$SetSize$_(t.innerWidth, t.innerHeight, !0), 
            this._$_runtime$_._$UpdateRender$_();
        }
        _$SetSize$_(t, s, i = !1) {
            if (t = Math.floor(t), s = Math.floor(s), t <= 0 || s <= 0) throw new Error("invalid size");
            if (this._$_windowInnerWidth$_ !== t || this._$_windowInnerHeight$_ !== s || i) {
                this._$_windowInnerWidth$_ = t, this._$_windowInnerHeight$_ = s;
                const e = this._$GetCurrentFullscreenMode$_();
                "letterbox-scale" === e ? this._$_CalculateLetterboxScale$_(t, s) : "letterbox-integer-scale" === e ? this._$_CalculateLetterboxIntegerScale$_(t, s) : "off" === e ? this._$_CalculateFixedSizeCanvas$_(t, s) : this._$_CalculateFullsizeCanvas$_(t, s), 
                this._$_UpdateFullscreenScalingQuality$_(e);
                for (const {
                    canvas: n
                } of this._$_canvasLayers$_) n.width = this._$_canvasDeviceWidth$_, 
                n.height = this._$_canvasDeviceHeight$_;
                this._$_runtime$_._$PostComponentMessageToDOM$_("canvas", "update-size", {
                    marginLeft: this._$_canvasCssOffsetX$_,
                    marginTop: this._$_canvasCssOffsetY$_,
                    styleWidth: this._$_canvasCssWidth$_,
                    styleHeight: this._$_canvasCssHeight$_,
                    displayScale: this._$GetDisplayScale$_()
                });
                const h = this._$GetRenderer$_();
                h._$SetSize$_(this._$_canvasDeviceWidth$_, this._$_canvasDeviceHeight$_, !0);
                for (const o of this._$_availableAdditionalRenderTargets$_) h._$DeleteRenderTarget$_(o);
                v._$clearArray$_(this._$_availableAdditionalRenderTargets$_), this._$UpdateDefaultProjectionMatrix$_();
                const r = this._$_runtime$_._$GetLayoutManager$_();
                r._$SetAllLayerProjectionChanged$_(), r._$SetAllLayerMVChanged$_();
            }
        }
        _$UpdateDefaultProjectionMatrix$_() {
            this._$GetRenderer$_()._$CalculatePerspectiveMatrix$_(this._$_defaultProjectionMatrix$_, this._$GetDrawWidth$_() / this._$GetDrawHeight$_());
        }
        _$GetDefaultProjectionMatrix$_() {
            return this._$_defaultProjectionMatrix$_;
        }
        _$_CalculateLetterboxScale$_(t, s) {
            const i = this._$_runtime$_._$GetDevicePixelRatio$_(), e = this._$_runtime$_._$GetOriginalViewportWidth$_(), h = this._$_runtime$_._$GetOriginalViewportHeight$_(), r = e / h, n = t / s;
            if (r < n) {
                const o = s * r;
                this._$_canvasCssWidth$_ = Math.round(o), this._$_canvasCssHeight$_ = s, 
                this._$_canvasCssOffsetX$_ = Math.floor((t - this._$_canvasCssWidth$_) / 2), 
                this._$_canvasCssOffsetY$_ = 0;
            } else {
                const a = t / r;
                this._$_canvasCssWidth$_ = t, this._$_canvasCssHeight$_ = Math.round(a), 
                this._$_canvasCssOffsetX$_ = 0, this._$_canvasCssOffsetY$_ = Math.floor((s - this._$_canvasCssHeight$_) / 2);
            }
            this._$_canvasDeviceWidth$_ = Math.round(this._$_canvasCssWidth$_ * i), 
            this._$_canvasDeviceHeight$_ = Math.round(this._$_canvasCssHeight$_ * i), 
            this._$_runtime$_._$SetViewportSize$_(e, h);
        }
        _$_CalculateLetterboxIntegerScale$_(t, s) {
            let i = this._$_runtime$_._$GetDevicePixelRatio$_(), e = (1 !== i && (t += 1, 
            s += 1), this._$_runtime$_._$GetOriginalViewportWidth$_()), h = this._$_runtime$_._$GetOriginalViewportHeight$_(), r = e / h, n = t / s, o;
            if (r < n) {
                const a = s * r;
                o = a * i / e;
            } else {
                const l = t / r;
                o = l * i / h;
            }
            1 < o ? o = Math.floor(o) : o < 1 && (o = 1 / Math.ceil(1 / o)), this._$_canvasDeviceWidth$_ = Math.round(e * o), 
            this._$_canvasDeviceHeight$_ = Math.round(h * o), this._$_canvasCssWidth$_ = this._$_canvasDeviceWidth$_ / i, 
            this._$_canvasCssHeight$_ = this._$_canvasDeviceHeight$_ / i, this._$_canvasCssOffsetX$_ = Math.max(Math.floor((t - this._$_canvasCssWidth$_) / 2), 0), 
            this._$_canvasCssOffsetY$_ = Math.max(Math.floor((s - this._$_canvasCssHeight$_) / 2), 0), 
            this._$_runtime$_._$SetViewportSize$_(e, h);
        }
        _$_CalculateFullsizeCanvas$_(t, s) {
            const i = this._$_runtime$_._$GetDevicePixelRatio$_(), e = (this._$_canvasCssWidth$_ = t, 
            this._$_canvasCssHeight$_ = s, this._$_canvasDeviceWidth$_ = Math.round(this._$_canvasCssWidth$_ * i), 
            this._$_canvasDeviceHeight$_ = Math.round(this._$_canvasCssHeight$_ * i), 
            this._$_canvasCssOffsetX$_ = 0, this._$_canvasCssOffsetY$_ = 0, this._$GetDisplayScale$_());
            this._$_runtime$_._$SetViewportSize$_(this._$_canvasCssWidth$_ / e, this._$_canvasCssHeight$_ / e);
        }
        _$_CalculateFixedSizeCanvas$_(t, s) {
            const i = this._$_runtime$_._$GetDevicePixelRatio$_();
            this._$_canvasCssWidth$_ = this._$_runtime$_._$GetViewportWidth$_(), 
            this._$_canvasCssHeight$_ = this._$_runtime$_._$GetViewportHeight$_(), 
            this._$_canvasDeviceWidth$_ = Math.round(this._$_canvasCssWidth$_ * i), 
            this._$_canvasDeviceHeight$_ = Math.round(this._$_canvasCssHeight$_ * i), 
            this._$IsDocumentFullscreen$_() ? (this._$_canvasCssOffsetX$_ = Math.floor((t - this._$_canvasCssWidth$_) / 2), 
            this._$_canvasCssOffsetY$_ = Math.floor((s - this._$_canvasCssHeight$_) / 2)) : (this._$_canvasCssOffsetX$_ = 0, 
            this._$_canvasCssOffsetY$_ = 0), this._$_runtime$_._$SetViewportSize$_(this._$_runtime$_._$GetViewportWidth$_(), this._$_runtime$_._$GetViewportHeight$_());
        }
        _$_UpdateFullscreenScalingQuality$_(i) {
            if ("high" === this._$_wantFullscreenScalingQuality$_) this._$_drawWidth$_ = this._$_canvasDeviceWidth$_, 
            this._$_drawHeight$_ = this._$_canvasDeviceHeight$_, this._$_fullscreenScalingQuality$_ = "high"; else {
                let t, s;
                if (s = "off" === this._$GetCurrentFullscreenMode$_() ? (t = this._$_runtime$_._$GetViewportWidth$_(), 
                this._$_runtime$_._$GetViewportHeight$_()) : (t = this._$_runtime$_._$GetOriginalViewportWidth$_(), 
                this._$_runtime$_._$GetOriginalViewportHeight$_()), this._$_canvasDeviceWidth$_ < t || this._$_canvasDeviceHeight$_ < s) this._$_drawWidth$_ = this._$_canvasDeviceWidth$_, 
                this._$_drawHeight$_ = this._$_canvasDeviceHeight$_, this._$_fullscreenScalingQuality$_ = "high"; else if (this._$_drawWidth$_ = t, 
                this._$_drawHeight$_ = s, this._$_fullscreenScalingQuality$_ = "low", 
                "scale-inner" === i) {
                    const e = t / s, h = this._$_windowInnerWidth$_ / this._$_windowInnerHeight$_;
                    h < e ? this._$_drawWidth$_ = this._$_drawHeight$_ * h : e < h && (this._$_drawHeight$_ = this._$_drawWidth$_ / h);
                } else if ("scale-outer" === i) {
                    const r = t / s, n = this._$_windowInnerWidth$_ / this._$_windowInnerHeight$_;
                    r < n ? this._$_drawWidth$_ = this._$_drawHeight$_ * n : n < r && (this._$_drawHeight$_ = this._$_drawWidth$_ / n);
                }
            }
        }
        _$GetRuntime$_() {
            return this._$_runtime$_;
        }
        _$GetMainCanvas$_() {
            return this._$_canvasLayers$_[0].canvas;
        }
        _$GetEffectChainManager$_() {
            return this._$_effectChainManager$_;
        }
        _$IsDocumentFullscreen$_() {
            return this._$_isDocumentFullscreen$_;
        }
        _$GetCssDisplayMode$_() {
            return this._$_cssDisplayMode$_;
        }
        _$SetFullscreenMode$_(t) {
            if (!Va.has(t)) throw new Error("invalid fullscreen mode");
            this._$_fullscreenMode$_ = t;
            const s = this._$_runtime$_._$GetLayoutManager$_();
            s._$SetAllLayerProjectionChanged$_(), s._$SetAllLayerMVChanged$_();
        }
        _$GetFullscreenMode$_() {
            return this._$_fullscreenMode$_;
        }
        _$SetDocumentFullscreenMode$_(t) {
            if (!Va.has(t)) throw new Error("invalid fullscreen mode");
            this._$_documentFullscreenMode$_ = t;
            const s = this._$_runtime$_._$GetLayoutManager$_();
            s._$SetAllLayerProjectionChanged$_(), s._$SetAllLayerMVChanged$_();
        }
        _$GetDocumentFullscreenMode$_() {
            return this._$_documentFullscreenMode$_;
        }
        _$GetCurrentFullscreenMode$_() {
            return this._$IsDocumentFullscreen$_() ? this._$GetDocumentFullscreenMode$_() : this._$GetFullscreenMode$_();
        }
        _$SetFullscreenScalingQuality$_(t) {
            if (!Ua.has(t)) throw new Error("invalid fullscreen scaling quality");
            this._$_wantFullscreenScalingQuality$_ = t, this._$_runtime$_._$GetLayoutManager$_()._$SetAllLayerProjectionChanged$_();
        }
        _$GetSetFullscreenScalingQuality$_() {
            return this._$_wantFullscreenScalingQuality$_;
        }
        _$GetCurrentFullscreenScalingQuality$_() {
            return this._$_fullscreenScalingQuality$_;
        }
        static _$_FullscreenModeNumberToString$_(t) {
            switch (t) {
              case 0:
                return "off";

              case 1:
                return "crop";

              case 2:
                return "scale-inner";

              case 3:
                return "scale-outer";

              case 4:
                return "letterbox-scale";

              case 5:
                return "letterbox-integer-scale";

              default:
                throw new Error("invalid fullscreen mode");
            }
        }
        _$GetLastWidth$_() {
            return this._$_windowInnerWidth$_;
        }
        _$GetLastHeight$_() {
            return this._$_windowInnerHeight$_;
        }
        _$GetDrawWidth$_() {
            return this._$_drawWidth$_;
        }
        _$GetDrawHeight$_() {
            return this._$_drawHeight$_;
        }
        _$SetMipmapsEnabled$_(t) {
            this._$_enableMipmaps$_ = !!t;
        }
        _$_SetTextureAnisotropy$_(t) {
            this._$_textureAnisotropy$_ = t;
        }
        _$GetTextureAnisotropy$_() {
            return this._$_textureAnisotropy$_;
        }
        _$IsRendererContextLost$_() {
            return this._$GetRenderer$_()._$IsContextLost$_();
        }
        _$_OnWebGLContextLost$_(t) {
            console.log("[Construct] WebGL context lost"), t.preventDefault(), this._$_availableAdditionalRenderTargets$_ = [], 
            this._$_usedAdditionalRenderTargets$_.clear(), this._$_effectChainManager$_._$OnContextLost$_(), 
            this._$_webglRenderer$_._$OnContextLost$_(), this._$_runtime$_._$_OnRendererContextLost$_();
        }
        _$_OnWebGPUDeviceLost$_() {
            console.log("[Construct] WebGPU device lost"), this._$_availableAdditionalRenderTargets$_ = [], 
            this._$_usedAdditionalRenderTargets$_.clear(), this._$_effectChainManager$_._$OnContextLost$_(), 
            this._$_runtime$_._$_OnRendererContextLost$_();
        }
        async _$_OnWebGLContextRestored$_(t) {
            await this._$_webglRenderer$_._$OnContextRestored$_(), await this._$_InitRenderer$_(), 
            await this._$_runtime$_._$_OnRendererContextRestored$_(), console.log("[Construct] WebGL context restored");
        }
        async _$_OnWebGPUDeviceRestored$_() {
            await this._$_InitRenderer$_(), await this._$_runtime$_._$_OnRendererContextRestored$_(), 
            console.log("[Construct] WebGPU device restored");
        }
        _$GetWebGLRenderer$_() {
            return this._$_webglRenderer$_;
        }
        _$GetWebGPURenderer$_() {
            return this._$_webgpuRenderer$_;
        }
        _$GetRenderer$_() {
            return this._$_webgpuRenderer$_ || this._$_webglRenderer$_;
        }
        _$GetIRenderer$_() {
            return this._$_iRenderer$_;
        }
        _$GetRenderScale$_() {
            return "low" === this._$_fullscreenScalingQuality$_ ? 1 / this._$_runtime$_._$GetDevicePixelRatio$_() : this._$GetDisplayScale$_();
        }
        _$GetDisplayScale$_() {
            const t = this._$GetCurrentFullscreenMode$_();
            if ("off" === t || "crop" === t) return 1;
            const s = this._$_runtime$_._$GetOriginalViewportWidth$_(), i = this._$_runtime$_._$GetOriginalViewportHeight$_(), e = s / i, h = this._$_canvasDeviceWidth$_ / this._$_canvasDeviceHeight$_;
            return "scale-inner" !== t && e < h || "scale-inner" === t && h < e ? this._$_canvasCssHeight$_ / i : this._$_canvasCssWidth$_ / s;
        }
        _$GetEffectLayerScaleParam$_() {
            return "low" === this._$GetCurrentFullscreenScalingQuality$_() ? 1 : this._$GetDisplayScale$_();
        }
        _$GetEffectDevicePixelRatioParam$_() {
            return "low" === this._$GetCurrentFullscreenScalingQuality$_() ? 1 : this._$_runtime$_._$GetDevicePixelRatio$_();
        }
        _$SetDeviceTransformOffset$_(t, s) {
            this._$_deviceTransformOffX$_ = t, this._$_deviceTransformOffY$_ = s;
        }
        _$SetDeviceTransform$_(s, i, e, t = !0) {
            i = i || this._$_drawWidth$_, e = e || this._$_drawHeight$_;
            const h = i / 2 + this._$_deviceTransformOffX$_, r = e / 2 + this._$_deviceTransformOffY$_;
            if (t) {
                let t = this._$GetDefaultProjectionMatrix$_();
                i === this._$_drawWidth$_ && e === this._$_drawHeight$_ || (s._$CalculatePerspectiveMatrix$_(za, i / e), 
                t = za), s._$SetProjectionMatrix$_(t);
            }
            const n = s._$CalculateLookAtModelView2$_(h, r, s._$GetDefaultCameraZ$_(e), h, r, 0, e);
            s._$SetModelViewMatrix$_(n);
        }
        _$SetCssTransform$_(t, s = !0) {
            const i = this._$GetCssWidth$_(), e = this._$GetCssHeight$_(), h = i / 2, r = e / 2, n = (s && t._$SetProjectionMatrix$_(this._$GetDefaultProjectionMatrix$_()), 
            t._$CalculateLookAtModelView2$_(h, r, t._$GetDefaultCameraZ$_(e), h, r, 0, e));
            t._$SetModelViewMatrix$_(n);
        }
        _$GetDeviceWidth$_() {
            return this._$_canvasDeviceWidth$_;
        }
        _$GetDeviceHeight$_() {
            return this._$_canvasDeviceHeight$_;
        }
        _$GetCssWidth$_() {
            return this._$_canvasCssWidth$_;
        }
        _$GetCssHeight$_() {
            return this._$_canvasCssHeight$_;
        }
        _$GetCanvasClientX$_() {
            return this._$_canvasCssOffsetX$_;
        }
        _$GetCanvasClientY$_() {
            return this._$_canvasCssOffsetY$_;
        }
        _$GetHTMLLayerCount$_() {
            return this._$_canvasLayers$_.length;
        }
        _$_CanUseImageBitmapRenderingContext$_() {
            return "undefined" != typeof OffscreenCanvas && this._$GetMainCanvas$_() instanceof OffscreenCanvas && ("Chromium" !== v._$Platform$_._$BrowserEngine$_ || 124 <= v._$Platform$_._$BrowserVersionNumber$_);
        }
        async _$SetHTMLLayerCount$_(i, e = !1) {
            if (i < 1) throw new Error("invalid HTML layer count");
            if (this._$_canvasLayers$_.length !== i) {
                let t = {
                    count: i,
                    immediate: e,
                    marginLeft: this._$_canvasCssOffsetX$_,
                    marginTop: this._$_canvasCssOffsetY$_,
                    styleWidth: this._$_canvasCssWidth$_,
                    styleHeight: this._$_canvasCssHeight$_
                }, s;
                if (s = this._$IsInWorker$_() ? await this._$_runtime$_._$PostComponentMessageToDOMAsync$_("canvas", "set-html-layer-count", t) : self.c3_runtimeInterface._OnSetHTMLLayerCount(t), 
                i < this._$_canvasLayers$_.length) this._$_canvasLayers$_.length = i; else for (const h of s.addedCanvases) {
                    h.width = this._$_canvasDeviceWidth$_, h.height = this._$_canvasDeviceHeight$_;
                    const r = this._$_CanUseImageBitmapRenderingContext$_() ? "bitmaprenderer" : "2d", n = h.getContext(r);
                    if (!n) throw new Error(`failed to acquire '${r}' canvas context`);
                    this._$_canvasLayers$_.push({
                        canvas: h,
                        _$ctx$_: n
                    });
                }
                this._$_runtime$_._$UpdateRender$_();
            }
        }
        _$BlitMainCanvasToHTMLLayerCanvas$_(t) {
            if (!(t >= this._$_canvasLayers$_.length)) {
                const s = this._$GetMainCanvas$_(), i = this._$_canvasLayers$_[t]._$ctx$_;
                this._$_CanUseImageBitmapRenderingContext$_() ? i.transferFromImageBitmap(s.transferToImageBitmap()) : (i.globalCompositeOperation = "copy", 
                i.drawImage(s, 0, 0));
            }
        }
        _$GetAdditionalRenderTarget$_(s) {
            s.depth = this._$_runtime$_._$Uses3DFeatures$_();
            let t = this._$_availableAdditionalRenderTargets$_, i = t.findIndex(t => t._$IsCompatibleWithOptions$_(s)), e;
            return -1 !== i ? (e = t[i], t.splice(i, 1)) : e = this._$GetRenderer$_()._$CreateRenderTarget$_(s), 
            this._$_usedAdditionalRenderTargets$_.add(e), e;
        }
        _$ReleaseAdditionalRenderTarget$_(t) {
            if (!this._$_usedAdditionalRenderTargets$_.has(t)) throw new Error("render target not in use");
            this._$_usedAdditionalRenderTargets$_.delete(t), this._$_availableAdditionalRenderTargets$_.push(t);
        }
        _$GetEffectCompositorRenderTarget$_() {
            const t = {
                _$sampling$_: this._$_runtime$_._$GetSampling$_()
            };
            return "low" === this._$GetCurrentFullscreenScalingQuality$_() && (t.width = this._$GetDrawWidth$_(), 
            t.height = this._$GetDrawHeight$_()), this._$GetAdditionalRenderTarget$_(t);
        }
        _$ReleaseEffectCompositorRenderTarget$_(t) {
            this._$ReleaseAdditionalRenderTarget$_(t);
        }
        *_$activeLayersGpuProfiles$_() {
            for (const t of this._$_runtime$_._$GetLayoutManager$_()._$runningLayouts$_()) for (const s of t._$GetLayers$_()) {
                const i = this._$_layersGpuProfile$_.get(s);
                i && (yield i);
            }
        }
        _$GetLayerTimingsBuffer$_(t) {
            if (!this._$GetRenderer$_()._$SupportsGPUProfiling$_()) return null;
            let s = this._$_layersGpuProfile$_.get(t);
            return s || (s = {
                _$layer$_: t,
                name: t._$GetName$_(),
                _$timingsBuffer$_: v._$New$_(v._$Gfx$_._$WebGLQueryResultBuffer$_, this._$_webglRenderer$_),
                _$curUtilisation$_: 0,
                _$lastTotalUtilisation$_: 0,
                _$lastSelfUtilisation$_: 0
            }, this._$_layersGpuProfile$_.set(t, s)), s._$timingsBuffer$_;
        }
        _$_Update1sFrameRange$_() {
            const t = this._$GetRenderer$_();
            if (t._$SupportsGPUProfiling$_() && 0 === this._$_gpuTimeEndFrame$_) {
                this._$_gpuTimeEndFrame$_ = t._$GetFrameNumber$_(), this._$_gpuCurUtilisation$_ = NaN;
                for (const s of this._$activeLayersGpuProfiles$_()) s._$curUtilisation$_ = NaN;
            }
        }
        _$_UpdateTick$_() {
            this._$_webglRenderer$_ && this._$_webglRenderer$_._$SupportsGPUProfiling$_() && this._$_UpdateTick_WebGL$_(), 
            this._$_webgpuRenderer$_ && this._$_webgpuRenderer$_._$SupportsGPUProfiling$_() && this._$_UpdateTick_WebGPU$_();
        }
        _$_UpdateTick_WebGL$_() {
            if (isNaN(this._$_gpuCurUtilisation$_) && (this._$_gpuCurUtilisation$_ = this._$_gpuFrameTimingsBuffer$_._$GetFrameRangeResultSum$_(this._$_gpuTimeStartFrame$_, this._$_gpuTimeEndFrame$_), 
            !isNaN(this._$_gpuCurUtilisation$_))) {
                if (this._$_runtime$_._$IsDebug$_()) for (const t of this._$activeLayersGpuProfiles$_()) if (t._$curUtilisation$_ = t._$timingsBuffer$_._$GetFrameRangeResultSum$_(this._$_gpuTimeStartFrame$_, this._$_gpuTimeEndFrame$_), 
                isNaN(t._$curUtilisation$_)) return;
                if (this._$_gpuFrameTimingsBuffer$_._$DeleteAllBeforeFrameNumber$_(this._$_gpuTimeEndFrame$_), 
                this._$_gpuLastUtilisation$_ = Math.min(this._$_gpuCurUtilisation$_, 1), 
                this._$_runtime$_._$IsDebug$_()) {
                    const i = new Map();
                    for (const h of this._$activeLayersGpuProfiles$_()) h._$timingsBuffer$_._$DeleteAllBeforeFrameNumber$_(this._$_gpuTimeEndFrame$_), 
                    h._$lastTotalUtilisation$_ = Math.min(h._$curUtilisation$_, 1), 
                    i.set(h._$layer$_, h._$lastTotalUtilisation$_);
                    for (const r of this._$activeLayersGpuProfiles$_()) {
                        const n = r._$layer$_, o = i.get(n) || 0, a = o - n._$GetSubLayers$_().reduce((t, s) => t + (i.get(s) || 0), 0);
                        r._$lastSelfUtilisation$_ = v._$clamp$_(a, 0, 1);
                    }
                    const s = this._$_runtime$_._$GetMainRunningLayout$_(), e = this._$_gpuLastUtilisation$_ - s._$_GetRootLayers$_().reduce((t, s) => t + (i.get(s) || 0), 0);
                    self.C3Debugger.UpdateGPUProfile(v._$clamp$_(e, 0, 1), this._$_gpuLastUtilisation$_, [ ...this._$activeLayersGpuProfiles$_() ]);
                }
                this._$_gpuTimeStartFrame$_ = this._$_gpuTimeEndFrame$_, this._$_gpuTimeEndFrame$_ = 0;
            }
        }
        _$GetGPUFrameTimingsBuffer$_() {
            return this._$_gpuFrameTimingsBuffer$_;
        }
        _$_UpdateTick_WebGPU$_() {
            if (0 !== this._$_gpuTimeEndFrame$_) {
                for (let t = this._$_gpuTimeStartFrame$_; t < this._$_gpuTimeEndFrame$_; ++t) {
                    const i = this._$_webgpuFrameTimings$_.get(t);
                    if (i && !i._$HasResult$_()) return;
                }
                let t = this._$_runtime$_._$GetMainRunningLayout$_(), n = v._$MakeFilledArray$_(t._$GetLayerCount$_() + 1, 0), s = 0;
                for (let t = this._$_gpuTimeStartFrame$_; t < this._$_gpuTimeEndFrame$_; ++t) {
                    const o = this._$_webgpuFrameTimings$_.get(t);
                    if (o) {
                        let i = o._$GetResult$_(), e = BigInt(0), h = BigInt(0), r = BigInt(0);
                        for (let t = 0, s = Math.min(n.length, i.length / 2); t < s; ++t) {
                            const u = i[2 * t], c = i[2 * t + 1], f = (u !== r && (e === r || u < e) && (e = u), 
                            c > h && (h = c), c - u), d = Number(f) / 1e9;
                            n[t] += d;
                        }
                        const a = h - e, l = Number(a) / 1e9;
                        s += l;
                    }
                }
                if (this._$_gpuLastUtilisation$_ = v._$clamp$_(s, 0, 1), this._$_runtime$_._$IsDebug$_()) {
                    const e = t._$GetLayers$_(), h = new Map();
                    for (let t = 0, s = Math.min(e.length, n.length - 1); t < s; ++t) {
                        const g = n[t + 1];
                        h.set(e[t], g);
                    }
                    const r = [], p = new Map();
                    for (const [ y, w ] of h) {
                        const S = [ ...y._$selfAndAllSubLayers$_() ].reduce((t, s) => t + (h.get(s) || 0), 0);
                        p.set(y, S), r.push({
                            name: y._$GetName$_(),
                            _$lastSelfUtilisation$_: v._$clamp$_(w, 0, 1),
                            _$lastTotalUtilisation$_: v._$clamp$_(S, 0, 1)
                        });
                    }
                    const m = this._$_gpuLastUtilisation$_ - t._$_GetRootLayers$_().reduce((t, s) => t + (p.get(s) || 0), 0);
                    self.C3Debugger.UpdateGPUProfile(v._$clamp$_(m, 0, 1), this._$_gpuLastUtilisation$_, r);
                }
                for (let t = this._$_gpuTimeStartFrame$_; t < this._$_gpuTimeEndFrame$_; ++t) this._$_webgpuFrameTimings$_.delete(t);
                this._$_gpuTimeStartFrame$_ = this._$_gpuTimeEndFrame$_, this._$_gpuTimeEndFrame$_ = 0;
            }
        }
        _$_AddWebGPUFrameTiming$_(t) {
            this._$_webgpuFrameTimings$_.set(this._$_webgpuRenderer$_._$GetFrameNumber$_(), t);
        }
        _$GetGPUUtilisation$_() {
            return this._$_gpuLastUtilisation$_;
        }
        _$SnapshotCanvas$_(t, s, i, e, h, r) {
            return this._$_snapshotFormat$_ = t, this._$_snapshotQuality$_ = s, 
            this._$_snapshotArea$_._$setWH$_(i, e, h, r), this._$_snapshotPromise$_ || (this._$_snapshotPromise$_ = new Promise(t => {
                this._$_snapshotResolve$_ = t;
            })), this._$_snapshotPromise$_;
        }
        _$_MaybeTakeSnapshot$_() {
            if (this._$_snapshotFormat$_) {
                let t = this._$GetMainCanvas$_(), s = this._$_snapshotArea$_, i = v._$clamp$_(Math.floor(s._$getLeft$_()), 0, t.width), e = v._$clamp$_(Math.floor(s._$getTop$_()), 0, t.height), h = s.width(), r = (h = 0 === h ? t.width - i : v._$clamp$_(Math.floor(h), 0, t.width - i), 
                s.height());
                if (r = 0 === r ? t.height - e : v._$clamp$_(Math.floor(r), 0, t.height - e), 
                (0 !== i || 0 !== e || h !== t.width || r !== t.height) && 0 < h && 0 < r) {
                    const n = v._$CreateCanvas$_(h, r), o = n.getContext("2d");
                    o.drawImage(t, i, e, h, r, 0, 0, h, r), t = n;
                }
                v._$CanvasToBlob$_(t, this._$_snapshotFormat$_, this._$_snapshotQuality$_).then(t => {
                    this._$_snapshotUrl$_ && URL.revokeObjectURL(this._$_snapshotUrl$_), 
                    this._$_snapshotUrl$_ = URL.createObjectURL(t), this._$_snapshotPromise$_ = null, 
                    this._$_snapshotResolve$_(this._$_snapshotUrl$_);
                }), this._$_snapshotFormat$_ = "", this._$_snapshotQuality$_ = 1;
            }
        }
        _$GetCanvasSnapshotUrl$_() {
            return this._$_snapshotUrl$_;
        }
        _$SetIsPastingToDrawingCanvas$_(t) {
            t ? this._$_isPastingToDrawingCanvas$_++ : this._$_isPastingToDrawingCanvas$_--;
        }
        _$IsPastingToDrawingCanvas$_() {
            return 0 < this._$_isPastingToDrawingCanvas$_;
        }
        _$InitLoadingScreen$_(t) {
            const s = this._$GetRenderer$_();
            if (2 === t) this._$_percentText$_ = v._$New$_(v._$Gfx$_._$RendererText$_, this._$GetRenderer$_()), 
            this._$_percentText$_._$SetFontName$_("Arial"), this._$_percentText$_._$SetFontSize$_(16), 
            this._$_percentText$_._$SetHorizontalAlignment$_("center"), this._$_percentText$_._$SetVerticalAlignment$_("center"), 
            this._$_percentText$_._$SetSize$_(300, 200); else if (0 === t) {
                const i = this._$_runtime$_._$GetLoadingLogoAsset$_();
                i && i._$LoadStaticTexture$_(s).catch(t => console.warn("[C3 runtime] Failed to create texture for loading logo: ", t));
            } else 4 === t && (this._$_LoadSvgSplashImage$_("splash-images/splash-logo.svg").then(t => {
                "done" === this._$_splashState$_ ? s._$DeleteTexture$_(t) : this._$_splashTextures$_._$logo$_ = t;
            }).catch(t => console.warn("Failed to load splash image: ", t)), this._$_LoadBitmapSplashImage$_("splash-images/splash-poweredby-512.png").then(t => {
                "done" === this._$_splashState$_ ? s._$DeleteTexture$_(t) : this._$_splashTextures$_._$powered$_ = t;
            }).catch(t => console.warn("Failed to load splash image: ", t)), this._$_LoadBitmapSplashImage$_("splash-images/splash-website-512.png").then(t => {
                "done" === this._$_splashState$_ ? s._$DeleteTexture$_(t) : this._$_splashTextures$_._$website$_ = t;
            }).catch(t => console.warn("Failed to load splash image: ", t)));
        }
        async _$_LoadSvgSplashImage$_(t) {
            t = new URL(t, this._$_runtime$_._$GetRuntimeBaseURL$_()).toString();
            const s = await v._$FetchBlob$_(t), i = await this._$_runtime$_._$RasterSvgImage$_(s, 2048, 2048);
            return this._$GetRenderer$_()._$CreateStaticTextureAsync$_(i, {
                _$mipMapQuality$_: "high"
            });
        }
        async _$_LoadBitmapSplashImage$_(t) {
            t = new URL(t, this._$_runtime$_._$GetRuntimeBaseURL$_()).toString();
            const s = await v._$FetchBlob$_(t);
            return this._$GetRenderer$_()._$CreateStaticTextureAsync$_(s, {
                _$mipMapQuality$_: "high"
            });
        }
        _$HideCordovaSplashScreen$_() {
            this._$_runtime$_._$PostComponentMessageToDOM$_("runtime", "hide-cordova-splash");
        }
        _$StartLoadingScreen$_() {
            this._$_loaderStartTime$_ = Date.now(), this._$_runtime$_._$Dispatcher$_().addEventListener("loadingprogress", this._$_loadingprogress_handler$_), 
            this._$_rafId$_ = requestAnimationFrame(() => this._$_DrawLoadingScreen$_());
            const t = this._$_runtime$_._$GetLoaderStyle$_();
            3 !== t && this._$HideCordovaSplashScreen$_();
        }
        async _$EndLoadingScreen$_() {
            const t = this._$GetRenderer$_(), s = (this._$_loadingProgress$_ = 1, 
            this._$_runtime$_._$GetLoaderStyle$_());
            4 === s && await this._$_splashDonePromise$_, this._$_splashDoneResolve$_ = null, 
            this._$_splashDonePromise$_ = null, -1 !== this._$_rafId$_ && (cancelAnimationFrame(this._$_rafId$_), 
            this._$_rafId$_ = -1), this._$_runtime$_._$Dispatcher$_().removeEventListener("loadingprogress", this._$_loadingprogress_handler$_), 
            this._$_loadingprogress_handler$_ = null, this._$_percentText$_ && (this._$_percentText$_._$Release$_(), 
            this._$_percentText$_ = null), this._$_runtime$_._$ReleaseLoadingLogoAsset$_(), 
            t._$Start$_(), this._$_splashTextures$_._$logo$_ && (t._$DeleteTexture$_(this._$_splashTextures$_._$logo$_), 
            this._$_splashTextures$_._$logo$_ = null), this._$_splashTextures$_._$powered$_ && (t._$DeleteTexture$_(this._$_splashTextures$_._$powered$_), 
            this._$_splashTextures$_._$powered$_ = null), this._$_splashTextures$_._$website$_ && (t._$DeleteTexture$_(this._$_splashTextures$_._$website$_), 
            this._$_splashTextures$_._$website$_ = null), t._$ClearRgba$_(0, 0, 0, 0), 
            t._$Finish$_(), this._$_splashState$_ = "done", this._$_gpuTimeStartFrame$_ = t._$GetFrameNumber$_(), 
            3 === s && this._$HideCordovaSplashScreen$_();
        }
        _$_DrawLoadingScreen$_() {
            if (-1 !== this._$_rafId$_) {
                const t = this._$GetRenderer$_(), s = (t._$Start$_(), this._$_rafId$_ = -1, 
                this._$_runtime$_._$GetAssetManager$_()._$HasHadErrorLoading$_()), i = this._$_runtime$_._$GetLoaderStyle$_();
                if (3 !== i && (this._$SetCssTransform$_(t), t._$ClearRgba$_(0, 0, 0, 0), 
                t._$ResetColor$_(), t._$SetTextureFillMode$_(), t._$SetTexture$_(null)), 
                0 === i) this._$_DrawProgressBarAndLogoLoadingScreen$_(s); else if (1 === i) this._$_DrawProgressBarLoadingScreen$_(s, 120, 0); else if (2 === i) this._$_DrawPercentTextLoadingScreen$_(s); else if (3 === i) v._$noop$_(); else {
                    if (4 !== i) throw new Error("invalid loader style");
                    this._$_DrawSplashLoadingScreen$_(s);
                }
                t._$Finish$_(), this._$_rafId$_ = requestAnimationFrame(() => this._$_DrawLoadingScreen$_());
            }
        }
        _$_DrawPercentTextLoadingScreen$_(t) {
            t ? this._$_percentText$_._$SetColorRgb$_(1, 0, 0) : this._$_percentText$_._$SetColorRgb$_(.6, .6, .6), 
            this._$_percentText$_._$SetText$_(Math.round(100 * this._$_loadingProgress$_) + "%");
            const s = this._$_canvasCssWidth$_ / 2, i = this._$_canvasCssHeight$_ / 2, e = (Ja._$setRect$_(s - 150, i - 100, 150 + s, 100 + i), 
            this._$GetRenderer$_());
            e._$SetTexture$_(this._$_percentText$_._$GetTexture$_()), e._$Quad3$_(Ja, this._$_percentText$_._$GetTexRect$_());
        }
        _$_DrawProgressBarLoadingScreen$_(t, s, i) {
            const e = this._$GetRenderer$_(), h = (e._$SetColorFillMode$_(), t ? e._$SetColorRgba$_(1, 0, 0, 1) : e._$SetColorRgba$_(.118, .565, 1, 1), 
            this._$_canvasCssWidth$_ / 2), r = this._$_canvasCssHeight$_ / 2, n = s / 2;
            x._$setWH$_(h - n, r - 4 + i, Math.floor(s * this._$_loadingProgress$_), 8), 
            e.Rect(x), x._$setWH$_(h - n, r - 4 + i, s, 8), x.offset(-.5, -.5), 
            x._$inflate$_(.5, .5), e._$SetColorRgba$_(0, 0, 0, 1), e._$LineRect2$_(x), 
            x._$inflate$_(1, 1), e._$SetColorRgba$_(1, 1, 1, 1), e._$LineRect2$_(x);
        }
        _$_DrawProgressBarAndLogoLoadingScreen$_(t) {
            const s = this._$GetRenderer$_(), i = this._$_runtime$_._$GetLoadingLogoAsset$_();
            if (i) {
                const e = i._$GetTexture$_();
                if (e) {
                    const h = e._$GetWidth$_(), r = e._$GetHeight$_(), n = this._$_canvasCssWidth$_ / 2, o = this._$_canvasCssHeight$_ / 2, a = h / 2, l = r / 2;
                    Ja._$setRect$_(n - a, o - l, n + a, o + l), s._$SetTexture$_(e), 
                    s._$Quad$_(Ja), this._$_DrawProgressBarLoadingScreen$_(t, h, 16 + l);
                } else this._$_DrawProgressBarLoadingScreen$_(t, 120, 0);
            } else this._$_DrawProgressBarLoadingScreen$_(t, 120, 0);
        }
        _$_DrawSplashLoadingScreen$_(t) {
            let s = this._$GetRenderer$_(), i = this._$_splashTextures$_._$logo$_, e = this._$_splashTextures$_._$powered$_, h = this._$_splashTextures$_._$website$_, r = Date.now(), n = (0 === this._$_splashFrameNumber$_ && (this._$_loaderStartTime$_ = r), 
            this._$_runtime$_._$IsPreview$_() || this._$_runtime$_._$IsFBInstantAvailable$_() && !this._$_runtime$_._$IsCordova$_()), o = n ? 0 : 200, a = n ? 0 : 3e3, l = 1, u = ("fade-in" === this._$_splashState$_ ? l = Math.min((r - this._$_loaderStartTime$_) / 300, 1) : "fade-out" === this._$_splashState$_ && (l = Math.max(1 - (r - this._$_splashFadeOutStartTime$_) / 300, 0)), 
            s._$SetColorFillMode$_(), s._$SetColorRgba$_(.231 * l, .251 * l, .271 * l, l), 
            x.set(0, 0, this._$_canvasCssWidth$_, this._$_canvasCssHeight$_), s.Rect(x), 
            Math.ceil(this._$_canvasCssWidth$_)), c = Math.ceil(this._$_canvasCssHeight$_), f, d;
            256 < this._$_canvasCssHeight$_ ? (s._$SetColorRgba$_(.302 * l, .334 * l, .365 * l, l), 
            f = u, d = Math.max(.005 * c, 2), x._$setWH$_(0, .8 * c - d / 2, f, d), 
            s.Rect(x), t ? s._$SetColorRgba$_(l, 0, 0, l) : s._$SetColorRgba$_(.161 * l, .953 * l, .816 * l, l), 
            f = u * this._$_loadingProgress$_, x._$setWH$_(.5 * u - f / 2, .8 * c - d / 2, f, d), 
            s.Rect(x), s._$SetColorRgba$_(l, l, l, l), s._$SetTextureFillMode$_(), 
            e && (f = 1.5 * v._$clamp$_(.22 * c, 105, .6 * u), d = f / 8, x._$setWH$_(.5 * u - f / 2, .2 * c - d / 2, f, d), 
            s._$SetTexture$_(e), s.Rect(x)), i && (f = Math.min(.395 * c, .95 * u), 
            d = f, x._$setWH$_(.5 * u - f / 2, .485 * c - d / 2, f, d), s._$SetTexture$_(i), 
            s.Rect(x)), h && (f = 1.5 * v._$clamp$_(.22 * c, 105, .6 * u), d = f / 8, 
            x._$setWH$_(.5 * u - f / 2, .868 * c - d / 2, f, d), s._$SetTexture$_(h), 
            s.Rect(x))) : (s._$SetColorRgba$_(.302 * l, .334 * l, .365 * l, l), 
            f = u, d = Math.max(.005 * c, 2), x._$setWH$_(0, .85 * c - d / 2, f, d), 
            s.Rect(x), t ? s._$SetColorRgba$_(l, 0, 0, l) : s._$SetColorRgba$_(.161 * l, .953 * l, .816 * l, l), 
            f = u * this._$_loadingProgress$_, x._$setWH$_(.5 * u - f / 2, .85 * c - d / 2, f, d), 
            s.Rect(x), s._$SetColorRgba$_(l, l, l, l), s._$SetTextureFillMode$_(), 
            i && (f = .55 * c, d = f, x._$setWH$_(.5 * u - f / 2, .45 * c - d / 2, f, d), 
            s._$SetTexture$_(i), s.Rect(x))), this._$_splashFrameNumber$_++, "fade-in" === this._$_splashState$_ && 300 <= r - this._$_loaderStartTime$_ && 2 <= this._$_splashFrameNumber$_ && (this._$_splashState$_ = "wait", 
            this._$_splashFadeInFinishTime$_ = r), "wait" === this._$_splashState$_ && r - this._$_splashFadeInFinishTime$_ >= a && 1 <= this._$_loadingProgress$_ && (this._$_splashState$_ = "fade-out", 
            this._$_splashFadeOutStartTime$_ = r), ("fade-out" === this._$_splashState$_ && r - this._$_splashFadeOutStartTime$_ >= 300 + o || n && 1 <= this._$_loadingProgress$_ && r - this._$_loaderStartTime$_ < 500) && this._$_splashDoneResolve$_();
        }
    };
}

{
    let j = self._$C3$_, V = self.C3Debugger, i = {
        messagePort: null,
        runtimeBaseUrl: "",
        headless: !1,
        hasDom: !0,
        isInWorker: !1,
        useAudio: !0,
        exportType: ""
    }, n = !0;
    j._$Runtime$_ = class extends j._$DefendedBase$_ {
        constructor(t) {
            t = Object.assign({}, i, t), super(), this._$_messagePort$_ = t.messagePort, 
            this._$_runtimeBaseUrl$_ = t.runtimeBaseUrl, this._$_previewUrl$_ = t.previewUrl, 
            this._$_isHeadless$_ = !!t.headless, this._$_hasDom$_ = !!t.hasDom, 
            this._$_isInWorker$_ = !!t.isInWorker, n = t.ife, this._$_useAudio$_ = !!t.useAudio, 
            this._$_exportType$_ = t.exportType, this._$_isiOSCordova$_ = !!t.isiOSCordova, 
            this._$_isiOSWebView$_ = !!t.isiOSWebView, this._$_isWindowsWebView2$_ = !!t.isWindowsWebView2, 
            this._$_isAnyWebView2Wrapper$_ = !!t.isAnyWebView2Wrapper, this._$_isFBInstantAvailable$_ = !!t.isFBInstantAvailable, 
            this._$_isDebug$_ = !("preview" !== this._$_exportType$_ || !t.isDebug), 
            this._$_breakpointsEnabled$_ = this._$_isDebug$_, this._$_isDebugging$_ = this._$_isDebug$_, 
            this._$_debuggingDisabled$_ = 0, this._$_additionalLoadPromises$_ = [], 
            this._$_additionalCreatePromises$_ = [], this._$_isUsingCreatePromises$_ = !1, 
            this._$_projectName$_ = "", this._$_projectVersion$_ = "", this._$_projectUniqueId$_ = "", 
            this._$_appId$_ = "", this._$_originalViewportWidth$_ = 0, this._$_originalViewportHeight$_ = 0, 
            this._$_devicePixelRatio$_ = self.devicePixelRatio, this._$_parallaxXorigin$_ = 0, 
            this._$_parallaxYorigin$_ = 0, this._$_viewportWidth$_ = 0, this._$_viewportHeight$_ = 0, 
            this._$_loaderStyle$_ = 0, this._$_usesLoaderLayout$_ = !1, this._$_isLoading$_ = !0, 
            this._$_usesAnyBackgroundBlending$_ = !1, this._$_usesAnyCrossSampling$_ = !1, 
            this._$_usesAnyDepthSampling$_ = !1, this._$_loadingLogoAsset$_ = null, 
            this._$_assetManager$_ = j._$New$_(j._$AssetManager$_, this, t), this._$_layoutManager$_ = j._$New$_(j._$LayoutManager$_, this), 
            this._$_eventSheetManager$_ = j._$New$_(j._$EventSheetManager$_, this), 
            this._$_addonManager$_ = j._$New$_(j._$AddonManager$_, this, t.wrapperComponentIds), 
            this._$_collisionEngine$_ = j._$New$_(j._$CollisionEngine$_, this), 
            this._$_timelineManager$_ = j._$New$_(j._$TimelineManager$_, this), 
            this._$_transitionManager$_ = j._$New$_(j._$TransitionManager$_, this), 
            this._$_templateManager$_ = j._$New$_(j._$TemplateManager$_, this), 
            this._$_flowchartManager$_ = j._$New$_(j._$FlowchartManager$_, this), 
            this._$_textIconManager$_ = j._$New$_(j._$TextIconManager$_, {
                _$getIconSetMeta$_: t => this._$_GetTextIconSetMeta$_(t),
                _$getIconSetContent$_: t => this._$_GetTextIconSetContent$_(t)
            }), this._$_iconChangeHandlers$_ = new Map(), this._$_allObjectClasses$_ = [], 
            this._$_objectClassesByName$_ = new Map(), this._$_objectClassesBySid$_ = new Map(), 
            this._$_familyCount$_ = 0, this._$_allContainers$_ = [], this._$_allEffectLists$_ = new Set(), 
            this._$_currentLayoutStack$_ = [], this._$_instancesPendingCreate$_ = [], 
            this._$_instancesPendingDestroy$_ = new Map(), this._$_hasPendingInstances$_ = !1, 
            this._$_isFlushingPendingInstances$_ = !1, this._$_objectCount$_ = 0, 
            this._$_nextUid$_ = 0, this._$_instancesByUid$_ = new Map(), this._$_instancesPendingRelease$_ = new Set(), 
            this._$_instancesPendingReleaseAffectedObjectClasses$_ = new Set(), 
            this._$_objectReferenceTable$_ = [], this._$_jsPropNameTable$_ = [], 
            this._$_canvasManager$_ = null, this._$_uses3dFeatures$_ = !1, this._$_framerateMode$_ = "vsync", 
            this._$_sampling$_ = "trilinear", this._$_isPixelRoundingEnabled$_ = !1, 
            this._$_needRender$_ = !0, this._$_pauseOnBlur$_ = !1, this._$_isPausedOnBlur$_ = !1, 
            this._$_exportToVideo$_ = null, this._$_tickCallbacks$_ = {
                _$normal$_: t => {
                    this._$_rafId$_ = -1, this._$_ruafId$_ = -1, this._$Tick$_(t);
                },
                _$tickOnly$_: t => {
                    this._$_ruafId$_ = -1, this._$Tick$_(t, !1, "skip-render");
                },
                _$renderOnly$_: () => {
                    this._$_rafId$_ = -1, this._$Render$_();
                }
            }, this._$_rafId$_ = -1, this._$_ruafId$_ = -1, this._$_tickCount$_ = 0, 
            this._$_tickCountNoSave$_ = 0, this._$_hasStarted$_ = !1, this._$_isInTick$_ = !1, 
            this._$_hasStartedTicking$_ = !1, this._$_isLayoutFirstTick$_ = !0, 
            this._$_isAutoSuspendEnabled$_ = !0, this._$_isPageVisibilitySuspended$_ = !1, 
            this._$_suspendCount$_ = 0, this._$_scheduleTriggersThrottle$_ = new j._$PromiseThrottle$_(1), 
            this._$_randomNumberCallback$_ = () => Math.random(), this._$_startTime$_ = 0, 
            this._$_lastTickTime$_ = 0, this._$_dtRaw$_ = 0, this._$_dt1$_ = 0, 
            this._$_dt$_ = 0, this._$_timeScale$_ = 1, this._$_maxDt$_ = 1 / 30, 
            this._$_minDt$_ = 0, this._$_gameTime$_ = j._$New$_(j._$KahanSum$_), 
            this._$_gameTimeRaw$_ = j._$New$_(j._$KahanSum$_), this._$_wallTime$_ = j._$New$_(j._$KahanSum$_), 
            this._$_instanceTimes$_ = new Map(), this._$_fpsFrameCount$_ = -1, this._$_fpsLastTime$_ = 0, 
            this._$_fps$_ = 0, this._$_tpsTickCount$_ = -1, this._$_tps$_ = 0, this._$_mainThreadTimeCounter$_ = 0, 
            this._$_mainThreadTime$_ = 0, this._$_isLoadingState$_ = !1, this._$_saveToSlotName$_ = "", 
            this._$_loadFromSlotName$_ = "", this._$_loadFromJson$_ = null, this._$_lastSaveJson$_ = "", 
            this._$_projectStorage$_ = null, this._$_savegamesStorage$_ = null, 
            this._$_dispatcher$_ = j._$New$_(j.Event._$Dispatcher$_), this._$_domEventHandlers$_ = new Map(), 
            this._$_pendingResponsePromises$_ = new Map(), this._$_nextDomResponseId$_ = 0, 
            this._$_didRequestDeviceOrientationEvent$_ = !1, this._$_didRequestDeviceMotionEvent$_ = !1, 
            this._$_isReadyToHandleEvents$_ = !1, this._$_waitingToHandleEvents$_ = [], 
            this._$_eventObjects$_ = {
                pretick: j._$New$_(j.Event, "pretick", !1),
                tick: j._$New$_(j.Event, "tick", !1),
                tick2: j._$New$_(j.Event, "tick2", !1),
                instancedestroy: j._$New$_(j.Event, "instancedestroy", !1),
                beforelayoutchange: j._$New$_(j.Event, "beforelayoutchange", !1),
                layoutchange: j._$New$_(j.Event, "layoutchange", !1)
            }, this._$_eventObjects$_.instancedestroy._$instance$_ = null, this._$_userScriptDispatcher$_ = j._$New$_(j.Event._$Dispatcher$_), 
            this._$_userScriptEventObjects$_ = null;
            const s = (t, s) => j._$BehaviorInstance$_._$SortByTickSequence$_(this, t, s);
            this._$_behInstsToTick$_ = j._$New$_(j._$RedBlackSet$_, s), this._$_behInstsToPostTick$_ = j._$New$_(j._$RedBlackSet$_, s), 
            this._$_behInstsToTick2$_ = j._$New$_(j._$RedBlackSet$_, s), this._$_jobScheduler$_ = j._$New$_(j._$JobSchedulerRuntime$_, this, t.jobScheduler), 
            t.canvas && (this._$_canvasManager$_ = j._$New$_(j._$CanvasManager$_, this)), 
            this._$_messagePort$_.onmessage = t => this._OnMessageFromDOM(t.data), 
            this._$AddDOMComponentMessageHandler$_("runtime", "visibilitychange", t => this._$_OnVisibilityChange$_(t)), 
            this._$AddDOMComponentMessageHandler$_("runtime", "wrapper-extension-message", t => this._$_OnWrapperExtensionMessage$_(t)), 
            this._$AddDOMComponentMessageHandler$_("runtime", "opus-decode", t => this._$_WasmDecodeWebMOpus$_(t.arrayBuffer)), 
            this._$AddDOMComponentMessageHandler$_("runtime", "get-remote-preview-status-info", () => this._$_GetRemotePreviewStatusInfo$_()), 
            this._$AddDOMComponentMessageHandler$_("runtime", "js-invoke-function", t => this._$_InvokeFunctionFromJS$_(t)), 
            this._$AddDOMComponentMessageHandler$_("runtime", "go-to-last-error-script", self.goToLastErrorScript), 
            this._$AddDOMComponentMessageHandler$_("runtime", "offline-audio-render-completed", t => this._$_OnOfflineAudioRenderCompleted$_(t)), 
            this._$_dispatcher$_.addEventListener("window-blur", t => this._$_OnWindowBlur$_(t)), 
            this._$_dispatcher$_.addEventListener("window-focus", () => this._$_OnWindowFocus$_()), 
            this._$_timelineManager$_._$AddRuntimeListeners$_(), this._$_templateManager$_._$AddRuntimeListeners$_(), 
            this._$_iRuntime$_ = null, this._$_interfaceMap$_ = new WeakMap(), this._$_commonScriptInterfaces$_ = {
                keyboard: null,
                _$mouse$_: null,
                _$touch$_: null,
                _$timelineController$_: null,
                _$platformInfo$_: null
            }, this._$_instancesNeedingAfterLoadMap$_ = new WeakMap(), this._$_instancesNeedingAfterLoadArray$_ = [];
        }
        static _$Create$_(t) {
            return j._$New$_(j._$Runtime$_, t);
        }
        _$Release$_() {
            j._$clearArray$_(this._$_allObjectClasses$_), this._$_objectClassesByName$_.clear(), 
            this._$_objectClassesBySid$_.clear(), this._$_layoutManager$_._$Release$_(), 
            this._$_layoutManager$_ = null, this._$_eventSheetManager$_._$Release$_(), 
            this._$_eventSheetManager$_ = null, this._$_addonManager$_._$Release$_(), 
            this._$_addonManager$_ = null, this._$_assetManager$_._$Release$_(), 
            this._$_assetManager$_ = null, this._$_collisionEngine$_._$Release$_(), 
            this._$_collisionEngine$_ = null, this._$_timelineManager$_._$Release$_(), 
            this._$_timelineManager$_ = null, this._$_transitionManager$_._$Release$_(), 
            this._$_transitionManager$_ = null, this._$_templateManager$_._$Release$_(), 
            this._$_templateManager$_ = null, this._$_flowchartManager$_._$Release$_(), 
            this._$_flowchartManager$_ = null, this._$_textIconManager$_._$Release$_(), 
            this._$_textIconManager$_ = null, this._$_canvasManager$_ && (this._$_canvasManager$_._$Release$_(), 
            this._$_canvasManager$_ = null), this._$_dispatcher$_._$Release$_(), 
            this._$_dispatcher$_ = null, this._$_tickEvent$_ = null;
        }
        ["_OnMessageFromDOM"](t) {
            const s = t.type;
            if ("event" === s) this._$_OnEventFromDOM$_(t); else {
                if ("result" !== s) throw new Error(`unknown message '${s}'`);
                this._$_OnResultFromDOM$_(t);
            }
        }
        _$_OnEventFromDOM$_(t) {
            if (this._$_isReadyToHandleEvents$_) {
                const s = t.component, i = t.handler, e = t.data, h = t.dispatchOpts, r = !(!h || !h.dispatchRuntimeEvent), n = !(!h || !h.dispatchUserScriptEvent), o = t.responseId;
                if ("runtime" === s) {
                    if (r) {
                        const l = new j.Event(i);
                        l.data = e, this._$_dispatcher$_._$dispatchEventAndWaitAsyncSequential$_(l);
                    }
                    if (n) {
                        const u = new j.Event(i, !0);
                        for (const [ c, f ] of Object.entries(e)) u[c] = f;
                        this._$DispatchUserScriptEvent$_(u);
                    }
                }
                const a = this._$_domEventHandlers$_.get(s);
                if (a) {
                    const d = a.get(i);
                    if (d) {
                        let t = null;
                        try {
                            t = d(e);
                        } catch (t) {
                            return console.error(`Exception in '${s}' handler '${i}':`, t), 
                            void (null !== o && this._$_PostResultToDOM$_(o, !1, "" + t));
                        }
                        null !== o && (t && t.then ? t.then(t => this._$_PostResultToDOM$_(o, !0, t)).catch(t => {
                            console.error(`Rejection from '${s}' handler '${i}':`, t), 
                            this._$_PostResultToDOM$_(o, !1, "" + t);
                        }) : this._$_PostResultToDOM$_(o, !0, t));
                    } else r || n || console.warn(`[Runtime] No DOM handler '${i}' for component '${s}'`);
                } else r || n || console.warn(`[Runtime] No DOM event handlers for component '${s}'`);
            } else this._$_waitingToHandleEvents$_.push(t);
        }
        _$_PostResultToDOM$_(t, s, i) {
            this._$_messagePort$_.postMessage({
                type: "result",
                responseId: t,
                isOk: s,
                result: i
            });
        }
        _$_OnResultFromDOM$_(t) {
            const s = t.responseId, i = t.isOk, e = t.result, h = this._$_pendingResponsePromises$_.get(s);
            i ? h.resolve(e) : h.reject(e), this._$_pendingResponsePromises$_.delete(s);
        }
        _$AddDOMComponentMessageHandler$_(t, s, i) {
            let e = this._$_domEventHandlers$_.get(t);
            if (e || (e = new Map(), this._$_domEventHandlers$_.set(t, e)), e.has(s)) throw new Error(`[Runtime] Component '${t}' already has handler '${s}'`);
            e.set(s, i);
        }
        _$PostComponentMessageToDOM$_(t, s, i, e) {
            this._$_messagePort$_.postMessage({
                type: "event",
                component: t,
                handler: s,
                data: i,
                responseId: null
            }, e);
        }
        _$PostComponentMessageToDOMAsync$_(t, s, i, e) {
            const h = this._$_nextDomResponseId$_++, r = new Promise((t, s) => {
                this._$_pendingResponsePromises$_.set(h, {
                    resolve: t,
                    reject: s
                });
            });
            return this._$_messagePort$_.postMessage({
                type: "event",
                component: t,
                handler: s,
                data: i,
                responseId: h
            }, e), r;
        }
        _$SendWrapperExtensionMessage$_(t, s, i, e = -1) {
            this._$PostComponentMessageToDOM$_("runtime", "send-wrapper-extension-message", {
                componentId: t,
                messageId: s,
                params: i,
                asyncId: e
            });
        }
        _$SendWrapperExtensionMessageAsync$_(t, s, i) {
            const e = this._$_nextDomResponseId$_++, h = new Promise((t, s) => {
                this._$_pendingResponsePromises$_.set(e, {
                    resolve: t,
                    reject: s
                });
            });
            return this._$SendWrapperExtensionMessage$_(t, s, i, e), h;
        }
        _$_OnWrapperExtensionMessage$_(t) {
            if (-1 !== t.asyncId) {
                const s = t.asyncId, i = this._$_pendingResponsePromises$_.get(s);
                i.resolve(t.params), this._$_pendingResponsePromises$_.delete(s);
            } else this._$_OnEventFromDOM$_({
                component: "wrapper-extension:" + t.componentId,
                handler: t.messageId,
                data: t.params,
                responseId: null
            });
        }
        _$AddWrapperExtensionMessageHandler$_(t, s, i) {
            this._$AddDOMComponentMessageHandler$_("wrapper-extension:" + t, s, i);
        }
        _$HasWrapperComponentId$_(t) {
            return this._$_addonManager$_._$HasWrapperComponentId$_(t);
        }
        _$PostToDebugger$_(t) {
            if (!this._$IsDebug$_()) throw new Error("not in debug mode");
            this._$PostComponentMessageToDOM$_("runtime", "post-to-debugger", t);
        }
        async _$Init$_(t) {
            j._$CommonACES_SetRuntime$_(this), this._$IsDebug$_() ? await V._$Init$_(this) : self.C3Debugger && self.C3Debugger.InitPreview(this);
            const [ s ] = await Promise.all([ this._$_assetManager$_._$FetchJson$_("data.json"), this._$_MaybeLoadOpusDecoder$_(), this._$_jobScheduler$_._$Init$_() ]);
            if (await this._$_LoadDataJson$_(s), await this._$_InitialiseCanvas$_(t), 
            this._$IsPreview$_() || console.info("%cMade with Construct, the game and animation creation tool. Visit: https://www.construct.net", "font-weight: bold"), 
            this._$GetWebGLRenderer$_()) {
                const i = this._$GetWebGLRenderer$_();
                console.info(`[C3 runtime] Hosted in ${this._$IsInWorker$_() ? "worker" : "DOM"}, rendering with WebGL ${i._$GetWebGLVersionNumber$_()} [${i._$GetUnmaskedRenderer$_()}]`);
            } else this._$GetWebGPURenderer$_() && console.info(`[C3 runtime] Hosted in ${this._$IsInWorker$_() ? "worker" : "DOM"}, rendering with WebGPU [${this._$GetWebGPURenderer$_().GetAdapterInfoString()}]`);
            this._$GetRenderer$_()._$HasMajorPerformanceCaveat$_() && console.warn("[C3 runtime] The renderer indicates a major performance caveat. Software rendering may be in use. This can result in significantly degraded performance."), 
            this._$_isReadyToHandleEvents$_ = !0;
            for (const e of this._$_waitingToHandleEvents$_) this._$_OnEventFromDOM$_(e);
            j._$clearArray$_(this._$_waitingToHandleEvents$_), this._$_canvasManager$_ && this._$_canvasManager$_._$StartLoadingScreen$_();
            for (const h of t.runOnStartupFunctions) this._$_additionalLoadPromises$_.push(this._$_RunOnStartupFunction$_(h));
            if (await Promise.all([ this._$_assetManager$_._$WaitForAllToLoad$_(), ...this._$_additionalLoadPromises$_ ]), 
            j._$clearArray$_(this._$_additionalLoadPromises$_), !this._$_assetManager$_._$HasHadErrorLoading$_()) return this._$_canvasManager$_ && await this._$_canvasManager$_._$EndLoadingScreen$_(), 
            await this._$_dispatcher$_._$dispatchEventAndWaitAsync$_(new j.Event("beforeruntimestart")), 
            await this._$Start$_(), this._$_messagePort$_.postMessage({
                type: "runtime-ready"
            }), this;
            this._$_canvasManager$_ && this._$_canvasManager$_._$HideCordovaSplashScreen$_();
        }
        async _$_RunOnStartupFunction$_(t) {
            try {
                await t(this._$_iRuntime$_);
            } catch (t) {
                console.error("[C3 runtime] Error in runOnStartup function: ", t);
            }
        }
        async _$_LoadDataJson$_(t) {
            const s = t.project, i = (this._$_projectName$_ = s[0], this._$_projectVersion$_ = s[16], 
            this._$_projectUniqueId$_ = s[31], this._$_appId$_ = s[38], s[39] || "loading-logo.png"), e = (this._$_isPixelRoundingEnabled$_ = !!s[9], 
            this._$_originalViewportWidth$_ = this._$_viewportWidth$_ = s[10], this._$_originalViewportHeight$_ = this._$_viewportHeight$_ = s[11], 
            this._$_collisionEngine$_._$_InitCollisionCellSize$_(this._$_originalViewportWidth$_, this._$_originalViewportHeight$_), 
            this._$_parallaxXorigin$_ = this._$_originalViewportWidth$_ / 2, this._$_parallaxYorigin$_ = this._$_originalViewportHeight$_ / 2, 
            this._$_framerateMode$_ = s[37], this._$_uses3dFeatures$_ = !!s[40], 
            this._$_sampling$_ = s[14], this._$_usesAnyBackgroundBlending$_ = s[15], 
            this._$_usesAnyCrossSampling$_ = s[42], this._$_usesAnyDepthSampling$_ = s[17], 
            this._$_usesLoaderLayout$_ = !!s[18], this._$_loaderStyle$_ = s[19], 
            this._$_nextUid$_ = s[21], this._$_pauseOnBlur$_ = s[22], this._$_assetManager$_);
            if (e._$_SetFileStructure$_(s[45]), e._$_SetAudioFiles$_(s[7], s[25]), 
            e._$_SetMediaSubfolder$_(s[8]), e._$_SetFontsSubfolder$_(s[32]), e._$_SetIconsSubfolder$_(s[28]), 
            e._$_SetWebFonts$_(s[29]), 0 === this._$_loaderStyle$_) {
                let t = "";
                (t = "flat" === e._$GetFileStructure$_() ? e._$GetIconsSubfolder$_() + i : i) && (this._$_loadingLogoAsset$_ = e._$LoadImage$_({
                    url: t
                }));
            }
            this._$_canvasManager$_ && (this._$_canvasManager$_._$SetFullscreenMode$_(j._$CanvasManager$_._$_FullscreenModeNumberToString$_(s[12])), 
            this._$_canvasManager$_._$SetFullscreenScalingQuality$_(s[23] ? "high" : "low"), 
            this._$_canvasManager$_._$SetMipmapsEnabled$_(0 !== s[24]), this._$_canvasManager$_._$_SetGPUPowerPreference$_(s[34]), 
            this._$_canvasManager$_._$_SetTextureAnisotropy$_(s[41]), this._$_canvasManager$_._$_SetWebGPUEnabled$_(s[13]), 
            this._$_canvasManager$_._$_SetZAxisScale$_(s[30]), this._$_canvasManager$_._$_SetZDistances$_(s[46], s[47]), 
            this._$_canvasManager$_._$_SetInitFieldOfView$_(s[26]), this._$_canvasManager$_._$_SetLimitedToWebGL1$_(s[48]));
            const h = s[43], r = (h && await this._$_LoadExportToVideoData$_(h), 
            this._$_InitScriptInterfaces$_(), this._$_addonManager$_._$CreateSystemPlugin$_(), 
            this._$_objectReferenceTable$_ = self._$C3_GetObjectRefTable$_(), s[2]);
            for (const l of r[1]) this._$_addonManager$_._$CreateBehavior$_(l);
            for (const u of r[0]) this._$_addonManager$_._$CreatePlugin$_(u);
            this._$_objectReferenceTable$_ = self._$C3_GetObjectRefTable$_(), this._$_LoadJsPropNameTable$_(), 
            this._$_addonManager$_._$_InitAddonScriptInterfaces$_();
            for (const c of s[3]) {
                const f = j._$ObjectClass$_._$Create$_(this, this._$_allObjectClasses$_.length, c);
                this._$_allObjectClasses$_.push(f), this._$_objectClassesByName$_.set(f._$GetName$_().toLowerCase(), f), 
                this._$_objectClassesBySid$_.set(f._$GetSID$_(), f);
            }
            for (const d of s[4]) {
                const p = this._$_allObjectClasses$_[d[0]];
                p._$_LoadFamily$_(d);
            }
            for (const m of s[27]) {
                const g = m.map(t => this._$_allObjectClasses$_[t]);
                this._$_allContainers$_.push(j._$New$_(j._$Container$_, this, g));
            }
            this._$_InitObjectsScriptInterface$_();
            for (const y of this._$_allObjectClasses$_) y._$_OnAfterCreate$_();
            for (const w of s[5]) this._$_layoutManager$_._$Create$_(w);
            const n = s[1];
            if (n) {
                const S = this._$_layoutManager$_._$GetLayoutByName$_(n);
                S && this._$_layoutManager$_._$SetFirstLayout$_(S);
            }
            for (const b of s[35]) this._$_transitionManager$_._$Create$_(b);
            for (const M of s[33]) this._$_timelineManager$_._$Create$_(M);
            for (const v of s[44]) this._$_templateManager$_._$Create$_(v);
            this._$_templateManager$_._$HasTemplates$_() || (this._$_templateManager$_._$Release$_(), 
            this._$_templateManager$_ = null);
            for (const x of s[49]) this._$_flowchartManager$_._$Create$_(x);
            this._$_flowchartManager$_._$HasFlowcharts$_() || (this._$_flowchartManager$_._$Release$_(), 
            this._$_flowchartManager$_ = null);
            for (const G of s[6]) this._$_eventSheetManager$_._$Create$_(G);
            this._$_eventSheetManager$_._$_PostInit$_(), this._$_InitGlobalVariableScriptInterface$_(), 
            j._$clearArray$_(this._$_objectReferenceTable$_), this._$FlushPendingInstances$_();
            let o = "any", a = s[20];
            1 === a ? o = "portrait" : 2 === a && (o = "landscape"), this._$PostComponentMessageToDOM$_("runtime", "set-target-orientation", {
                targetOrientation: o
            });
        }
        async _$_LoadExportToVideoData$_(t) {
            const s = t.format;
            "image-sequence" === s ? this._$_exportToVideo$_ = new self.C3ExportToImageSequence(this, t) : "image-sequence-gif" === s ? this._$_exportToVideo$_ = new self.C3ExportToGIF(this, t) : "webm" === s ? this._$_exportToVideo$_ = new self.C3ExportToWebMVideo(this, t) : "mp4" === s && (this._$_exportToVideo$_ = new self.C3ExportToMP4Video(this, t)), 
            this._$_framerateMode$_ = "unlimited-frame", this._$_canvasManager$_._$SetFullscreenMode$_("off"), 
            this._$_devicePixelRatio$_ = 1, self.devicePixelRatio = 1, await this._$PostComponentMessageToDOMAsync$_("runtime", "set-exporting-to-video", {
                message: this._$_exportToVideo$_.GetExportingMessageForPercent(0),
                duration: this._$_exportToVideo$_._$GetDuration$_()
            });
        }
        _$GetLoaderStyle$_() {
            return this._$_loaderStyle$_;
        }
        _$IsExportToVideo$_() {
            return null !== this._$_exportToVideo$_;
        }
        _$GetExportVideoDuration$_() {
            return this._$_exportToVideo$_._$GetDuration$_();
        }
        _$GetExportVideoFramerate$_() {
            return this._$_exportToVideo$_.GetFramerate();
        }
        _$_InitExportToVideo$_() {
            return this._$_exportToVideo$_._$Init$_({
                width: this._$_canvasManager$_._$GetDeviceWidth$_(),
                height: this._$_canvasManager$_._$GetDeviceHeight$_()
            });
        }
        _$_ExportToVideoAddFrame$_() {
            const t = this._$_tickCount$_ / this._$GetExportVideoFramerate$_();
            return this._$_exportToVideo$_.AddFrame(this._$_canvasManager$_._$GetMainCanvas$_(), t);
        }
        _$_ExportToVideoAddKeyframe$_() {
            this._$_exportToVideo$_ && this._$_exportToVideo$_._$AddKeyframe$_();
        }
        _$_OnOfflineAudioRenderCompleted$_(t) {
            this._$_exportToVideo$_.OnOfflineAudioRenderCompleted(t);
        }
        _$_ExportToVideoFinish$_() {
            return this._$_exportToVideo$_._$Finish$_();
        }
        _$IsFBInstantAvailable$_() {
            return this._$_isFBInstantAvailable$_;
        }
        _$IsLoading$_() {
            return this._$_isLoading$_;
        }
        _$AddLoadPromise$_(t) {
            this._$_additionalLoadPromises$_.push(t);
        }
        _$SetUsingCreatePromises$_(t) {
            this._$_isUsingCreatePromises$_ = !!t;
        }
        _$AddCreatePromise$_(t) {
            this._$_isUsingCreatePromises$_ && this._$_additionalCreatePromises$_.push(t);
        }
        _$GetCreatePromises$_() {
            return this._$_additionalCreatePromises$_;
        }
        _$_GetNextFamilyIndex$_() {
            return this._$_familyCount$_++;
        }
        _$GetFamilyCount$_() {
            return this._$_familyCount$_;
        }
        _$_AddEffectList$_(t) {
            this._$_allEffectLists$_.add(t);
        }
        _$_RemoveEffectList$_(t) {
            this._$_allEffectLists$_.delete(t);
        }
        _$_GetAllEffectLists$_() {
            return this._$_allEffectLists$_;
        }
        async _$_InitialiseCanvas$_(t) {
            this._$_canvasManager$_ && (await this._$_canvasManager$_._$CreateCanvas$_(t), 
            this._$_canvasManager$_._$InitLoadingScreen$_(this._$_loaderStyle$_));
        }
        async _$_MaybeLoadOpusDecoder$_() {
            const h = this._$_assetManager$_;
            if (!h._$IsAudioFormatSupported$_("audio/webm; codecs=opus")) {
                let t = null, s = h._$GetScriptSubfolder$_(), i = s + "opus.wasm.js", e = s + "opus.wasm.wasm";
                try {
                    t = this._$IsiOSCordova$_() && h._$IsFileProtocol$_() ? await h._$CordovaFetchLocalFileAsArrayBuffer$_(e) : await h._$FetchArrayBuffer$_(e);
                } catch (t) {
                    return void console.info("Failed to fetch Opus decoder WASM; assuming project has no Opus audio.", t);
                }
                this._$AddJobWorkerBuffer$_(t, "opus-decoder-wasm"), await this._$AddJobWorkerScripts$_([ i ]);
            }
        }
        async _$_WasmDecodeWebMOpus$_(t) {
            const s = await this._$AddJob$_("OpusDecode", {
                arrayBuffer: t
            }, [ t ]);
            return s;
        }
        async _$Start$_() {
            this._$_hasStarted$_ = !0, this._$_startTime$_ = Date.now();
            let s = null, t = new Promise(t => s = t);
            if (this._$_usesLoaderLayout$_) {
                for (const h of this._$_allObjectClasses$_) h._$IsFamily$_() || h._$IsOnLoaderLayout$_() || !h._$IsWorldType$_() || h._$OnCreate$_();
                (async () => {
                    await this._$_assetManager$_._$WaitForAllToLoad$_(), await t, 
                    this._$_isLoading$_ = !1, this._$_OnLoadFinished$_();
                })();
            } else this._$_isLoading$_ = !1;
            this._$_assetManager$_._$SetInitialLoadFinished$_(), this._$IsDebug$_() && V.RuntimeInit(n);
            for (const r of this._$_layoutManager$_._$GetAllLayouts$_()) r._$_CreateGlobalNonWorlds$_();
            this._$IsExportToVideo$_() && await this._$_InitExportToVideo$_();
            const i = this._$_layoutManager$_._$GetFirstLayout$_(), e = (await i._$_Load$_(null, this._$GetRenderer$_()), 
            await i._$_StartRunning$_(!0), this._$_fpsLastTime$_ = performance.now(), 
            s(), this._$_usesLoaderLayout$_ || this._$_OnLoadFinished$_(), await this._$PostComponentMessageToDOMAsync$_("runtime", "before-start-ticking"));
            e.isSuspended && !this._$IsExportToVideo$_() ? (this._$_suspendCount$_++, 
            this._$_isPageVisibilitySuspended$_ = !0) : this._$Tick$_();
        }
        _$_OnLoadFinished$_() {
            this._$Trigger$_(j._$Plugins$_._$System$_._$Cnds$_._$OnLoadFinished$_, null, null), 
            this._$PostComponentMessageToDOM$_("runtime", "register-sw");
        }
        _$GetObjectReference$_(t) {
            t = Math.floor(t);
            const s = this._$_objectReferenceTable$_;
            if (t < 0 || t >= s.length) throw new Error("invalid object reference");
            return s[t];
        }
        _$_LoadJsPropNameTable$_() {
            for (const t of self._$C3_JsPropNameTable$_) {
                const s = j.first(Object.keys(t));
                this._$_jsPropNameTable$_.push(s);
            }
        }
        _$GetJsPropName$_(t) {
            t = Math.floor(t);
            const s = this._$_jsPropNameTable$_;
            if (t < 0 || t >= s.length) throw new Error("invalid prop reference");
            return s[t];
        }
        _$HasDOM$_() {
            return this._$_hasDom$_;
        }
        _$IsHeadless$_() {
            return this._$_isHeadless$_;
        }
        _$IsInWorker$_() {
            return this._$_isInWorker$_;
        }
        _$GetRuntimeBaseURL$_() {
            return this._$_runtimeBaseUrl$_;
        }
        _$GetPreviewURL$_() {
            return this._$_previewUrl$_;
        }
        _$GetEventSheetManager$_() {
            return this._$_eventSheetManager$_;
        }
        _$GetEventStack$_() {
            return this._$_eventSheetManager$_._$GetEventStack$_();
        }
        _$GetCurrentEventStackFrame$_() {
            return this._$_eventSheetManager$_._$GetCurrentEventStackFrame$_();
        }
        _$GetCurrentEvent$_() {
            return this._$_eventSheetManager$_._$GetCurrentEvent$_();
        }
        _$GetCurrentCondition$_() {
            return this._$_eventSheetManager$_._$GetCurrentCondition$_();
        }
        _$IsCurrentConditionFirst$_() {
            return 0 === this._$GetCurrentEventStackFrame$_()._$GetConditionIndex$_();
        }
        _$GetCurrentAction$_() {
            return this._$_eventSheetManager$_._$GetCurrentAction$_();
        }
        _$GetAddonManager$_() {
            return this._$_addonManager$_;
        }
        _$GetSystemPlugin$_() {
            return this._$_addonManager$_._$GetSystemPlugin$_();
        }
        _$GetObjectClassByIndex$_(t) {
            if ((t = Math.floor(t)) < 0 || t >= this._$_allObjectClasses$_.length) throw new RangeError("invalid index");
            return this._$_allObjectClasses$_[t];
        }
        _$GetObjectClassByName$_(t) {
            return this._$_objectClassesByName$_.get(t.toLowerCase()) || null;
        }
        _$GetObjectClassBySID$_(t) {
            return this._$_objectClassesBySid$_.get(t) || null;
        }
        _$GetSingleGlobalObjectClassByCtor$_(t) {
            const s = j._$AddonManager$_._$GetPluginByConstructorFunction$_(t);
            return s ? s._$GetSingleGlobalObjectClass$_() : null;
        }
        _$GetAllObjectClasses$_() {
            return this._$_allObjectClasses$_;
        }
        *_$allInstances$_() {
            for (const t of this._$_allObjectClasses$_) t._$IsFamily$_() || (yield* t.instances());
        }
        _$Dispatcher$_() {
            return this._$_dispatcher$_;
        }
        _$UserScriptDispatcher$_() {
            return this._$_userScriptDispatcher$_;
        }
        _$DispatchUserScriptEvent$_(t) {
            t.runtime = this._$GetIRuntime$_();
            const s = this._$IsDebug$_() && !this._$_eventSheetManager$_._$IsInEventEngine$_();
            s && V.StartMeasuringScriptTime(), this._$_userScriptDispatcher$_.dispatchEvent(t), 
            s && V.AddScriptTime();
        }
        _$DispatchUserScriptEventAsyncWait$_(t) {
            return t.runtime = this._$GetIRuntime$_(), this._$_userScriptDispatcher$_._$dispatchEventAndWaitAsync$_(t);
        }
        _$GetOriginalViewportWidth$_() {
            return this._$_originalViewportWidth$_;
        }
        _$GetOriginalViewportHeight$_() {
            return this._$_originalViewportHeight$_;
        }
        _$SetOriginalViewportSize$_(t, s) {
            if (this._$_originalViewportWidth$_ !== t || this._$_originalViewportHeight$_ !== s) {
                this._$_originalViewportWidth$_ = t, this._$_originalViewportHeight$_ = s;
                const i = this._$GetLayoutManager$_();
                i._$SetAllLayerProjectionChanged$_(), i._$SetAllLayerMVChanged$_();
            }
        }
        _$GetViewportWidth$_() {
            return this._$_viewportWidth$_;
        }
        _$GetViewportHeight$_() {
            return this._$_viewportHeight$_;
        }
        _$SetViewportSize$_(t, s) {
            if (this._$_viewportWidth$_ !== t || this._$_viewportHeight$_ !== s) {
                this._$_viewportWidth$_ = t, this._$_viewportHeight$_ = s;
                const i = this._$GetLayoutManager$_();
                i._$SetAllLayerProjectionChanged$_(), i._$SetAllLayerMVChanged$_();
            }
        }
        _$_SetDevicePixelRatio$_(t) {
            this._$IsExportToVideo$_() || (this._$_devicePixelRatio$_ = t);
        }
        _$GetDevicePixelRatio$_() {
            return this._$_devicePixelRatio$_;
        }
        _$GetParallaxXOrigin$_() {
            return this._$_parallaxXorigin$_;
        }
        _$GetParallaxYOrigin$_() {
            return this._$_parallaxYorigin$_;
        }
        _$GetCanvasManager$_() {
            return this._$_canvasManager$_;
        }
        _$GetDrawWidth$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetDrawWidth$_() : this._$_viewportWidth$_;
        }
        _$GetDrawHeight$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetDrawHeight$_() : this._$_viewportHeight$_;
        }
        _$GetRenderScale$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetRenderScale$_() : 1;
        }
        _$GetDisplayScale$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetDisplayScale$_() : 1;
        }
        _$GetEffectLayerScaleParam$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetEffectLayerScaleParam$_() : 1;
        }
        _$GetEffectDevicePixelRatioParam$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetEffectDevicePixelRatioParam$_() : 1;
        }
        _$GetCanvasClientX$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetCanvasClientX$_() : 0;
        }
        _$GetCanvasClientY$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetCanvasClientY$_() : 0;
        }
        _$GetCanvasCssWidth$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetCssWidth$_() : 0;
        }
        _$GetCanvasCssHeight$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetCssHeight$_() : 0;
        }
        _$GetFullscreenMode$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetFullscreenMode$_() : "off";
        }
        _$GetAdditionalRenderTarget$_(t) {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetAdditionalRenderTarget$_(t) : null;
        }
        _$ReleaseAdditionalRenderTarget$_(t) {
            this._$_canvasManager$_ && this._$_canvasManager$_._$ReleaseAdditionalRenderTarget$_(t);
        }
        _$UsesAnyBackgroundBlending$_() {
            return this._$_usesAnyBackgroundBlending$_;
        }
        _$UsesAnyCrossSampling$_() {
            return this._$_usesAnyCrossSampling$_;
        }
        _$UsesAnyDepthSampling$_() {
            return this._$_usesAnyDepthSampling$_;
        }
        _$GetGPUUtilisation$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetGPUUtilisation$_() : NaN;
        }
        _$IsLinearSampling$_() {
            return "nearest" !== this._$GetSampling$_();
        }
        _$GetFramerateMode$_() {
            return this._$_framerateMode$_;
        }
        _$_SetFramerateMode$_(t) {
            this._$_framerateMode$_ !== t && (this._$_framerateMode$_ = t, -1 !== this._$_rafId$_ || -1 !== this._$_ruafId$_) && (this._$_CancelAnimationFrame$_(), 
            this._$_RequestAnimationFrame$_());
        }
        _$GetSampling$_() {
            return this._$_sampling$_;
        }
        _$UsesLoaderLayout$_() {
            return this._$_usesLoaderLayout$_;
        }
        _$GetLoadingLogoAsset$_() {
            return this._$_loadingLogoAsset$_;
        }
        _$ReleaseLoadingLogoAsset$_() {
            this._$_loadingLogoAsset$_ && (this._$_loadingLogoAsset$_._$ReleaseTexture$_(), 
            this._$_loadingLogoAsset$_._$Release$_(), this._$_loadingLogoAsset$_ = null);
        }
        _$GetLayoutManager$_() {
            return this._$_layoutManager$_;
        }
        _$GetMainRunningLayout$_() {
            return this._$_layoutManager$_._$GetMainRunningLayout$_();
        }
        _$GetTimelineManager$_() {
            return this._$_timelineManager$_;
        }
        _$GetTransitionManager$_() {
            return this._$_transitionManager$_;
        }
        _$GetTemplateManager$_() {
            return this._$_templateManager$_;
        }
        _$GetFlowchartManager$_() {
            return this._$_flowchartManager$_;
        }
        _$GetAssetManager$_() {
            return this._$_assetManager$_;
        }
        _$LoadImage$_(t) {
            return this._$_assetManager$_._$LoadImage$_(t);
        }
        _$CreateInstance$_(t, s, i, e, h, r) {
            if (r && this._$_templateManager$_) {
                if (t instanceof j._$ObjectClass$_ && t._$IsFamily$_()) {
                    const o = t._$GetFamilyMembers$_(), a = Math.floor(this._$Random$_() * o.length);
                    return this._$CreateInstance$_(o[a], s, i, e, h, r);
                }
                const n = this._$_templateManager$_._$GetTemplateData$_(t, r);
                if (n) {
                    const l = this._$CreateInstanceFromData$_(n, s, !1, i, e, !1, h, void 0, h);
                    return this._$_templateManager$_._$MapInstanceToTemplateName$_(l, r), 
                    l;
                }
            }
            return this._$CreateInstanceFromData$_(t, s, !1, i, e, !1, h, void 0, h);
        }
        _$CreateInstanceFromData$_(t, s, i, e, h, r, n, o, a) {
            let l = null, u = null;
            if (t instanceof j._$ObjectClass$_) {
                if ((u = t)._$IsFamily$_()) {
                    const S = u._$GetFamilyMembers$_(), b = Math.floor(this._$Random$_() * S.length);
                    u = S[b];
                }
                l = u._$GetDefaultInstanceData$_();
            } else l = t, u = this._$GetObjectClassByIndex$_(l[1]);
            const c = u._$GetPlugin$_()._$IsWorldType$_();
            if (this._$_isLoading$_ && c && !u._$IsOnLoaderLayout$_()) return null;
            const f = s;
            c || (s = null);
            let d;
            d = i && !r && l && !this._$_instancesByUid$_.has(l[2]) ? l[2] : this._$_nextUid$_++;
            const p = l ? l[0] : null, m = j._$New$_(j.Instance, {
                runtime: this,
                _$objectType$_: u,
                _$layer$_: s,
                _$worldData$_: p,
                _$instVarData$_: l ? l[3] : null,
                uid: d,
                tags: l ? l[6] : null
            });
            this._$_instancesByUid$_.set(d, m);
            let g = null, y = (c && (g = m._$GetWorldInfo$_(), void 0 !== e && void 0 !== h && (g._$SetX$_(e), 
            g._$SetY$_(h)), u._$_SetAnyCollisionCellChanged$_(!0)), s && (a || s._$_AddInstance$_(m, !0), 
            s._$GetLayout$_()._$MaybeLoadTexturesFor$_(u)), this._$_objectCount$_++, 
            !0);
            if (o) {
                const M = o._$GetObjectClass$_();
                if (M._$IsInContainer$_() && u._$IsInContainer$_()) {
                    const v = u._$GetContainer$_(), x = M._$GetContainer$_();
                    v === x && (y = !1);
                }
            }
            if (u._$IsInContainer$_() && !i && !r && y) {
                const G = new Set();
                for (const T of u._$GetContainer$_()._$objectTypes$_()) if (T !== u) {
                    const _ = this._$_MaybeGetChildInstanceForObjectTypeData$_(T, g, G);
                    if (_) {
                        const I = this._$CreateInstanceFromData$_(_, f, !1, g ? g._$GetX$_() : e, g ? g._$GetY$_() : h, !0, !1, void 0, a);
                        m._$_AddSibling$_(I);
                    } else {
                        const C = this._$CreateInstanceFromData$_(T, f, !1, g ? g._$GetX$_() : e, g ? g._$GetY$_() : h, !0, !1, void 0, a);
                        m._$_AddSibling$_(C);
                    }
                }
                for (const R of m._$siblings$_()) {
                    R._$_AddSibling$_(m);
                    for (const P of m._$siblings$_()) R !== P && R._$_AddSibling$_(P);
                }
            }
            if (c && !i && n && this._$_CreateChildInstancesFromData$_(m, p, g, s, e, h, a), 
            u._$IsInContainer$_() && !i && !r && n) for (const E of m._$siblings$_()) {
                const A = E._$GetWorldInfo$_();
                if (A) {
                    const B = E._$GetPlugin$_(), F = E._$GetObjectClass$_()._$GetDefaultInstanceData$_()[0];
                    B._$IsWorldType$_() ? this._$_CreateChildInstancesFromData$_(E, F, A, s, A._$GetX$_(), A._$GetY$_(), a) : this._$_CreateChildInstancesFromData$_(E, F, A, s, void 0, void 0, a);
                }
            }
            if (!r && n) {
                void 0 === e && (e = p[0]), void 0 === h && (h = p[1]);
                const O = g._$GetTopParent$_(), N = e - g._$GetX$_() + O._$GetX$_(), W = h - g._$GetY$_() + O._$GetY$_();
                O._$SetXY$_(N, W);
            }
            u._$_SetIIDsStale$_();
            const k = l ? j._$cloneArray$_(l[5]) : null, L = l ? l[4].map(t => j._$cloneArray$_(t)) : null, w = c && p && p[13];
            if (w && m._$_SetHasTilemap$_(), m._$_CreateSdkInstance$_(k, L), w) {
                const D = p[13];
                m._$GetSdkInstance$_()._$LoadTilemapData$_(D[2], D[0], D[1]);
            }
            return this._$_instancesPendingCreate$_.push(m), this._$_hasPendingInstances$_ = !0, 
            this._$IsDebug$_() && V.InstanceCreated(m), m;
        }
        _$_GetInstanceData$_(t) {
            const s = t[0], i = t[1], e = t[2], h = t[6];
            if (h) return h;
            const r = this._$_layoutManager$_._$GetLayoutBySID$_(s), n = r._$GetLayer$_(i);
            return n._$GetInitialInstanceData$_(e);
        }
        _$_MaybeGetChildInstanceForObjectTypeData$_(t, s, i) {
            const e = s?._$GetSceneGraphChildrenExportData$_() ?? [];
            for (const h of e) {
                const r = this._$_GetInstanceData$_(h), n = !!h[4], o = this._$GetObjectClassByIndex$_(r[1]);
                if (!i.has(r) && (t === o && n)) return i.add(r), r;
            }
        }
        _$_CreateChildInstancesFromData$_(a, t, s, l, u, c, f) {
            const i = s._$GetSceneGraphZIndexExportData$_(), e = s._$GetSceneGraphChildrenExportData$_();
            if (a._$GetWorldInfo$_()._$SetSceneGraphZIndex$_(i), e) {
                void 0 === u && (u = t[0]), void 0 === c && (c = t[1]);
                const d = new Set(), p = t[0], m = t[1];
                for (const g of e) {
                    let t = g[0], s = g[1], i = g[2], e = g[3], h = !!g[4], r = g[5], n = g[6], o;
                    if (n) o = n; else {
                        const b = this._$_layoutManager$_._$GetLayoutBySID$_(t), M = b._$GetLayer$_(s);
                        o = M._$GetInitialInstanceData$_(i);
                    }
                    const y = this._$GetObjectClassByIndex$_(o[1]), w = a._$HasSibling$_(y), S = d.has(y);
                    if (w && !S && h) {
                        const v = a._$GetSibling$_(y), x = (v._$GetWorldInfo$_()._$Init$_(o[0]), 
                        u + o[0][0] - p), G = c + o[0][1] - m;
                        v._$GetWorldInfo$_()._$SetXY$_(x, G), v._$GetWorldInfo$_()._$SetSceneGraphZIndex$_(r), 
                        a._$AddChild$_(v, {
                            _$transformX$_: !!(e >> 0 & 1),
                            _$transformY$_: !!(e >> 1 & 1),
                            _$transformWidth$_: !!(e >> 2 & 1),
                            _$transformHeight$_: !!(e >> 3 & 1),
                            _$transformAngle$_: !!(e >> 4 & 1),
                            _$destroyWithParent$_: !!(e >> 5 & 1),
                            _$transformZElevation$_: !!(e >> 6 & 1),
                            _$transformOpacity$_: !!(e >> 7 & 1),
                            _$transformVisibility$_: !!(e >> 8 & 1)
                        }), d.add(y);
                    } else {
                        const T = u + o[0][0] - p, _ = c + o[0][1] - m, I = this._$CreateInstanceFromData$_(o, l, !1, T, _, !1, !0, a, f);
                        I._$GetWorldInfo$_()._$SetSceneGraphZIndex$_(r), a._$AddChild$_(I, {
                            _$transformX$_: !!(e >> 0 & 1),
                            _$transformY$_: !!(e >> 1 & 1),
                            _$transformWidth$_: !!(e >> 2 & 1),
                            _$transformHeight$_: !!(e >> 3 & 1),
                            _$transformAngle$_: !!(e >> 4 & 1),
                            _$destroyWithParent$_: !!(e >> 5 & 1),
                            _$transformZElevation$_: !!(e >> 6 & 1),
                            _$transformOpacity$_: !!(e >> 7 & 1),
                            _$transformVisibility$_: !!(e >> 8 & 1)
                        });
                    }
                }
            }
        }
        _$DestroyInstance$_(i) {
            if (!this._$_instancesPendingRelease$_.has(i)) {
                let t = i._$GetObjectClass$_(), s = this._$_instancesPendingDestroy$_.get(t);
                if (s) {
                    if (s.has(i)) return;
                    s.add(i);
                } else (s = new Set()).add(i), this._$_instancesPendingDestroy$_.set(t, s);
                if (this._$IsDebug$_() && V.InstanceDestroyed(i), i._$_MarkDestroyed$_(), 
                this._$_hasPendingInstances$_ = !0, i._$IsInContainer$_()) for (const e of i._$siblings$_()) this._$DestroyInstance$_(e);
                for (const h of i.children()) h._$GetDestroyWithParent$_() && this._$DestroyInstance$_(h);
                if (!this._$_layoutManager$_._$IsEndingLayout$_() && !this._$_isLoadingState$_) {
                    const r = this._$GetEventSheetManager$_();
                    r._$BlockFlushingInstances$_(!0), i._$_TriggerOnDestroyed$_(), 
                    r._$BlockFlushingInstances$_(!1);
                }
                i._$_FireDestroyedScriptEvents$_(this._$_layoutManager$_._$IsEndingLayout$_());
            }
        }
        _$FlushPendingInstances$_() {
            this._$_hasPendingInstances$_ && (this._$_isFlushingPendingInstances$_ = !0, 
            this._$_FlushInstancesPendingCreate$_(), this._$_FlushInstancesPendingDestroy$_(), 
            this._$_isFlushingPendingInstances$_ = !1, this._$_hasPendingInstances$_ = !1, 
            this._$UpdateRender$_());
        }
        _$_FlushInstancesPendingCreate$_() {
            for (const t of this._$_instancesPendingCreate$_) {
                const s = t._$GetObjectClass$_();
                s._$_AddInstance$_(t);
                for (const i of s._$GetFamilies$_()) i._$_AddInstance$_(t), i._$_SetIIDsStale$_();
            }
            j._$clearArray$_(this._$_instancesPendingCreate$_);
        }
        _$_FlushInstancesPendingDestroy$_() {
            this._$_dispatcher$_._$SetDelayRemoveEventsEnabled$_(!0);
            for (const [ t, s ] of this._$_instancesPendingDestroy$_.entries()) this._$_FlushInstancesPendingDestroyForObjectClass$_(t, s), 
            s.clear();
            this._$_instancesPendingDestroy$_.clear(), this._$_dispatcher$_._$SetDelayRemoveEventsEnabled$_(!1);
        }
        _$_FlushInstancesPendingDestroyForObjectClass$_(t, s) {
            for (const i of s) {
                const e = this._$_eventObjects$_.instancedestroy, h = (e._$instance$_ = i, 
                this._$_dispatcher$_.dispatchEvent(e), this._$_instancesByUid$_.delete(i._$GetUID$_()), 
                this._$_instanceTimes$_.delete(i), i._$GetWorldInfo$_());
                h && (h._$_RemoveFromCollisionCells$_(), h._$_RemoveFromRenderCells$_(), 
                h._$_MarkDestroyed$_()), this._$_instancesPendingRelease$_.add(i), 
                this._$_objectCount$_--;
            }
            j._$arrayRemoveAllInSet$_(t._$GetInstances$_(), s), t._$_SetIIDsStale$_(), 
            this._$_instancesPendingReleaseAffectedObjectClasses$_.add(t);
            for (const r of t._$GetFamilies$_()) j._$arrayRemoveAllInSet$_(r._$GetInstances$_(), s), 
            r._$_SetIIDsStale$_(), this._$_instancesPendingReleaseAffectedObjectClasses$_.add(r);
            if (t._$GetPlugin$_()._$IsWorldType$_()) {
                const n = new Set([ ...s ].map(t => t._$GetWorldInfo$_()._$GetLayer$_()));
                for (const o of n) o._$_RemoveAllInstancesInSet$_(s);
            }
        }
        _$_GetInstancesPendingCreate$_() {
            return this._$_instancesPendingCreate$_;
        }
        *_$instancesPendingCreateForObjectClass$_(t) {
            for (const s of this._$_GetInstancesPendingCreate$_()) t._$IsFamily$_() ? s._$GetObjectClass$_()._$BelongsToFamily$_(t) && (yield s) : s._$GetObjectClass$_() === t && (yield s);
        }
        _$_GetNewUID$_() {
            return this._$_nextUid$_++;
        }
        _$_MapInstanceByUID$_(t, s) {
            this._$_instancesByUid$_.set(t, s);
        }
        _$_SetAutoSuspendEnabled$_(t) {
            this._$_isAutoSuspendEnabled$_ !== (t = !!t) && (this._$_isAutoSuspendEnabled$_ = !!t, 
            this._$_isAutoSuspendEnabled$_) && this._$_isPageVisibilitySuspended$_ && (this._$SetSuspended$_(!1), 
            this._$_isPageVisibilitySuspended$_ = !1);
        }
        _$_IsAutoSuspendEnabled$_() {
            return this._$_isAutoSuspendEnabled$_;
        }
        _$_OnRendererContextLost$_() {
            this._$_dispatcher$_.dispatchEvent(j._$New$_(j.Event, "renderercontextlost")), 
            this._$SetSuspended$_(!0);
            for (const s of this._$_allObjectClasses$_) !s._$IsFamily$_() && s._$HasLoadedTextures$_() && s._$ReleaseTextures$_();
            const t = this._$GetMainRunningLayout$_();
            t && t._$_OnRendererContextLost$_(), j._$ImageInfo$_._$OnRendererContextLost$_(), 
            j._$ImageAsset$_._$OnRendererContextLost$_();
        }
        async _$_OnRendererContextRestored$_() {
            await this._$GetMainRunningLayout$_()._$_Load$_(null, this._$GetRenderer$_()), 
            this._$_dispatcher$_.dispatchEvent(j._$New$_(j.Event, "renderercontextrestored")), 
            this._$SetSuspended$_(!1), this._$UpdateRender$_();
        }
        _$_OnVisibilityChange$_(t) {
            if (this._$_isAutoSuspendEnabled$_) {
                const s = t.hidden;
                this._$SetSuspended$_(s), (this._$_isPageVisibilitySuspended$_ = s) || this._$UpdateRender$_();
            }
        }
        _$_OnWindowBlur$_(t) {
            !this._$IsPreview$_() || !this._$_pauseOnBlur$_ || j._$Platform$_._$IsMobile$_ || t.data.parentHasFocus || (this._$SetSuspended$_(!0), 
            this._$_isPausedOnBlur$_ = !0);
        }
        _$_OnWindowFocus$_() {
            this._$_isPausedOnBlur$_ && (this._$SetSuspended$_(!1), this._$_isPausedOnBlur$_ = !1);
        }
        _$_RequestAnimationFrame$_() {
            const t = this._$_tickCallbacks$_;
            "vsync" === this._$_framerateMode$_ ? -1 === this._$_rafId$_ && (this._$_rafId$_ = self.requestAnimationFrame(t._$normal$_)) : "unlimited-tick" === this._$_framerateMode$_ ? (-1 === this._$_ruafId$_ && (this._$_ruafId$_ = j._$RequestUnlimitedAnimationFrame$_(t._$tickOnly$_)), 
            -1 === this._$_rafId$_ && (this._$_rafId$_ = self.requestAnimationFrame(t._$renderOnly$_))) : -1 === this._$_ruafId$_ && (this._$_ruafId$_ = j._$RequestUnlimitedAnimationFrame$_(t._$normal$_));
        }
        _$_CancelAnimationFrame$_() {
            -1 !== this._$_rafId$_ && (self.cancelAnimationFrame(this._$_rafId$_), 
            this._$_rafId$_ = -1), -1 !== this._$_ruafId$_ && (j._$CancelUnlimitedAnimationFrame$_(this._$_ruafId$_), 
            this._$_ruafId$_ = -1);
        }
        _$IsSuspended$_() {
            return 0 < this._$_suspendCount$_;
        }
        _$SetSuspended$_(t) {
            if (!this._$IsExportToVideo$_()) {
                const s = this._$IsSuspended$_(), i = (this._$_suspendCount$_ += t ? 1 : -1, 
                this._$_suspendCount$_ < 0 && (this._$_suspendCount$_ = 0), this._$IsSuspended$_());
                if (!s && i) console.log("[Construct] Suspending"), this._$_CancelAnimationFrame$_(), 
                this._$_dispatcher$_.dispatchEvent(j._$New$_(j.Event, "suspend")), 
                this._$Trigger$_(j._$Plugins$_._$System$_._$Cnds$_._$OnSuspend$_, null, null); else if (s && !i) {
                    console.log("[Construct] Resuming");
                    const e = performance.now();
                    this._$_lastTickTime$_ = e, this._$_fpsLastTime$_ = e, this._$_fpsFrameCount$_ = 0, 
                    this._$_fps$_ = 0, this._$_tpsTickCount$_ = 0, this._$_tps$_ = 0, 
                    this._$_mainThreadTime$_ = 0, this._$_mainThreadTimeCounter$_ = 0, 
                    this._$_dispatcher$_.dispatchEvent(j._$New$_(j.Event, "resume")), 
                    this._$Trigger$_(j._$Plugins$_._$System$_._$Cnds$_._$OnResume$_, null, null), 
                    this._$HitBreakpoint$_() || this._$Tick$_(e);
                }
            }
        }
        _$_AddBehInstToTick$_(t) {
            this._$_behInstsToTick$_._$Add$_(t);
        }
        _$_AddBehInstToPostTick$_(t) {
            this._$_behInstsToPostTick$_._$Add$_(t);
        }
        _$_AddBehInstToTick2$_(t) {
            this._$_behInstsToTick2$_._$Add$_(t);
        }
        _$_RemoveBehInstToTick$_(t) {
            this._$_behInstsToTick$_._$Remove$_(t);
        }
        _$_RemoveBehInstToPostTick$_(t) {
            this._$_behInstsToPostTick$_._$Remove$_(t);
        }
        _$_RemoveBehInstToTick2$_(t) {
            this._$_behInstsToTick2$_._$Remove$_(t);
        }
        _$_BehaviorTick$_() {
            const t = globalThis._$ISDKBehaviorInstanceBase$_;
            this._$_behInstsToTick$_._$SetQueueingEnabled$_(!0);
            for (const s of this._$_behInstsToTick$_) s instanceof t ? s._$_tick$_() : s._$Tick$_();
            this._$_behInstsToTick$_._$SetQueueingEnabled$_(!1);
        }
        _$_BehaviorPostTick$_() {
            const t = globalThis._$ISDKBehaviorInstanceBase$_;
            this._$_behInstsToPostTick$_._$SetQueueingEnabled$_(!0);
            for (const s of this._$_behInstsToPostTick$_) s instanceof t ? s._$_postTick$_() : s._$PostTick$_();
            this._$_behInstsToPostTick$_._$SetQueueingEnabled$_(!1);
        }
        _$_BehaviorTick2$_() {
            const t = globalThis._$ISDKBehaviorInstanceBase$_;
            this._$_behInstsToTick2$_._$SetQueueingEnabled$_(!0);
            for (const s of this._$_behInstsToTick2$_) s instanceof t ? s._$_tick2$_() : s._$Tick2$_();
            this._$_behInstsToTick2$_._$SetQueueingEnabled$_(!1);
        }
        *_$_DebugBehaviorTick$_() {
            const s = globalThis._$ISDKBehaviorInstanceBase$_;
            this._$_behInstsToTick$_._$SetQueueingEnabled$_(!0);
            for (const i of this._$_behInstsToTick$_) {
                let t;
                t = i instanceof s ? i._$_tick$_() : i._$Tick$_(), j._$IsIterator$_(t) && (yield* t);
            }
            this._$_behInstsToTick$_._$SetQueueingEnabled$_(!1);
        }
        *_$_DebugBehaviorPostTick$_() {
            const s = globalThis._$ISDKBehaviorInstanceBase$_;
            this._$_behInstsToPostTick$_._$SetQueueingEnabled$_(!0);
            for (const i of this._$_behInstsToPostTick$_) {
                let t;
                t = i instanceof s ? i._$_postTick$_() : i._$PostTick$_(), j._$IsIterator$_(t) && (yield* t);
            }
            this._$_behInstsToPostTick$_._$SetQueueingEnabled$_(!1);
        }
        *_$_DebugBehaviorTick2$_() {
            const s = globalThis._$ISDKBehaviorInstanceBase$_;
            this._$_behInstsToTick2$_._$SetQueueingEnabled$_(!0);
            for (const i of this._$_behInstsToTick2$_) {
                let t;
                t = i instanceof s ? i._$_tick2$_() : i._$Tick2$_(), j._$IsIterator$_(t) && (yield* t);
            }
            this._$_behInstsToTick2$_._$SetQueueingEnabled$_(!1);
        }
        async _$Tick$_(a, t, s) {
            this._$_hasStartedTicking$_ = !0;
            const l = "background-wake" === s, u = "background-wake" !== s && "skip-render" !== s, c = this._$GetLayoutManager$_(), f = this._$GetCanvasManager$_();
            if (this._$_hasStarted$_ && (!this._$IsSuspended$_() || t || l)) {
                let t = performance.now(), s = (this._$_isInTick$_ = !0, this._$_MeasureDt$_(a || 0), 
                this._$_tpsTickCount$_++, this._$_ReleasePendingInstances$_(), this._$Step_BeforePreTick$_()), i = (this._$IsDebugging$_() && await s, 
                this._$_dispatcher$_._$dispatchEventAndWait_AsyncOptional$_(this._$_eventObjects$_.pretick)), e = (i instanceof Promise && await i, 
                this._$Step_AfterPreTick$_()), h = (this._$IsDebugging$_() && await e, 
                this._$_NeedsHandleSaveOrLoad$_() && await this._$_HandleSaveOrLoad$_(), 
                c._$IsPendingChangeMainLayout$_() && await this._$_MaybeChangeLayout$_(), 
                this._$Step_RunEventsEtc$_()), r = (this._$IsDebugging$_() && await h, 
                c._$GetMainRunningLayout$_()), n = r._$_GetPendingSetHTMLLayerCount$_(), o = !1;
                if (-1 !== n && (r._$_ResetPendingHTMLLayerCount$_(), f._$GetHTMLLayerCount$_() !== n)) {
                    const d = this._$GetCanvasManager$_()._$SetHTMLLayerCount$_(n);
                    this._$IsInWorker$_() && (o = !0, await d);
                }
                u && this._$Render$_(), o && this._$PostComponentMessageToDOM$_("canvas", "cleanup-html-layers"), 
                this._$IsExportToVideo$_() && (await this._$_ExportToVideoAddFrame$_(), 
                this._$GetGameTime$_() >= this._$GetExportVideoDuration$_()) ? this._$_ExportToVideoFinish$_() : (this._$IsSuspended$_() || l || this._$_RequestAnimationFrame$_(), 
                this._$_tickCount$_++, this._$_tickCountNoSave$_++, this._$_isInTick$_ = !1, 
                this._$_mainThreadTimeCounter$_ += performance.now() - t);
            }
        }
        async _$Step_BeforePreTick$_() {
            const t = this._$_eventSheetManager$_, s = this._$IsDebug$_();
            this._$FlushPendingInstances$_(), t._$BlockFlushingInstances$_(!0), 
            this._$PushCurrentLayout$_(this._$GetMainRunningLayout$_()), s && V.StartMeasuringTime(), 
            this._$IsDebugging$_() ? await t._$DebugRunScheduledWaits$_() : t._$RunScheduledWaits$_(), 
            s && V.AddEventsTime(), this._$PopCurrentLayout$_(), t._$BlockFlushingInstances$_(!1), 
            this._$FlushPendingInstances$_(), t._$BlockFlushingInstances$_(!0);
        }
        async _$Step_AfterPreTick$_() {
            const t = this._$IsDebug$_(), s = this._$IsDebugging$_(), i = this._$_dispatcher$_, e = this._$_eventObjects$_, h = this._$_userScriptEventObjects$_;
            t && V.StartMeasuringTime(), s ? await this._$DebugIterateAndBreak$_(this._$_DebugBehaviorTick$_()) : this._$_BehaviorTick$_(), 
            s ? await this._$DebugIterateAndBreak$_(this._$_DebugBehaviorPostTick$_()) : this._$_BehaviorPostTick$_(), 
            t && V.AddBehaviorTickTime(), t && V.StartMeasuringTime(), s ? await this._$DebugFireGeneratorEventAndBreak$_(e.tick) : i.dispatchEvent(e.tick), 
            t && V.AddPluginTickTime(), this._$_eventSheetManager$_._$BlockFlushingInstances$_(!1), 
            this._$DispatchUserScriptEvent$_(h.tick);
        }
        async _$Step_RunEventsEtc$_() {
            const t = this._$_eventSheetManager$_, s = this._$_dispatcher$_, i = this._$_eventObjects$_, e = this._$IsDebug$_(), h = this._$IsDebugging$_();
            e && V.StartMeasuringTime(), h ? await t._$DebugRunEvents$_(this._$_layoutManager$_) : t._$RunEvents$_(this._$_layoutManager$_), 
            e && V.AddEventsTime(), this._$_collisionEngine$_._$ClearRegisteredCollisions$_(), 
            this._$_ReleasePendingInstances$_(), this._$_isLayoutFirstTick$_ = !1, 
            t._$BlockFlushingInstances$_(!0), e && V.StartMeasuringTime(), h ? await this._$DebugIterateAndBreak$_(this._$_DebugBehaviorTick2$_()) : this._$_BehaviorTick2$_(), 
            e && V.AddBehaviorTickTime(), e && V.StartMeasuringTime(), h ? await this._$DebugFireGeneratorEventAndBreak$_(i.tick2) : s.dispatchEvent(i.tick2), 
            e && V.AddPluginTickTime(), t._$BlockFlushingInstances$_(!1), h && await t._$RunQueuedDebugTriggersAsync$_();
        }
        _$_ReleasePendingInstances$_() {
            if (0 !== this._$_instancesPendingRelease$_.size) {
                const t = this._$_dispatcher$_;
                t._$SetDelayRemoveEventsEnabled$_(!0);
                for (const s of this._$_instancesPendingReleaseAffectedObjectClasses$_) s._$GetSolStack$_()._$RemoveInstances$_(this._$_instancesPendingRelease$_);
                this._$_instancesPendingReleaseAffectedObjectClasses$_.clear(), 
                this._$_eventSheetManager$_._$_OnInstancesReleased$_(this._$_instancesPendingRelease$_);
                for (const i of this._$_instancesPendingRelease$_) i._$Release$_();
                this._$_instancesPendingRelease$_.clear(), t._$SetDelayRemoveEventsEnabled$_(!1);
            }
        }
        async _$_MaybeChangeLayout$_() {
            let t = this._$GetLayoutManager$_(), s = 0;
            for (;t._$IsPendingChangeMainLayout$_() && s++ < 10; ) await this._$_DoChangeLayout$_(t._$GetPendingChangeMainLayout$_());
        }
        _$_MeasureDt$_(t) {
            let s = 0;
            if (this._$IsExportToVideo$_()) s = 1 / this._$GetExportVideoFramerate$_(), 
            this._$_dtRaw$_ = s, this._$_dt1$_ = s; else if (0 !== this._$_lastTickTime$_) {
                const i = Math.max(t - this._$_lastTickTime$_, 0);
                .5 < (s = i / 1e3) && (s = 0), this._$_dtRaw$_ = s, this._$_dt1$_ = j._$clamp$_(s, this._$_minDt$_, this._$_maxDt$_);
            }
            this._$_lastTickTime$_ = t, this._$_dt$_ = this._$_dt1$_ * this._$_timeScale$_, 
            this._$_gameTime$_._$Add$_(this._$_dt$_), this._$_gameTimeRaw$_._$Add$_(s * this._$_timeScale$_), 
            this._$_wallTime$_._$Add$_(this._$_dt1$_);
            for (const [ e, h ] of this._$_instanceTimes$_) h._$Add$_(this._$_dt1$_ * e._$GetTimeScale$_());
            this._$_canvasManager$_ && this._$_canvasManager$_._$_UpdateTick$_(), 
            1e3 <= t - this._$_fpsLastTime$_ && (this._$_fpsLastTime$_ += 1e3, 1e3 <= t - this._$_fpsLastTime$_ && (this._$_fpsLastTime$_ = t), 
            this._$_fps$_ = this._$_fpsFrameCount$_, this._$_fpsFrameCount$_ = 0, 
            this._$_tps$_ = this._$_tpsTickCount$_, this._$_tpsTickCount$_ = 0, 
            this._$_mainThreadTime$_ = Math.min(this._$_mainThreadTimeCounter$_ / 1e3, 1), 
            this._$_mainThreadTimeCounter$_ = 0, this._$_canvasManager$_ && this._$_canvasManager$_._$_Update1sFrameRange$_(), 
            this._$_collisionEngine$_._$_Update1sStats$_(), this._$IsDebug$_()) && V.Update1sPerfStats();
        }
        _$_SetTrackingInstanceTime$_(t, s) {
            if (s) {
                if (!this._$_instanceTimes$_.has(t)) {
                    const i = j._$New$_(j._$KahanSum$_);
                    i._$Copy$_(this._$_gameTime$_), this._$_instanceTimes$_.set(t, i);
                }
            } else this._$_instanceTimes$_.delete(t);
        }
        _$_GetInstanceGameTime$_(t) {
            const s = this._$_instanceTimes$_.get(t);
            return s ? s._$Get$_() : this._$GetGameTime$_();
        }
        async _$_DoChangeLayout$_(t) {
            const s = this._$_dispatcher$_, i = this._$GetLayoutManager$_(), e = i._$GetMainRunningLayout$_();
            await e._$_StopRunning$_(), e._$_Unload$_(t, this._$GetRenderer$_()), 
            e === t && this._$_eventSheetManager$_._$ClearAllScheduledWaits$_(), 
            this._$_collisionEngine$_._$ClearRegisteredCollisions$_(), this._$_ReleasePendingInstances$_(), 
            s.dispatchEvent(this._$_eventObjects$_.beforelayoutchange), j._$Asyncify$_._$SetHighThroughputMode$_(!0), 
            await t._$_Load$_(e, this._$GetRenderer$_()), j._$Asyncify$_._$SetHighThroughputMode$_(!1), 
            await t._$_StartRunning$_(!1), s.dispatchEvent(this._$_eventObjects$_.layoutchange), 
            this._$UpdateRender$_(), this._$_isLayoutFirstTick$_ = !0, this._$FlushPendingInstances$_(), 
            this._$_ExportToVideoAddKeyframe$_();
        }
        _$UpdateRender$_() {
            this._$_needRender$_ = !0;
        }
        _$GetWebGLRenderer$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetWebGLRenderer$_() : null;
        }
        _$GetWebGPURenderer$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetWebGPURenderer$_() : null;
        }
        _$GetRenderer$_() {
            return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetRenderer$_() : null;
        }
        _$Render$_() {
            const i = this._$_canvasManager$_;
            if (i && !i._$IsRendererContextLost$_()) {
                const e = this._$GetRenderer$_(), t = e._$SupportsGPUProfiling$_(), h = t && e._$IsWebGL$_(), r = t && e._$IsWebGPU$_();
                if (h && e._$CheckForQueryResults$_(), this._$_needRender$_ || this._$IsExportToVideo$_()) {
                    const n = this._$_layoutManager$_._$GetMainRunningLayout$_(), o = (this._$_fpsFrameCount$_++, 
                    e._$Start$_(), this._$IsDebug$_());
                    o && V.StartMeasuringTime(), this._$_needRender$_ = !1;
                    let t = null, s = (h && (t = i._$GetGPUFrameTimingsBuffer$_()._$AddTimeElapsedQuery$_(), 
                    e._$StartQuery$_(t)), null);
                    r && (s = e.StartFrameTiming(2 * (1 + n._$GetLayerCount$_())), 
                    e.StartMeasuringRenderPassTime(0, 1)), this._$Uses3DFeatures$_() && "low" === i._$GetCurrentFullscreenScalingQuality$_() ? e._$SetFixedSizeDepthBuffer$_(i._$GetDrawWidth$_(), i._$GetDrawHeight$_()) : e._$SetAutoSizeDepthBuffer$_(), 
                    this._$_Render$_(this._$GetRenderer$_(), n), t && e._$EndQuery$_(t), 
                    r && (e.StopMeasuringRenderPassTime(), this._$_canvasManager$_._$_AddWebGPUFrameTiming$_(s)), 
                    e._$Finish$_(), o && (V.AddDrawCallsTime(), V.UpdateInspectHighlight()), 
                    i && i._$_MaybeTakeSnapshot$_();
                } else e._$IncrementFrameNumber$_();
            }
        }
        _$_NeedsHTMLLayerCompositing$_(t) {
            return "low" === this._$GetCanvasManager$_()._$GetCurrentFullscreenScalingQuality$_() || t._$IsWebGL$_() && (this._$UsesAnyBackgroundBlending$_() || this._$Uses3DFeatures$_());
        }
        _$_Render$_(s, i) {
            s._$SetTextureFillMode$_(), s._$SetAlphaBlend$_(), s._$SetColorRgba$_(1, 1, 1, 1), 
            s._$SetRenderTarget$_(null), s._$SetTexture$_(null), s._$SetDepthEnabled$_(this._$Uses3DFeatures$_()), 
            this._$_NeedsHTMLLayerCompositing$_(s) && i._$_MaybeStartDrawToOwnTexture$_(s);
            const e = i._$GetHTMLLayerCount$_();
            for (let t = 1; t < e; ++t) i._$DrawForHTMLLayerIndex$_(s, t), s._$IsWebGPU$_() && s.Restart();
            this._$_NeedsHTMLLayerCompositing$_(s) || i._$_MaybeStartDrawToOwnTexture$_(s), 
            i._$DrawMain$_(s);
        }
        _$Trigger$_(t, s, i) {
            if (!this._$_hasStarted$_) return !1;
            let e = !this._$_isInTick$_ && !this._$_eventSheetManager$_._$IsInTrigger$_(), h = 0;
            e && (h = performance.now());
            const r = this._$IsDebug$_(), n = (r && this._$SetDebuggingEnabled$_(!1), 
            this._$_eventSheetManager$_._$_Trigger$_(this._$_layoutManager$_, t, s, i));
            if (e) {
                const o = performance.now() - h;
                this._$_mainThreadTimeCounter$_ += o, r && V.AddTriggersTime(o);
            }
            return r && this._$SetDebuggingEnabled$_(!0), n;
        }
        _$DebugTrigger$_(t, s, i) {
            if (!this._$IsDebugging$_()) return this._$Trigger$_(t, s, i);
            if (this._$HitBreakpoint$_()) throw new Error("called DebugTrigger() while stopped on breakpoint");
            if (this._$_isInTick$_ || this._$_eventSheetManager$_._$IsInTrigger$_()) return this._$_eventSheetManager$_._$_DebugTrigger$_(this._$_layoutManager$_, t, s, i);
            throw new Error("called DebugTrigger() outside of event code - use TriggerAsync() instead");
        }
        async _$TriggerAsync$_(t, s, i) {
            if (!this._$IsDebugging$_()) return this._$Trigger$_(t, s, i);
            if (!this._$_hasStarted$_) return !1;
            if (this._$HitBreakpoint$_()) return this._$_eventSheetManager$_._$QueueDebugTrigger$_(t, s, i);
            if (!this._$GetMainRunningLayout$_()) return this._$_eventSheetManager$_._$QueueTrigger$_(t, s, i);
            let e = performance.now(), h = this._$_eventSheetManager$_._$_DebugTrigger$_(this._$_layoutManager$_, t, s, i), r = h.next();
            for (;!r.done; ) await this._$DebugBreak$_(r.value), r = h.next();
            return this._$IsSuspended$_() || this._$_eventSheetManager$_._$IsInTrigger$_() || (await this._$_eventSheetManager$_._$RunQueuedDebugTriggersAsync$_(), 
            this._$_hasStartedTicking$_ && !this._$_isInTick$_ && this._$_RequestAnimationFrame$_()), 
            this._$_mainThreadTimeCounter$_ += performance.now() - e, r.value;
        }
        _$FastTrigger$_(t, s, i) {
            const e = this._$IsDebug$_(), h = (e && this._$SetDebuggingEnabled$_(!1), 
            this._$_eventSheetManager$_._$_FastTrigger$_(this._$_layoutManager$_, t, s, i));
            return e && this._$SetDebuggingEnabled$_(!0), h;
        }
        _$DebugFastTrigger$_(t, s, i) {
            return this._$_eventSheetManager$_._$_DebugFastTrigger$_(this._$_layoutManager$_, t, s, i);
        }
        _$ScheduleTriggers$_(t) {
            return this._$_scheduleTriggersThrottle$_._$Add$_(t);
        }
        _$PushCurrentLayout$_(t) {
            this._$_currentLayoutStack$_.push(t);
        }
        _$PopCurrentLayout$_() {
            if (!this._$_currentLayoutStack$_.length) throw new Error("layout stack empty");
            this._$_currentLayoutStack$_.pop();
        }
        _$GetCurrentLayout$_() {
            return this._$_currentLayoutStack$_.length ? this._$_currentLayoutStack$_.at(-1) : this._$GetMainRunningLayout$_();
        }
        _$GetDt$_(t) {
            return t && -1 !== t._$GetTimeScale$_() ? this._$_dt1$_ * t._$GetTimeScale$_() : this._$_dt$_;
        }
        _$_GetDtFast$_() {
            return this._$_dt$_;
        }
        _$GetDt1$_() {
            return this._$_dt1$_;
        }
        _$GetDtRaw$_() {
            return this._$_dtRaw$_;
        }
        _$GetTimeScale$_() {
            return this._$_timeScale$_;
        }
        _$SetTimeScale$_(t) {
            (isNaN(t) || t < 0) && (t = 0), this._$_timeScale$_ = t;
        }
        _$SetMinDt$_(t) {
            this._$_minDt$_ = Math.max(t, 0);
        }
        _$GetMinDt$_() {
            return this._$_minDt$_;
        }
        _$SetMaxDt$_(t) {
            this._$_maxDt$_ = Math.max(t, 0);
        }
        _$GetMaxDt$_() {
            return this._$_maxDt$_;
        }
        _$GetFramesPerSecond$_() {
            return this._$_fps$_;
        }
        _$GetTicksPerSecond$_() {
            return this._$_tps$_;
        }
        _$GetMainThreadTime$_() {
            return this._$_mainThreadTime$_;
        }
        _$GetStartTime$_() {
            return this._$_startTime$_;
        }
        _$GetGameTime$_() {
            return this._$_gameTime$_._$Get$_();
        }
        _$GetGameTimeRaw$_() {
            return this._$_gameTimeRaw$_._$Get$_();
        }
        _$GetWallTime$_() {
            return this._$_wallTime$_._$Get$_();
        }
        _$GetTickCount$_() {
            return this._$_tickCount$_;
        }
        _$GetTickCountNoSave$_() {
            return this._$_tickCountNoSave$_;
        }
        _$GetObjectCount$_() {
            return this._$_objectCount$_;
        }
        _$GetProjectName$_() {
            return this._$_projectName$_;
        }
        _$GetProjectVersion$_() {
            return this._$_projectVersion$_;
        }
        _$GetProjectUniqueId$_() {
            return this._$_projectUniqueId$_;
        }
        _$GetAppId$_() {
            return this._$_appId$_;
        }
        _$GetInstanceByUID$_(t) {
            if (this._$_isLoadingState$_) throw new Error("cannot call while loading state - wait until afterload event");
            return this._$_instancesByUid$_.get(t) || null;
        }
        _$_RefreshUidMap$_() {
            this._$_instancesByUid$_.clear();
            for (const t of this._$_allObjectClasses$_) if (!t._$IsFamily$_()) for (const s of t._$GetInstances$_()) this._$_instancesByUid$_.set(s._$GetUID$_(), s);
        }
        _$IsPreview$_() {
            return "preview" === this._$_exportType$_;
        }
        _$IsDebug$_() {
            return this._$_isDebug$_;
        }
        _$GetExportType$_() {
            return this._$_exportType$_;
        }
        _$IsCordova$_() {
            return "cordova" === this._$_exportType$_;
        }
        _$IsAndroidWebView$_() {
            return "Android" === j._$Platform$_._$OS$_ && ("cordova" === this._$_exportType$_ || "playable-ad-single-file" === this._$_exportType$_ || "playable-ad-zip" === this._$_exportType$_ || "instant-games" === this._$_exportType$_);
        }
        _$IsiOSCordova$_() {
            return this._$_isiOSCordova$_;
        }
        _$IsiOSWebView$_() {
            return this._$_isiOSWebView$_;
        }
        _$IsWindowsWebView2$_() {
            return this._$_isWindowsWebView2$_;
        }
        _$IsAnyWebView2Wrapper$_() {
            return this._$_isAnyWebView2Wrapper$_;
        }
        _$GetCollisionEngine$_() {
            return this._$_collisionEngine$_;
        }
        _$GetSolidBehavior$_() {
            return this._$_addonManager$_._$GetSolidBehavior$_();
        }
        _$GetJumpthruBehavior$_() {
            return this._$_addonManager$_._$GetJumpthruBehavior$_();
        }
        _$Uses3DFeatures$_() {
            return this._$_uses3dFeatures$_;
        }
        _$GetZScaleFactor$_() {
            return this._$GetRenderer$_()._$GetZAxisScaleFactor$_(this._$GetViewportHeight$_());
        }
        _$GetDefaultCameraZ$_(t) {
            return this._$GetRenderer$_()._$GetDefaultCameraZ$_(t || this._$GetViewportHeight$_());
        }
        _$IsLayoutFirstTick$_() {
            return this._$_isLayoutFirstTick$_;
        }
        _$SetPixelRoundingEnabled$_(t) {
            this._$_isPixelRoundingEnabled$_ !== (t = !!t) && (this._$_isPixelRoundingEnabled$_ = t, 
            this._$GetLayoutManager$_()._$SetAllLayerMVChanged$_(), this._$UpdateRender$_());
        }
        _$IsPixelRoundingEnabled$_() {
            return this._$_isPixelRoundingEnabled$_;
        }
        _$GetTextIconSet$_(t) {
            if (!this._$_iconChangeHandlers$_.has(t)) {
                const i = () => this._$DeleteTextIconSet$_(t);
                this._$_iconChangeHandlers$_.set(t, i), t._$Dispatcher$_().addEventListener("animationframeimagechange", i);
            }
            const s = this._$_textIconManager$_._$GetIconSet$_(t);
            return s._$HasLoaded$_() || s._$LoadContent$_().then(() => this._$UpdateRender$_()), 
            s;
        }
        _$DeleteTextIconSet$_(t) {
            this._$_textIconManager$_._$DeleteIconSet$_(t);
        }
        _$_GetTextIconSetMeta$_(t) {
            const s = [];
            for (const i of t._$GetAnimations$_()) for (const e of i._$GetFrames$_()) {
                const h = e._$GetImageInfo$_();
                s.push({
                    source: e,
                    width: h._$GetWidth$_(),
                    height: h._$GetHeight$_(),
                    tag: e._$GetTag$_()
                });
            }
            return {
                _$icons$_: s
            };
        }
        async _$_GetTextIconSetContent$_(t) {
            const s = j._$New$_(j._$PromiseThrottle$_), i = [], h = new Map();
            for (const n of t._$GetAnimations$_()) for (const o of n._$GetFrames$_()) {
                const a = o._$GetImageInfo$_()._$GetImageAsset$_();
                h.has(a) || (h.set(a, null), i.push(s._$Add$_(async () => {
                    const t = await a._$LoadToDrawable$_();
                    h.set(a, t);
                })));
            }
            await Promise.all(i);
            const e = [];
            for (const l of t._$GetAnimations$_()) for (const u of l._$GetFrames$_()) e.push(s._$Add$_(async () => {
                const t = u._$GetImageInfo$_(), s = h.get(t._$GetImageAsset$_()), i = await t._$ExtractImageToCanvas$_(s), e = await createImageBitmap(i);
                return {
                    _$drawable$_: e
                };
            }));
            const r = await Promise.all(e);
            for (const c of h.values()) c instanceof ImageBitmap && c.close && c.close();
            return {
                _$icons$_: r
            };
        }
        _$SaveToSlot$_(t) {
            this._$_saveToSlotName$_ = t;
        }
        _$LoadFromSlot$_(t) {
            this._$_loadFromSlotName$_ = t;
        }
        _$LoadFromJsonString$_(t) {
            this._$_loadFromJson$_ = t;
        }
        _$GetLastSaveJsonString$_() {
            return this._$_lastSaveJson$_;
        }
        _$_NeedsHandleSaveOrLoad$_() {
            return !(!this._$_saveToSlotName$_ && !this._$_loadFromSlotName$_ && null === this._$_loadFromJson$_);
        }
        async _$_HandleSaveOrLoad$_() {
            if (this._$_saveToSlotName$_ && (this._$FlushPendingInstances$_(), await this._$_DoSaveToSlot$_(this._$_saveToSlotName$_), 
            this._$_ClearSaveOrLoad$_()), this._$_loadFromSlotName$_ && (await this._$_DoLoadFromSlot$_(this._$_loadFromSlotName$_), 
            this._$_ClearSaveOrLoad$_(), this._$IsDebug$_()) && V.StepIfPausedInDebugger(), 
            null !== this._$_loadFromJson$_) {
                this._$FlushPendingInstances$_();
                try {
                    await this._$_DoLoadFromJsonString$_(this._$_loadFromJson$_), 
                    this._$_lastSaveJson$_ = this._$_loadFromJson$_, await this._$TriggerAsync$_(j._$Plugins$_._$System$_._$Cnds$_._$OnLoadComplete$_, null), 
                    this._$_lastSaveJson$_ = "";
                } catch (t) {
                    console.error("[Construct] Failed to load state from JSON string: ", t), 
                    await this._$TriggerAsync$_(j._$Plugins$_._$System$_._$Cnds$_._$OnLoadFailed$_, null);
                }
                this._$_ClearSaveOrLoad$_();
            }
        }
        _$_ClearSaveOrLoad$_() {
            this._$_saveToSlotName$_ = "", this._$_loadFromSlotName$_ = "", this._$_loadFromJson$_ = null;
        }
        _$_GetProjectStorage$_() {
            return this._$_projectStorage$_ || (this._$_projectStorage$_ = localforage._$createInstance$_({
                name: "c3-localstorage-" + this._$GetProjectUniqueId$_(),
                description: this._$GetProjectName$_()
            })), this._$_projectStorage$_;
        }
        _$_GetSavegamesStorage$_() {
            return this._$_savegamesStorage$_ || (this._$_savegamesStorage$_ = localforage._$createInstance$_({
                name: "c3-savegames-" + this._$GetProjectUniqueId$_(),
                description: this._$GetProjectName$_()
            })), this._$_savegamesStorage$_;
        }
        async _$_DoSaveToSlot$_(t) {
            const s = await this._$_SaveToJsonString$_();
            try {
                await this._$_GetSavegamesStorage$_().setItem(t, s), console.log("[Construct] Saved state to storage (" + s.length + " chars)"), 
                this._$_lastSaveJson$_ = s, await this._$TriggerAsync$_(j._$Plugins$_._$System$_._$Cnds$_._$OnSaveComplete$_, null), 
                this._$_lastSaveJson$_ = "";
            } catch (t) {
                console.error("[Construct] Failed to save state to storage: ", t), 
                await this._$TriggerAsync$_(j._$Plugins$_._$System$_._$Cnds$_._$OnSaveFailed$_, null);
            }
        }
        async _$_DoLoadFromSlot$_(t) {
            try {
                const s = await this._$_GetSavegamesStorage$_().getItem(t);
                if (!s) throw new Error("empty slot");
                console.log("[Construct] Loaded state from storage (" + s.length + " chars)"), 
                await this._$_DoLoadFromJsonString$_(s), this._$_lastSaveJson$_ = s, 
                await this._$TriggerAsync$_(j._$Plugins$_._$System$_._$Cnds$_._$OnLoadComplete$_, null), 
                this._$_lastSaveJson$_ = "";
            } catch (t) {
                console.error("[Construct] Failed to load state from storage: ", t), 
                await this._$TriggerAsync$_(j._$Plugins$_._$System$_._$Cnds$_._$OnLoadFailed$_, null);
            }
        }
        async _$_SaveToJsonString$_() {
            const t = {
                c3save: !0,
                version: 1,
                rt: {
                    time: this._$GetGameTime$_(),
                    timeRaw: this._$GetGameTimeRaw$_(),
                    walltime: this._$GetWallTime$_(),
                    timescale: this._$GetTimeScale$_(),
                    tickcount: this._$GetTickCount$_(),
                    next_uid: this._$_nextUid$_,
                    running_layout: this._$GetMainRunningLayout$_()._$GetSID$_(),
                    start_time_offset: Date.now() - this._$_startTime$_
                },
                types: {},
                layouts: {},
                events: this._$_eventSheetManager$_._$_SaveToJson$_(),
                timelines: this._$_timelineManager$_._$_SaveToJson$_(),
                user_script_data: null
            };
            for (const i of this._$_allObjectClasses$_) i._$IsFamily$_() || i._$HasNoSaveBehavior$_() || (t.types[i._$GetSID$_().toString()] = i._$_SaveToJson$_());
            for (const e of this._$_layoutManager$_._$GetAllLayouts$_()) t.layouts[e._$GetSID$_().toString()] = e._$_SaveToJson$_();
            const s = this._$_CreateUserScriptEvent$_("save");
            return s.saveData = null, await this._$DispatchUserScriptEventAsyncWait$_(s), 
            t.user_script_data = s.saveData, JSON.stringify(t);
        }
        _$IsLoadingState$_() {
            return this._$_isLoadingState$_;
        }
        async _$_DoLoadFromJsonString$_(t) {
            const s = this._$GetLayoutManager$_(), i = JSON.parse(t);
            if (i.c2save) throw new Error("C2 saves are incompatible with C3 runtime");
            if (!i.c3save) throw new Error("not valid C3 save data");
            if (1 < i.version) throw new Error("C3 save data from future version");
            this._$ClearIntancesNeedingAfterLoad$_(), this._$_dispatcher$_.dispatchEvent(j._$New$_(j.Event, "beforeload"));
            for (const a of this._$allInstances$_()) {
                const l = a._$GetObjectClass$_();
                l._$HasNoSaveBehavior$_() || a._$_OnBeforeLoad$_();
            }
            let e = i.rt, h = (this._$_gameTime$_.Set(e.time), e.hasOwnProperty("timeRaw") && this._$_gameTimeRaw$_.Set(e.timeRaw), 
            this._$_wallTime$_.Set(e.walltime), this._$_timeScale$_ = e.timescale, 
            this._$_tickCount$_ = e.tickcount, this._$_startTime$_ = Date.now() - e.start_time_offset, 
            e.running_layout), r = !(this._$_isLoadingState$_ = !0);
            if (h !== this._$GetMainRunningLayout$_()._$GetSID$_()) {
                const u = s._$GetLayoutBySID$_(h);
                if (!u) return;
                await this._$_DoChangeLayout$_(u), r = !0;
            }
            for (const [ c, f ] of Object.entries(i.layouts)) {
                const d = parseInt(c, 10), p = s._$GetLayoutBySID$_(d);
                p && p._$_LoadFromJson$_(f);
            }
            const n = new Set();
            for (const [ m, g ] of Object.entries(i.types)) {
                const y = parseInt(m, 10), w = this._$GetObjectClassBySID$_(y);
                !w || w._$IsFamily$_() || w._$HasNoSaveBehavior$_() || w._$_LoadFromJson$_(g, n);
            }
            for (const S of this._$_layoutManager$_._$GetAllLayouts$_()) for (const b of S._$allLayers$_()) b._$_LoadFromJsonAfterInstances$_();
            if (this._$FlushPendingInstances$_(), this._$_RefreshUidMap$_(), this._$_isLoadingState$_ = !1, 
            r) {
                for (const M of this._$allInstances$_()) M._$SetupInitialSceneGraphConnections$_();
                for (const [ v, x ] of Object.entries(i.types)) {
                    const G = parseInt(v, 10), T = this._$GetObjectClassBySID$_(G);
                    !T || T._$IsFamily$_() || T._$HasNoSaveBehavior$_() || T._$_SetupSceneGraphConnectionsOnChangeOfLayout$_(x);
                }
            }
            this._$_nextUid$_ = e.next_uid, this._$_eventSheetManager$_._$_LoadFromJson$_(i.events);
            for (const _ of this._$_allObjectClasses$_) if (!_._$IsFamily$_() && _._$IsInContainer$_()) for (const I of _._$GetInstances$_()) {
                const C = I._$GetIID$_();
                for (const R of _._$GetContainer$_()._$objectTypes$_()) if (R !== _) {
                    const P = R._$GetInstances$_();
                    if (C < 0 || C >= P.length) throw new Error("missing sibling instance");
                    I._$_AddSibling$_(P[C]);
                }
            }
            this._$_timelineManager$_._$_LoadFromJson$_(i.timelines), s._$SetAllLayerProjectionChanged$_(), 
            s._$SetAllLayerMVChanged$_();
            for (const E of n) E._$_OnCreatedForLoadingSavegame$_();
            this._$DoAfterLoad$_(), this._$_dispatcher$_.dispatchEvent(j._$New$_(j.Event, "afterload")), 
            this._$DispatchUserScriptEvent$_(this._$_CreateUserScriptEvent$_("afterload"));
            for (const [ A, F ] of Object.entries(i.types)) {
                const O = parseInt(A, 10), D = this._$GetObjectClassBySID$_(O);
                D && D._$_ClearLoadInstancesJson$_();
            }
            const o = this._$_CreateUserScriptEvent$_("load");
            o.saveData = i.user_script_data, await this._$DispatchUserScriptEventAsyncWait$_(o), 
            this._$UpdateRender$_();
        }
        _$SortOnTmpHierarchyPosition$_(t, s) {
            return t._$GetWorldInfo$_()._$GetTmpHierarchyPosition$_() - s._$GetWorldInfo$_()._$GetTmpHierarchyPosition$_();
        }
        _$AddInstanceNeedingAfterLoad$_(t, s) {
            !t._$GetWorldInfo$_() || this._$_instancesNeedingAfterLoadMap$_.has(t) || (this._$_instancesNeedingAfterLoadMap$_.set(t, s), 
            this._$_instancesNeedingAfterLoadArray$_.push(t));
        }
        _$ClearIntancesNeedingAfterLoad$_() {
            this._$_instancesNeedingAfterLoadMap$_ = new WeakMap(), j._$clearArray$_(this._$_instancesNeedingAfterLoadArray$_);
        }
        _$DoAfterLoad$_(t = "full", s = null) {
            this._$_instancesNeedingAfterLoadArray$_.sort(this._$SortOnTmpHierarchyPosition$_);
            for (const i of this._$_instancesNeedingAfterLoadArray$_) i._$_OnAfterLoad$_(this._$_instancesNeedingAfterLoadMap$_.get(i), t, s);
            for (const e of this._$_instancesNeedingAfterLoadArray$_) e._$_OnAfterLoad2$_(this._$_instancesNeedingAfterLoadMap$_.get(e), t, s);
            this._$ClearIntancesNeedingAfterLoad$_();
        }
        async _$AddJobWorkerScripts$_(t) {
            const s = await Promise.all(t.map(async t => {
                const s = this._$IsCordova$_() && this._$_assetManager$_._$IsFileProtocol$_();
                if (s || "playable-ad-single-file" === this._$GetExportType$_()) {
                    const i = await this._$_assetManager$_._$FetchBlob$_(t);
                    return URL.createObjectURL(i);
                }
                return new URL(t, location.href).toString();
            }));
            this._$_jobScheduler$_._$ImportScriptsToJobWorkers$_(s);
        }
        _$AddJobWorkerBlob$_(t, s) {
            this._$_jobScheduler$_._$SendBlobToJobWorkers$_(t, s);
        }
        _$AddJobWorkerBuffer$_(t, s) {
            this._$_jobScheduler$_._$SendBufferToJobWorkers$_(t, s);
        }
        _$AddJob$_(t, s, i, e) {
            return this._$_jobScheduler$_._$AddJob$_(t, s, i, null, null, e);
        }
        _$BroadcastJob$_(t, s, i, e) {
            return this._$_jobScheduler$_._$BroadcastJob$_(t, s, i, e);
        }
        _$GetMaxNumJobWorkers$_() {
            return this._$_jobScheduler$_._$GetMaxNumWorkers$_();
        }
        _$InvokeDownload$_(t, s) {
            this._$PostComponentMessageToDOM$_("runtime", "invoke-download", {
                url: t,
                filename: s
            });
        }
        async _$RasterSvgImage$_(t, s, i, e, h, r) {
            if (e = e || s, h = h || i, this._$IsInWorker$_()) {
                const n = await this._$PostComponentMessageToDOMAsync$_("runtime", "raster-svg-image", {
                    blob: t,
                    imageWidth: s,
                    imageHeight: i,
                    surfaceWidth: e,
                    surfaceHeight: h,
                    imageBitmapOpts: r
                });
                return n.imageBitmap;
            }
            {
                const o = await self.C3_RasterSvgImageBlob(t, s, i, e, h);
                return r ? self.createImageBitmap(o, r) : o;
            }
        }
        async _$GetSvgImageSize$_(t) {
            return this._$IsInWorker$_() ? this._$PostComponentMessageToDOMAsync$_("runtime", "get-svg-image-size", {
                blob: t
            }) : self.C3_GetSvgImageSize(t);
        }
        _$RequestDeviceOrientationEvent$_() {
            this._$_didRequestDeviceOrientationEvent$_ || (this._$_didRequestDeviceOrientationEvent$_ = !0, 
            this._$PostComponentMessageToDOM$_("runtime", "enable-device-orientation"));
        }
        _$RequestDeviceMotionEvent$_() {
            this._$_didRequestDeviceMotionEvent$_ || (this._$_didRequestDeviceMotionEvent$_ = !0, 
            this._$PostComponentMessageToDOM$_("runtime", "enable-device-motion"));
        }
        _$Random$_() {
            return this._$_randomNumberCallback$_();
        }
        _$SetRandomNumberGeneratorCallback$_(t) {
            this._$_randomNumberCallback$_ = t;
        }
        _$_GetRemotePreviewStatusInfo$_() {
            const t = this._$GetRenderer$_();
            return {
                fps: this._$GetFramesPerSecond$_(),
                tps: this._$GetTicksPerSecond$_(),
                cpu: this._$GetMainThreadTime$_(),
                gpu: this._$GetGPUUtilisation$_(),
                layout: this._$GetMainRunningLayout$_() ? this._$GetMainRunningLayout$_()._$GetName$_() : "",
                renderer: t._$IsWebGL$_() ? t._$GetUnmaskedRenderer$_() : t.GetAdapterInfoString()
            };
        }
        _$HitBreakpoint$_() {
            return !!this._$IsDebug$_() && V._$HitBreakpoint$_();
        }
        _$DebugBreak$_(t) {
            return this._$IsDebugging$_() ? V._$DebugBreak$_(t) : Promise.resolve();
        }
        _$DebugBreakNext$_() {
            return !!this._$IsDebugging$_() && V.BreakNext();
        }
        _$SetDebugBreakpointsEnabled$_(t) {
            this._$_breakpointsEnabled$_ = !!t, this._$_UpdateDebuggingFlag$_();
        }
        _$AreDebugBreakpointsEnabled$_() {
            return this._$_breakpointsEnabled$_;
        }
        _$IsDebugging$_() {
            return this._$_isDebugging$_;
        }
        _$SetDebuggingEnabled$_(t) {
            t ? this._$_debuggingDisabled$_-- : this._$_debuggingDisabled$_++, this._$_UpdateDebuggingFlag$_();
        }
        _$_UpdateDebuggingFlag$_() {
            this._$_isDebugging$_ = this._$IsDebug$_() && this._$_breakpointsEnabled$_ && 0 === this._$_debuggingDisabled$_;
        }
        _$IsCPUProfiling$_() {
            return this._$IsDebug$_() && V._$IsCPUProfiling$_();
        }
        _$IsGPUProfiling$_() {
            return this._$IsDebug$_() && this._$GetRenderer$_()._$SupportsGPUProfiling$_() && V._$IsGPUProfiling$_();
        }
        async _$DebugIterateAndBreak$_(t) {
            if (t) for (const s of t) await this._$DebugBreak$_(s);
        }
        _$DebugFireGeneratorEventAndBreak$_(t) {
            return this._$DebugIterateAndBreak$_(this._$_dispatcher$_._$dispatchGeneratorEvent$_(t));
        }
        _$_InvokeFunctionFromJS$_(t) {
            return this._$_eventSheetManager$_._$_InvokeFunctionFromJS$_(t.name, t.params);
        }
        _$_GetHTMLLayerWrapElement$_(t) {
            if (this._$IsInWorker$_()) throw new Error("not supported in worker mode");
            return self.c3_runtimeInterface._GetHTMLWrapElement(t);
        }
        _$GetIRuntime$_() {
            return this._$_iRuntime$_;
        }
        _$_CreateUserScriptEvent$_(t) {
            const s = j._$New$_(j.Event, t, !1);
            return s.runtime = this._$_iRuntime$_, s;
        }
        _$_InitScriptInterfaces$_() {
            this._$_iRuntime$_ = new self._$IRuntime$_(this), this._$_userScriptEventObjects$_ = {
                tick: this._$_CreateUserScriptEvent$_("tick")
            };
        }
        _$_InitObjectsScriptInterface$_() {
            const t = {};
            for (const s of this._$_allObjectClasses$_) t[s._$GetJsPropName$_()] = {
                value: s._$GetIObjectClass$_(),
                enumerable: !0,
                writable: !1
            };
            this._$_iRuntime$_._$_InitObjects$_(t);
        }
        _$_InitGlobalVariableScriptInterface$_() {
            const t = {};
            for (const s of this._$GetEventSheetManager$_()._$GetAllGlobalVariables$_()) t[s._$GetJsPropName$_()] = s._$_GetScriptInterfaceDescriptor$_();
            this._$_iRuntime$_._$_InitGlobalVars$_(t);
        }
        _$_GetCommonScriptInterfaces$_() {
            return this._$_commonScriptInterfaces$_;
        }
        _$_MapScriptInterface$_(t, s) {
            this._$_interfaceMap$_.set(t, s);
        }
        _$_UnwrapScriptInterface$_(t) {
            return this._$_interfaceMap$_.get(t);
        }
        _$_UnwrapIObjectClass$_(t) {
            if (!(t instanceof self._$IObjectClass$_)) throw new TypeError("expected IObjectClass");
            const s = this._$_UnwrapScriptInterface$_(t);
            if (s && s instanceof j._$ObjectClass$_) return s;
            throw new Error("invalid IObjectClass");
        }
        _$_UnwrapIInstance$_(t) {
            if (!(t instanceof self._$IInstance$_)) throw new TypeError("expected IInstance");
            const s = this._$_UnwrapScriptInterface$_(t);
            if (s && s instanceof j.Instance) return s;
            throw new Error("invalid IInstance");
        }
        _$_UnwrapIWorldInstance$_(t) {
            if (!(t instanceof self._$IWorldInstance$_)) throw new TypeError("expected IWorldInstance");
            const s = this._$_UnwrapScriptInterface$_(t);
            if (s && s instanceof j.Instance) return s;
            throw new Error("invalid IInstance");
        }
    }, self.C3_CreateRuntime = j._$Runtime$_._$Create$_, self.C3_InitRuntime = (t, s) => t._$Init$_(s);
}

{
    const qa = self._$C3$_;
    qa._$JobSchedulerRuntime$_ = class extends qa._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_runtime$_ = t, this._$_jobPromises$_ = new Map(), this._$_nextJobId$_ = 0, 
            this._$_inputPort$_ = s.inputPort, s.outputPort.onmessage = t => this._$_OnJobWorkerMessage$_(t), 
            this._$_maxNumWorkers$_ = s.maxNumWorkers, this._$_jobWorkerCount$_ = 1, 
            this._$_isCreatingWorker$_ = !1, this._$_hadErrorCreatingWorker$_ = !1;
        }
        async _$Init$_() {}
        _$GetMaxNumWorkers$_() {
            return this._$_maxNumWorkers$_;
        }
        _$ImportScriptsToJobWorkers$_(t) {
            this._$_inputPort$_.postMessage({
                type: "_import_scripts",
                scripts: t
            });
        }
        _$SendBlobToJobWorkers$_(t, s) {
            this._$_inputPort$_.postMessage({
                type: "_send_blob",
                blob: t,
                id: s
            });
        }
        _$SendBufferToJobWorkers$_(t, s) {
            this._$_inputPort$_.postMessage({
                type: "_send_buffer",
                buffer: t,
                id: s
            }, [ t ]);
        }
        _$AddJob$_(t, s, i, e, h, r) {
            if (i = i || [], "number" == typeof r && (r = Math.floor(r)) <= 0) throw new Error("invalid maxWorkerNum");
            const n = this._$_nextJobId$_++, o = {
                type: t,
                isBroadcast: !1,
                maxWorkerNum: r,
                jobId: n,
                params: s,
                transferables: i
            }, a = new Promise((t, s) => {
                this._$_jobPromises$_.set(n, {
                    resolve: t,
                    progress: e,
                    reject: s,
                    _$cancelled$_: !1,
                    maxWorkerNum: r
                });
            });
            return h && h._$SetAction$_(() => this._$_CancelJob$_(n)), this._$_inputPort$_.postMessage(o, i), 
            this._$_MaybeCreateExtraWorker$_(), a;
        }
        _$BroadcastJob$_(t, s, i, e) {
            if (i = i || [], "number" == typeof e && (e = Math.floor(e)) <= 0) throw new Error("invalid maxWorkerNum");
            const h = this._$_nextJobId$_++, r = {
                type: t,
                isBroadcast: !0,
                maxWorkerNum: e,
                jobId: h,
                params: s,
                transferables: i
            };
            this._$_inputPort$_.postMessage(r, i);
        }
        _$_CancelJob$_(t) {
            const s = this._$_jobPromises$_.get(t);
            s && (s._$cancelled$_ = !0, s.resolve = null, s.progress = null, s.reject = null, 
            this._$_inputPort$_.postMessage({
                type: "_cancel",
                jobId: t
            }));
        }
        _$_OnJobWorkerMessage$_(t) {
            const s = t.data, i = s.type, e = s.jobId;
            switch (i) {
              case "result":
                this._$_OnJobResult$_(e, s.result);
                break;

              case "progress":
                this._$_OnJobProgress$_(e, s.progress);
                break;

              case "error":
                this._$_OnJobError$_(e, s.error);
                break;

              case "ready":
                this._$_OnJobWorkerReady$_();
                break;

              default:
                throw new Error(`unknown message from worker '${i}'`);
            }
        }
        _$_OnJobResult$_(t, s) {
            const i = this._$_jobPromises$_.get(t);
            if (!i) throw new Error("invalid job ID");
            i._$cancelled$_ || i.resolve(s), this._$_jobPromises$_.delete(t);
        }
        _$_OnJobProgress$_(t, s) {
            const i = this._$_jobPromises$_.get(t);
            if (!i) throw new Error("invalid job ID");
            !i._$cancelled$_ && i.progress && i.progress(s);
        }
        _$_OnJobError$_(t, s) {
            const i = this._$_jobPromises$_.get(t);
            if (!i) throw new Error("invalid job ID");
            i._$cancelled$_ || i.reject(s), this._$_jobPromises$_.delete(t);
        }
        _$_OnJobWorkerReady$_() {
            this._$_isCreatingWorker$_ && (this._$_isCreatingWorker$_ = !1, this._$_jobWorkerCount$_++, 
            this._$_jobWorkerCount$_ < this._$_maxNumWorkers$_ ? this._$_MaybeCreateExtraWorker$_() : this._$_inputPort$_.postMessage({
                type: "_no_more_workers"
            }));
        }
        _$_GetWorkerCountNeededForPendingJobs$_() {
            let t = 0, s = [ ...this._$_jobPromises$_.values() ].sort((t, s) => {
                const i = t.maxWorkerNum || 1 / 0, e = s.maxWorkerNum || 1 / 0;
                return i - e;
            });
            for (const i of s) {
                const e = i.maxWorkerNum || 1 / 0;
                t < e && t++;
            }
            return t;
        }
        async _$_MaybeCreateExtraWorker$_() {
            if (!(this._$_jobWorkerCount$_ >= this._$_maxNumWorkers$_ || this._$_isCreatingWorker$_ || this._$_hadErrorCreatingWorker$_ || this._$_GetWorkerCountNeededForPendingJobs$_() <= this._$_jobWorkerCount$_)) try {
                this._$_isCreatingWorker$_ = !0;
                const t = await this._$_runtime$_._$PostComponentMessageToDOMAsync$_("runtime", "create-job-worker");
                t.outputPort.onmessage = t => this._$_OnJobWorkerMessage$_(t);
            } catch (t) {
                this._$_hadErrorCreatingWorker$_ = !0, this._$_isCreatingWorker$_ = !1, 
                console.error(`[Construct] Failed to create job worker; stopping creating any more (created ${this._$_jobWorkerCount$_} so far)`, t);
            }
        }
    };
}

self.C3_Shaders = {};

{
    let S = function(t, s) {
        const i = t[1], e = s[1];
        if ("number" == typeof i && "number" == typeof e) return i - e;
        {
            const h = "" + i, r = "" + e;
            return h < r ? -1 : r < h ? 1 : 0;
        }
    }, b = (S, self._$C3$_), i = null, e = "", h = "", r = [], n = "", o = "", a = "", M = b._$New$_(b._$ArrayStack$_);
    b._$Plugins$_._$System$_ = class extends b._$SDKPluginBase$_ {
        constructor(t) {
            super(t), this._$_loopStack$_ = this._$_runtime$_._$GetEventSheetManager$_()._$GetLoopStack$_(), 
            this._$_eventStack$_ = this._$_runtime$_._$GetEventSheetManager$_()._$GetEventStack$_(), 
            this._$_imagesLoadingTotal$_ = 0, this._$_imagesLoadingComplete$_ = 0, 
            this._$_functionMaps$_ = new Map();
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$UpdateRender$_() {
            this._$_runtime$_._$UpdateRender$_();
        }
        _$Trigger$_(t) {
            this._$_runtime$_._$Trigger$_(t, null, null);
        }
        _$GetRegex$_(t, s) {
            return i && t === e && s === h || (i = new RegExp(t, s), e = t, h = s), 
            i.lastIndex = 0, i;
        }
        _$GetRegexMatches$_(t, s, i) {
            if (t !== n || s !== o || i !== a) {
                const e = this._$GetRegex$_(s, i);
                r = t.match(e), n = t, o = s, a = i;
            }
            return r;
        }
        async _$_LoadTexturesForObjectClasses$_(t, s) {
            if (s.length) {
                this._$_imagesLoadingTotal$_ += s.length;
                const i = [];
                for (const e of s) i.push(t._$MaybeLoadTexturesFor$_(e));
                await b._$PromiseAllWithProgress$_(i, () => {
                    this._$_imagesLoadingComplete$_++;
                }), this._$_imagesLoadingComplete$_++, this._$_imagesLoadingComplete$_ === this._$_imagesLoadingTotal$_ && (this._$_imagesLoadingComplete$_ = 0, 
                this._$_imagesLoadingTotal$_ = 0, this._$_runtime$_._$Trigger$_(b._$Plugins$_._$System$_._$Cnds$_._$OnImageLoadingComplete$_, null, null));
            }
        }
        _$_UnloadTexturesForObjectClasses$_(t, s) {
            for (const i of s) 0 === i._$GetInstanceCount$_() && t._$MaybeUnloadTexturesFor$_(i);
        }
        _$_GetForEachStack$_() {
            return M;
        }
        _$_Repeat$_(s) {
            const i = this._$_runtime$_._$GetEventSheetManager$_(), t = i._$GetEventStack$_(), e = t._$GetCurrentStackFrame$_(), h = e._$GetCurrentEvent$_(), r = h._$GetSolModifiers$_(), n = e._$IsSolModifierAfterCnds$_(), o = t._$Push$_(h), a = i._$GetLoopStack$_(), l = a._$Push$_();
            if (l._$SetEnd$_(s), n) for (let t = 0; t < s && !l._$IsStopped$_(); ++t) i._$PushCopySol$_(r), 
            l._$SetIndex$_(t), h._$Retrigger$_(e, o), i._$PopSol$_(r); else for (let t = 0; t < s && !l._$IsStopped$_(); ++t) l._$SetIndex$_(t), 
            h._$Retrigger$_(e, o);
            return t._$Pop$_(), a._$Pop$_(), !1;
        }
        *_$_DebugRepeat$_(s) {
            const i = this._$_runtime$_._$GetEventSheetManager$_(), t = i._$GetEventStack$_(), e = t._$GetCurrentStackFrame$_(), h = e._$GetCurrentEvent$_(), r = h._$GetSolModifiers$_(), n = e._$IsSolModifierAfterCnds$_(), o = t._$Push$_(h), a = i._$GetLoopStack$_(), l = a._$Push$_();
            if (l._$SetEnd$_(s), n) for (let t = 0; t < s && !l._$IsStopped$_(); ++t) i._$PushCopySol$_(r), 
            l._$SetIndex$_(t), yield* h._$DebugRetrigger$_(e, o), i._$PopSol$_(r); else for (let t = 0; t < s && !l._$IsStopped$_(); ++t) l._$SetIndex$_(t), 
            yield* h._$DebugRetrigger$_(e, o);
            return t._$Pop$_(), a._$Pop$_(), !1;
        }
        _$_While$_() {
            const s = this._$_runtime$_._$GetEventSheetManager$_(), t = s._$GetEventStack$_(), i = t._$GetCurrentStackFrame$_(), e = i._$GetCurrentEvent$_(), h = e._$GetSolModifiers$_(), r = i._$IsSolModifierAfterCnds$_(), n = t._$Push$_(e), o = s._$GetLoopStack$_(), a = o._$Push$_();
            if (r) for (let t = 0; !a._$IsStopped$_(); ++t) s._$PushCopySol$_(h), 
            a._$SetIndex$_(t), e._$Retrigger$_(i, n) || a._$Stop$_(), s._$PopSol$_(h); else for (let t = 0; !a._$IsStopped$_(); ++t) a._$SetIndex$_(t), 
            e._$Retrigger$_(i, n) || a._$Stop$_();
            return t._$Pop$_(), o._$Pop$_(), !1;
        }
        *_$_DebugWhile$_() {
            const s = this._$_runtime$_._$GetEventSheetManager$_(), t = s._$GetEventStack$_(), i = t._$GetCurrentStackFrame$_(), e = i._$GetCurrentEvent$_(), h = e._$GetSolModifiers$_(), r = i._$IsSolModifierAfterCnds$_(), n = t._$Push$_(e), o = s._$GetLoopStack$_(), a = o._$Push$_();
            if (r) for (let t = 0; !a._$IsStopped$_(); ++t) {
                s._$PushCopySol$_(h), a._$SetIndex$_(t);
                const l = yield* e._$DebugRetrigger$_(i, n);
                l || a._$Stop$_(), s._$PopSol$_(h);
            } else for (let t = 0; !a._$IsStopped$_(); ++t) {
                a._$SetIndex$_(t);
                const u = yield* e._$DebugRetrigger$_(i, n);
                u || a._$Stop$_();
            }
            return t._$Pop$_(), o._$Pop$_(), !1;
        }
        _$_For$_(t, s, i) {
            const e = this._$_runtime$_._$GetEventSheetManager$_(), h = e._$GetEventStack$_(), r = h._$GetCurrentStackFrame$_(), n = r._$GetCurrentEvent$_(), o = n._$GetSolModifiers$_(), a = r._$IsSolModifierAfterCnds$_(), l = h._$Push$_(n), u = e._$GetLoopStack$_(), c = u._$Push$_();
            if (c._$SetName$_(t), c._$SetEnd$_(i), i < s) if (a) for (let t = s; t >= i && !c._$IsStopped$_(); --t) e._$PushCopySol$_(o), 
            c._$SetIndex$_(t), n._$Retrigger$_(r, l), e._$PopSol$_(o); else for (let t = s; t >= i && !c._$IsStopped$_(); --t) c._$SetIndex$_(t), 
            n._$Retrigger$_(r, l); else if (a) for (let t = s; t <= i && !c._$IsStopped$_(); ++t) e._$PushCopySol$_(o), 
            c._$SetIndex$_(t), n._$Retrigger$_(r, l), e._$PopSol$_(o); else for (let t = s; t <= i && !c._$IsStopped$_(); ++t) c._$SetIndex$_(t), 
            n._$Retrigger$_(r, l);
            return h._$Pop$_(), u._$Pop$_(), !1;
        }
        *_$_DebugFor$_(t, s, i) {
            const e = this._$_runtime$_._$GetEventSheetManager$_(), h = e._$GetEventStack$_(), r = h._$GetCurrentStackFrame$_(), n = r._$GetCurrentEvent$_(), o = n._$GetSolModifiers$_(), a = r._$IsSolModifierAfterCnds$_(), l = h._$Push$_(n), u = e._$GetLoopStack$_(), c = u._$Push$_();
            if (c._$SetName$_(t), c._$SetEnd$_(i), i < s) if (a) for (let t = s; t >= i && !c._$IsStopped$_(); --t) e._$PushCopySol$_(o), 
            c._$SetIndex$_(t), yield* n._$DebugRetrigger$_(r, l), e._$PopSol$_(o); else for (let t = s; t >= i && !c._$IsStopped$_(); --t) c._$SetIndex$_(t), 
            yield* n._$DebugRetrigger$_(r, l); else if (a) for (let t = s; t <= i && !c._$IsStopped$_(); ++t) e._$PushCopySol$_(o), 
            c._$SetIndex$_(t), yield* n._$DebugRetrigger$_(r, l), e._$PopSol$_(o); else for (let t = s; t <= i && !c._$IsStopped$_(); ++t) c._$SetIndex$_(t), 
            yield* n._$DebugRetrigger$_(r, l);
            return h._$Pop$_(), u._$Pop$_(), !1;
        }
        _$_ForEach$_(i) {
            const t = i._$GetCurrentSol$_(), s = t._$GetInstances$_();
            if (0 !== s.length) {
                const e = this._$_runtime$_._$GetEventSheetManager$_(), h = e._$GetEventStack$_(), r = h._$GetCurrentStackFrame$_(), n = r._$GetCurrentEvent$_(), o = n._$GetSolModifiers$_(), a = r._$IsSolModifierAfterCnds$_(), l = h._$Push$_(n), u = e._$GetLoopStack$_(), c = u._$Push$_(), f = i._$IsInContainer$_(), d = M._$Push$_();
                if (b._$shallowAssignArray$_(d, s), c._$SetEnd$_(d.length), a) for (let t = 0, s = d.length; t < s && !c._$IsStopped$_(); ++t) {
                    e._$PushCopySol$_(o);
                    const p = d[t];
                    i._$GetCurrentSol$_()._$SetSinglePicked$_(p), f && p._$SetSiblingsSinglePicked$_(), 
                    c._$SetIndex$_(t), n._$Retrigger$_(r, l), e._$PopSol$_(o);
                } else {
                    t._$_SetSelectAll$_(!1);
                    const m = t._$_GetOwnInstances$_();
                    b._$clearArray$_(m), m.push(null);
                    for (let t = 0, s = d.length; t < s && !c._$IsStopped$_(); ++t) {
                        const g = d[t];
                        m[0] = g, f && g._$SetSiblingsSinglePicked$_(), c._$SetIndex$_(t), 
                        n._$Retrigger$_(r, l);
                    }
                }
                h._$Pop$_(), u._$Pop$_(), b._$clearArray$_(d), M._$Pop$_();
            }
            return !1;
        }
        *_$_DebugForEach$_(i) {
            const t = i._$GetCurrentSol$_(), s = t._$GetInstances$_();
            if (0 !== s.length) {
                const e = this._$_runtime$_._$GetEventSheetManager$_(), h = e._$GetEventStack$_(), r = h._$GetCurrentStackFrame$_(), n = r._$GetCurrentEvent$_(), o = n._$GetSolModifiers$_(), a = r._$IsSolModifierAfterCnds$_(), l = h._$Push$_(n), u = e._$GetLoopStack$_(), c = u._$Push$_(), f = i._$IsInContainer$_(), d = M._$Push$_();
                if (b._$shallowAssignArray$_(d, s), c._$SetEnd$_(d.length), a) for (let t = 0, s = d.length; t < s && !c._$IsStopped$_(); ++t) {
                    e._$PushCopySol$_(o);
                    const p = d[t];
                    i._$GetCurrentSol$_()._$SetSinglePicked$_(p), f && p._$SetSiblingsSinglePicked$_(), 
                    c._$SetIndex$_(t), yield* n._$DebugRetrigger$_(r, l), e._$PopSol$_(o);
                } else {
                    t._$_SetSelectAll$_(!1);
                    const m = t._$_GetOwnInstances$_();
                    b._$clearArray$_(m), m.push(null);
                    for (let t = 0, s = d.length; t < s && !c._$IsStopped$_(); ++t) {
                        const g = d[t];
                        m[0] = g, f && g._$SetSiblingsSinglePicked$_(), c._$SetIndex$_(t), 
                        yield* n._$DebugRetrigger$_(r, l);
                    }
                }
                h._$Pop$_(), u._$Pop$_(), b._$clearArray$_(d), M._$Pop$_();
            }
            return !1;
        }
        _$_ForEachOrdered$_(i, t) {
            const s = i._$GetCurrentSol$_(), e = s._$GetInstances$_();
            if (0 !== e.length) {
                const h = this._$_runtime$_._$GetEventSheetManager$_(), r = h._$GetEventStack$_(), n = h._$GetCurrentCondition$_(), o = r._$GetCurrentStackFrame$_(), a = o._$GetCurrentEvent$_(), l = a._$GetSolModifiers$_(), u = o._$IsSolModifierAfterCnds$_(), c = r._$Push$_(a), f = h._$GetLoopStack$_(), d = f._$Push$_(), p = i._$IsInContainer$_(), m = M._$Push$_();
                b._$clearArray$_(m), d._$SetEnd$_(e.length);
                for (let t = 0, s = e.length; t < s; ++t) m.push([ e[t], n._$ReevaluateParameter$_(1, t) ]);
                if (m.sort(S), 1 === t && m.reverse(), u) for (let t = 0, s = m.length; t < s && !d._$IsStopped$_(); ++t) {
                    h._$PushCopySol$_(l);
                    const g = m[t][0];
                    i._$GetCurrentSol$_()._$SetSinglePicked$_(g), p && g._$SetSiblingsSinglePicked$_(), 
                    d._$SetIndex$_(t), a._$Retrigger$_(o, c), h._$PopSol$_(l);
                } else {
                    s._$_SetSelectAll$_(!1);
                    const y = s._$_GetOwnInstances$_();
                    b._$clearArray$_(y), y.push(null);
                    for (let t = 0, s = m.length; t < s && !d._$IsStopped$_(); ++t) {
                        const w = m[t][0];
                        y[0] = w, p && w._$SetSiblingsSinglePicked$_(), d._$SetIndex$_(t), 
                        a._$Retrigger$_(o, c);
                    }
                }
                r._$Pop$_(), f._$Pop$_(), b._$clearArray$_(m), M._$Pop$_();
            }
            return !1;
        }
        *_$_DebugForEachOrdered$_(i, t) {
            const s = i._$GetCurrentSol$_(), e = s._$GetInstances$_();
            if (0 !== e.length) {
                const h = this._$_runtime$_._$GetEventSheetManager$_(), r = h._$GetEventStack$_(), n = h._$GetCurrentCondition$_(), o = r._$GetCurrentStackFrame$_(), a = o._$GetCurrentEvent$_(), l = a._$GetSolModifiers$_(), u = o._$IsSolModifierAfterCnds$_(), c = r._$Push$_(a), f = h._$GetLoopStack$_(), d = f._$Push$_(), p = i._$IsInContainer$_(), m = M._$Push$_();
                b._$clearArray$_(m), d._$SetEnd$_(e.length);
                for (let t = 0, s = e.length; t < s; ++t) m.push([ e[t], n._$ReevaluateParameter$_(1, t) ]);
                if (m.sort(S), 1 === t && m.reverse(), u) for (let t = 0, s = m.length; t < s && !d._$IsStopped$_(); ++t) {
                    h._$PushCopySol$_(l);
                    const g = m[t][0];
                    i._$GetCurrentSol$_()._$SetSinglePicked$_(g), p && g._$SetSiblingsSinglePicked$_(), 
                    d._$SetIndex$_(t), yield* a._$DebugRetrigger$_(o, c), h._$PopSol$_(l);
                } else {
                    s._$_SetSelectAll$_(!1);
                    const y = s._$_GetOwnInstances$_();
                    b._$clearArray$_(y), y.push(null);
                    for (let t = 0, s = m.length; t < s && !d._$IsStopped$_(); ++t) {
                        const w = m[t][0];
                        y[0] = w, p && w._$SetSiblingsSinglePicked$_(), d._$SetIndex$_(t), 
                        yield* a._$DebugRetrigger$_(o, c);
                    }
                }
                r._$Pop$_(), f._$Pop$_(), b._$clearArray$_(m), M._$Pop$_();
            }
            return !1;
        }
        _$_GetFunctionMap$_(t, s) {
            let i = this._$_functionMaps$_.get(t);
            if (!i) {
                if (!s) return null;
                i = {
                    _$defaultFunc$_: null,
                    _$strMap$_: new Map()
                }, this._$_functionMaps$_.set(t, i);
            }
            return i;
        }
        _$_DoCallMappedFunction$_(t, s, i, e, h) {
            s._$GetEventBlock$_()._$RunAsMappedFunctionCall$_(i, s._$IsCopyPicked$_()), 
            e && t._$PopSol$_(h);
        }
        *_$_DebugDoCallMappedFunction$_(t, s, i, e, h) {
            yield* s._$GetEventBlock$_()._$DebugRunAsMappedFunctionCall$_(i, s._$IsCopyPicked$_()), 
            e && t._$PopSol$_(h);
        }
    };
}

{
    const Xa = self._$C3$_;
    Xa._$Plugins$_._$System$_._$Type$_ = class extends Xa._$DefendedBase$_ {
        constructor(t) {
            super(), this._$_objectClass$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), 
            this._$_plugin$_ = t._$GetPlugin$_();
        }
        _$OnCreate$_() {}
        _$Release$_() {
            this._$_objectClass$_ = null, this._$_runtime$_ = null, this._$_plugin$_ = null;
        }
    };
}

{
    const Ya = self._$C3$_;
    Ya._$Plugins$_._$System$_.Instance = class extends Ya._$DefendedBase$_ {
        constructor(t, s) {
            super(), this._$_inst$_ = t, this._$_objectClass$_ = this._$_inst$_._$GetObjectClass$_(), 
            this._$_sdkType$_ = this._$_objectClass$_._$GetSdkType$_(), this._$_runtime$_ = this._$_inst$_._$GetRuntime$_();
        }
        _$Release$_() {
            this._$_inst$_ = null, this._$_objectClass$_ = null, this._$_sdkType$_ = null, 
            this._$_runtime$_ = null;
        }
    };
}

{
    const G = self._$C3$_, $a = [];
    G._$Plugins$_._$System$_._$Cnds$_ = {
        _$EveryTick$_() {
            return !0;
        },
        _$OnLayoutStart$_() {
            return !0;
        },
        _$OnLayoutEnd$_() {
            return !0;
        },
        _$OnSuspend$_() {
            return !0;
        },
        _$OnResume$_() {
            return !0;
        },
        _$IsSuspended$_() {
            return this._$_runtime$_._$IsSuspended$_();
        },
        _$Else$_() {
            const t = this._$_runtime$_._$GetCurrentEventStackFrame$_();
            return !t._$GetElseBranchRan$_() && !t._$GetLastEventTrue$_();
        },
        _$TriggerOnce$_() {
            let t = this._$_runtime$_._$GetCurrentCondition$_(), s = t._$GetSavedDataMap$_(), i = s.get("TriggerOnce_lastTick");
            void 0 === i && (i = -1, s.set("TriggerOnce_lastTick", -1));
            const e = this._$_runtime$_._$GetTickCount$_();
            return s.set("TriggerOnce_lastTick", e), this._$_runtime$_._$IsLayoutFirstTick$_() || i !== e - 1;
        },
        _$Every$_(t) {
            const s = this._$_runtime$_._$GetCurrentCondition$_(), i = s._$GetSavedDataMap$_(), e = i.get("Every_lastTime") || 0, h = this._$_runtime$_._$GetGameTime$_(), r = (i.has("Every_seconds") || i.set("Every_seconds", t), 
            i.get("Every_seconds"));
            return e + r <= h ? (i.set("Every_lastTime", e + r), h >= i.get("Every_lastTime") + .04 && i.set("Every_lastTime", h), 
            i.set("Every_seconds", t), !0) : (h < e - .1 && i.set("Every_lastTime", h), 
            !1);
        },
        _$IsGroupActive$_(t) {
            const s = this._$_runtime$_._$GetEventSheetManager$_()._$GetEventGroupByName$_(t);
            return s && s._$IsGroupActive$_();
        },
        _$IsPreview$_() {
            return this._$_runtime$_._$IsPreview$_();
        },
        _$IsMobile$_() {
            return G._$Platform$_._$IsMobile$_;
        },
        _$OnLoadFinished$_() {
            return !0;
        },
        _$OnCanvasSnapshot$_() {
            return !0;
        },
        _$EffectsSupported$_() {
            return !0;
        },
        _$OnSaveComplete$_() {
            return !0;
        },
        _$OnSaveFailed$_() {
            return !0;
        },
        _$OnLoadComplete$_() {
            return !0;
        },
        _$OnLoadFailed$_() {
            return !0;
        },
        _$ObjectUIDExists$_(t) {
            return !!this._$_runtime$_._$GetInstanceByUID$_(t);
        },
        _$IsOnPlatform$_(t) {
            switch (t) {
              case 0:
                return "browser" === G._$Platform$_._$Context$_;

              case 1:
                return "iOS" === G._$Platform$_._$OS$_;

              case 2:
                return "Android" === G._$Platform$_._$OS$_;

              case 8:
                return "cordova" === G._$Platform$_._$Context$_;

              case 9:
                return "scirra-arcade" === this._$_runtime$_._$GetExportType$_();

              case 10:
                return "nwjs" === G._$Platform$_._$Context$_;

              case 13:
                return "windows-uwp" === this._$_runtime$_._$GetExportType$_();

              default:
                return !1;
            }
        },
        _$RegexTest$_(t, s, i) {
            const e = this._$GetRegex$_(s, i);
            return e.test(t);
        },
        _$Compare$_(t, s, i) {
            return G.compare(t, s, i);
        },
        _$CompareBetween$_(t, s, i) {
            return s <= t && t <= i;
        },
        _$CompareVar$_(t, s, i) {
            return G.compare(t._$GetValue$_(), s, i);
        },
        _$CompareBoolVar$_(t) {
            return !!t._$GetValue$_();
        },
        _$CompareTime$_(t, s) {
            const i = this._$_runtime$_._$GetGameTime$_();
            if (0 !== t) return G.compare(i, t, s);
            {
                const e = this._$_runtime$_._$GetCurrentCondition$_(), h = e._$GetSavedDataMap$_();
                return !h.get("CompareTime_executed") && s <= i ? (h.set("CompareTime_executed", !0), 
                !0) : !1;
            }
        },
        _$IsNaN$_(t) {
            return isNaN(t);
        },
        _$AngleWithin$_(t, s, i) {
            return G._$angleDiff$_(G._$toRadians$_(t), G._$toRadians$_(i)) <= G._$toRadians$_(s);
        },
        _$IsClockwiseFrom$_(t, s) {
            return G._$angleClockwise$_(G._$toRadians$_(t), G._$toRadians$_(s));
        },
        _$IsBetweenAngles$_(t, s, i) {
            let e = G._$toRadians$_(t), h = G._$toRadians$_(s), r = G._$toRadians$_(i), n = !G._$angleClockwise$_(r, h);
            return n ? !(!G._$angleClockwise$_(e, h) && G._$angleClockwise$_(e, r)) : G._$angleClockwise$_(e, h) && !G._$angleClockwise$_(e, r);
        },
        _$IsValueType$_(t, s) {
            return "number" == typeof t ? 0 === s : 1 === s;
        },
        _$EvaluateExpression$_(t) {
            return !!t;
        },
        _$OnSignal$_(t) {
            return t.toLowerCase() === this._$_runtime$_._$GetEventSheetManager$_()._$GetCurrentSignalTag$_();
        },
        _$PickByComparison$_(t, i, e, h) {
            if (!t) return !1;
            let s = this._$_GetForEachStack$_(), r = s._$Push$_(), n = t._$GetCurrentSol$_(), o = (G._$shallowAssignArray$_(r, n._$GetInstances$_()), 
            n._$IsSelectAll$_() && G._$clearArray$_(n._$_GetOwnElseInstances$_()), 
            this._$_runtime$_._$GetCurrentCondition$_()), a = 0;
            for (let t = 0, s = r.length; t < s; ++t) {
                const u = r[t];
                r[a] = u, i = o._$ReevaluateParameter$_(1, t), h = o._$ReevaluateParameter$_(3, t), 
                G.compare(i, e, h) ? ++a : n._$_PushElseInstance$_(u);
            }
            G._$truncateArray$_(r, a), n._$SetArrayPicked$_(r);
            const l = !!r.length;
            return G._$clearArray$_(r), s._$Pop$_(), t._$ApplySolToContainer$_(), 
            l;
        },
        _$PickByEvaluate$_(t, s) {
            if (!t) return !1;
            let i = this._$_GetForEachStack$_(), e = i._$Push$_(), h = t._$GetCurrentSol$_(), r = (G._$shallowAssignArray$_(e, h._$GetInstances$_()), 
            h._$IsSelectAll$_() && G._$clearArray$_(h._$_GetOwnElseInstances$_()), 
            this._$_runtime$_._$GetCurrentCondition$_()), n = 0;
            for (let t = 0, s = e.length; t < s; ++t) {
                const a = e[t];
                e[n] = a, r._$ReevaluateParameter$_(1, t) ? ++n : h._$_PushElseInstance$_(a);
            }
            G._$truncateArray$_(e, n), h._$SetArrayPicked$_(e);
            const o = !!e.length;
            return G._$clearArray$_(e), i._$Pop$_(), t._$ApplySolToContainer$_(), 
            o;
        },
        _$PickByHighestLowestValue$_(t, i, e) {
            if (!t) return !1;
            const s = t._$GetCurrentSol$_(), h = s._$GetInstances$_();
            if (0 === h.length) return !1;
            let r = this._$_runtime$_._$GetCurrentCondition$_(), n = null, o = 0;
            for (let t = 0, s = h.length; t < s; ++t) {
                const a = h[t];
                e = r._$ReevaluateParameter$_(2, t), (null === n || 0 === i && e < o || 1 === i && e > o) && (o = e, 
                n = a);
            }
            return s._$PickOne$_(n), t._$ApplySolToContainer$_(), !0;
        },
        _$PickNth$_(t, s) {
            if (!t) return !1;
            const i = t._$GetCurrentSol$_(), e = i._$GetInstances$_();
            if ((s = Math.floor(s)) >= e.length) return !1;
            const h = e[s];
            return i._$PickOne$_(h), t._$ApplySolToContainer$_(), !0;
        },
        _$PickRandom$_(t) {
            if (!t) return !1;
            const s = t._$GetCurrentSol$_(), i = s._$GetInstances$_(), e = Math.floor(this._$_runtime$_._$Random$_() * i.length);
            if (e >= i.length) return !1;
            const h = i[e];
            return s._$PickOne$_(h), t._$ApplySolToContainer$_(), !0;
        },
        _$PickAll$_(t) {
            if (!t) return !1;
            if (!t._$GetInstanceCount$_()) return !1;
            const s = t._$GetCurrentSol$_();
            return s._$_SetSelectAll$_(!0), t._$ApplySolToContainer$_(), !0;
        },
        _$PickOverlappingPoint$_(t, i, e) {
            if (!t) return !1;
            const h = t._$GetCurrentSol$_(), s = h._$GetInstances$_(), r = this._$_runtime$_._$GetCurrentEvent$_(), n = r._$IsOrBlock$_(), o = this._$_runtime$_._$GetCurrentCondition$_()._$IsInverted$_();
            h._$IsSelectAll$_() ? (G._$shallowAssignArray$_($a, s), h._$ClearArrays$_(), 
            h._$_SetSelectAll$_(!1)) : n ? (G._$shallowAssignArray$_($a, h._$_GetOwnElseInstances$_()), 
            G._$clearArray$_(h._$_GetOwnElseInstances$_())) : (G._$shallowAssignArray$_($a, h._$_GetOwnInstances$_()), 
            G._$clearArray$_(h._$_GetOwnInstances$_()));
            for (let t = 0, s = $a.length; t < s; ++t) {
                const a = $a[t];
                G.xor(a._$GetWorldInfo$_()._$ContainsPoint$_(i, e), o) ? h._$_PushInstance$_(a) : h._$_PushElseInstance$_(a);
            }
            return t._$ApplySolToContainer$_(), G.xor(!!h._$_GetOwnInstances$_().length, o);
        },
        _$PickLastCreated$_(s) {
            if (!s) return !1;
            let i = s._$IsFamily$_(), e = null, h = this._$_runtime$_._$_GetInstancesPendingCreate$_();
            for (let t = h.length - 1; 0 <= t; --t) {
                const r = h[t];
                if (i) {
                    if (r._$GetObjectClass$_()._$BelongsToFamily$_(s)) {
                        e = r;
                        break;
                    }
                } else if (r._$GetObjectClass$_() === s) {
                    e = r;
                    break;
                }
            }
            if (!e) {
                const n = s._$GetInstances$_();
                n.length && (e = n.at(-1));
            }
            if (!e) return !1;
            const t = s._$GetCurrentSol$_();
            return t._$PickOne$_(e), s._$ApplySolToContainer$_(), !0;
        },
        _$Repeat$_(t) {
            return this._$_runtime$_._$IsDebugging$_() ? this._$_DebugRepeat$_(t) : this._$_Repeat$_(t);
        },
        _$While$_() {
            return this._$_runtime$_._$IsDebugging$_() ? this._$_DebugWhile$_() : this._$_While$_();
        },
        _$For$_(t, s, i) {
            return this._$_runtime$_._$IsDebugging$_() ? this._$_DebugFor$_(t, s, i) : this._$_For$_(t, s, i);
        },
        _$ForEach$_(t) {
            return this._$_runtime$_._$IsDebugging$_() ? this._$_DebugForEach$_(t) : this._$_ForEach$_(t);
        },
        _$ForEachOrdered$_(t, s, i) {
            return this._$_runtime$_._$IsDebugging$_() ? this._$_DebugForEachOrdered$_(t, i) : this._$_ForEachOrdered$_(t, i);
        },
        _$LayerVisible$_(t) {
            return !!t && t._$IsVisible$_();
        },
        _$LayerInteractive$_(t) {
            return !!t && t._$IsSelfAndParentsInteractive$_();
        },
        _$LayerIsHTML$_(t) {
            return !!t && t._$IsHTMLElementsLayer$_();
        },
        _$LayerEmpty$_(t) {
            return !!t && !t._$GetInstanceCount$_();
        },
        _$LayerCmpOpacity$_(t, s, i) {
            return !!t && G.compare(100 * t._$GetOpacity$_(), s, i);
        },
        _$LayerNameExists$_(t) {
            const s = this._$_runtime$_._$GetMainRunningLayout$_();
            return !!s && s._$HasLayerByName$_(t);
        },
        _$OnImageLoadingComplete$_() {
            return !0;
        },
        _$IsLoadingImages$_() {
            return 0 < this._$_imagesLoadingTotal$_;
        },
        _$TemplateExists$_(t, s) {
            const i = this._$_runtime$_._$GetTemplateManager$_();
            return !!i && !!s && !!i._$GetTemplateData$_(t, s);
        }
    };
}

{
    let m = function(t, s) {
        const i = t[0], e = s[0], h = i - e;
        if (0 != h) return h;
        const r = t[1], n = s[1];
        return r - n;
    }, g = function(t, s) {
        return t[1] - s[1];
    };
    m, g;
    const Ka = self._$C3$_, Za = [], Qa = [], tl = Ka._$New$_(Ka.Rect), sl = Ka._$New$_(Ka._$Color$_), il = [];
    Ka._$Plugins$_._$System$_._$Acts$_ = {
        _$SetVar$_(t, s) {
            t._$SetValue$_(s);
        },
        _$AddVar$_(t, s) {
            t._$IsNumber$_() && "number" != typeof s && (s = parseFloat(s)), t._$SetValue$_(t._$GetValue$_() + s);
        },
        _$SubVar$_(t, s) {
            t._$IsNumber$_() && t._$SetValue$_(t._$GetValue$_() - s);
        },
        _$SetBoolVar$_(t, s) {
            t._$SetValue$_(!!s);
        },
        _$ToggleBoolVar$_(t) {
            t._$SetValue$_(!t._$GetValue$_());
        },
        _$ResetEventVar$_(t) {
            t._$SetValue$_(t._$GetInitialValue$_());
        },
        _$ResetGlobals$_(t) {
            this._$_runtime$_._$GetEventSheetManager$_()._$ResetAllGlobalsToInitialValue$_(t);
        },
        _$CreateObject$_(t, s, i, e, h, r) {
            if (t && s) {
                const n = this._$_runtime$_._$CreateInstance$_(t, s, i, e, h, r);
                if (n) {
                    h && s._$SortAndAddInstancesByZIndex$_(n);
                    const o = this._$_runtime$_._$GetEventSheetManager$_(), a = (o._$BlockFlushingInstances$_(!0), 
                    n._$_TriggerOnCreatedOnSelfAndRelated$_(), o._$BlockFlushingInstances$_(!1), 
                    new Map());
                    n._$CollectInstancesToPick$_(a, t, h);
                    for (const [ l, u ] of a) l._$GetCurrentSol$_()._$SetSetPicked$_(u);
                }
            }
        },
        _$CreateObjectByName$_(t, s, i, e, h, r) {
            if (t && s) {
                const n = this._$_runtime$_._$GetObjectClassByName$_(t);
                n && Ka._$Plugins$_._$System$_._$Acts$_._$CreateObject$_.call(this, n, s, i, e, h, r);
            }
        },
        _$RecreateInitialObjects$_(h, r, n, o, a, t, l, u, c, f, d) {
            if (h) {
                let s = this._$_runtime$_._$GetCurrentLayout$_(), i = s;
                if (t) {
                    const p = this._$_runtime$_._$GetLayoutManager$_()._$GetLayoutByName$_(t);
                    if (!p) return;
                    i = p;
                }
                let e = null;
                if (!("number" != typeof l || 0 <= l) || (e = i._$GetLayer$_(l))) {
                    let t = null;
                    if (!("number" != typeof u || 0 <= u) || (t = s._$GetLayer$_(u))) {
                        tl.set(r, n, o, a);
                        const m = i._$RecreateInitialObjects$_(h, tl, e, t, c, f, d);
                        h._$GetCurrentSol$_()._$SetArrayPicked$_(m), h._$ApplySolToContainer$_();
                    }
                }
            }
        },
        _$StopLoop$_() {
            const t = this._$_loopStack$_;
            t._$IsInLoop$_() && t._$GetCurrent$_()._$Stop$_();
        },
        _$SetGroupActive$_(t, s) {
            const i = this._$_runtime$_._$GetEventSheetManager$_()._$GetEventGroupByName$_(t);
            i && (0 === s ? i._$SetGroupActive$_(!1) : 1 === s ? i._$SetGroupActive$_(!0) : i._$SetGroupActive$_(!i._$IsGroupActive$_()));
        },
        _$SetTimescale$_(t) {
            this._$_runtime$_._$SetTimeScale$_(t);
        },
        _$SetObjectTimescale$_(t, s) {
            if (s < 0 && (s = 0), t) {
                const i = t._$GetCurrentSol$_(), e = i._$GetInstances$_();
                for (const h of e) h._$SetTimeScale$_(s);
            }
        },
        _$RestoreObjectTimescale$_(t) {
            if (t) {
                const s = t._$GetCurrentSol$_(), i = s._$GetInstances$_();
                for (const e of i) e._$RestoreTimeScale$_();
            }
        },
        _$Wait$_(t) {
            if (!(t < 0)) return this._$_runtime$_._$GetEventSheetManager$_()._$AddScheduledWait$_()._$InitTimer$_(t), 
            !0;
        },
        _$WaitForSignal$_(t) {
            return this._$_runtime$_._$GetEventSheetManager$_()._$AddScheduledWait$_()._$InitSignal$_(t), 
            !0;
        },
        _$WaitForPreviousActions$_() {
            const t = this._$_runtime$_._$GetEventSheetManager$_();
            return t._$AddScheduledWait$_()._$InitPromise$_(t._$GetPromiseForAllAsyncActions$_()), 
            !0;
        },
        _$Signal$_(t) {
            this._$_runtime$_._$GetEventSheetManager$_()._$Signal$_(t);
        },
        async _$SnapshotCanvas$_(t, s, i, e, h, r) {
            const n = this._$_runtime$_._$GetCanvasManager$_();
            n && (this._$UpdateRender$_(), await n._$SnapshotCanvas$_(0 === t ? "image/png" : "image/jpeg", s / 100, i, e, h, r), 
            await this._$_runtime$_._$TriggerAsync$_(Ka._$Plugins$_._$System$_._$Cnds$_._$OnCanvasSnapshot$_, null));
        },
        _$SetCanvasSize$_(t, s) {
            if (!(t <= 0 || s <= 0)) {
                this._$_runtime$_._$SetViewportSize$_(t, s), this._$_runtime$_._$GetCurrentLayout$_()._$BoundScrolling$_();
                const i = this._$_runtime$_._$GetCanvasManager$_();
                i && ("off" !== i._$GetCurrentFullscreenMode$_() && this._$_runtime$_._$SetOriginalViewportSize$_(t, s), 
                i._$SetSize$_(i._$GetLastWidth$_(), i._$GetLastHeight$_(), !0), 
                this._$_runtime$_._$UpdateRender$_());
            }
        },
        _$SetFullscreenQuality$_(t) {
            const s = this._$_runtime$_._$GetCanvasManager$_();
            s && "off" !== s._$GetCurrentFullscreenMode$_() && (s._$SetFullscreenScalingQuality$_(0 !== t ? "high" : "low"), 
            s._$SetSize$_(s._$GetLastWidth$_(), s._$GetLastHeight$_(), !0));
        },
        _$SaveState$_(t) {
            this._$_runtime$_._$SaveToSlot$_(t);
        },
        _$LoadState$_(t) {
            this._$_runtime$_._$LoadFromSlot$_(t);
        },
        _$LoadStateJSON$_(t) {
            this._$_runtime$_._$LoadFromJsonString$_(t);
        },
        _$SetHalfFramerateMode$_(t) {},
        _$ResetPersisted$_() {
            for (const t of this._$_runtime$_._$GetLayoutManager$_()._$GetAllLayouts$_()) t._$ResetPersistData$_();
        },
        _$SetPixelRounding$_(t) {
            this._$_runtime$_._$SetPixelRoundingEnabled$_(0 !== t);
        },
        _$SetFramerateMinMax$_(t, s) {
            this._$_runtime$_._$SetMaxDt$_(1 / t), this._$_runtime$_._$SetMinDt$_(1 / s);
        },
        _$SetDeltaTimeMinMax$_(t, s) {
            this._$_runtime$_._$SetMinDt$_(t), this._$_runtime$_._$SetMaxDt$_(s);
        },
        _$SetFramerateMode$_(t) {
            this._$_runtime$_._$_SetFramerateMode$_([ "vsync", "unlimited-tick", "unlimited-frame" ][t]);
        },
        _$SortZOrderByInstVar$_(t, i) {
            if (t) {
                const s = t._$GetCurrentSol$_(), e = s._$GetInstances$_(), h = Za, r = Qa, n = this._$_runtime$_._$GetCurrentLayout$_(), o = t._$IsFamily$_(), a = t._$GetFamilyIndex$_();
                for (let t = 0, s = e.length; t < s; ++t) {
                    const l = e[t], u = l._$GetWorldInfo$_();
                    if (u) {
                        let t;
                        t = o ? l._$GetInstanceVariableValue$_(i + l._$GetObjectClass$_()._$GetFamilyInstanceVariableOffset$_(a)) : l._$GetInstanceVariableValue$_(i), 
                        h.push([ u._$GetLayer$_()._$GetIndex$_(), u._$GetZIndex$_() ]), 
                        r.push([ l, t ]);
                    }
                }
                if (h.length) {
                    h.sort(m), r.sort(g);
                    let i = !1;
                    for (let t = 0, s = h.length; t < s; ++t) {
                        const c = r[t][0], f = n._$GetLayerByIndex$_(h[t][0]), d = h[t][1], p = f._$_GetInstances$_();
                        p[d] !== c && ((p[d] = c)._$GetWorldInfo$_()._$_SetLayer$_(f, !0), 
                        f._$SetZIndicesChanged$_(c), i = !0);
                    }
                    i && this._$_runtime$_._$UpdateRender$_(), Ka._$clearArray$_(Za), 
                    Ka._$clearArray$_(Qa);
                }
            }
        },
        _$SetCollisionCellSize$_(t, s) {
            t = Math.floor(t), s = Math.floor(s), t <= 0 || s <= 0 || !Number.isFinite(t) || !Number.isFinite(s) || this._$_runtime$_._$GetCollisionEngine$_()._$SetCollisionCellSize$_(t, s);
        },
        _$GoToLayout$_(t) {
            if (!this._$_runtime$_._$IsLoading$_()) {
                const s = this._$_runtime$_._$GetLayoutManager$_();
                s._$IsPendingChangeMainLayout$_() || s._$ChangeMainLayout$_(t);
            }
        },
        _$GoToLayoutByName$_(t) {
            if (!this._$_runtime$_._$IsLoading$_()) {
                const s = this._$_runtime$_._$GetLayoutManager$_();
                if (!s._$IsPendingChangeMainLayout$_()) {
                    const i = s._$GetLayoutByName$_(t);
                    i && s._$ChangeMainLayout$_(i);
                }
            }
        },
        _$NextPrevLayout$_(t) {
            if (!this._$_runtime$_._$IsLoading$_()) {
                const s = this._$_runtime$_._$GetLayoutManager$_();
                if (!s._$IsPendingChangeMainLayout$_()) {
                    const i = s._$GetAllLayouts$_(), e = i.indexOf(s._$GetMainRunningLayout$_());
                    if ((!t || 0 !== e) && (t || e !== i.length - 1)) {
                        const h = i[e + (t ? -1 : 1)];
                        s._$ChangeMainLayout$_(h);
                    }
                }
            }
        },
        _$RestartLayout$_() {
            if (!this._$_runtime$_._$IsLoading$_()) {
                const t = this._$_runtime$_._$GetLayoutManager$_();
                t._$IsPendingChangeMainLayout$_() || (t._$ChangeMainLayout$_(t._$GetMainRunningLayout$_()), 
                this._$_runtime$_._$GetEventSheetManager$_()._$ResetAllGroupsInitialActivation$_());
            }
        },
        _$SetLayerVisible$_(t, s) {
            t && t._$SetVisible$_(s);
        },
        _$SetLayerInteractive$_(t, s) {
            t && t._$SetInteractive$_(s);
        },
        _$SetLayerHTML$_(t, s) {
            t && t._$SetIsHTMLElementsLayer$_(s);
        },
        _$SetLayerOpacity$_(t, s) {
            t && t._$SetOpacity$_(s / 100);
        },
        _$SetLayerScale$_(t, s) {
            t && t._$SetOwnScale$_(s);
        },
        _$SetLayerScaleRate$_(t, s) {
            t && t._$SetScaleRate$_(s);
        },
        _$SetLayerAngle$_(t, s) {
            t && t._$SetAngle$_(Ka._$toRadians$_(+s));
        },
        _$SetLayerScroll$_(t, s, i) {
            t && (t._$SetOwnScrollPositionEnabled$_(!0), t._$SetScrollX$_(s), t._$SetScrollY$_(i));
        },
        _$RestoreLayerScroll$_(t) {
            t && t._$SetOwnScrollPositionEnabled$_(!1);
        },
        _$SetLayerParallax$_(t, s, i) {
            t && t._$SetParallax$_(s / 100, i / 100);
        },
        _$SetLayerZElevation$_(t, s) {
            t && t._$SetZElevation$_(+s);
        },
        _$SetLayerBackground$_(t, s) {
            if (t) {
                sl._$setFromRgbValue$_(s), sl._$clamp$_();
                const i = t._$GetBackgroundColor$_();
                i._$equalsIgnoringAlpha$_(sl) || (i._$copyRgb$_(sl), this._$UpdateRender$_());
            }
        },
        _$SetLayerTransparent$_(t, s) {
            t && t._$SetTransparent$_(s);
        },
        _$SetLayerBlendMode$_(t, s) {
            t && t._$SetBlendMode$_(s);
        },
        _$SetLayerEffectEnabled$_(t, s, i) {
            if (t) {
                const e = t._$GetEffectList$_(), h = e._$GetEffectTypeByName$_(i);
                if (h) {
                    const r = 1 === s;
                    h._$IsActive$_() !== r && (h._$SetActive$_(r), t._$UpdateActiveEffects$_(), 
                    this._$_runtime$_._$UpdateRender$_());
                }
            }
        },
        _$SetLayerEffectParam$_(t, s, i, e) {
            if (t) {
                const h = t._$GetEffectList$_(), r = h._$GetEffectTypeByName$_(s);
                if (r) {
                    i = Math.floor(i);
                    const n = r._$GetShaderProgram$_()._$GetParameterType$_(i);
                    if (n) {
                        "color" === n ? (sl._$setFromRgbValue$_(e), e = sl) : "percent" === n && (e /= 100);
                        const o = h._$SetEffectParameter$_(r._$GetIndex$_(), i, e);
                        o && r._$IsActive$_() && this._$_runtime$_._$UpdateRender$_();
                    }
                }
            }
        },
        _$SetLayerForceOwnTexture$_(t, s) {
            t && t._$SetForceOwnTexture$_(s);
        },
        _$SetLayoutScale$_(t) {
            this._$_runtime$_._$GetCurrentLayout$_()._$SetScale$_(+t);
        },
        _$SetLayoutAngle$_(t) {
            this._$_runtime$_._$GetCurrentLayout$_()._$SetAngle$_(Ka._$toRadians$_(+t));
        },
        _$SetLayoutEffectEnabled$_(t, s) {
            const i = this._$_runtime$_._$GetCurrentLayout$_(), e = i._$GetEffectList$_(), h = e._$GetEffectTypeByName$_(s);
            if (h) {
                const r = 1 === t;
                h._$IsActive$_() !== r && (h._$SetActive$_(r), i._$UpdateActiveEffects$_(), 
                this._$_runtime$_._$UpdateRender$_());
            }
        },
        _$SetLayoutEffectParam$_(t, s, i) {
            const e = this._$_runtime$_._$GetCurrentLayout$_(), h = e._$GetEffectList$_(), r = h._$GetEffectTypeByName$_(t);
            if (r) {
                s = Math.floor(s);
                const n = r._$GetShaderProgram$_()._$GetParameterType$_(s);
                if (n) {
                    "color" === n ? (sl._$setFromRgbValue$_(i), i = sl) : "percent" === n && (i /= 100);
                    const o = h._$SetEffectParameter$_(r._$GetIndex$_(), s, i);
                    o && r._$IsActive$_() && this._$_runtime$_._$UpdateRender$_();
                }
            }
        },
        _$SetLayoutVanishingPoint$_(t, s) {
            const i = this._$_runtime$_._$GetCurrentLayout$_();
            i._$SetVanishingPointXY$_(t / 100, s / 100);
        },
        _$SetLayoutProjection$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_();
            0 === t ? s._$SetPerspectiveProjection$_() : s._$SetOrthographicProjection$_();
        },
        _$ScrollX$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_();
            s._$SetScrollX$_(t);
        },
        _$ScrollY$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_();
            s._$SetScrollY$_(t);
        },
        _$Scroll$_(t, s) {
            const i = this._$_runtime$_._$GetCurrentLayout$_();
            i._$SetScrollX$_(t), i._$SetScrollY$_(s);
        },
        _$ScrollToObject$_(t) {
            if (t) {
                const s = t._$GetFirstPicked$_();
                if (s) {
                    const i = s._$GetWorldInfo$_();
                    if (i) {
                        const e = this._$_runtime$_._$GetCurrentLayout$_();
                        e._$SetScrollX$_(i._$GetX$_()), e._$SetScrollY$_(i._$GetY$_());
                    }
                }
            }
        },
        _$AddLayer$_(t, s, i) {
            const e = this._$_runtime$_._$GetCurrentLayout$_();
            try {
                e._$AddLayer$_(t, s, i);
            } catch (t) {
                console.warn("[Construct] Cannot add layer: ", t);
            }
        },
        _$MoveLayer$_(t, s, i) {
            if (t) {
                const e = this._$_runtime$_._$GetCurrentLayout$_();
                try {
                    e._$MoveLayer$_(t, s, i);
                } catch (t) {
                    console.warn("[Construct] Cannot move layer: ", t);
                }
            }
        },
        _$RemoveLayer$_(t) {
            if (t) {
                const s = this._$_runtime$_._$GetCurrentLayout$_();
                s._$RemoveLayer$_(t);
            }
        },
        _$RemoveAllDynamicLayers$_() {
            this._$_runtime$_._$GetCurrentLayout$_()._$RemoveAllDynamicLayers$_();
        },
        async _$LoadObjectTextures$_(t) {
            const s = this._$_runtime$_._$GetMainRunningLayout$_();
            if (s && t && !this._$_runtime$_._$IsLoading$_()) {
                const i = t._$IsFamily$_() ? t._$GetFamilyMembers$_() : [ t ];
                await this._$_LoadTexturesForObjectClasses$_(s, i);
            }
        },
        async _$LoadObjectTexturesByName$_(t) {
            await Ka._$Plugins$_._$System$_._$Acts$_._$LoadObjectTextures$_.call(this, this._$_runtime$_._$GetObjectClassByName$_(t));
        },
        _$UnloadObjectTextures$_(t) {
            const s = this._$_runtime$_._$GetMainRunningLayout$_();
            if (s && t) {
                const i = t._$IsFamily$_() ? t._$GetFamilyMembers$_() : [ t ];
                this._$_UnloadTexturesForObjectClasses$_(s, i);
            }
        },
        _$UnloadObjectTexturesByName$_(t) {
            Ka._$Plugins$_._$System$_._$Acts$_._$UnloadObjectTextures$_.call(this, this._$_runtime$_._$GetObjectClassByName$_(t));
        },
        _$UnloadUnusedTextures$_() {
            const t = this._$_runtime$_._$GetMainRunningLayout$_();
            if (t) {
                const s = t._$_GetTextureLoadedObjectTypes$_();
                this._$_UnloadTexturesForObjectClasses$_(t, s);
            }
        },
        async _$LoadLayoutTextures$_(t) {
            const s = this._$_runtime$_._$GetMainRunningLayout$_();
            t && s && !this._$_runtime$_._$IsLoading$_() && await this._$_LoadTexturesForObjectClasses$_(s, t._$_GetInitialObjectClasses$_());
        },
        async _$LoadLayoutTexturesByName$_(t) {
            const s = this._$_runtime$_._$GetMainRunningLayout$_(), i = this._$_runtime$_._$GetLayoutManager$_()._$GetLayoutByName$_(t);
            i && s && !this._$_runtime$_._$IsLoading$_() && await this._$_LoadTexturesForObjectClasses$_(s, i._$_GetInitialObjectClasses$_());
        },
        _$SetFunctionReturnValue$_(t) {
            const s = this._$_eventStack$_._$GetCurrentExpFuncStackFrame$_();
            if (s) switch (s._$GetFunctionReturnType$_()) {
              case 1:
                "number" == typeof t && s._$SetFunctionReturnValue$_(t);
                break;

              case 2:
                "string" == typeof t && s._$SetFunctionReturnValue$_(t);
                break;

              case 3:
                s._$SetFunctionReturnValue$_(t);
            }
        },
        _$MapFunction$_(t, s, i) {
            const e = this._$_GetFunctionMap$_(t.toLowerCase(), !0), h = e._$strMap$_, r = s.toLowerCase(), n = (h.has(r) && console.warn(`[Construct] Function map '${t}' string '${s}' already in map; overwriting entry`), 
            Ka.first(h.values()) || e._$defaultFunc$_);
            if (n) {
                const o = 0 !== n._$GetReturnType$_(), a = 0 !== i._$GetReturnType$_();
                if (o != a) return void console.error(`[Construct] Function map '${t}' string '${s}' function return type not compatible with other functions in the map; entry ignored`);
            }
            h.set(r, i);
        },
        _$MapFunctionDefault$_(t, s) {
            const i = this._$_GetFunctionMap$_(t.toLowerCase(), !0), e = (i._$defaultFunc$_ && console.warn(`[Construct] Function map '${t}' already has a default; overwriting entry`), 
            Ka.first(i._$strMap$_.values()) || i._$defaultFunc$_);
            if (e) {
                const h = 0 !== e._$GetReturnType$_(), r = 0 !== s._$GetReturnType$_();
                if (h != r) return void console.error(`[Construct] Function map '${t}' default: function return type not compatible with other functions in the map; entry ignored`);
            }
            i._$defaultFunc$_ = s;
        },
        _$CallMappedFunction$_(t, s, i) {
            const e = this._$_runtime$_, h = e._$IsDebugging$_() ? il : null, r = (i = Math.floor(i), 
            this._$_GetFunctionMap$_(t.toLowerCase(), !1));
            if (!r) return console.warn(`[Construct] Call mapped function: map name '${t}' not found; call ignored`), 
            h;
            let n = r._$strMap$_.get(s.toLowerCase());
            if (!n) {
                if (!r._$defaultFunc$_) return console.warn(`[Construct] Call mapped function: no function associated with map '${t}' string '${s}'; call ignored (consider setting a default)`), 
                h;
                n = r._$defaultFunc$_, i = 0;
            }
            if (!n._$IsEnabled$_()) return h;
            if (0 !== n._$GetReturnType$_()) return console.warn(`[Construct] Call mapped function: map '${t}' string '${s}' has a return type so cannot be called`), 
            h;
            const o = e._$GetEventSheetManager$_(), a = o._$GetCurrentEvent$_(), l = a._$GetSolModifiersIncludingParents$_(), u = 0 < l.length, c = (u && (n._$IsCopyPicked$_() ? o._$PushCopySol$_(l) : o._$PushCleanSol$_(l)), 
            []), f = o._$FindFirstFunctionBlockParent$_(a);
            if (f) {
                const p = f._$GetFunctionParameters$_();
                for (let t = i, s = p.length; t < s; ++t) c.push(p[t]._$GetValue$_());
            }
            const d = n._$GetFunctionParameters$_();
            for (let t = c.length, s = d.length; t < s; ++t) c.push(d[t]._$GetInitialValue$_());
            return e._$IsDebugging$_() ? this._$_DebugDoCallMappedFunction$_(o, n, c, u, l) : this._$_DoCallMappedFunction$_(o, n, c, u, l);
        }
    };
}

{
    const T = self._$C3$_;
    T._$Plugins$_._$System$_._$Exps$_ = {
        _$int$_: function(t) {
            return "string" == typeof t && (t = parseInt(t, 10), isNaN(t)) && (t = 0), 
            Math.floor(t);
        },
        float: function(t) {
            return t = "string" == typeof t && (t = parseFloat(t), isNaN(t)) ? 0 : t;
        },
        _$str$_(t) {
            return t.toString();
        },
        _$len$_(t) {
            return "string" == typeof t ? t.length : 0;
        },
        random(t, s) {
            return void 0 === s ? this._$_runtime$_._$Random$_() * t : this._$_runtime$_._$Random$_() * (s - t) + t;
        },
        _$choose$_(...t) {
            const s = Math.floor(this._$_runtime$_._$Random$_() * t.length);
            return t[s];
        },
        _$chooseindex$_(t, ...s) {
            return "number" != typeof t && (t = 0), s[t = T._$clamp$_(Math.floor(t), 0, s.length - 1)];
        },
        pi() {
            return Math.PI;
        },
        _$infinity$_() {
            return 1 / 0;
        },
        sqrt(t) {
            return Math.sqrt(t);
        },
        abs(t) {
            return Math.abs(t);
        },
        round(t) {
            return Math.round(t);
        },
        _$roundtodp$_(t, s) {
            s = Math.max(Math.floor(s), 0);
            const i = Math.pow(10, s);
            return Math.round((t + Number.EPSILON) * i) / i;
        },
        floor(t) {
            return Math.floor(t);
        },
        ceil(t) {
            return Math.ceil(t);
        },
        sign(t) {
            return Math.sign(t);
        },
        sin(t) {
            return Math.sin(T._$toRadians$_(t));
        },
        cos(t) {
            return Math.cos(T._$toRadians$_(t));
        },
        tan(t) {
            return Math.tan(T._$toRadians$_(t));
        },
        asin(t) {
            return T._$toDegrees$_(Math.asin(t));
        },
        acos(t) {
            return T._$toDegrees$_(Math.acos(t));
        },
        atan(t) {
            return T._$toDegrees$_(Math.atan(t));
        },
        exp(t) {
            return Math.exp(t);
        },
        _$ln$_(t) {
            return Math.log(t);
        },
        log10(t) {
            return Math.log10(t);
        },
        max(...i) {
            let e = i[0];
            "number" != typeof e && (e = 0);
            for (let s = 1, t = i.length; s < t; ++s) {
                let t = i[s];
                "number" == typeof t && e < t && (e = t);
            }
            return e;
        },
        min(...i) {
            let e = i[0];
            "number" != typeof e && (e = 0);
            for (let s = 1, t = i.length; s < t; ++s) {
                let t = i[s];
                "number" == typeof t && e > t && (e = t);
            }
            return e;
        },
        _$clamp$_(t, s, i) {
            return T._$clamp$_(t, s, i);
        },
        _$distance$_(t, s, i, e) {
            return T._$distanceTo$_(t, s, i, e);
        },
        angle(t, s, i, e) {
            return T._$toDegrees$_(T._$angleTo$_(t, s, i, e));
        },
        _$lerp$_(t, s, i) {
            return T._$lerp$_(t, s, i);
        },
        _$unlerp$_(t, s, i) {
            return T._$unlerp$_(t, s, i);
        },
        _$qarp$_(t, s, i, e) {
            return T._$qarp$_(t, s, i, e);
        },
        _$cubic$_(t, s, i, e, h) {
            return T._$cubic$_(t, s, i, e, h);
        },
        _$cosp$_(t, s, i) {
            return T._$cosp$_(t, s, i);
        },
        _$anglediff$_(t, s) {
            return T._$toDegrees$_(T._$angleDiff$_(T._$toRadians$_(t), T._$toRadians$_(s)));
        },
        _$anglelerp$_(t, s, i) {
            return T._$toDegrees$_(T._$angleLerp$_(T._$toRadians$_(t), T._$toRadians$_(s), i));
        },
        _$anglerotate$_(t, s, i) {
            return T._$toDegrees$_(T._$angleRotate$_(T._$toRadians$_(t), T._$toRadians$_(s), T._$toRadians$_(i)));
        },
        _$setbit$_(t, s, i) {
            return (t |= 0) & ~(1 << (s |= 0)) | (i = 0 !== i ? 1 : 0) << s;
        },
        _$togglebit$_(t, s) {
            return (t |= 0) ^ 1 << (s |= 0);
        },
        _$getbit$_(t, s) {
            return (t |= 0) & 1 << (s |= 0) ? 1 : 0;
        },
        _$newline$_() {
            return "\n";
        },
        _$uppercase$_(t) {
            return "string" == typeof t ? t.toUpperCase() : "";
        },
        _$lowercase$_(t) {
            return "string" == typeof t ? t.toLowerCase() : "";
        },
        left(t, s) {
            return "string" == typeof t ? t.substr(0, s) : "";
        },
        mid(t, s, i) {
            return "string" != typeof t ? "" : i < 0 ? t.substr(s) : t.substr(s, i);
        },
        right(t, s) {
            return "string" == typeof t ? t.substr(Math.max(t.length - s, 0)) : "";
        },
        trim(t) {
            return "string" == typeof t ? t.trim() : "";
        },
        _$tokenat$_(t, s, i) {
            if ("string" != typeof t || "string" != typeof i) return "";
            let e = t.split(i);
            return (s = Math.floor(s)) < 0 || s >= e.length ? "" : e[s];
        },
        _$tokencount$_(t, s) {
            return "string" == typeof t && "string" == typeof s && t.length ? t.split(s).length : 0;
        },
        find(t, s) {
            return "string" == typeof t && "string" == typeof s ? t.search(new RegExp(T._$EscapeRegex$_(s), "i")) : -1;
        },
        _$findcase$_(t, s) {
            return "string" == typeof t && "string" == typeof s ? t.search(new RegExp(T._$EscapeRegex$_(s), "")) : -1;
        },
        replace(t, s, i) {
            return "string" == typeof t && "string" == typeof s && "string" == typeof i ? t.replace(new RegExp(T._$EscapeRegex$_(s), "gi"), i) : "string" == typeof t ? t : "";
        },
        _$stringsub$_(t, ...i) {
            let e = t;
            for (let t = 0, s = i.length; t < s; ++t) e = e.replaceAll(`{${t}}`, i[t].toString());
            return e;
        },
        _$regexsearch$_(t, s, i) {
            const e = this._$GetRegex$_(s, i);
            return t ? t.search(e) : -1;
        },
        _$regexreplace$_(t, s, i, e) {
            const h = this._$GetRegex$_(s, i);
            return t ? t.replace(h, e) : "";
        },
        _$regexmatchcount$_(t, s, i) {
            const e = this._$GetRegexMatches$_(t.toString(), s, i);
            return e ? e.length : 0;
        },
        _$regexmatchat$_(t, s, i, e) {
            e = Math.floor(e);
            const h = this._$GetRegexMatches$_(t.toString(), s, i);
            return !h || e < 0 || e >= h.length ? "" : h[e];
        },
        _$zeropad$_(t, s) {
            let i = t < 0 ? "-" : "", e = s - (t = t < 0 ? -t : t).toString().length;
            return (i += "0".repeat(Math.max(e, 0))) + t.toString();
        },
        _$urlencode$_(t) {
            return encodeURIComponent(t);
        },
        _$urldecode$_(t) {
            return decodeURIComponent(t);
        },
        dt() {
            return this._$_runtime$_._$_GetDtFast$_();
        },
        timescale() {
            return this._$_runtime$_._$GetTimeScale$_();
        },
        _$wallclocktime$_() {
            return (Date.now() - this._$_runtime$_._$GetStartTime$_()) / 1e3;
        },
        _$unixtime$_() {
            return Date.now();
        },
        time() {
            return this._$_runtime$_._$GetGameTime$_();
        },
        tickcount() {
            return this._$_runtime$_._$GetTickCount$_();
        },
        _$objectcount$_() {
            return this._$_runtime$_._$GetObjectCount$_();
        },
        fps() {
            return this._$_runtime$_._$GetFramesPerSecond$_();
        },
        _$cpuutilisation$_() {
            return this._$_runtime$_._$GetMainThreadTime$_();
        },
        _$gpuutilisation$_() {
            return this._$_runtime$_._$GetGPUUtilisation$_();
        },
        _$windowwidth$_() {
            return this._$_runtime$_._$GetCanvasManager$_()._$GetDeviceWidth$_();
        },
        _$windowheight$_() {
            return this._$_runtime$_._$GetCanvasManager$_()._$GetDeviceHeight$_();
        },
        _$originalwindowwidth$_() {
            return this._$_runtime$_._$GetOriginalViewportWidth$_();
        },
        _$originalwindowheight$_() {
            return this._$_runtime$_._$GetOriginalViewportHeight$_();
        },
        _$originalviewportwidth$_() {
            return this._$_runtime$_._$GetOriginalViewportWidth$_();
        },
        _$originalviewportheight$_() {
            return this._$_runtime$_._$GetOriginalViewportHeight$_();
        },
        _$scrollx$_() {
            return this._$_runtime$_._$GetCurrentLayout$_()._$GetScrollX$_();
        },
        _$scrolly$_() {
            return this._$_runtime$_._$GetCurrentLayout$_()._$GetScrollY$_();
        },
        _$layoutname$_() {
            return this._$_runtime$_._$GetCurrentLayout$_()._$GetName$_();
        },
        _$layoutscale$_() {
            return this._$_runtime$_._$GetCurrentLayout$_()._$GetScale$_();
        },
        _$layoutangle$_() {
            return T._$toDegrees$_(this._$_runtime$_._$GetCurrentLayout$_()._$GetAngle$_());
        },
        _$layoutwidth$_() {
            return this._$_runtime$_._$GetCurrentLayout$_()._$GetWidth$_();
        },
        _$layoutheight$_() {
            return this._$_runtime$_._$GetCurrentLayout$_()._$GetHeight$_();
        },
        _$vanishingpointx$_() {
            return 100 * this._$_runtime$_._$GetCurrentLayout$_()._$GetVanishingPointX$_();
        },
        _$vanishingpointy$_() {
            return 100 * this._$_runtime$_._$GetCurrentLayout$_()._$GetVanishingPointY$_();
        },
        _$viewportleft$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetViewport3D$_()._$getLeft$_() : 0;
        },
        _$viewporttop$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetViewport3D$_()._$getTop$_() : 0;
        },
        _$viewportright$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetViewport3D$_()._$getRight$_() : 0;
        },
        _$viewportbottom$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetViewport3D$_()._$getBottom$_() : 0;
        },
        _$viewportwidth$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetViewport3D$_().width() : 0;
        },
        _$viewportheight$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetViewport3D$_().height() : 0;
        },
        _$viewportmidx$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            if (s) {
                const i = s._$GetViewport3D$_();
                return (i._$getLeft$_() + i._$getRight$_()) / 2;
            }
            return 0;
        },
        _$viewportmidy$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            if (s) {
                const i = s._$GetViewport3D$_();
                return (i._$getTop$_() + i._$getBottom$_()) / 2;
            }
            return 0;
        },
        _$canvastolayerx$_(t, s, i) {
            const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return e ? e._$CanvasCssToLayer$_(s, i)[0] : 0;
        },
        _$canvastolayery$_(t, s, i) {
            const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return e ? e._$CanvasCssToLayer$_(s, i)[1] : 0;
        },
        _$layertocanvasx$_(t, s, i) {
            const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return e ? e._$LayerToCanvasCss$_(s, i)[0] : 0;
        },
        _$layertocanvasy$_(t, s, i) {
            const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return e ? e._$LayerToCanvasCss$_(s, i)[1] : 0;
        },
        _$layertolayerx$_(t, s, i, e) {
            const h = this._$_runtime$_._$GetCurrentLayout$_(), r = h._$GetLayer$_(t), n = h._$GetLayer$_(s);
            if (!r || !n || r === n) return i;
            const [ o, a ] = r._$LayerToCanvasCss$_(i, e);
            return n._$CanvasCssToLayer$_(o, a)[0];
        },
        _$layertolayery$_(t, s, i, e) {
            const h = this._$_runtime$_._$GetCurrentLayout$_(), r = h._$GetLayer$_(t), n = h._$GetLayer$_(s);
            if (!r || !n || r === n) return e;
            const [ o, a ] = r._$LayerToCanvasCss$_(i, e);
            return n._$CanvasCssToLayer$_(o, a)[1];
        },
        _$layerscale$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetOwnScale$_() : 0;
        },
        _$layerangle$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? T._$toDegrees$_(s._$GetOwnAngle$_()) : 0;
        },
        _$layeropacity$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? 100 * s._$GetOpacity$_() : 0;
        },
        _$layerscalerate$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetScaleRate$_() : 0;
        },
        _$layerscrollx$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetScrollX$_() : 0;
        },
        _$layerscrolly$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetScrollY$_() : 0;
        },
        _$layerparallaxx$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? 100 * s._$GetParallaxX$_() : 0;
        },
        _$layerparallaxy$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? 100 * s._$GetParallaxY$_() : 0;
        },
        _$layerzelevation$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetZElevation$_() : 0;
        },
        _$layerindex$_(t) {
            const s = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
            return s ? s._$GetIndex$_() : -1;
        },
        _$canvassnapshot$_() {
            const t = this._$_runtime$_._$GetCanvasManager$_();
            return t ? t._$GetCanvasSnapshotUrl$_() : "";
        },
        _$loopindex$_(t) {
            const s = this._$_loopStack$_;
            if (!s._$IsInLoop$_()) return 0;
            if (t) {
                const i = s._$FindByName$_(t);
                return i ? i._$GetIndex$_() : 0;
            }
            return s._$GetCurrent$_()._$GetIndex$_();
        },
        _$savestatejson$_() {
            return this._$_runtime$_._$GetLastSaveJsonString$_();
        },
        _$callmapped$_(t, s, ...i) {
            const e = this._$_GetFunctionMap$_(t.toLowerCase(), !1);
            if (!e) return console.warn(`[Construct] Call mapped function: map name '${t}' not found; returning 0`), 
            0;
            let h = e._$strMap$_.get(s.toLowerCase());
            if (!h) {
                if (!e._$defaultFunc$_) return console.warn(`[Construct] Call mapped function: no function associated with map '${t}' string '${s}'; returning 0 (consider setting a default)`), 
                0;
                h = e._$defaultFunc$_;
            }
            const r = h._$GetReturnType$_(), n = h._$GetDefaultReturnValue$_();
            if (0 === r) return console.warn(`[Construct] Call mapped function: map '${t}' string '${s}' has no return type so cannot be called from an expression; returning 0`), 
            0;
            if (!h._$IsEnabled$_()) return n;
            const o = this._$_runtime$_, a = o._$GetEventSheetManager$_(), l = a._$GetCurrentEvent$_(), u = l._$GetSolModifiersIncludingParents$_(), c = 0 < u.length, f = (c && (h._$IsCopyPicked$_() ? a._$PushCopySol$_(u) : a._$PushCleanSol$_(u)), 
            h._$GetFunctionParameters$_());
            for (let t = i.length, s = f.length; t < s; ++t) i.push(f[t]._$GetInitialValue$_());
            const d = h._$GetEventBlock$_(), p = d._$RunAsExpressionFunctionCall$_(d._$GetSolModifiersIncludingParents$_(), h._$IsCopyPicked$_(), r, n, ...i);
            return c && a._$PopSol$_(u), p;
        },
        _$loadingprogress$_() {
            return this._$_runtime$_._$GetAssetManager$_()._$GetLoadProgress$_();
        },
        _$imageloadingprogress$_() {
            return 0 === this._$_imagesLoadingTotal$_ ? 1 : this._$_imagesLoadingComplete$_ / this._$_imagesLoadingTotal$_;
        },
        renderer() {
            return this._$_runtime$_._$GetWebGPURenderer$_() ? "webgpu" : "webgl";
        },
        _$rendererdetail$_() {
            return this._$_runtime$_._$GetWebGPURenderer$_() ? this._$_runtime$_._$GetWebGPURenderer$_().GetAdapterInfoString() : this._$_runtime$_._$GetWebGLRenderer$_()._$GetUnmaskedRenderer$_();
        },
        _$imagememoryusage$_() {
            let t = this._$_runtime$_._$GetRenderer$_()._$GetEstimatedTextureMemoryUsage$_();
            return Math.round(100 * t / 1048576) / 100;
        },
        _$rgb$_(t, s, i) {
            return T._$PackRGB$_(t, s, i);
        },
        _$rgbex$_(t, s, i) {
            return T._$PackRGBEx$_(t / 100, s / 100, i / 100);
        },
        _$rgba$_(t, s, i, e) {
            return T._$PackRGBAEx$_(t / 100, s / 100, i / 100, e / 100);
        },
        _$rgbex255$_(t, s, i) {
            return T._$PackRGBEx$_(t / 255, s / 255, i / 255);
        },
        _$rgba255$_(t, s, i, e) {
            return T._$PackRGBAEx$_(t / 255, s / 255, i / 255, e / 255);
        },
        _$projectname$_() {
            return this._$_runtime$_._$GetProjectName$_();
        },
        _$projectversion$_() {
            return this._$_runtime$_._$GetProjectVersion$_();
        },
        _$currenteventsheetname$_() {
            return this._$_runtime$_._$GetCurrentEvent$_()._$GetEventSheet$_()._$GetName$_();
        },
        _$currenteventnumber$_() {
            return this._$_runtime$_._$GetCurrentEvent$_()._$GetDisplayNumber$_();
        }
    };
}

{
    const el = self._$C3$_, hl = [];
    el._$Plugins$_.Audio = class extends el._$SDKPluginBase$_ {
        constructor(t) {
            super(t);
        }
        _$_AddActionPromise$_(t) {
            hl.push(t);
        }
        static async _$WaitForAllActionPromises$_() {
            await Promise.all(hl), el._$clearArray$_(hl);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    let s = function() {
        return i._$GetSingleGlobalInstance$_()._$GetSdkInstance$_();
    }, t = function() {
        if (self.C3Audio_DOMInterface) return self.C3Audio_DOMInterface;
        throw new Error("audio scripting API cannot be used here - make sure the project is using DOM mode, not worker mode");
    };
    s, t;
    const rl = self._$C3$_, nl = self._$C3X$_;
    rl._$Plugins$_.Audio._$Type$_ = class extends rl._$SDKTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
        _$GetScriptInterfaceClass$_() {
            return self._$IAudioObjectType$_;
        }
    };
    let i = null;
    self._$IAudioObjectType$_ = class extends self._$IObjectClass$_ {
        constructor(t) {
            super(t), i = t;
        }
        get _$audioContext$_() {
            return t().GetAudioContextExtern();
        }
        get _$destinationNode$_() {
            return t().GetDestinationNodeExtern();
        }
        get isSilent() {
            return s()._$_IsSilent$_();
        }
        set isSilent(t) {
            s()._$_SetSilent$_(t);
        }
        get masterVolume() {
            return s()._$_GetMasterVolume$_();
        }
        set masterVolume(t) {
            nl._$RequireFiniteNumber$_(t), s()._$_SetMasterVolume$_(t);
        }
        _$stopAll$_() {
            s()._$_StopAll$_();
        }
    };
}

{
    const ol = self._$C3$_, al = [ "interactive", "balanced", "playback" ];
    ol._$Plugins$_.Audio.Instance = class extends ol._$SDKInstanceBase$_ {
        constructor(t, s) {
            super(t, "audio"), this._$_nextPlayTime$_ = 0, this._$_triggerTags$_ = [], 
            this._$_enableMultiTags$_ = !0, this._$_timeScaleMode$_ = 0, this._$_saveLoadMode$_ = 0, 
            this._$_playInBackground$_ = !1, this._$_panningModel$_ = 1, this._$_distanceModel$_ = 1, 
            this._$_listenerPos$_ = [ this._$_runtime$_._$GetViewportWidth$_() / 2, this._$_runtime$_._$GetViewportHeight$_() / 2, 600 ], 
            this._$_listenerForwardVec$_ = [ 0, 0, -1 ], this._$_listenerUpVec$_ = [ 0, 1, 0 ], 
            this._$_referenceDistance$_ = 600, this._$_maxDistance$_ = 1e4, this._$_rolloffFactor$_ = 1, 
            this._$_listenerInst$_ = null, this._$_loadListenerUid$_ = -1, this._$_masterVolume$_ = 1, 
            this._$_isSilent$_ = !1, this._$_sampleRate$_ = 0, this._$_audioContextState$_ = "suspended", 
            this._$_outputLatency$_ = 0, this._$_effectCount$_ = new Map(), this._$_preloadTotal$_ = 0, 
            this._$_preloadCount$_ = 0, this._$_bufferMetadata$_ = new Map(), this._$_remoteUrls$_ = new Map();
            let i = "interactive";
            s && (this._$_timeScaleMode$_ = s[0], this._$_saveLoadMode$_ = s[1], 
            this._$_playInBackground$_ = s[2], i = al[s[3]], this._$_enableMultiTags$_ = s[4], 
            this._$_panningModel$_ = s[5], this._$_distanceModel$_ = s[6], this._$_listenerPos$_[2] = s[7], 
            this._$_referenceDistance$_ = s[8], this._$_maxDistance$_ = s[9], this._$_rolloffFactor$_ = s[10]), 
            this._$_lastAIState$_ = [], this._$_lastFxState$_ = [], this._$_lastAnalysersData$_ = [], 
            this._$AddDOMMessageHandlers$_([ [ "state", t => this._$_OnUpdateState$_(t) ], [ "audiocontext-state", t => this._$_OnAudioContextStateChanged$_(t) ], [ "fxstate", t => this._$_OnUpdateFxState$_(t) ], [ "trigger", t => this._$_OnTrigger$_(t) ], [ "buffer-metadata", t => this._$_OnBufferMetadata$_(t) ] ]);
            const e = this._$GetRuntime$_()._$Dispatcher$_(), h = (this._$_disposables$_ = new ol._$CompositeDisposable$_(ol._$Disposable$_._$From$_(e, "instancedestroy", t => this._$_OnInstanceDestroyed$_(t._$instance$_)), ol._$Disposable$_._$From$_(e, "afterload", () => this._$_OnAfterLoad$_()), ol._$Disposable$_._$From$_(e, "suspend", () => this._$_OnSuspend$_()), ol._$Disposable$_._$From$_(e, "resume", () => this._$_OnResume$_())), 
            "Safari" === ol._$Platform$_._$Browser$_), r = this._$_runtime$_._$IsiOSWebView$_(), n = this._$_runtime$_._$GetAssetManager$_()._$IsFileProtocol$_(), o = "playable-ad-single-file" === this._$_runtime$_._$GetExportType$_(), a = h || r || n || o;
            this._$_runtime$_._$AddLoadPromise$_(this._$PostToDOMAsync$_("create-audio-context", {
                preloadList: this._$_runtime$_._$GetAssetManager$_()._$GetAudioToPreload$_().map(t => ({
                    originalUrl: t.originalUrl,
                    url: t.url,
                    type: t.type,
                    fileSize: t.fileSize
                })),
                timeScaleMode: this._$_timeScaleMode$_,
                latencyHint: i,
                panningModel: this._$_panningModel$_,
                distanceModel: this._$_distanceModel$_,
                refDistance: this._$_referenceDistance$_,
                maxDistance: this._$_maxDistance$_,
                rolloffFactor: this._$_rolloffFactor$_,
                listenerPos: this._$_listenerPos$_,
                usePlayMusicAsSoundWorkaround: a
            }).then(t => {
                this._$_sampleRate$_ = t.sampleRate, this._$_audioContextState$_ = t.audioContextState, 
                this._$_outputLatency$_ = t.outputLatency;
            })), this._$_StartTicking$_();
        }
        _$Release$_() {
            this._$_listenerInst$_ = null, super._$Release$_();
        }
        _$_SplitTags$_(t) {
            return this._$_enableMultiTags$_ ? t.split(" ").filter(t => !!t) : t ? [ t ] : [];
        }
        _$_MatchTagLists$_(s, t) {
            for (const i of t) {
                let t = !1;
                for (const e of s) if (ol._$equalsNoCase$_(e, i)) {
                    t = !0;
                    break;
                }
                if (!t) return !1;
            }
            return !0;
        }
        _$_MatchTagListToStr$_(t, s) {
            return this._$_MatchTagLists$_(t, this._$_SplitTags$_(s));
        }
        _$_AddActionPromise$_(t) {
            this._$GetPlugin$_()._$_AddActionPromise$_(t);
        }
        _$_OnInstanceDestroyed$_(t) {
            this._$_listenerInst$_ === t && (this._$_listenerInst$_ = null);
        }
        _$DbToLinearNoCap$_(t) {
            return Math.pow(10, t / 20);
        }
        _$DbToLinear$_(t) {
            const s = this._$DbToLinearNoCap$_(t);
            return isFinite(s) ? Math.max(Math.min(s, 1), 0) : 0;
        }
        _$LinearToDbNoCap$_(t) {
            return Math.log(t) / Math.log(10) * 20;
        }
        _$LinearToDb$_(t) {
            return this._$LinearToDbNoCap$_(Math.max(Math.min(t, 1), 0));
        }
        _$_OnSuspend$_() {
            this._$_playInBackground$_ || this._$PostToDOM$_("set-suspended", {
                isSuspended: !0
            });
        }
        _$_OnResume$_() {
            this._$_playInBackground$_ || this._$PostToDOM$_("set-suspended", {
                isSuspended: !1
            });
        }
        _$_OnUpdateState$_(t) {
            const s = t.tickCount, i = (this._$_outputLatency$_ = t.outputLatency, 
            this._$_lastAIState$_.filter(t => t.hasOwnProperty("placeholder") && (t.placeholder > s || -1 === t.placeholder)));
            this._$_lastAIState$_ = t.audioInstances, this._$_lastAnalysersData$_ = t.analysers, 
            0 < i.length && ol._$appendArray$_(this._$_lastAIState$_, i);
        }
        _$_OnBufferMetadata$_(t) {
            this._$_bufferMetadata$_.set(t.originalUrl, {
                duration: t.duration
            });
        }
        _$_OnAudioContextStateChanged$_(t) {
            this._$_audioContextState$_ = t.audioContextState;
        }
        _$GetAudioContextState$_() {
            return this._$_runtime$_._$IsExportToVideo$_() ? "running" : this._$_audioContextState$_;
        }
        _$_OnUpdateFxState$_(t) {
            this._$_lastFxState$_ = t.fxstate;
        }
        _$_GetFirstAudioStateByTags$_(t) {
            const s = this._$_SplitTags$_(t);
            for (const i of this._$_lastAIState$_) if (this._$_MatchTagLists$_(i.tags, s)) return i;
            return null;
        }
        _$_IsTagPlaying$_(t) {
            const s = this._$_SplitTags$_(t);
            return this._$_lastAIState$_.some(t => this._$_MatchTagLists$_(t.tags, s) && t.isPlaying);
        }
        _$_MaybeMarkAsPlaying$_(t, s, i, e, h) {
            if (this._$_IsTagPlaying$_(s)) return null;
            const r = this._$_bufferMetadata$_.get(t), n = {
                tags: this._$_SplitTags$_(s),
                duration: r ? r.duration : 0,
                volume: h,
                isPlaying: !0,
                playbackTime: 0,
                playbackRate: 1,
                uid: -1,
                bufferOriginalUrl: t,
                bufferUrl: "",
                bufferType: "",
                isMusic: i,
                isLooping: e,
                isMuted: !1,
                resumePosition: 0,
                pan: null,
                placeholder: -1
            };
            return this._$_lastAIState$_.push(n), n;
        }
        _$_MaybeMarkAsStopped$_(t) {
            const s = this._$_SplitTags$_(t);
            for (const i of this._$_lastAIState$_) this._$_MatchTagLists$_(i.tags, s) && (i.isPlaying = !1);
        }
        async _$_OnTrigger$_(t) {
            const s = t.type, i = (this._$_triggerTags$_ = t.tags, t.aiid);
            if ("ended" === s) {
                for (const e of this._$_lastAIState$_) if (e.aiid === i) {
                    e.isPlaying = !1;
                    break;
                }
                await this._$TriggerAsync$_(ol._$Plugins$_.Audio._$Cnds$_._$OnEnded$_);
            } else "fade-ended" === s && await this._$TriggerAsync$_(ol._$Plugins$_.Audio._$Cnds$_._$OnFadeEnded$_);
        }
        _$_MatchTriggerTag$_(t) {
            return this._$_MatchTagListToStr$_(this._$_triggerTags$_, t);
        }
        _$Tick$_() {
            const t = {
                timeScale: this._$_runtime$_._$GetTimeScale$_(),
                gameTime: this._$_runtime$_._$GetGameTimeRaw$_(),
                instPans: this._$GetInstancePans$_(),
                tickCount: this._$_runtime$_._$GetTickCountNoSave$_()
            };
            if (this._$_listenerInst$_) {
                const s = this._$_listenerInst$_._$GetWorldInfo$_();
                this._$_listenerPos$_[0] = s._$GetX$_(), this._$_listenerPos$_[1] = s._$GetY$_(), 
                t.listenerPos = this._$_listenerPos$_, t.listenerOrientation = [ ...this._$_listenerForwardVec$_, ...this._$_listenerUpVec$_ ];
            }
            this._$PostToDOM$_("tick", t);
        }
        _$rotatePtAround$_(t, s, i, e, h) {
            if (0 !== i) {
                const r = Math.sin(i), n = Math.cos(i), o = (t -= e) * r, a = (s -= h) * r, l = t * n, u = s * n;
                t = l - a, s = u + o, t += e, s += h;
            }
            return [ t, s ];
        }
        _$GetInstancePans$_() {
            return this._$_lastAIState$_.filter(t => -1 !== t.uid).map(t => this._$_runtime$_._$GetInstanceByUID$_(t.uid)).filter(t => t).map(t => {
                const s = t._$GetWorldInfo$_(), i = s._$GetLayer$_()._$GetAngle$_(), [ e, h ] = this._$rotatePtAround$_(s._$GetX$_(), s._$GetY$_(), -i, this._$_listenerPos$_[0], this._$_listenerPos$_[1]);
                return {
                    uid: t._$GetUID$_(),
                    x: e,
                    y: h,
                    z: s._$GetTotalZElevation$_(),
                    angle: s._$GetAngle$_() - i
                };
            });
        }
        _$GetAnalyserData$_(t, s) {
            for (const i of this._$_lastAnalysersData$_) if (i.index === s && ol._$equalsNoCase$_(i.tag, t)) return i;
            return null;
        }
        _$_IncrementEffectCount$_(t) {
            for (const s of this._$_SplitTags$_(t)) {
                const i = s.toLowerCase();
                this._$_effectCount$_.set(i, (this._$_effectCount$_.get(i) || 0) + 1);
            }
        }
        _$_IsSilent$_() {
            return this._$_isSilent$_;
        }
        _$_SetSilent$_(t) {
            this._$_isSilent$_ !== (t = !!t) && (this._$_isSilent$_ = t, this._$PostToDOM$_("set-silent", {
                isSilent: t
            }));
        }
        _$_GetMasterVolume$_() {
            return this._$_masterVolume$_;
        }
        _$_SetMasterVolume$_(t) {
            this._$_masterVolume$_ !== t && (this._$_masterVolume$_ = t, this._$PostToDOM$_("set-master-volume", {
                vol: t
            }));
        }
        _$_StopAll$_() {
            this._$PostToDOM$_("stop-all");
            for (const t of this._$_lastAIState$_) t.isPlaying = !1;
        }
        _$_ShouldSave$_(t) {
            return !t.hasOwnProperty("placeholder") && 3 !== this._$_saveLoadMode$_ && !(t.isMusic && 1 === this._$_saveLoadMode$_ || !t.isMusic && 2 === this._$_saveLoadMode$_);
        }
        _$SaveToJson$_() {
            return {
                isSilent: this._$_isSilent$_,
                masterVolume: this._$_masterVolume$_,
                listenerZ: this._$_listenerPos$_[2],
                listenerForwardVec: this._$_listenerForwardVec$_,
                listenerUpVec: this._$_listenerUpVec$_,
                listenerUid: this._$_listenerInst$_ ? this._$_listenerInst$_._$GetUID$_() : -1,
                remoteUrls: [ ...this._$_remoteUrls$_.entries() ],
                playing: this._$_lastAIState$_.filter(t => this._$_ShouldSave$_(t)),
                effects: this._$_lastFxState$_,
                analysers: this._$_lastAnalysersData$_
            };
        }
        _$LoadFromJson$_(t) {
            if (this._$_isSilent$_ = t.isSilent, this._$_masterVolume$_ = t.masterVolume, 
            this._$_listenerPos$_[2] = t.listenerZ, this._$_listenerInst$_ = null, 
            this._$_loadListenerUid$_ = t.listenerUid, t.hasOwnProperty("listenerForwardVec") ? this._$_listenerForwardVec$_ = t.listenerForwardVec : this._$_listenerForwardVec$_ = [ 0, 0, -1 ], 
            t.hasOwnProperty("listenerUpVec") ? this._$_listenerUpVec$_ = t.listenerUpVec : this._$_listenerUpVec$_ = [ 0, 1, 0 ], 
            this._$_remoteUrls$_.clear(), t.remoteUrls) for (const [ s, i ] of t.remoteUrls) this._$_remoteUrls$_.set(s, i);
            this._$_lastAIState$_ = t.playing;
            for (const e of this._$_lastAIState$_) e.hasOwnProperty("tag") && !e.hasOwnProperty("tags") && (e.tags = [ e.tag ].filter(t => !!t));
            this._$_lastFxState$_ = t.effects, this._$_lastAnalysersData$_ = t.analysers;
        }
        _$_OnAfterLoad$_() {
            if (-1 !== this._$_loadListenerUid$_ && (this._$_listenerInst$_ = this._$_runtime$_._$GetInstanceByUID$_(this._$_loadListenerUid$_), 
            this._$_loadListenerUid$_ = -1, this._$_listenerInst$_)) {
                const t = this._$_listenerInst$_._$GetWorldInfo$_();
                this._$_listenerPos$_[0] = t._$GetX$_(), this._$_listenerPos$_[1] = t._$GetY$_();
            }
            for (const s of this._$_lastAIState$_) {
                const i = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(s.bufferOriginalUrl);
                i ? (s.bufferUrl = i.url, s.bufferType = i.type) : s.bufferUrl = null;
            }
            for (const e of Object.values(this._$_lastFxState$_)) for (const h of e) if (h.hasOwnProperty("bufferOriginalUrl")) {
                const r = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(h.bufferOriginalUrl);
                r && (h.bufferUrl = r.url, h.bufferType = r.type);
            }
            this._$PostToDOM$_("load-state", {
                saveLoadMode: this._$_saveLoadMode$_,
                timeScale: this._$_runtime$_._$GetTimeScale$_(),
                gameTime: this._$_runtime$_._$GetGameTimeRaw$_(),
                listenerPos: this._$_listenerPos$_,
                listenerOrientation: [ ...this._$_listenerForwardVec$_, ...this._$_listenerUpVec$_ ],
                isSilent: this._$_isSilent$_,
                masterVolume: this._$_masterVolume$_,
                playing: this._$_lastAIState$_.filter(t => null !== t.bufferUrl),
                effects: this._$_lastFxState$_
            });
        }
        _$GetDebuggerProperties$_() {
            const t = [];
            for (const [ i, e ] of Object.entries(this._$_lastFxState$_)) t.push({
                name: "$" + i,
                value: e.map(t => t.type).join(", ")
            });
            const s = "plugins.audio.debugger";
            return [ {
                title: s + ".tag-effects",
                properties: t
            }, {
                title: s + ".currently-playing",
                properties: [ {
                    name: s + ".currently-playing-count",
                    value: this._$_lastAIState$_.length
                }, ...this._$_lastAIState$_.map((t, s) => ({
                    name: "$#" + s,
                    value: `${t.bufferOriginalUrl} ("${t.tags}") ${Math.round(10 * t.playbackTime) / 10} / ` + Math.round(10 * t.duration) / 10
                })) ]
            } ];
        }
    };
}

{
    const ll = self._$C3$_;
    ll._$Plugins$_.Audio._$Cnds$_ = {
        _$OnEnded$_(t) {
            return this._$_MatchTriggerTag$_(t);
        },
        _$OnFadeEnded$_(t) {
            return this._$_MatchTriggerTag$_(t);
        },
        _$PreloadsComplete$_() {
            return this._$_preloadCount$_ === this._$_preloadTotal$_;
        },
        _$AdvancedAudioSupported$_() {
            return !0;
        },
        _$IsSilent$_() {
            return this._$_IsSilent$_();
        },
        _$IsAnyPlaying$_() {
            for (const t of this._$_lastAIState$_) if (t.isPlaying) return !0;
            return !1;
        },
        _$IsTagPlaying$_(t) {
            return this._$_IsTagPlaying$_(t);
        }
    };
}

{
    const ul = self._$C3$_, cl = [ "lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "peaking", "notch", "allpass" ];
    ul._$Plugins$_.Audio._$Acts$_ = {
        Play(t, s, i, e, h) {
            const r = ul._$Plugins$_.Audio._$Acts$_._$_DoPlay$_.call(this, t, s, i, e, h);
            return this._$_AddActionPromise$_(r), r;
        },
        _$PlayFromTimeline$_(t, s, i, e) {
            ul._$Plugins$_.Audio._$Acts$_._$_DoPlay$_.call(this, t, 0, s, 0, i, e);
        },
        async _$_DoPlay$_(t, s, i, e, h, r) {
            if (!this._$_isSilent$_) {
                const n = t[1], o = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(t[0]);
                if (o) {
                    const a = this._$_nextPlayTime$_, l = (this._$_nextPlayTime$_ = 0, 
                    this._$_MaybeMarkAsPlaying$_(t[0], h, n, 0 !== s, this._$DbToLinear$_(i)));
                    try {
                        await this._$PostToDOMAsync$_("play", {
                            originalUrl: t[0],
                            url: o.url,
                            type: o.type,
                            isMusic: n,
                            tags: this._$_SplitTags$_(h),
                            isLooping: 0 !== s,
                            vol: this._$DbToLinear$_(i),
                            stereoPan: ul._$clamp$_(e / 100, -1, 1),
                            pos: r || 0,
                            off: a,
                            trueClock: !!self.C3_GetAudioContextCurrentTime
                        });
                    } finally {
                        l && (l.placeholder = this._$_runtime$_._$GetTickCountNoSave$_());
                    }
                }
            }
        },
        async _$PlayAtPosition$_(t, s, i, e, h, r, n, o, a, l, u) {
            if (!this._$_isSilent$_) {
                const c = t[1], f = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(t[0]);
                if (f) {
                    const d = this._$_nextPlayTime$_, p = (this._$_nextPlayTime$_ = 0, 
                    this._$_MaybeMarkAsPlaying$_(t[0], u, c, 0 !== s, this._$DbToLinear$_(i)));
                    try {
                        await this._$PostToDOMAsync$_("play", {
                            originalUrl: t[0],
                            url: f.url,
                            type: f.type,
                            isMusic: c,
                            tags: this._$_SplitTags$_(u),
                            isLooping: 0 !== s,
                            vol: this._$DbToLinear$_(i),
                            pos: 0,
                            off: d,
                            trueClock: !!self.C3_GetAudioContextCurrentTime,
                            panning: {
                                x: e,
                                y: h,
                                z: r,
                                angle: ul._$toRadians$_(n),
                                innerAngle: ul._$toRadians$_(o),
                                outerAngle: ul._$toRadians$_(a),
                                outerGain: this._$DbToLinear$_(l)
                            }
                        });
                    } finally {
                        p && (p.placeholder = this._$_runtime$_._$GetTickCountNoSave$_());
                    }
                }
            }
        },
        async _$PlayAtObject$_(t, s, i, e, h, r, n, o) {
            if (!this._$_isSilent$_ && e) {
                const a = e._$GetFirstPicked$_();
                if (a && a._$GetWorldInfo$_()) {
                    const l = a._$GetWorldInfo$_(), u = l._$GetLayer$_()._$GetAngle$_(), [ c, f ] = this._$rotatePtAround$_(l._$GetX$_(), l._$GetY$_(), -u, this._$_listenerPos$_[0], this._$_listenerPos$_[1]), d = t[1], p = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(t[0]);
                    if (p) {
                        const m = this._$_nextPlayTime$_, g = (this._$_nextPlayTime$_ = 0, 
                        this._$_MaybeMarkAsPlaying$_(t[0], o, d, 0 !== s, this._$DbToLinear$_(i)));
                        try {
                            await this._$PostToDOMAsync$_("play", {
                                originalUrl: t[0],
                                url: p.url,
                                type: p.type,
                                isMusic: d,
                                tags: this._$_SplitTags$_(o),
                                isLooping: 0 !== s,
                                vol: this._$DbToLinear$_(i),
                                pos: 0,
                                off: m,
                                trueClock: !!self.C3_GetAudioContextCurrentTime,
                                panning: {
                                    x: c,
                                    y: f,
                                    z: l._$GetTotalZElevation$_(),
                                    angle: l._$GetAngle$_() - u,
                                    innerAngle: ul._$toRadians$_(h),
                                    outerAngle: ul._$toRadians$_(r),
                                    outerGain: this._$DbToLinear$_(n),
                                    uid: a._$GetUID$_()
                                }
                            });
                        } finally {
                            g && (g.placeholder = this._$_runtime$_._$GetTickCountNoSave$_());
                        }
                    }
                }
            }
        },
        async _$PlayByName$_(t, s, i, e, h, r) {
            if (!this._$_isSilent$_) {
                const n = 1 === t, o = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(s) || this._$_remoteUrls$_.get(s.toLowerCase());
                if (o) {
                    const a = this._$_nextPlayTime$_, l = (this._$_nextPlayTime$_ = 0, 
                    this._$_MaybeMarkAsPlaying$_(s, r, n, 0 !== i, this._$DbToLinear$_(e)));
                    try {
                        await this._$PostToDOMAsync$_("play", {
                            originalUrl: s,
                            url: o.url,
                            type: o.type,
                            isMusic: n,
                            tags: this._$_SplitTags$_(r),
                            isLooping: 0 !== i,
                            vol: this._$DbToLinear$_(e),
                            stereoPan: ul._$clamp$_(h / 100, -1, 1),
                            pos: 0,
                            off: a,
                            trueClock: !!self.C3_GetAudioContextCurrentTime
                        });
                    } finally {
                        l && (l.placeholder = this._$_runtime$_._$GetTickCountNoSave$_());
                    }
                }
            }
        },
        async _$PlayAtPositionByName$_(t, s, i, e, h, r, n, o, a, l, u, c) {
            if (!this._$_isSilent$_) {
                const f = 1 === t, d = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(s) || this._$_remoteUrls$_.get(s.toLowerCase());
                if (d) {
                    const p = this._$_nextPlayTime$_, m = (this._$_nextPlayTime$_ = 0, 
                    this._$_MaybeMarkAsPlaying$_(s, c, f, 0 !== i, this._$DbToLinear$_(e)));
                    try {
                        await this._$PostToDOMAsync$_("play", {
                            originalUrl: s,
                            url: d.url,
                            type: d.type,
                            isMusic: f,
                            tags: this._$_SplitTags$_(c),
                            isLooping: 0 !== i,
                            vol: this._$DbToLinear$_(e),
                            pos: 0,
                            off: p,
                            trueClock: !!self.C3_GetAudioContextCurrentTime,
                            panning: {
                                x: h,
                                y: r,
                                z: n,
                                angle: ul._$toRadians$_(o),
                                innerAngle: ul._$toRadians$_(a),
                                outerAngle: ul._$toRadians$_(l),
                                outerGain: this._$DbToLinear$_(u)
                            }
                        });
                    } finally {
                        m && (m.placeholder = this._$_runtime$_._$GetTickCountNoSave$_());
                    }
                }
            }
        },
        async _$PlayAtObjectByName$_(t, s, i, e, h, r, n, o, a) {
            if (!this._$_isSilent$_ && !this._$_isSilent$_ && h) {
                const l = h._$GetFirstPicked$_();
                if (l && l._$GetWorldInfo$_()) {
                    const u = l._$GetWorldInfo$_(), c = u._$GetLayer$_()._$GetAngle$_(), [ f, d ] = this._$rotatePtAround$_(u._$GetX$_(), u._$GetY$_(), -c, this._$_listenerPos$_[0], this._$_listenerPos$_[1]), p = 1 === t, m = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(s) || this._$_remoteUrls$_.get(s.toLowerCase());
                    if (m) {
                        const g = this._$_nextPlayTime$_, y = (this._$_nextPlayTime$_ = 0, 
                        this._$_MaybeMarkAsPlaying$_(s, a, p, 0 !== i, this._$DbToLinear$_(e)));
                        try {
                            await this._$PostToDOMAsync$_("play", {
                                originalUrl: s,
                                url: m.url,
                                type: m.type,
                                isMusic: p,
                                tags: this._$_SplitTags$_(a),
                                isLooping: 0 !== i,
                                vol: this._$DbToLinear$_(e),
                                pos: 0,
                                off: g,
                                trueClock: !!self.C3_GetAudioContextCurrentTime,
                                panning: {
                                    x: f,
                                    y: d,
                                    z: u._$GetTotalZElevation$_(),
                                    angle: u._$GetAngle$_() - c,
                                    innerAngle: ul._$toRadians$_(r),
                                    outerAngle: ul._$toRadians$_(n),
                                    outerGain: this._$DbToLinear$_(o),
                                    uid: l._$GetUID$_()
                                }
                            });
                        } finally {
                            y && (y.placeholder = this._$_runtime$_._$GetTickCountNoSave$_());
                        }
                    }
                }
            }
        },
        _$SetLooping$_(t, s) {
            this._$PostToDOM$_("set-looping", {
                tags: this._$_SplitTags$_(t),
                isLooping: 0 === s
            });
        },
        _$SetMuted$_(t, s) {
            this._$PostToDOM$_("set-muted", {
                tags: this._$_SplitTags$_(t),
                isMuted: 0 === s
            });
        },
        _$SetVolume$_(t, s) {
            this._$PostToDOM$_("set-volume", {
                tags: this._$_SplitTags$_(t),
                vol: this._$DbToLinear$_(s)
            });
        },
        _$FadeVolume$_(t, s, i, e) {
            this._$PostToDOM$_("fade-volume", {
                tags: this._$_SplitTags$_(t),
                vol: this._$DbToLinear$_(s),
                duration: i,
                stopOnEnd: 0 === e
            });
        },
        _$SetStereoPan$_(t, s) {
            this._$PostToDOM$_("set-stereo-pan", {
                tags: this._$_SplitTags$_(t),
                p: ul._$clamp$_(s / 100, -1, 1)
            });
        },
        async _$Preload$_(t) {
            const s = t[1], i = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(t[0]);
            i && (this._$_preloadTotal$_++, await this._$PostToDOMAsync$_("preload", {
                originalUrl: t[0],
                url: i.url,
                type: i.type,
                isMusic: s
            }), this._$_preloadCount$_++);
        },
        async _$PreloadByName$_(t, s) {
            const i = 1 === t, e = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(s) || this._$_remoteUrls$_.get(s.toLowerCase());
            e && (this._$_preloadTotal$_++, await this._$PostToDOMAsync$_("preload", {
                originalUrl: s,
                url: e.url,
                type: e.type,
                isMusic: i
            }), this._$_preloadCount$_++);
        },
        _$SetPlaybackRate$_(t, s) {
            this._$PostToDOM$_("set-playback-rate", {
                tags: this._$_SplitTags$_(t),
                rate: Math.max(s, 0)
            });
        },
        _$Stop$_(t) {
            this._$_MaybeMarkAsStopped$_(t), this._$PostToDOM$_("stop", {
                tags: this._$_SplitTags$_(t)
            });
        },
        _$StopAll$_() {
            this._$_StopAll$_();
        },
        _$SetPaused$_(t, s) {
            this._$PostToDOM$_("set-paused", {
                tags: this._$_SplitTags$_(t),
                paused: 0 === s
            });
        },
        _$Seek$_(t, s) {
            this._$PostToDOM$_("seek", {
                tags: this._$_SplitTags$_(t),
                pos: s
            });
        },
        _$SetSilent$_(t) {
            2 === t && (t = this._$_IsSilent$_() ? 1 : 0), this._$_SetSilent$_(0 === t);
        },
        _$SetMasterVolume$_(t) {
            const s = this._$DbToLinear$_(t);
            this._$_SetMasterVolume$_(s);
        },
        _$AddFilterEffect$_(t, s, i, e, h, r, n) {
            const o = cl[s];
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "filter",
                tags: this._$_SplitTags$_(t),
                params: [ o, i, e, h, r, ul._$clamp$_(n / 100, 0, 1) ]
            });
        },
        _$AddDelayEffect$_(t, s, i, e) {
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "delay",
                tags: this._$_SplitTags$_(t),
                params: [ s, this._$DbToLinear$_(i), ul._$clamp$_(e / 100, 0, 1) ]
            });
        },
        _$AddFlangerEffect$_(t, s, i, e, h, r) {
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "flanger",
                tags: this._$_SplitTags$_(t),
                params: [ s / 1e3, i / 1e3, e, h / 100, ul._$clamp$_(r / 100, 0, 1) ]
            });
        },
        _$AddPhaserEffect$_(t, s, i, e, h, r, n) {
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "phaser",
                tags: this._$_SplitTags$_(t),
                params: [ s, i, e, h, r, ul._$clamp$_(n / 100, 0, 1) ]
            });
        },
        _$AddConvolutionEffect$_(t, s, i, e) {
            const h = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(s[0]);
            h && (this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "convolution",
                tags: this._$_SplitTags$_(t),
                bufferOriginalUrl: s[0],
                bufferUrl: h.url,
                bufferType: h.type,
                params: [ 0 === i, ul._$clamp$_(e / 100, 0, 1) ]
            }));
        },
        _$AddGainEffect$_(t, s) {
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "gain",
                tags: this._$_SplitTags$_(t),
                params: [ this._$DbToLinear$_(s) ]
            });
        },
        _$AddStereoPanEffect$_(t, s) {
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "stereopan",
                tags: this._$_SplitTags$_(t),
                params: [ ul._$clamp$_(s / 100, -1, 1) ]
            });
        },
        _$AddMuteEffect$_(t) {
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "gain",
                tags: this._$_SplitTags$_(t),
                params: [ 0 ]
            });
        },
        _$AddTremoloEffect$_(t, s, i) {
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "tremolo",
                tags: this._$_SplitTags$_(t),
                params: [ s, ul._$clamp$_(i / 100, 0, 1) ]
            });
        },
        _$AddRingModEffect$_(t, s, i) {
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "ringmod",
                tags: this._$_SplitTags$_(t),
                params: [ s, ul._$clamp$_(i / 100, 0, 1) ]
            });
        },
        _$AddDistortionEffect$_(t, s, i, e, h, r) {
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "distortion",
                tags: this._$_SplitTags$_(t),
                params: [ this._$DbToLinearNoCap$_(s), this._$DbToLinearNoCap$_(i), e, this._$DbToLinearNoCap$_(h), ul._$clamp$_(r / 100, 0, 1) ]
            });
        },
        _$AddCompressorEffect$_(t, s, i, e, h, r) {
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "compressor",
                tags: this._$_SplitTags$_(t),
                params: [ s, i, e, h / 1e3, r / 1e3 ]
            });
        },
        _$AddAnalyserEffect$_(t, s, i) {
            this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                type: "analyser",
                tags: this._$_SplitTags$_(t),
                params: [ s, i ]
            });
        },
        _$RemoveEffects$_(t) {
            const s = this._$_SplitTags$_(t);
            for (const i of s) this._$_effectCount$_.set(i.toLowerCase(), 0);
            this._$PostToDOM$_("remove-effects", {
                tags: s
            }), this._$_lastFxState$_ = {};
        },
        _$SetEffectParameter$_(t, s, i, e, h, r) {
            this._$PostToDOM$_("set-effect-param", {
                tags: this._$_SplitTags$_(t),
                index: Math.floor(s),
                param: i,
                value: e,
                ramp: h,
                time: r
            });
        },
        _$SetListenerObject$_(t) {
            if (t) {
                const s = t._$GetFirstPicked$_();
                s && s._$GetWorldInfo$_() && (this._$_listenerInst$_ = s);
            }
        },
        _$SetListenerZ$_(t) {
            this._$_listenerPos$_[2] = t;
        },
        _$SetListenerOrientation$_(t, s, i, e, h, r) {
            this._$_listenerForwardVec$_[0] = t, this._$_listenerForwardVec$_[1] = s, 
            this._$_listenerForwardVec$_[2] = -i, this._$_listenerUpVec$_[0] = e, 
            this._$_listenerUpVec$_[1] = h, this._$_listenerUpVec$_[2] = -r;
        },
        _$ScheduleNextPlay$_(t) {
            this._$_nextPlayTime$_ = Math.max(t, 0);
        },
        _$UnloadAudio$_(t) {
            const s = t[1], i = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(t[0]);
            i && this._$PostToDOM$_("unload", {
                url: i.url,
                type: i.type,
                isMusic: s
            });
        },
        _$UnloadAudioByName$_(t, s) {
            const i = 1 === t, e = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(s) || this._$_remoteUrls$_.get(s.toLowerCase());
            e && this._$PostToDOM$_("unload", {
                url: e.url,
                type: e.type,
                isMusic: i
            });
        },
        _$UnloadAll$_() {
            this._$PostToDOM$_("unload-all");
        },
        _$AddRemoteURL$_(t, s, i) {
            this._$_remoteUrls$_.set(i.toLowerCase(), {
                url: t,
                type: s
            });
        }
    };
}

{
    const fl = self._$C3$_;
    fl._$Plugins$_.Audio._$Exps$_ = {
        _$Duration$_(t) {
            const s = this._$_GetFirstAudioStateByTags$_(t);
            return s ? s.duration : 0;
        },
        _$PlaybackTime$_(t) {
            const s = this._$_GetFirstAudioStateByTags$_(t);
            return s ? s.playbackTime : 0;
        },
        _$PlaybackRate$_(t) {
            const s = this._$_GetFirstAudioStateByTags$_(t);
            return s ? s.playbackRate : 0;
        },
        _$Volume$_(t) {
            const s = this._$_GetFirstAudioStateByTags$_(t);
            return s ? this._$LinearToDb$_(s.volume) : 0;
        },
        _$MasterVolume$_() {
            return this._$LinearToDb$_(this._$_GetMasterVolume$_());
        },
        _$EffectCount$_(t) {
            return this._$_effectCount$_.get(t.toLowerCase()) || 0;
        },
        _$AnalyserFreqBinCount$_(t, s) {
            const i = this._$GetAnalyserData$_(t, Math.floor(s));
            return i ? i.binCount : 0;
        },
        _$AnalyserFreqBinAt$_(t, s, i) {
            const e = this._$GetAnalyserData$_(t, Math.floor(s));
            return !e || (i = Math.floor(i)) < 0 || i >= e.binCount ? 0 : e.freqBins[i];
        },
        _$AnalyserPeakLevel$_(t, s) {
            const i = this._$GetAnalyserData$_(t, Math.floor(s));
            return i ? i.peak : 0;
        },
        _$AnalyserRMSLevel$_(t, s) {
            const i = this._$GetAnalyserData$_(t, Math.floor(s));
            return i ? i.rms : 0;
        },
        _$SampleRate$_() {
            return this._$_sampleRate$_;
        },
        _$CurrentTime$_() {
            return self.C3_GetAudioContextCurrentTime ? self.C3_GetAudioContextCurrentTime() : performance.now() / 1e3;
        },
        _$OutputLatency$_() {
            return this._$_outputLatency$_;
        },
        _$NormalizedVolume$_(t, s) {
            return 0 === (t = fl._$clamp$_(+t, 0, 100) / 100) ? -1 / 0 : t < .1 ? this._$LinearToDb$_(fl._$lerp$_(0, this._$DbToLinear$_(s), 10 * t)) : fl._$lerp$_(s, 0, (t - .1) / .9);
        }
    };
}

{
    const dl = self._$C3$_;
    dl._$Plugins$_.Keyboard = class extends dl._$SDKPluginBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    let i = function() {
        return s._$GetSingleGlobalInstance$_()._$GetSdkInstance$_();
    };
    i;
    const pl = self._$C3$_;
    pl._$Plugins$_.Keyboard._$Type$_ = class extends pl._$SDKTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
        _$GetScriptInterfaceClass$_() {
            return self._$IKeyboardObjectType$_;
        }
    };
    let s = null;
    self._$IKeyboardObjectType$_ = class extends self._$IObjectClass$_ {
        constructor(t) {
            super(t), (s = t)._$GetRuntime$_()._$_GetCommonScriptInterfaces$_().keyboard = this;
        }
        _$isKeyDown$_(t) {
            const s = i();
            if ("string" == typeof t) return s._$IsKeyDown$_(t);
            if ("number" == typeof t) return s._$IsKeyCodeDown$_(t);
            throw new TypeError("expected string or number");
        }
    };
}

{
    const ml = self._$C3$_;
    ml._$Plugins$_.Keyboard.Instance = class extends ml._$SDKInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_keysDownByString$_ = new Set(), this._$_keysDownByWhich$_ = new Set(), 
            this._$_triggerWhich$_ = 0, this._$_triggerString$_ = "", this._$_triggerTypedKey$_ = "";
            const i = this._$GetRuntime$_()._$Dispatcher$_();
            this._$_disposables$_ = new ml._$CompositeDisposable$_(ml._$Disposable$_._$From$_(i, "keydown", t => this._$_OnKeyDown$_(t.data)), ml._$Disposable$_._$From$_(i, "keyup", t => this._$_OnKeyUp$_(t.data)), ml._$Disposable$_._$From$_(i, "window-blur", () => this._$_OnWindowOrKeyboardBlur$_()), ml._$Disposable$_._$From$_(i, "keyboard-blur", () => this._$_OnWindowOrKeyboardBlur$_()));
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$_OnKeyDown$_(t) {
            const s = t.which, i = t.code || s.toString(), e = t.key;
            this._$_keysDownByString$_.has(i) || (this._$_keysDownByString$_.add(i), 
            this._$_keysDownByWhich$_.add(s), this._$_triggerString$_ = i, this._$_triggerWhich$_ = s, 
            this._$_triggerTypedKey$_ = e, this._$Trigger$_(ml._$Plugins$_.Keyboard._$Cnds$_._$OnAnyKey$_), 
            this._$Trigger$_(ml._$Plugins$_.Keyboard._$Cnds$_._$OnKey$_), this._$Trigger$_(ml._$Plugins$_.Keyboard._$Cnds$_._$OnLeftRightKeyPressed$_), 
            this._$Trigger$_(ml._$Plugins$_.Keyboard._$Cnds$_._$OnKeyCode$_));
        }
        _$_OnKeyUp$_(t) {
            const s = t.which, i = t.code || s.toString(), e = t.key;
            this._$_keysDownByString$_.delete(i), this._$_keysDownByWhich$_.delete(s), 
            this._$_triggerString$_ = i, this._$_triggerWhich$_ = s, this._$_triggerTypedKey$_ = e, 
            this._$Trigger$_(ml._$Plugins$_.Keyboard._$Cnds$_._$OnAnyKeyReleased$_), 
            this._$Trigger$_(ml._$Plugins$_.Keyboard._$Cnds$_._$OnKeyReleased$_), 
            this._$Trigger$_(ml._$Plugins$_.Keyboard._$Cnds$_._$OnLeftRightKeyReleased$_), 
            this._$Trigger$_(ml._$Plugins$_.Keyboard._$Cnds$_._$OnKeyCodeReleased$_);
        }
        _$_OnWindowOrKeyboardBlur$_() {
            for (const t of this._$_keysDownByWhich$_) this._$_keysDownByWhich$_.delete(t), 
            this._$_triggerWhich$_ = t, this._$Trigger$_(ml._$Plugins$_.Keyboard._$Cnds$_._$OnAnyKeyReleased$_), 
            this._$Trigger$_(ml._$Plugins$_.Keyboard._$Cnds$_._$OnKeyReleased$_), 
            this._$Trigger$_(ml._$Plugins$_.Keyboard._$Cnds$_._$OnKeyCodeReleased$_);
            this._$_keysDownByString$_.clear();
        }
        _$IsKeyDown$_(t) {
            return this._$_keysDownByString$_.has(t);
        }
        _$IsKeyCodeDown$_(t) {
            return this._$_keysDownByWhich$_.has(t);
        }
        _$SaveToJson$_() {
            return {
                tk: this._$_triggerWhich$_,
                tkk: this._$_triggerTypedKey$_
            };
        }
        _$LoadFromJson$_(t) {
            this._$_triggerWhich$_ = t.tk, t.hasOwnProperty("tkk") && (this._$_triggerTypedKey$_ = t.tkk);
        }
        _$GetDebuggerProperties$_() {
            const t = "plugins.keyboard";
            return [ {
                title: t + ".name",
                properties: [ {
                    name: t + ".debugger.last-key-code",
                    value: this._$_triggerWhich$_
                }, {
                    name: t + ".debugger.last-key-string",
                    value: ml._$Plugins$_.Keyboard._$Exps$_._$StringFromKeyCode$_(this._$_triggerWhich$_)
                }, {
                    name: t + ".debugger.last-typed-key",
                    value: this._$_triggerTypedKey$_
                } ]
            } ];
        }
    };
}

{
    const gl = self._$C3$_, yl = [ "ShiftLeft", "ShiftRight", "ControlLeft", "ControlRight", "AltLeft", "AltRight", "MetaLeft", "MetaRight" ];
    gl._$Plugins$_.Keyboard._$Cnds$_ = {
        _$IsKeyDown$_(t) {
            return this._$_keysDownByWhich$_.has(t);
        },
        _$OnKey$_(t) {
            return this._$_triggerWhich$_ === t;
        },
        _$OnAnyKey$_() {
            return !0;
        },
        _$OnAnyKeyReleased$_() {
            return !0;
        },
        _$OnKeyReleased$_(t) {
            return this._$_triggerWhich$_ === t;
        },
        _$IsKeyCodeDown$_(t) {
            return t = Math.floor(t), this._$_keysDownByWhich$_.has(t);
        },
        _$OnKeyCode$_(t) {
            return this._$_triggerWhich$_ === t;
        },
        _$OnKeyCodeReleased$_(t) {
            return this._$_triggerWhich$_ === t;
        },
        _$OnLeftRightKeyPressed$_(t) {
            const s = yl[t];
            return this._$_triggerString$_ === s;
        },
        _$OnLeftRightKeyReleased$_(t) {
            const s = yl[t];
            return this._$_triggerString$_ === s;
        },
        _$IsLeftRightKeyDown$_(t) {
            const s = yl[t];
            return this._$_keysDownByString$_.has(s);
        }
    };
}

{
    const wl = self._$C3$_;
    wl._$Plugins$_.Keyboard._$Acts$_ = {};
}

{
    let s = function(t) {
        switch (t = Math.floor(t)) {
          case 8:
            return "backspace";

          case 9:
            return "tab";

          case 13:
            return "enter";

          case 16:
            return "shift";

          case 17:
            return "control";

          case 18:
            return "alt";

          case 19:
            return "pause";

          case 20:
            return "capslock";

          case 27:
            return "esc";

          case 33:
            return "pageup";

          case 34:
            return "pagedown";

          case 35:
            return "end";

          case 36:
            return "home";

          case 37:
            return "";

          case 38:
            return "";

          case 39:
            return "";

          case 40:
            return "";

          case 45:
            return "insert";

          case 46:
            return "del";

          case 91:
            return "left window key";

          case 92:
            return "right window key";

          case 93:
            return "select";

          case 96:
            return "numpad 0";

          case 97:
            return "numpad 1";

          case 98:
            return "numpad 2";

          case 99:
            return "numpad 3";

          case 100:
            return "numpad 4";

          case 101:
            return "numpad 5";

          case 102:
            return "numpad 6";

          case 103:
            return "numpad 7";

          case 104:
            return "numpad 8";

          case 105:
            return "numpad 9";

          case 106:
            return "numpad *";

          case 107:
            return "numpad +";

          case 109:
            return "numpad -";

          case 110:
            return "numpad .";

          case 111:
            return "numpad /";

          case 112:
            return "F1";

          case 113:
            return "F2";

          case 114:
            return "F3";

          case 115:
            return "F4";

          case 116:
            return "F5";

          case 117:
            return "F6";

          case 118:
            return "F7";

          case 119:
            return "F8";

          case 120:
            return "F9";

          case 121:
            return "F10";

          case 122:
            return "F11";

          case 123:
            return "F12";

          case 144:
            return "numlock";

          case 145:
            return "scroll lock";

          case 186:
            return ";";

          case 187:
            return "=";

          case 188:
            return ",";

          case 189:
            return "-";

          case 190:
            return ".";

          case 191:
            return "/";

          case 192:
            return "'";

          case 219:
            return "[";

          case 220:
            return "\\";

          case 221:
            return "]";

          case 222:
            return "#";

          case 223:
            return "`";

          default:
            return String.fromCharCode(t);
        }
    };
    s;
    const Sl = self._$C3$_;
    Sl._$Plugins$_.Keyboard._$Exps$_ = {
        _$LastKeyCode$_() {
            return this._$_triggerWhich$_;
        },
        _$StringFromKeyCode$_(t) {
            return s(t);
        },
        _$TypedKey$_() {
            return this._$_triggerTypedKey$_;
        }
    };
}

{
    const bl = self._$C3$_;
    bl._$Plugins$_.Touch = class extends bl._$SDKPluginBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    let i = function() {
        return s._$GetSingleGlobalInstance$_()._$GetSdkInstance$_();
    };
    i;
    const Ml = self._$C3$_, vl = self._$C3X$_;
    Ml._$Plugins$_.Touch._$Type$_ = class extends Ml._$SDKTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
        _$GetScriptInterfaceClass$_() {
            return self._$ITouchObjectType$_;
        }
    };
    let s = null;
    self._$ITouchObjectType$_ = class extends self._$IObjectClass$_ {
        constructor(t) {
            super(t), (s = t)._$GetRuntime$_()._$_GetCommonScriptInterfaces$_()._$touch$_ = this;
        }
        requestPermission(t) {
            vl._$RequireString$_(t);
            const s = i();
            if ("orientation" === t) return s._$_RequestPermission$_(0);
            if ("motion" === t) return s._$_RequestPermission$_(1);
            throw new Error("invalid type");
        }
    };
}

{
    const I = self._$C3$_;
    I._$Plugins$_.Touch.Instance = class extends I._$SDKInstanceBase$_ {
        constructor(t, s) {
            super(t, "touch"), this._$_touches$_ = new Map(), this._$_useMouseInput$_ = !1, 
            this._$_isMouseDown$_ = !1, this._$_orientCompassHeading$_ = 0, this._$_orientAlpha$_ = 0, 
            this._$_orientBeta$_ = 0, this._$_orientGamma$_ = 0, this._$_accX$_ = 0, 
            this._$_accY$_ = 0, this._$_accZ$_ = 0, this._$_accWithGX$_ = 0, this._$_accWithGY$_ = 0, 
            this._$_accWithGZ$_ = 0, this._$_triggerIndex$_ = 0, this._$_triggerId$_ = 0, 
            this._$_triggerPermission$_ = 0, this._$_curTouchX$_ = 0, this._$_curTouchY$_ = 0, 
            this._$_getTouchIndex$_ = 0, this._$_triggerType$_ = 0, this._$_permissionPromises$_ = [], 
            s && (this._$_useMouseInput$_ = s[0]), this._$AddDOMMessageHandler$_("permission-result", t => this._$_OnPermissionResult$_(t));
            const i = this._$GetRuntime$_()._$Dispatcher$_();
            this._$_disposables$_ = new I._$CompositeDisposable$_(I._$Disposable$_._$From$_(i, "pointerdown", t => this._$_OnPointerDown$_(t.data)), I._$Disposable$_._$From$_(i, "pointermove", t => this._$_OnPointerMove$_(t.data)), I._$Disposable$_._$From$_(i, "pointerup", t => this._$_OnPointerUp$_(t.data, !1)), I._$Disposable$_._$From$_(i, "pointercancel", t => this._$_OnPointerUp$_(t.data, !0)), I._$Disposable$_._$From$_(i, "deviceorientation", t => this._$_OnDeviceOrientation$_(t.data)), I._$Disposable$_._$From$_(i, "deviceorientationabsolute", t => this._$_OnDeviceOrientationAbsolute$_(t.data)), I._$Disposable$_._$From$_(i, "devicemotion", t => this._$_OnDeviceMotion$_(t.data)), I._$Disposable$_._$From$_(i, "tick2", t => this._$_OnTick2$_()));
        }
        _$Release$_() {
            this._$_touches$_.clear(), super._$Release$_();
        }
        _$_OnPointerDown$_(t) {
            if ("mouse" === t.pointerType) {
                if (!this._$_useMouseInput$_) return;
                this._$_isMouseDown$_ = !0;
            }
            const s = t.pointerId;
            if (!this._$_touches$_.has(s)) {
                const i = t.pageX - this._$_runtime$_._$GetCanvasClientX$_(), e = t.pageY - this._$_runtime$_._$GetCanvasClientY$_(), h = performance.now(), r = this._$_touches$_.size, n = (this._$_triggerIndex$_ = r, 
                this._$_triggerId$_ = s, I._$New$_(I._$Plugins$_.Touch._$TouchInfo$_));
                n._$Init$_(h, i, e, s, r), this._$_touches$_.set(s, n), this._$Trigger$_(I._$Plugins$_.Touch._$Cnds$_._$OnNthTouchStart$_), 
                this._$Trigger$_(I._$Plugins$_.Touch._$Cnds$_._$OnTouchStart$_), 
                this._$_curTouchX$_ = i, this._$_curTouchY$_ = e, this._$_triggerType$_ = 0, 
                this._$Trigger$_(I._$Plugins$_.Touch._$Cnds$_._$OnTouchObject$_);
            }
        }
        _$_OnPointerMove$_(t) {
            if ("mouse" !== t.pointerType || this._$_isMouseDown$_) {
                const s = this._$_touches$_.get(t.pointerId);
                if (s) {
                    const i = performance.now();
                    if (!(i - s._$GetTime$_() < 2)) {
                        const e = t.pageX - this._$_runtime$_._$GetCanvasClientX$_(), h = t.pageY - this._$_runtime$_._$GetCanvasClientY$_();
                        s._$Update$_(i, e, h, t.width, t.height, t.pressure);
                    }
                }
            }
        }
        _$_OnPointerUp$_(t, s) {
            if ("mouse" === t.pointerType) {
                if (!this._$_isMouseDown$_) return;
                this._$_isMouseDown$_ = !1;
            }
            const i = performance.now(), e = t.pointerId, h = this._$_touches$_.get(e);
            if (h) {
                if (this._$_triggerIndex$_ = h._$GetStartIndex$_(), this._$_triggerId$_ = h._$GetId$_(), 
                !s) {
                    const r = t.pageX - this._$_runtime$_._$GetCanvasClientX$_(), n = t.pageY - this._$_runtime$_._$GetCanvasClientY$_();
                    this._$_curTouchX$_ = r, this._$_curTouchY$_ = n, this._$_triggerType$_ = 1, 
                    this._$Trigger$_(I._$Plugins$_.Touch._$Cnds$_._$OnTouchObject$_);
                }
                if (this._$Trigger$_(I._$Plugins$_.Touch._$Cnds$_._$OnNthTouchEnd$_), 
                this._$Trigger$_(I._$Plugins$_.Touch._$Cnds$_._$OnTouchEnd$_), !s) {
                    const o = h._$ShouldTriggerTap$_(i);
                    "single-tap" === o ? (this._$Trigger$_(I._$Plugins$_.Touch._$Cnds$_._$OnTapGesture$_), 
                    this._$_curTouchX$_ = h._$GetX$_(), this._$_curTouchY$_ = h._$GetY$_(), 
                    this._$Trigger$_(I._$Plugins$_.Touch._$Cnds$_._$OnTapGestureObject$_)) : "double-tap" === o && (this._$Trigger$_(I._$Plugins$_.Touch._$Cnds$_._$OnDoubleTapGesture$_), 
                    this._$_curTouchX$_ = h._$GetX$_(), this._$_curTouchY$_ = h._$GetY$_(), 
                    this._$Trigger$_(I._$Plugins$_.Touch._$Cnds$_._$OnDoubleTapGestureObject$_));
                }
                h._$Release$_(), this._$_touches$_.delete(e);
            }
        }
        _$_RequestPermission$_(i) {
            return this._$_PostToDOMMaybeSync$_("request-permission", {
                type: i
            }), new Promise((t, s) => {
                this._$_permissionPromises$_.push({
                    type: i,
                    resolve: t,
                    reject: s
                });
            });
        }
        _$_OnPermissionResult$_(t) {
            const s = t.result, i = t.type, e = (this._$_triggerPermission$_ = i, 
            this._$_permissionPromises$_.filter(t => t.type === i));
            for (const h of e) h.resolve(s ? "granted" : "denied");
            this._$_permissionPromises$_ = this._$_permissionPromises$_.filter(t => t.type !== i), 
            s ? (this._$Trigger$_(I._$Plugins$_.Touch._$Cnds$_._$OnPermissionGranted$_), 
            0 === i ? this._$_runtime$_._$RequestDeviceOrientationEvent$_() : this._$_runtime$_._$RequestDeviceMotionEvent$_()) : this._$Trigger$_(I._$Plugins$_.Touch._$Cnds$_._$OnPermissionDenied$_);
        }
        _$_OnDeviceOrientation$_(t) {
            "number" == typeof t.webkitCompassHeading ? this._$_orientCompassHeading$_ = t.webkitCompassHeading : t.absolute && (this._$_orientCompassHeading$_ = t.alpha), 
            this._$_orientAlpha$_ = t.alpha, this._$_orientBeta$_ = t.beta, this._$_orientGamma$_ = t.gamma;
        }
        _$_OnDeviceOrientationAbsolute$_(t) {
            this._$_orientCompassHeading$_ = t.alpha;
        }
        _$_OnDeviceMotion$_(t) {
            const s = t.acceleration, i = (s && (this._$_accX$_ = s.x, this._$_accY$_ = s.y, 
            this._$_accZ$_ = s.z), t.accelerationIncludingGravity);
            i && (this._$_accWithGX$_ = i.x, this._$_accWithGY$_ = i.y, this._$_accWithGZ$_ = i.z);
        }
        _$_OnTick2$_() {
            let t = performance.now(), s = 0;
            for (const i of this._$_touches$_.values()) i._$GetTime$_() <= t - 50 && i._$_SetLastTime$_(t), 
            i._$ShouldTriggerHold$_(t) && (this._$_triggerIndex$_ = i._$GetStartIndex$_(), 
            this._$_triggerId$_ = i._$GetId$_(), this._$_getTouchIndex$_ = s, this._$Trigger$_(I._$Plugins$_.Touch._$Cnds$_._$OnHoldGesture$_), 
            this._$_curTouchX$_ = i._$GetX$_(), this._$_curTouchY$_ = i._$GetY$_(), 
            this._$Trigger$_(I._$Plugins$_.Touch._$Cnds$_._$OnHoldGestureObject$_), 
            this._$_getTouchIndex$_ = 0), ++s;
        }
        _$_GetTouchByIndex$_(t) {
            t = Math.floor(t);
            for (const s of this._$_touches$_.values()) {
                if (0 === t) return s;
                --t;
            }
            return null;
        }
        _$_IsClientPosOnCanvas$_(t, s) {
            return 0 <= t && 0 <= s && t < this._$_runtime$_._$GetCanvasCssWidth$_() && s < this._$_runtime$_._$GetCanvasCssHeight$_();
        }
        _$GetDebuggerProperties$_() {
            return [ {
                title: "plugins.touch.debugger.touches",
                properties: [ ...this._$_touches$_.values() ].map(t => ({
                    name: "$" + t._$GetId$_(),
                    value: t._$GetX$_() + ", " + t._$GetY$_()
                }))
            } ];
        }
    };
}

{
    const xl = self._$C3$_;
    xl._$Plugins$_.Touch._$Cnds$_ = {
        _$OnTouchStart$_() {
            return !0;
        },
        _$OnTouchEnd$_() {
            return !0;
        },
        _$IsInTouch$_() {
            return 0 < this._$_touches$_.size;
        },
        _$OnTouchObject$_(t, s) {
            return !!t && s === this._$_triggerType$_ && !!this._$_IsClientPosOnCanvas$_(this._$_curTouchX$_, this._$_curTouchY$_) && this._$_runtime$_._$GetCollisionEngine$_()._$TestAndSelectCanvasPointOverlap$_(t, [ [ this._$_curTouchX$_, this._$_curTouchY$_ ] ], !1);
        },
        _$IsTouchingObject$_(t) {
            if (!t) return !1;
            const s = this._$_runtime$_._$GetCurrentCondition$_(), i = s._$IsInverted$_(), e = [ ...this._$_touches$_.values() ].filter(t => this._$_IsClientPosOnCanvas$_(t._$GetX$_(), t._$GetY$_())).map(t => [ t._$GetX$_(), t._$GetY$_() ]);
            return xl.xor(this._$_runtime$_._$GetCollisionEngine$_()._$TestAndSelectCanvasPointOverlap$_(t, e, i), i);
        },
        _$CompareTouchSpeed$_(t, s, i) {
            const e = this._$_GetTouchByIndex$_(t);
            return !!e && xl.compare(e._$GetSpeed$_(), s, i);
        },
        _$OrientationSupported$_() {
            return !0;
        },
        _$MotionSupported$_() {
            return !0;
        },
        _$CompareOrientation$_(t, s, i) {
            this._$_runtime$_._$RequestDeviceOrientationEvent$_();
            let e = 0;
            return e = 0 === t ? this._$_orientAlpha$_ : 1 === t ? this._$_orientBeta$_ : this._$_orientGamma$_, 
            xl.compare(e, s, i);
        },
        _$CompareAcceleration$_(t, s, i) {
            this._$_runtime$_._$RequestDeviceMotionEvent$_();
            let e = 0;
            return e = 0 === t ? this._$_accWithGX$_ : 1 === t ? this._$_accWithGY$_ : 2 === t ? this._$_accWithGZ$_ : 3 === t ? this._$_accX$_ : 4 === t ? this._$_accY$_ : this._$_accZ$_, 
            xl.compare(e, s, i);
        },
        _$OnNthTouchStart$_(t) {
            return (t = Math.floor(t)) === this._$_triggerIndex$_;
        },
        _$OnNthTouchEnd$_(t) {
            return (t = Math.floor(t)) === this._$_triggerIndex$_;
        },
        _$HasNthTouch$_(t) {
            return t = Math.floor(t), this._$_touches$_.size >= t + 1;
        },
        _$OnHoldGesture$_() {
            return !0;
        },
        _$OnTapGesture$_() {
            return !0;
        },
        _$OnDoubleTapGesture$_() {
            return !0;
        },
        _$OnHoldGestureObject$_(t) {
            return !!t && !!this._$_IsClientPosOnCanvas$_(this._$_curTouchX$_, this._$_curTouchY$_) && this._$_runtime$_._$GetCollisionEngine$_()._$TestAndSelectCanvasPointOverlap$_(t, [ [ this._$_curTouchX$_, this._$_curTouchY$_ ] ], !1);
        },
        _$OnTapGestureObject$_(t) {
            return !!t && !!this._$_IsClientPosOnCanvas$_(this._$_curTouchX$_, this._$_curTouchY$_) && this._$_runtime$_._$GetCollisionEngine$_()._$TestAndSelectCanvasPointOverlap$_(t, [ [ this._$_curTouchX$_, this._$_curTouchY$_ ] ], !1);
        },
        _$OnDoubleTapGestureObject$_(t) {
            return !!t && !!this._$_IsClientPosOnCanvas$_(this._$_curTouchX$_, this._$_curTouchY$_) && this._$_runtime$_._$GetCollisionEngine$_()._$TestAndSelectCanvasPointOverlap$_(t, [ [ this._$_curTouchX$_, this._$_curTouchY$_ ] ], !1);
        },
        _$OnPermissionGranted$_(t) {
            return this._$_triggerPermission$_ === t;
        },
        _$OnPermissionDenied$_(t) {
            return this._$_triggerPermission$_ === t;
        }
    };
}

{
    const Gl = self._$C3$_;
    Gl._$Plugins$_.Touch._$Acts$_ = {
        _$RequestPermission$_(t) {
            this._$_RequestPermission$_(t);
        }
    };
}

{
    const Tl = self._$C3$_;
    Tl._$Plugins$_.Touch._$Exps$_ = {
        _$TouchCount$_() {
            return this._$_touches$_.size;
        },
        _$X$_(t) {
            const s = this._$_GetTouchByIndex$_(this._$_getTouchIndex$_);
            return s ? s._$GetPositionForLayer$_(this._$_runtime$_._$GetCurrentLayout$_(), t, !0) : 0;
        },
        _$Y$_(t) {
            const s = this._$_GetTouchByIndex$_(this._$_getTouchIndex$_);
            return s ? s._$GetPositionForLayer$_(this._$_runtime$_._$GetCurrentLayout$_(), t, !1) : 0;
        },
        _$XAt$_(t, s) {
            const i = this._$_GetTouchByIndex$_(t);
            return i ? i._$GetPositionForLayer$_(this._$_runtime$_._$GetCurrentLayout$_(), s, !0) : 0;
        },
        _$YAt$_(t, s) {
            const i = this._$_GetTouchByIndex$_(t);
            return i ? i._$GetPositionForLayer$_(this._$_runtime$_._$GetCurrentLayout$_(), s, !1) : 0;
        },
        _$XForID$_(t, s) {
            const i = this._$_touches$_.get(t);
            return i ? i._$GetPositionForLayer$_(this._$_runtime$_._$GetCurrentLayout$_(), s, !0) : 0;
        },
        _$YForID$_(t, s) {
            const i = this._$_touches$_.get(t);
            return i ? i._$GetPositionForLayer$_(this._$_runtime$_._$GetCurrentLayout$_(), s, !1) : 0;
        },
        _$AbsoluteX$_() {
            const t = this._$_GetTouchByIndex$_(0);
            return t ? t._$GetX$_() : 0;
        },
        _$AbsoluteY$_() {
            const t = this._$_GetTouchByIndex$_(0);
            return t ? t._$GetY$_() : 0;
        },
        _$AbsoluteXAt$_(t) {
            const s = this._$_GetTouchByIndex$_(t);
            return s ? s._$GetX$_() : 0;
        },
        _$AbsoluteYAt$_(t) {
            const s = this._$_GetTouchByIndex$_(t);
            return s ? s._$GetY$_() : 0;
        },
        _$AbsoluteXForID$_(t) {
            const s = this._$_touches$_.get(t);
            return s ? s._$GetX$_() : 0;
        },
        _$AbsoluteYForID$_(t) {
            const s = this._$_touches$_.get(t);
            return s ? s._$GetY$_() : 0;
        },
        _$SpeedAt$_(t) {
            const s = this._$_GetTouchByIndex$_(t);
            return s ? s._$GetSpeed$_() : 0;
        },
        _$SpeedForID$_(t) {
            const s = this._$_touches$_.get(t);
            return s ? s._$GetSpeed$_() : 0;
        },
        _$AngleAt$_(t) {
            const s = this._$_GetTouchByIndex$_(t);
            return s ? Tl._$toDegrees$_(s._$GetAngle$_()) : 0;
        },
        _$AngleForID$_(t) {
            const s = this._$_touches$_.get(t);
            return s ? Tl._$toDegrees$_(s._$GetAngle$_()) : 0;
        },
        _$CompassHeading$_() {
            return this._$_runtime$_._$RequestDeviceOrientationEvent$_(), this._$_orientCompassHeading$_;
        },
        _$Alpha$_() {
            return this._$_runtime$_._$RequestDeviceOrientationEvent$_(), this._$_orientAlpha$_;
        },
        _$Beta$_() {
            return this._$_runtime$_._$RequestDeviceOrientationEvent$_(), this._$_orientBeta$_;
        },
        _$Gamma$_() {
            return this._$_runtime$_._$RequestDeviceOrientationEvent$_(), this._$_orientGamma$_;
        },
        _$AccelerationXWithG$_() {
            return this._$_runtime$_._$RequestDeviceMotionEvent$_(), this._$_accWithGX$_;
        },
        _$AccelerationYWithG$_() {
            return this._$_runtime$_._$RequestDeviceMotionEvent$_(), this._$_accWithGY$_;
        },
        _$AccelerationZWithG$_() {
            return this._$_runtime$_._$RequestDeviceMotionEvent$_(), this._$_accWithGZ$_;
        },
        _$AccelerationX$_() {
            return this._$_runtime$_._$RequestDeviceMotionEvent$_(), this._$_accX$_;
        },
        _$AccelerationY$_() {
            return this._$_runtime$_._$RequestDeviceMotionEvent$_(), this._$_accY$_;
        },
        _$AccelerationZ$_() {
            return this._$_runtime$_._$RequestDeviceMotionEvent$_(), this._$_accZ$_;
        },
        _$TouchIndex$_() {
            return this._$_triggerIndex$_;
        },
        _$TouchID$_() {
            return this._$_triggerId$_;
        },
        _$WidthForID$_(t) {
            const s = this._$_touches$_.get(t);
            return s ? s._$GetWidth$_() : 0;
        },
        _$HeightForID$_(t) {
            const s = this._$_touches$_.get(t);
            return s ? s._$GetHeight$_() : 0;
        },
        _$PressureForID$_(t) {
            const s = this._$_touches$_.get(t);
            return s ? s._$GetPressure$_() : 0;
        }
    };
}

{
    let n = self._$C3$_, s = -1e3, i = -1e3, e = -1e4;
    n._$Plugins$_.Touch._$TouchInfo$_ = class extends n._$DefendedBase$_ {
        constructor() {
            super(), this._$_pointerId$_ = 0, this._$_startIndex$_ = 0, this._$_startTime$_ = 0, 
            this._$_time$_ = 0, this._$_lastTime$_ = 0, this._$_startX$_ = 0, this._$_startY$_ = 0, 
            this._$_x$_ = 0, this._$_y$_ = 0, this._$_lastX$_ = 0, this._$_lastY$_ = 0, 
            this._$_width$_ = 0, this._$_height$_ = 0, this._$_pressure$_ = 0, this._$_hasTriggeredHold$_ = !1, 
            this._$_isTooFarForHold$_ = !1;
        }
        _$Release$_() {}
        _$Init$_(t, s, i, e, h) {
            this._$_pointerId$_ = e, this._$_startIndex$_ = h, this._$_time$_ = t, 
            this._$_lastTime$_ = t, this._$_startTime$_ = t, this._$_startX$_ = s, 
            this._$_startY$_ = i, this._$_x$_ = s, this._$_y$_ = i, this._$_lastX$_ = s, 
            this._$_lastY$_ = i;
        }
        _$Update$_(t, s, i, e, h, r) {
            this._$_lastTime$_ = this._$_time$_, this._$_time$_ = t, this._$_lastX$_ = this._$_x$_, 
            this._$_lastY$_ = this._$_y$_, this._$_x$_ = s, this._$_y$_ = i, this._$_width$_ = e, 
            this._$_height$_ = h, this._$_pressure$_ = r, !this._$_isTooFarForHold$_ && 15 <= n._$distanceTo$_(this._$_startX$_, this._$_startY$_, this._$_x$_, this._$_y$_) && (this._$_isTooFarForHold$_ = !0);
        }
        _$GetId$_() {
            return this._$_pointerId$_;
        }
        _$GetStartIndex$_() {
            return this._$_startIndex$_;
        }
        _$GetTime$_() {
            return this._$_time$_;
        }
        _$_SetLastTime$_(t) {
            this._$_lastTime$_ = t;
        }
        _$GetX$_() {
            return this._$_x$_;
        }
        _$GetY$_() {
            return this._$_y$_;
        }
        _$GetSpeed$_() {
            const t = n._$distanceTo$_(this._$_x$_, this._$_y$_, this._$_lastX$_, this._$_lastY$_), s = (this._$_time$_ - this._$_lastTime$_) / 1e3;
            return 0 < s ? t / s : 0;
        }
        _$GetAngle$_() {
            return n._$angleTo$_(this._$_lastX$_, this._$_lastY$_, this._$_x$_, this._$_y$_);
        }
        _$GetWidth$_() {
            return this._$_width$_;
        }
        _$GetHeight$_() {
            return this._$_height$_;
        }
        _$GetPressure$_() {
            return this._$_pressure$_;
        }
        _$ShouldTriggerHold$_(t) {
            return !this._$_hasTriggeredHold$_ && 500 <= t - this._$_startTime$_ && !this._$_isTooFarForHold$_ && n._$distanceTo$_(this._$_startX$_, this._$_startY$_, this._$_x$_, this._$_y$_) < 15 && (this._$_hasTriggeredHold$_ = !0);
        }
        _$ShouldTriggerTap$_(t) {
            return !this._$_hasTriggeredHold$_ && t - this._$_startTime$_ <= 333 && !this._$_isTooFarForHold$_ && n._$distanceTo$_(this._$_startX$_, this._$_startY$_, this._$_x$_, this._$_y$_) < 15 ? t - e <= 666 && n._$distanceTo$_(s, i, this._$_x$_, this._$_y$_) < 25 ? (s = -1e3, 
            i = -1e3, e = -1e4, "double-tap") : (s = this._$_x$_, i = this._$_y$_, 
            e = t, "single-tap") : "";
        }
        _$GetPositionForLayer$_(t, s, i) {
            if (void 0 === s) {
                const e = t._$GetLayerByIndex$_(0);
                return e._$CanvasCssToLayer_DefaultTransform$_(this._$_x$_, this._$_y$_)[i ? 0 : 1];
            }
            {
                const h = t._$GetLayer$_(s);
                return h ? h._$CanvasCssToLayer$_(this._$_x$_, this._$_y$_)[i ? 0 : 1] : 0;
            }
        }
    };
}

{
    const _l = self._$C3$_;
    _l._$Plugins$_.gamepad = class extends _l._$SDKPluginBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const Il = self._$C3$_;
    Il._$Plugins$_.gamepad._$Type$_ = class extends Il._$SDKTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    const Cl = self._$C3$_;
    class Rl {
        constructor(t, s, i) {
            this._$_index$_ = t, this._$_id$_ = s, this._$_vibrationEffects$_ = new Set(i), 
            this._$_state$_ = new Pl(), this._$_oldState$_ = new Pl(), this._$_buttonsPressed$_ = [], 
            this._$_buttonsReleased$_ = [];
        }
        _$GetID$_() {
            return this._$_id$_;
        }
        _$Update$_(t, s) {
            const i = this._$_oldState$_;
            this._$_oldState$_ = this._$_state$_, this._$_state$_ = i, this._$_state$_._$Update$_(t, s), 
            Cl._$resizeArray$_(this._$_buttonsPressed$_, this._$_state$_._$GetButtonCount$_(), !1), 
            Cl._$resizeArray$_(this._$_buttonsReleased$_, this._$_state$_._$GetButtonCount$_(), !1);
            for (let t = 0, s = this._$_state$_._$GetButtonCount$_(); t < s; ++t) {
                const e = this._$_oldState$_._$GetButtonAt$_(t), h = this._$_state$_._$GetButtonAt$_(t);
                .5 <= h && e < .5 && (this._$_buttonsPressed$_[t] = !0), h < .5 && .5 <= e && (this._$_buttonsReleased$_[t] = !0);
            }
        }
        _$GetButtonCount$_() {
            return this._$_state$_._$GetButtonCount$_();
        }
        _$GetAxisCount$_() {
            return this._$_state$_._$GetAxisCount$_();
        }
        _$HasButtonBecomePressed$_(t) {
            return !((t = Math.floor(t)) < 0 || t >= this._$_buttonsPressed$_.length) && this._$_buttonsPressed$_[t];
        }
        _$HasButtonBecomeReleased$_(t) {
            return !((t = Math.floor(t)) < 0 || t >= this._$_buttonsReleased$_.length) && this._$_buttonsReleased$_[t];
        }
        _$ResetButtonPressAndReleaseFlags$_() {
            this._$_buttonsPressed$_.fill(!1), this._$_buttonsReleased$_.fill(!1);
        }
        _$GetButtonAt$_(t) {
            return this._$_state$_._$GetButtonAt$_(t);
        }
        _$IsButtonDown$_(t) {
            return .5 <= this._$_state$_._$GetButtonAt$_(t);
        }
        _$GetAxisAt$_(t) {
            return this._$_state$_._$GetAxisAt$_(t);
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$GetVibrationEffects$_() {
            return this._$_vibrationEffects$_;
        }
    }
    class Pl {
        constructor() {
            this._$_buttons$_ = [], this._$_axes$_ = [];
        }
        _$Update$_(s, t) {
            let i = this._$_buttons$_, e = 0;
            for (let t = s.length; e < t; ++e) {
                const h = s[e];
                e === i.length ? i.push(h.value) : i[e] = h.value;
            }
            e < i.length && Cl._$truncateArray$_(i, e), Cl._$shallowAssignArray$_(this._$_axes$_, t);
        }
        _$GetButtonCount$_() {
            return this._$_buttons$_.length;
        }
        _$GetAxisCount$_() {
            return this._$_axes$_.length;
        }
        _$GetButtonAt$_(t) {
            return (t = Math.floor(t)) < 0 || t >= this._$_buttons$_.length ? 0 : this._$_buttons$_[t];
        }
        _$GetAxisAt$_(t) {
            return (t = Math.floor(t)) < 0 || t >= this._$_axes$_.length ? 0 : this._$_axes$_[t];
        }
    }
    Cl._$Plugins$_.gamepad.Instance = class extends Cl._$SDKInstanceBase$_ {
        constructor(t, s) {
            super(t, "gamepad"), this._$_deadZone$_ = 25, this._$_lastButton$_ = 0, 
            this._$_lastIndex$_ = -1, this._$_gamepads$_ = new Map(), s && (this._$_deadZone$_ = s[0]), 
            this._$AddDOMMessageHandler$_("gamepad-connected", t => this._$_OnGamepadConnected$_(t)), 
            this._$AddDOMMessageHandler$_("gamepad-disconnected", t => this._$_OnGamepadDisconnected$_(t)), 
            this._$AddDOMMessageHandler$_("input-update", t => this._$_OnInputUpdate$_(t));
            const i = this._$GetRuntime$_()._$Dispatcher$_();
            this._$_disposables$_ = new Cl._$CompositeDisposable$_(Cl._$Disposable$_._$From$_(i, "tick2", () => this._$_OnTick2$_()), Cl._$Disposable$_._$From$_(i, "suspend", () => this._$_OnSuspend$_()), Cl._$Disposable$_._$From$_(i, "resume", () => this._$_OnResume$_())), 
            this._$PostToDOM$_("ready");
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$_OnGamepadConnected$_(t) {
            const s = t.index, i = t.id, e = t.vibrationEffects;
            this._$_gamepads$_.has(s) || (this._$_gamepads$_.set(s, new Rl(s, i, e)), 
            this._$_lastIndex$_ = s, this._$Trigger$_(Cl._$Plugins$_.gamepad._$Cnds$_._$OnGamepadConnected$_), 
            this._$_lastIndex$_ = -1);
        }
        _$_OnGamepadDisconnected$_(t) {
            const s = t.index;
            this._$_lastIndex$_ = s, this._$Trigger$_(Cl._$Plugins$_.gamepad._$Cnds$_._$OnGamepadDisconnected$_), 
            this._$_lastIndex$_ = -1, this._$_gamepads$_.delete(s);
        }
        _$_OnInputUpdate$_(t) {
            for (const s of t) this._$_OnGamepadInputUpdate$_(s);
        }
        _$_OnGamepadInputUpdate$_(t) {
            const s = t.index, i = (this._$_gamepads$_.has(s) || this._$_OnGamepadConnected$_(t), 
            this._$_gamepads$_.get(s));
            i._$Update$_(t.buttons, t.axes);
            for (let t = 0, s = i._$GetButtonCount$_(); t < s; ++t) i._$HasButtonBecomePressed$_(t) && (this._$_lastButton$_ = t);
        }
        _$_GetGamepadByIndex$_(t) {
            return this._$_gamepads$_.get(Math.floor(t)) || null;
        }
        _$_GetAllGamepadsByIndex$_(t) {
            if (-1 === t) return [ ...this._$_gamepads$_.values() ];
            {
                const s = this._$_gamepads$_.get(Math.floor(t));
                return s ? [ s ] : [];
            }
        }
        _$_OnTick2$_() {
            for (const t of this._$_gamepads$_.values()) t._$ResetButtonPressAndReleaseFlags$_();
        }
        _$_OnSuspend$_() {
            this._$PostToDOM$_("suspend");
        }
        _$_OnResume$_() {
            this._$PostToDOM$_("resume");
        }
        _$GetDebuggerProperties$_() {
            const t = "plugins.gamepad";
            return [ {
                title: t + ".name",
                properties: [ {
                    name: t + ".debugger.last-button",
                    value: this._$_lastButton$_
                }, {
                    name: t + ".properties.analog-deadzone.name",
                    value: this._$_deadZone$_
                } ]
            } ];
        }
    };
}

{
    const El = self._$C3$_;
    El._$Plugins$_.gamepad._$Cnds$_ = {
        _$OnGamepadConnected$_() {
            return !0;
        },
        _$OnGamepadDisconnected$_() {
            return !0;
        },
        _$IsButtonDown$_(t, s) {
            const i = this._$_GetGamepadByIndex$_(t);
            if (!i) return !1;
            const e = i._$IsButtonDown$_(s);
            return e && (this._$_lastButton$_ = s), e;
        },
        _$OnButtonDown$_(t, s) {
            const i = this._$_GetGamepadByIndex$_(t);
            if (!i) return !1;
            const e = i._$HasButtonBecomePressed$_(s);
            return e && (this._$_lastButton$_ = s), e;
        },
        _$OnButtonUp$_(t, s) {
            const i = this._$_GetGamepadByIndex$_(t);
            if (!i) return !1;
            const e = i._$HasButtonBecomeReleased$_(s);
            return e && (this._$_lastButton$_ = s), e;
        },
        _$HasGamepads$_() {
            return 0 < this._$_gamepads$_.size;
        },
        _$CompareAxis$_(t, s, i, e) {
            s = Math.floor(s);
            const h = this._$_GetGamepadByIndex$_(t);
            if (!h) return !1;
            let r = h._$GetAxisAt$_(s), n = 0;
            return n = s % 2 == 0 ? h._$GetAxisAt$_(s + 1) : h._$GetAxisAt$_(s - 1), 
            r *= 100, n *= 100, Math.hypot(r, n) <= this._$_deadZone$_ && (r = 0), 
            El.compare(r, i, e);
        },
        _$OnAnyButtonDown$_(t) {
            const s = this._$_GetAllGamepadsByIndex$_(t);
            if (0 !== s.length) {
                const i = this._$_runtime$_, e = i._$GetEventSheetManager$_(), h = i._$GetCurrentEvent$_(), r = h._$GetSolModifiers$_(), n = i._$GetEventStack$_(), o = n._$GetCurrentStackFrame$_(), a = n._$Push$_(h);
                i._$SetDebuggingEnabled$_(!1);
                for (const l of s) for (let t = 0, s = l._$GetButtonCount$_(); t < s; ++t) l._$HasButtonBecomePressed$_(t) && (this._$_lastIndex$_ = l._$GetIndex$_(), 
                this._$_lastButton$_ = t, e._$PushCopySol$_(r), h._$Retrigger$_(o, a), 
                e._$PopSol$_(r), this._$_lastIndex$_ = -1);
                i._$SetDebuggingEnabled$_(!0), n._$Pop$_();
            }
            return !1;
        },
        _$OnAnyButtonUp$_(t) {
            const s = this._$_GetAllGamepadsByIndex$_(t);
            if (0 !== s.length) {
                const i = this._$_runtime$_, e = i._$GetEventSheetManager$_(), h = i._$GetCurrentEvent$_(), r = h._$GetSolModifiers$_(), n = i._$GetEventStack$_(), o = n._$GetCurrentStackFrame$_(), a = n._$Push$_(h);
                i._$SetDebuggingEnabled$_(!1);
                for (const l of s) for (let t = 0, s = l._$GetButtonCount$_(); t < s; ++t) l._$HasButtonBecomeReleased$_(t) && (this._$_lastIndex$_ = l._$GetIndex$_(), 
                this._$_lastButton$_ = t, e._$PushCopySol$_(r), h._$Retrigger$_(o, a), 
                e._$PopSol$_(r), this._$_lastIndex$_ = -1);
                i._$SetDebuggingEnabled$_(!0), n._$Pop$_();
            }
            return !1;
        },
        _$IsButtonIndexDown$_(t, s) {
            s = Math.floor(s);
            const i = this._$_GetGamepadByIndex$_(t);
            if (!i) return !1;
            const e = i._$IsButtonDown$_(s);
            return e && (this._$_lastButton$_ = s), e;
        },
        _$OnButtonIndexDown$_(t, s) {
            s = Math.floor(s);
            const i = this._$_GetGamepadByIndex$_(t);
            if (!i) return !1;
            const e = i._$HasButtonBecomePressed$_(s);
            return e && (this._$_lastButton$_ = s), e;
        },
        _$OnButtonIndexUp$_(t, s) {
            s = Math.floor(s);
            const i = this._$_GetGamepadByIndex$_(t);
            if (!i) return !1;
            const e = i._$HasButtonBecomeReleased$_(s);
            return e && (this._$_lastButton$_ = s), e;
        },
        _$GamepadSupportsVibrationType$_(t, s) {
            const i = this._$_GetGamepadByIndex$_(t);
            if (!i) return !1;
            const e = i._$GetVibrationEffects$_();
            return 0 === s ? e.has("dual-rumble") : 1 === s && e.has("trigger-rumble");
        },
        _$SupportsGamepad$_() {
            return !0;
        }
    };
}

{
    const Al = self._$C3$_;
    Al._$Plugins$_.gamepad._$Acts$_ = {
        _$VibrateDualRumble$_(t, s, i, e) {
            this._$PostToDOM$_("vibrate-dual-rumble", {
                index: t,
                duration: s,
                weakMag: Al._$clamp$_(i / 100, 0, 1),
                strongMag: Al._$clamp$_(e / 100, 0, 1)
            });
        },
        _$VibrateTriggerRumble$_(t, s, i, e, h, r) {
            this._$PostToDOM$_("vibrate-trigger-rumble", {
                index: t,
                duration: s,
                weakMag: Al._$clamp$_(i / 100, 0, 1),
                strongMag: Al._$clamp$_(e / 100, 0, 1),
                leftMag: Al._$clamp$_(h / 100, 0, 1),
                rightMag: Al._$clamp$_(r / 100, 0, 1)
            });
        },
        _$ResetVibrate$_(t) {
            this._$PostToDOM$_("reset-vibrate", {
                index: t
            });
        }
    };
}

{
    const Fl = self._$C3$_;
    Fl._$Plugins$_.gamepad._$Exps$_ = {
        _$GamepadCount$_() {
            return this._$_gamepads$_.size;
        },
        _$GamepadID$_(t) {
            const s = this._$_GetGamepadByIndex$_(t);
            return s ? s._$GetID$_() : "";
        },
        _$GamepadIndex$_() {
            return this._$_lastIndex$_;
        },
        _$GamepadAxes$_(t) {
            const i = this._$_GetGamepadByIndex$_(t);
            if (!i) return "";
            let e = "";
            for (let t = 0, s = i._$GetAxisCount$_(); t < s; ++t) e += `Axis ${t}: ${Math.round(100 * i._$GetAxisAt$_(t))}
`;
            return e;
        },
        _$GamepadButtons$_(t) {
            const i = this._$_GetGamepadByIndex$_(t);
            if (!i) return "";
            let e = "";
            for (let t = 0, s = i._$GetButtonCount$_(); t < s; ++t) e += `Button ${t}: ${Math.round(100 * i._$GetButtonAt$_(t))}
`;
            return e;
        },
        _$RawButton$_(t, s) {
            const i = this._$_GetGamepadByIndex$_(t);
            return i ? i._$GetButtonAt$_(Math.floor(s)) : 0;
        },
        _$RawAxis$_(t, s) {
            const i = this._$_GetGamepadByIndex$_(t);
            return i ? i._$GetAxisAt$_(Math.floor(s)) : 0;
        },
        _$RawButtonCount$_(t) {
            const s = this._$_GetGamepadByIndex$_(t);
            return s ? s._$GetButtonCount$_() : 0;
        },
        _$RawAxisCount$_(t) {
            const s = this._$_GetGamepadByIndex$_(t);
            return s ? s._$GetAxisCount$_() : 0;
        },
        _$Button$_(t, s) {
            const i = this._$_GetGamepadByIndex$_(t);
            return i ? 100 * i._$GetButtonAt$_(Math.floor(s)) : 0;
        },
        _$Axis$_(t, s) {
            s = Math.floor(s);
            const i = this._$_GetGamepadByIndex$_(t);
            if (!i) return 0;
            let e = i._$GetAxisAt$_(s), h = 0;
            return h = s % 2 == 0 ? i._$GetAxisAt$_(s + 1) : i._$GetAxisAt$_(s - 1), 
            e *= 100, h *= 100, e = Math.hypot(e, h) <= this._$_deadZone$_ ? 0 : e;
        },
        _$ButtonIndex$_() {
            return this._$_lastButton$_;
        },
        _$LastButton$_() {
            return this._$_lastButton$_;
        }
    };
}

{
    const Ol = self._$C3$_;
    Ol._$Plugins$_._$Arr$_ = class extends Ol._$SDKPluginBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const Dl = self._$C3$_;
    Dl._$Plugins$_._$Arr$_._$Type$_ = class extends Dl._$SDKTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    let r = function(s, i, e) {
        if (i < s.length) kl._$truncateArray$_(s, i); else if (i > s.length) if ("function" == typeof e) for (let t = s.length; t < i; ++t) s.push(e()); else for (let t = s.length; t < i; ++t) s.push(e);
    };
    r;
    const kl = self._$C3$_, Ll = self._$C3X$_, Bl = self._$IInstance$_, Nl = (kl._$Plugins$_._$Arr$_.Instance = class extends kl._$SDKInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_cx$_ = 10, this._$_cy$_ = 1, this._$_cz$_ = 1, this._$_arr$_ = null, 
            this._$_forX$_ = [], this._$_forY$_ = [], this._$_forZ$_ = [], this._$_forDepth$_ = -1, 
            s && (this._$_cx$_ = s[0], this._$_cy$_ = s[1], this._$_cz$_ = s[2]), 
            this._$_arr$_ = kl._$MakeFilledArray$_(this._$_cx$_, () => kl._$MakeFilledArray$_(this._$_cy$_, () => kl._$MakeFilledArray$_(this._$_cz$_, 0)));
        }
        _$Release$_() {
            this._$_arr$_ = null, super._$Release$_();
        }
        _$At$_(t, s, i) {
            return t = Math.floor(t), s = Math.floor(s), i = Math.floor(i), 0 <= t && t < this._$_cx$_ && 0 <= s && s < this._$_cy$_ && 0 <= i && i < this._$_cz$_ ? this._$_arr$_[t][s][i] : 0;
        }
        Set(t, s, i, e) {
            t = Math.floor(t), s = Math.floor(s), i = Math.floor(i), 0 <= t && t < this._$_cx$_ && 0 <= s && s < this._$_cy$_ && 0 <= i && i < this._$_cz$_ && (this._$_arr$_[t][s][i] = e);
        }
        _$SetSize$_(t, i, e) {
            if (t = Math.floor(t), i = Math.floor(i), e = Math.floor(e), i < 0 && (i = 0), 
            e < 0 && (e = 0), this._$_cx$_ !== (t = t < 0 ? 0 : t) || this._$_cy$_ !== i || this._$_cz$_ !== e) {
                this._$_cx$_ = t, this._$_cy$_ = i, this._$_cz$_ = e;
                const h = this._$_arr$_;
                r(h, t, () => kl._$MakeFilledArray$_(i, () => kl._$MakeFilledArray$_(e, 0)));
                for (let s = 0; s < t; ++s) {
                    r(h[s], i, () => kl._$MakeFilledArray$_(e, 0));
                    for (let t = 0; t < i; ++t) r(h[s][t], e, 0);
                }
            }
        }
        _$GetWidth$_() {
            return this._$_cx$_;
        }
        _$GetHeight$_() {
            return this._$_cy$_;
        }
        _$GetDepth$_() {
            return this._$_cz$_;
        }
        _$_ShuffleHelper$_(t, s, i, e, h) {
            for (;0 < s; ) {
                const r = Math.floor(this._$_runtime$_._$Random$_() * s);
                if (--s, 0 === t) {
                    const n = this._$At$_(s, e, h), o = this._$At$_(r, e, h);
                    this.Set(s, e, h, o), this.Set(r, e, h, n);
                } else if (1 === t) {
                    const a = this._$At$_(i, s, h), l = this._$At$_(i, r, h);
                    this.Set(i, s, h, l), this.Set(i, r, h, a);
                } else if (2 === t) {
                    const u = this._$At$_(i, e, s), c = this._$At$_(i, e, r);
                    this.Set(i, e, s, c), this.Set(i, e, r, u);
                }
            }
        }
        _$GetDebuggerProperties$_() {
            const t = "plugins.arr.debugger", s = "plugins.arr.properties", i = [ {
                title: t + ".array-properties.title",
                properties: [ {
                    name: s + ".width.name",
                    value: this._$_cx$_,
                    _$onedit$_: t => this._$SetSize$_(t, this._$_cy$_, this._$_cz$_)
                }, {
                    name: s + ".height.name",
                    value: this._$_cy$_,
                    _$onedit$_: t => this._$SetSize$_(this._$_cx$_, t, this._$_cz$_)
                }, {
                    name: s + ".depth.name",
                    value: this._$_cz$_,
                    _$onedit$_: t => this._$SetSize$_(this._$_cx$_, this._$_cy$_, t)
                }, {
                    name: s + ".elements.name",
                    value: this._$_cx$_ * this._$_cy$_ * this._$_cz$_
                } ]
            } ], e = [];
            if (1 === this._$_cy$_ && 1 === this._$_cz$_) for (let s = 0; s < this._$_cx$_; ++s) e.push({
                name: "$" + s,
                value: this._$_arr$_[s][0][0],
                _$onedit$_: t => this._$_arr$_[s][0][0] = t
            }); else for (let t = 0; t < this._$_cx$_; ++t) e.push({
                name: "$" + t,
                value: this._$_arr$_[t].toString()
            });
            return e.length && i.push({
                title: t + ".array-data.title",
                properties: e
            }), i;
        }
        _$GetAsJsonString$_() {
            return JSON.stringify({
                c2array: !0,
                size: [ this._$_cx$_, this._$_cy$_, this._$_cz$_ ],
                data: this._$_arr$_
            });
        }
        _$SaveToJson$_() {
            return {
                size: [ this._$_cx$_, this._$_cy$_, this._$_cz$_ ],
                data: this._$_arr$_
            };
        }
        _$LoadFromJson$_(t) {
            const s = t.size;
            this._$_cx$_ = s[0], this._$_cy$_ = s[1], this._$_cz$_ = s[2], this._$_arr$_ = t.data;
        }
        _$_GetForX$_() {
            return 0 <= this._$_forDepth$_ && this._$_forDepth$_ < this._$_forX$_.length ? this._$_forX$_[this._$_forDepth$_] : 0;
        }
        _$_GetForY$_() {
            return 0 <= this._$_forDepth$_ && this._$_forDepth$_ < this._$_forY$_.length ? this._$_forY$_[this._$_forDepth$_] : 0;
        }
        _$_GetForZ$_() {
            return 0 <= this._$_forDepth$_ && this._$_forDepth$_ < this._$_forZ$_.length ? this._$_forZ$_[this._$_forDepth$_] : 0;
        }
        _$GetScriptInterfaceClass$_() {
            return self._$IArrayInstance$_;
        }
    }, new WeakMap());
    self._$IArrayInstance$_ = class extends Bl {
        constructor() {
            super(), Nl.set(this, Bl._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        get width() {
            return Nl.get(this)._$GetWidth$_();
        }
        get height() {
            return Nl.get(this)._$GetHeight$_();
        }
        get depth() {
            return Nl.get(this)._$GetDepth$_();
        }
        _$setSize$_(t, s = 1, i = 1) {
            Ll._$RequireFiniteNumber$_(t), Ll._$RequireFiniteNumber$_(s), Ll._$RequireFiniteNumber$_(i), 
            Nl.get(this)._$SetSize$_(t, s, i);
        }
        _$getAt$_(t, s = 0, i = 0) {
            return Ll._$RequireFiniteNumber$_(t), Ll._$RequireFiniteNumber$_(s), 
            Ll._$RequireFiniteNumber$_(i), Nl.get(this)._$At$_(t, s, i);
        }
        _$setAt$_(t, s, i = 0, e = 0) {
            if (Ll._$RequireFiniteNumber$_(s), Ll._$RequireFiniteNumber$_(i), Ll._$RequireFiniteNumber$_(e), 
            "number" != typeof t && "string" != typeof t) throw new TypeError("invalid type");
            Nl.get(this).Set(s, i, e, t);
        }
    };
}

{
    let m = function(t, s, i, e, h, r) {
        t._$PushCopySol$_(i);
        const n = r._$GetObjectClass$_()._$GetCurrentSol$_();
        n._$PickOne$_(r._$GetInstance$_()), s._$Retrigger$_(e, h), t._$PopSol$_(i);
    };
    m;
    const Wl = self._$C3$_;
    Wl._$Plugins$_._$Arr$_._$Cnds$_ = {
        _$CompareX$_(t, s, i) {
            return Wl.compare(this._$At$_(t, 0, 0), s, i);
        },
        _$CompareXY$_(t, s, i, e) {
            return Wl.compare(this._$At$_(t, s, 0), i, e);
        },
        _$CompareXYZ$_(t, s, i, e, h) {
            return Wl.compare(this._$At$_(t, s, i), e, h);
        },
        _$ArrForEach$_(t) {
            const s = this._$_runtime$_, e = s._$GetEventSheetManager$_(), h = s._$GetCurrentEvent$_(), r = h._$GetSolModifiers$_(), i = s._$GetEventStack$_(), n = i._$GetCurrentStackFrame$_(), o = i._$Push$_(h), a = ++this._$_forDepth$_, l = this._$_forX$_, u = this._$_forY$_, c = this._$_forZ$_, f = this._$_cx$_, d = this._$_cy$_, p = this._$_cz$_;
            if (a === this._$_forX$_.length ? (l.push(0), u.push(0), c.push(0)) : (l[a] = 0, 
            u[a] = 0, c[a] = 0), s._$SetDebuggingEnabled$_(!1), 0 === t) for (let i = 0; i < f; ++i) for (let s = 0; s < d; ++s) for (let t = 0; t < p; ++t) l[a] = i, 
            u[a] = s, c[a] = t, m(e, h, r, n, o, this); else if (1 === t) for (let s = 0; s < f; ++s) for (let t = 0; t < d; ++t) l[a] = s, 
            u[a] = t, m(e, h, r, n, o, this); else for (let t = 0; t < f; ++t) l[a] = t, 
            m(e, h, r, n, o, this);
            return s._$SetDebuggingEnabled$_(!0), this._$_forDepth$_--, i._$Pop$_(), 
            !1;
        },
        _$CompareCurrent$_(t, s) {
            return Wl.compare(this._$At$_(this._$_GetForX$_(), this._$_GetForY$_(), this._$_GetForZ$_()), t, s);
        },
        _$Contains$_(e) {
            const t = this._$_cx$_, h = this._$_cy$_, r = this._$_cz$_, n = this._$_arr$_;
            for (let i = 0; i < t; ++i) for (let s = 0; s < h; ++s) for (let t = 0; t < r; ++t) if (n[i][s][t] === e) return !0;
            return !1;
        },
        _$IsEmpty$_() {
            return 0 === this._$_cx$_ || 0 === this._$_cy$_ || 0 === this._$_cz$_;
        },
        _$CompareSize$_(t, s, i) {
            let e = 0;
            switch (t) {
              case 0:
                e = this._$_cx$_;
                break;

              case 1:
                e = this._$_cy$_;
                break;

              case 2:
                e = this._$_cz$_;
            }
            return Wl.compare(e, s, i);
        }
    };
}

{
    let r = function(t, s) {
        if ("number" == typeof t && "number" == typeof s) return t - s;
        {
            const i = t.toString(), e = s.toString();
            return i < e ? -1 : e < i ? 1 : 0;
        }
    };
    r;
    const jl = self._$C3$_;
    jl._$Plugins$_._$Arr$_._$Acts$_ = {
        _$Clear$_(e) {
            const t = this._$_cx$_, h = this._$_cy$_, r = this._$_cz$_, n = this._$_arr$_;
            for (let i = 0; i < t; ++i) for (let s = 0; s < h; ++s) for (let t = 0; t < r; ++t) n[i][s][t] = e;
        },
        _$SetSize$_(t, s, i) {
            this._$SetSize$_(t, s, i);
        },
        _$SetX$_(t, s) {
            this.Set(t, 0, 0, s);
        },
        _$SetXY$_(t, s, i) {
            this.Set(t, s, 0, i);
        },
        _$SetXYZ$_(t, s, i, e) {
            this.Set(t, s, i, e);
        },
        _$Push$_(i, e, t) {
            const h = this._$_cx$_, r = this._$_cy$_, s = this._$_cz$_, n = this._$_arr$_;
            if (0 === t) {
                const o = jl._$MakeFilledArray$_(r, () => jl._$MakeFilledArray$_(s, e));
                0 === i ? n.push(o) : n.unshift(o), this._$_cx$_++;
            } else if (1 === t) {
                for (let t = 0; t < h; ++t) {
                    const a = jl._$MakeFilledArray$_(s, e);
                    0 === i ? n[t].push(a) : n[t].unshift(a);
                }
                this._$_cy$_++;
            } else {
                for (let s = 0; s < h; ++s) for (let t = 0; t < r; ++t) 0 === i ? n[s][t].push(e) : n[s][t].unshift(e);
                this._$_cz$_++;
            }
        },
        _$Pop$_(i, t) {
            const e = this._$_cx$_, h = this._$_cy$_, s = this._$_cz$_, r = this._$_arr$_;
            if (0 === t) 0 !== e && (0 === i ? r.pop() : r.shift(), this._$_cx$_--); else if (1 === t) {
                if (0 !== h) {
                    for (let t = 0; t < e; ++t) 0 === i ? r[t].pop() : r[t].shift();
                    this._$_cy$_--;
                }
            } else if (0 !== s) {
                for (let s = 0; s < e; ++s) for (let t = 0; t < h; ++t) 0 === i ? r[s][t].pop() : r[s][t].shift();
                this._$_cz$_--;
            }
        },
        _$Reverse$_(t) {
            const i = this._$_cx$_, e = this._$_cy$_, s = this._$_cz$_, h = this._$_arr$_;
            if (0 !== i && 0 !== e && 0 !== s) if (0 === t) h.reverse(); else if (1 === t) for (let t = 0; t < i; ++t) h[t].reverse(); else for (let s = 0; s < i; ++s) for (let t = 0; t < e; ++t) h[s][t].reverse();
        },
        _$Sort$_(t) {
            const i = this._$_cx$_, e = this._$_cy$_, s = this._$_cz$_, h = this._$_arr$_;
            if (0 !== i && 0 !== e && 0 !== s) if (0 === t) h.sort((t, s) => r(t[0][0], s[0][0])); else if (1 === t) for (let t = 0; t < i; ++t) h[t].sort((t, s) => r(t[0], s[0])); else for (let s = 0; s < i; ++s) for (let t = 0; t < e; ++t) h[s][t].sort(r);
        },
        _$Shuffle$_(i) {
            const e = this._$_cx$_, h = this._$_cy$_, r = this._$_cz$_;
            if (0 !== e && 0 !== h && 0 !== r) if (0 === i) for (let s = 0; s < h; ++s) for (let t = 0; t < r; ++t) this._$_ShuffleHelper$_(i, e, 0, s, t); else if (1 === i) for (let s = 0; s < e; ++s) for (let t = 0; t < r; ++t) this._$_ShuffleHelper$_(i, h, s, 0, t); else for (let s = 0; s < e; ++s) for (let t = 0; t < h; ++t) this._$_ShuffleHelper$_(i, r, s, t, 0);
        },
        _$Delete$_(i, t) {
            if (!((i = Math.floor(i)) < 0)) {
                const e = this._$_cx$_, h = this._$_cy$_, s = this._$_cz$_, r = this._$_arr$_;
                if (0 === t) e <= i || (r.splice(i, 1), this._$_cx$_--); else if (1 === t) {
                    if (!(h <= i)) {
                        for (let t = 0; t < e; ++t) r[t].splice(i, 1);
                        this._$_cy$_--;
                    }
                } else if (!(s <= i)) {
                    for (let s = 0; s < e; ++s) for (let t = 0; t < h; ++t) r[s][t].splice(i, 1);
                    this._$_cz$_--;
                }
            }
        },
        _$Insert$_(i, e, t) {
            if (!((e = Math.floor(e)) < 0)) {
                const h = this._$_cx$_, r = this._$_cy$_, s = this._$_cz$_, n = this._$_arr$_;
                if (0 === t) h < e || (n.splice(e, 0, jl._$MakeFilledArray$_(r, () => jl._$MakeFilledArray$_(s, i))), 
                this._$_cx$_++); else if (1 === t) {
                    if (!(r < e)) {
                        for (let t = 0; t < h; ++t) n[t].splice(e, 0, jl._$MakeFilledArray$_(s, i));
                        this._$_cy$_++;
                    }
                } else if (!(e > s)) {
                    for (let s = 0; s < h; ++s) for (let t = 0; t < r; ++t) n[s][t].splice(e, 0, i);
                    this._$_cz$_++;
                }
            }
        },
        _$SplitString$_(t, s, i) {
            const e = t.split(s);
            this._$SetSize$_(e.length, 1, 1);
            for (let s = 0, t = e.length; s < t; ++s) {
                let t = e[s];
                0 === i ? String(Number(t)) === t && (t = Number(t)) : 2 === i && (t = Number(t)), 
                this.Set(s, 0, 0, t);
            }
        },
        _$JSONLoad$_(t) {
            let s = null;
            try {
                s = JSON.parse(t);
            } catch (t) {
                return void console.error("[Construct] Failed to parse JSON: ", t);
            }
            if (s.c2array) {
                const i = s.size;
                this._$_cx$_ = i[0], this._$_cy$_ = i[1], this._$_cz$_ = i[2], this._$_arr$_ = s.data;
            }
        },
        _$JSONDownload$_(t) {
            const s = URL.createObjectURL(new Blob([ this._$GetAsJsonString$_() ], {
                type: "application/json"
            }));
            this._$_runtime$_._$InvokeDownload$_(s, t);
        }
    };
}

{
    const Vl = self._$C3$_;
    Vl._$Plugins$_._$Arr$_._$Exps$_ = {
        _$At$_(t, s, i) {
            return this._$At$_(t, s || 0, i || 0);
        },
        _$Width$_() {
            return this._$_cx$_;
        },
        _$Height$_() {
            return this._$_cy$_;
        },
        _$Depth$_() {
            return this._$_cz$_;
        },
        _$CurX$_() {
            return this._$_GetForX$_();
        },
        _$CurY$_() {
            return this._$_GetForY$_();
        },
        _$CurZ$_() {
            return this._$_GetForZ$_();
        },
        _$CurValue$_() {
            return this._$At$_(this._$_GetForX$_(), this._$_GetForY$_(), this._$_GetForZ$_());
        },
        _$Front$_() {
            return this._$At$_(0, 0, 0);
        },
        _$Back$_() {
            return this._$At$_(this._$_cx$_ - 1, 0, 0);
        },
        _$IndexOf$_(i) {
            const e = this._$_arr$_;
            for (let t = 0, s = this._$_cx$_; t < s; ++t) if (e[t][0][0] === i) return t;
            return -1;
        },
        _$LastIndexOf$_(s) {
            const i = this._$_arr$_;
            for (let t = this._$_cx$_ - 1; 0 <= t; --t) if (i[t][0][0] === s) return t;
            return -1;
        },
        _$JoinString$_(t) {
            let s = [];
            for (let t = 0; t < this._$_cx$_; ++t) s.push(this._$At$_(t, 0, 0));
            return s.join(t);
        },
        _$AsJSON$_() {
            return this._$GetAsJsonString$_();
        }
    };
}

{
    const Ul = self._$C3$_;
    Ul._$Plugins$_._$LocalStorage$_ = class extends Ul._$SDKPluginBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const Hl = self._$C3$_;
    Hl._$Plugins$_._$LocalStorage$_._$Type$_ = class extends Hl._$SDKTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    const zl = self._$C3$_;
    zl._$Plugins$_._$LocalStorage$_.Instance = class extends zl._$SDKInstanceBase$_ {
        constructor(t, s) {
            super(t, "localstorage"), this._$_currentKey$_ = "", this._$_lastValue$_ = "", 
            this._$_keyNamesList$_ = [], this._$_errorMessage$_ = "", this._$_isPersistent$_ = !1, 
            this._$_pendingGets$_ = 0, this._$_pendingSets$_ = 0, this._$_storage$_ = this._$_runtime$_._$_GetProjectStorage$_(), 
            this._$_debugCache$_ = new Map(), this._$_isLoadingDebugCache$_ = !1, 
            this._$_runtime$_._$AddLoadPromise$_(this._$_Init$_());
        }
        async _$_Init$_() {
            const t = await Promise.race([ this._$PostToDOMAsync$_("init"), zl._$Wait$_(3e3) ]);
            t && (this._$_isPersistent$_ = t.isPersistent);
        }
        _$Release$_() {
            super._$Release$_();
        }
        async _$_TriggerStorageError$_(t) {
            this._$_errorMessage$_ = this._$_GetErrorString$_(t), await this._$TriggerAsync$_(zl._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnError$_);
        }
        _$_GetErrorString$_(t) {
            return t ? "string" == typeof t ? t : "string" == typeof t.message ? t.message : "string" == typeof t.name ? t.name : "string" == typeof t.data ? t.data : "unknown error" : "unknown error";
        }
        _$GetDebuggerProperties$_() {
            return this._$_isLoadingDebugCache$_ || this._$_DebugCacheStorage$_(), 
            [ {
                title: "plugins.localstorage.name",
                properties: [ ...this._$_debugCache$_.entries() ].map(s => ({
                    name: "$" + s[0],
                    value: s[1],
                    _$onedit$_: t => this._$_storage$_.setItem(s[0], t)
                }))
            } ];
        }
        async _$_DebugCacheStorage$_() {
            this._$_isLoadingDebugCache$_ = !0;
            try {
                const i = await this._$_storage$_.keys(), e = (i.sort((t, s) => {
                    const i = t.toLowerCase(), e = s.toLowerCase();
                    return i < e ? -1 : e < i ? 1 : 0;
                }), await Promise.all(i.map(t => this._$_storage$_.getItem(t))));
                this._$_debugCache$_.clear();
                for (let t = 0, s = i.length; t < s; ++t) this._$_debugCache$_.set(i[t], e[t]);
            } catch (t) {
                console.warn("[C3 debugger] Error displaying local storage: ", t);
            } finally {
                this._$_isLoadingDebugCache$_ = !1;
            }
        }
    };
}

{
    const Jl = self._$C3$_;
    Jl._$Plugins$_._$LocalStorage$_._$Cnds$_ = {
        _$OnItemSet$_(t) {
            return this._$_currentKey$_ === t;
        },
        _$OnAnyItemSet$_() {
            return !0;
        },
        _$OnItemGet$_(t) {
            return this._$_currentKey$_ === t;
        },
        _$OnAnyItemGet$_() {
            return !0;
        },
        _$OnItemRemoved$_(t) {
            return this._$_currentKey$_ === t;
        },
        _$OnAnyItemRemoved$_() {
            return !0;
        },
        _$OnCleared$_() {
            return !0;
        },
        _$OnAllKeyNamesLoaded$_() {
            return !0;
        },
        _$OnError$_() {
            return !0;
        },
        _$OnItemExists$_(t) {
            return this._$_currentKey$_ === t;
        },
        _$OnItemMissing$_(t) {
            return this._$_currentKey$_ === t;
        },
        _$CompareKey$_(t, s) {
            return Jl.compare(this._$_currentKey$_, t, s);
        },
        _$CompareValue$_(t, s) {
            return Jl.compare(this._$_lastValue$_, t, s);
        },
        _$IsProcessingSets$_() {
            return 0 < this._$_pendingSets$_;
        },
        _$IsProcessingGets$_() {
            return 0 < this._$_pendingGets$_;
        },
        _$OnAllSetsComplete$_() {
            return !0;
        },
        _$OnAllGetsComplete$_() {
            return !0;
        },
        _$IsPersistent$_() {
            return this._$_isPersistent$_;
        }
    };
}

{
    let i = function(t) {
        return "string" == typeof t || "number" == typeof t;
    };
    i;
    const ql = self._$C3$_;
    ql._$Plugins$_._$LocalStorage$_._$Acts$_ = {
        async _$SetItem$_(t, s) {
            this._$_pendingSets$_++;
            try {
                const i = await this._$_storage$_.setItem(t, s);
                await this._$ScheduleTriggers$_(async () => {
                    this._$_currentKey$_ = t, this._$_lastValue$_ = i, await this._$TriggerAsync$_(ql._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnAnyItemSet$_), 
                    await this._$TriggerAsync$_(ql._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnItemSet$_);
                });
            } catch (t) {
                await this._$_TriggerStorageError$_(t);
            } finally {
                this._$_pendingSets$_--, 0 === this._$_pendingSets$_ && await this._$TriggerAsync$_(ql._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnAllSetsComplete$_);
            }
        },
        async _$SetBinaryItem$_(t, s) {
            if (s) {
                const i = s._$GetFirstPicked$_(this._$_inst$_);
                if (i) {
                    const e = i._$GetSdkInstance$_();
                    if (e) {
                        const h = e.GetArrayBufferReadOnly();
                        this._$_pendingSets$_++;
                        try {
                            await this._$_storage$_.setItem(t, h), await this._$ScheduleTriggers$_(async () => {
                                this._$_currentKey$_ = t, this._$_lastValue$_ = "", 
                                await this._$TriggerAsync$_(ql._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnAnyItemSet$_), 
                                await this._$TriggerAsync$_(ql._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnItemSet$_);
                            });
                        } catch (t) {
                            await this._$_TriggerStorageError$_(t);
                        } finally {
                            this._$_pendingSets$_--, 0 === this._$_pendingSets$_ && await this._$TriggerAsync$_(ql._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnAllSetsComplete$_);
                        }
                    }
                }
            }
        },
        async _$GetItem$_(t) {
            this._$_pendingGets$_++;
            try {
                const s = await this._$_storage$_.getItem(t);
                await this._$ScheduleTriggers$_(async () => {
                    this._$_currentKey$_ = t, this._$_lastValue$_ = i(s) ? s : "", 
                    await this._$TriggerAsync$_(ql._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnAnyItemGet$_), 
                    await this._$TriggerAsync$_(ql._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnItemGet$_);
                });
            } catch (t) {
                await this._$_TriggerStorageError$_(t);
            } finally {
                this._$_pendingGets$_--, 0 === this._$_pendingGets$_ && await this._$TriggerAsync$_(ql._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnAllGetsComplete$_);
            }
        },
        async _$GetBinaryItem$_(s, t) {
            if (t) {
                const i = t._$GetFirstPicked$_(this._$_inst$_);
                if (i) {
                    const e = i._$GetSdkInstance$_();
                    this._$_pendingGets$_++;
                    try {
                        let t = await this._$_storage$_.getItem(s);
                        t = t instanceof ArrayBuffer ? t : new ArrayBuffer(0), await this._$ScheduleTriggers$_(async () => {
                            this._$_lastValue$_ = "", this._$_currentKey$_ = s, 
                            e.SetArrayBufferTransfer(t), await this._$TriggerAsync$_(ql._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnAnyItemGet$_), 
                            await this._$TriggerAsync$_(ql._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnItemGet$_);
                        });
                    } catch (t) {
                        await this._$_TriggerStorageError$_(t);
                    } finally {
                        this._$_pendingGets$_--, 0 === this._$_pendingGets$_ && await this._$TriggerAsync$_(ql._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnAllGetsComplete$_);
                    }
                }
            }
        },
        async _$CheckItemExists$_(t) {
            try {
                const s = await this._$_storage$_.getItem(t);
                await this._$ScheduleTriggers$_(async () => {
                    this._$_currentKey$_ = t, null == s ? (this._$_lastValue$_ = "", 
                    await this._$TriggerAsync$_(ql._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnItemMissing$_)) : (this._$_lastValue$_ = i(s) ? s : "", 
                    await this._$TriggerAsync$_(ql._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnItemExists$_));
                });
            } catch (t) {
                await this._$_TriggerStorageError$_(t);
            }
        },
        async _$RemoveItem$_(t) {
            try {
                await this._$_storage$_.removeItem(t), await this._$ScheduleTriggers$_(async () => {
                    this._$_currentKey$_ = t, this._$_lastValue$_ = "", await this._$TriggerAsync$_(ql._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnAnyItemRemoved$_), 
                    await this._$TriggerAsync$_(ql._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnItemRemoved$_);
                });
            } catch (t) {
                await this._$_TriggerStorageError$_(t);
            }
        },
        async _$ClearStorage$_() {
            try {
                await this._$_storage$_.clear(), await this._$ScheduleTriggers$_(async () => {
                    this._$_currentKey$_ = "", this._$_lastValue$_ = "", ql._$clearArray$_(this._$_keyNamesList$_), 
                    await this._$TriggerAsync$_(ql._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnCleared$_);
                });
            } catch (t) {
                await this._$_TriggerStorageError$_(t);
            }
        },
        async _$GetAllKeyNames$_() {
            try {
                const t = await this._$_storage$_.keys();
                await this._$ScheduleTriggers$_(async () => {
                    this._$_keyNamesList$_ = t, await this._$TriggerAsync$_(ql._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnAllKeyNamesLoaded$_);
                });
            } catch (t) {
                await this._$_TriggerStorageError$_(t);
            }
        },
        async _$RequestPersistent$_() {
            const t = await this._$PostToDOMAsync$_("request-persistent");
            t.isOk && (this._$_isPersistent$_ = t.isPersistent);
        }
    };
}

{
    const Xl = self._$C3$_;
    Xl._$Plugins$_._$LocalStorage$_._$Exps$_ = {
        _$ItemValue$_() {
            return this._$_lastValue$_;
        },
        Key() {
            return this._$_currentKey$_;
        },
        _$KeyCount$_() {
            return this._$_keyNamesList$_.length;
        },
        _$KeyAt$_(t) {
            return (t = Math.floor(t)) < 0 || t >= this._$_keyNamesList$_.length ? "" : this._$_keyNamesList$_[t];
        },
        _$ErrorMessage$_() {
            return this._$_errorMessage$_;
        }
    };
}

{
    const Yl = self._$C3$_;
    Yl._$Plugins$_._$Sprite$_ = class extends Yl._$SDKPluginBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const $l = self._$C3$_, Kl = self._$C3X$_, Zl = [], Ql = ($l._$Plugins$_._$Sprite$_._$Type$_ = class extends $l._$SDKTypeBase$_ {
        constructor(t) {
            super(t), this._$_animations$_ = t._$GetAnimations$_();
        }
        _$Release$_() {
            $l._$clearArray$_(this._$_animations$_), super._$Release$_();
        }
        _$OnCreate$_() {
            for (const t of this._$_animations$_) t._$LoadAllAssets$_(this._$_runtime$_);
        }
        _$LoadTextures$_(s) {
            const i = {
                _$sampling$_: this._$_runtime$_._$GetSampling$_()
            };
            return Promise.all(this._$_animations$_.map(t => t._$LoadAllTextures$_(s, i)));
        }
        _$ReleaseTextures$_() {
            for (const t of this._$_animations$_) t._$ReleaseAllTextures$_();
        }
        _$OnDynamicTextureLoadComplete$_() {
            this._$_UpdateAllCurrentTexture$_();
        }
        _$_UpdateAllCurrentTexture$_() {
            for (const t of this._$_objectClass$_._$instancesIncludingPendingCreate$_()) t._$GetSdkInstance$_()._$_UpdateCurrentTexture$_();
        }
        _$FinishCondition$_(t) {
            $l._$Plugins$_._$Sprite$_._$FinishCollisionCondition$_(this, t);
        }
        _$BeforeRunAction$_(t) {
            Zl.push({
                _$objectClass$_: null,
                _$createHierarchy$_: !1,
                instances: []
            });
        }
        _$_SpawnPickInstance$_(t, s, i) {
            const e = Zl.at(-1);
            e._$objectClass$_ = t, e._$createHierarchy$_ = i, e.instances.push(s);
        }
        _$AfterRunAction$_(t) {
            const s = Zl.pop(), i = s._$objectClass$_, e = s._$createHierarchy$_;
            if (i) {
                const h = new Map();
                for (const r of s.instances) r._$CollectInstancesToPick$_(h, i, e);
                for (const [ n, o ] of h) n._$GetCurrentSol$_()._$SetSetPicked$_(o);
            }
        }
        _$_AddAnimation$_(t) {
            const s = this._$GetObjectClass$_()._$AddAnimation$_(t), i = this._$GetRuntime$_(), e = s._$GetFrameAt$_(0);
            return e._$GetImageInfo$_()._$LoadStaticTexture$_(i._$GetRenderer$_(), {
                _$sampling$_: i._$GetSampling$_()
            }).then(() => this._$_UpdateAllCurrentTexture$_()), s;
        }
        _$_RemoveAnimation$_(t) {
            for (const s of this._$_objectClass$_._$instancesIncludingPendingCreate$_()) s._$GetSdkInstance$_()._$_OnAnimationRemoved$_(t);
            this._$GetObjectClass$_()._$RemoveAnimation$_(t);
        }
        _$_AddAnimationFrame$_(t, s) {
            const i = this._$_objectClass$_._$GetAnimationByName$_(t);
            if (!i) throw new Error(`cannot find animation name '${t}'`);
            let e = i._$FrameTagOrIndexToIndex$_(s);
            e < 0 && (e += i._$GetFrameCount$_() + 1);
            const h = $l._$AnimationFrameInfo$_._$CreateDynamic$_(this._$GetRuntime$_()), r = (i._$InsertFrameAt$_(h, e), 
            this._$GetRuntime$_());
            h._$GetImageInfo$_()._$LoadStaticTexture$_(r._$GetRenderer$_(), {
                _$sampling$_: r._$GetSampling$_()
            }).then(() => this._$_UpdateAllCurrentTexture$_());
            for (const n of this._$_objectClass$_._$instancesIncludingPendingCreate$_()) n._$GetSdkInstance$_()._$_OnAnimationFramesChanged$_();
            return h;
        }
        _$_RemoveAnimationFrame$_(t, s) {
            const i = this._$_objectClass$_._$GetAnimationByName$_(t);
            if (!i) throw new Error(`cannot find animation name '${t}'`);
            if (1 === i._$GetFrameCount$_()) throw new Error(`cannot remove last frame from animation '${t}'`);
            let e = i._$FrameTagOrIndexToIndex$_(s);
            e < 0 && (e += i._$GetFrameCount$_()), i._$RemoveFrameAt$_(e);
            for (const h of this._$_objectClass$_._$instancesIncludingPendingCreate$_()) h._$GetSdkInstance$_()._$_OnAnimationFramesChanged$_();
        }
        _$GetScriptInterfaceClass$_() {
            return self._$ISpriteObjectType$_;
        }
    }, new WeakMap());
    self._$ISpriteObjectType$_ = class extends self._$IObjectClass$_ {
        constructor(t) {
            super(t), Ql.set(this, t._$GetSdkType$_());
        }
        _$getAnimation$_(t) {
            Kl._$RequireString$_(t);
            const s = Ql.get(this)._$GetObjectClass$_()._$GetAnimationByName$_(t);
            return s ? s._$GetIAnimation$_() : null;
        }
        _$getAllAnimations$_() {
            return Ql.get(this)._$GetObjectClass$_()._$GetAllAnimations$_().map(t => t._$GetIAnimation$_());
        }
        _$addAnimation$_(t) {
            return Kl._$RequireString$_(t), Ql.get(this)._$_AddAnimation$_(t)._$GetIAnimation$_();
        }
        _$removeAnimation$_(t) {
            Kl._$RequireString$_(t), Ql.get(this)._$_RemoveAnimation$_(t);
        }
        _$addAnimationFrame$_(t, s) {
            if (Kl._$RequireString$_(t), "number" != typeof s && "string" != typeof s) throw new TypeError("invalid insert location");
            return Ql.get(this)._$_AddAnimationFrame$_(t, s)._$GetIAnimationFrame$_();
        }
        _$removeAnimationFrame$_(t, s) {
            if (Kl._$RequireString$_(t), "number" != typeof s && "string" != typeof s) throw new TypeError("invalid insert location");
            Ql.get(this)._$_RemoveAnimationFrame$_(t, s);
        }
    };
}

{
    const C = self._$C3$_, tu = self._$C3X$_, su = C._$New$_(C.Rect), iu = C._$New$_(C._$Quad$_), eu = C._$New$_(C._$Vector2$_), R = (C._$Plugins$_._$Sprite$_.Instance = class extends C._$SDKWorldInstanceBase$_ {
        constructor(t, s) {
            super(t);
            let i = !0, e = "", h = 0, r = !0;
            s && (i = !!s[0], e = s[1], h = s[2], r = s[3]), this._$_currentAnimation$_ = this._$_objectClass$_._$GetAnimationByName$_(e) || this._$_objectClass$_._$GetAnimations$_()[0], 
            this._$_currentFrameIndex$_ = C._$clamp$_(h, 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1), 
            this._$_currentAnimationFrame$_ = this._$_currentAnimation$_._$GetFrameAt$_(this._$_currentFrameIndex$_);
            const n = this._$_currentAnimationFrame$_._$GetImageInfo$_(), o = (this._$_currentTexture$_ = n._$GetTexture$_(), 
            this._$_currentRcTex$_ = n._$GetTexRect$_(), this._$_currentQuadTex$_ = n._$GetTexQuad$_(), 
            this._$HandleRendererContextLoss$_(), t._$SetFlag$_(2, !0), t._$SetFlag$_(1, 0 <= this._$_currentAnimation$_._$GetSpeed$_()), 
            this._$_currentAnimationSpeed$_ = Math.abs(this._$_currentAnimation$_._$GetSpeed$_()), 
            this._$_currentAnimationRepeatTo$_ = this._$_currentAnimation$_._$GetRepeatTo$_(), 
            this._$_animationTimer$_ = C._$New$_(C._$KahanSum$_), this._$_frameStartTime$_ = 0, 
            this._$_animationRepeats$_ = 0, this._$_animTriggerName$_ = "", this._$_changeAnimFrameIndex$_ = -1, 
            this._$_changeAnimationName$_ = "", this._$_changeAnimationFrom$_ = 0, 
            this._$GetWorldInfo$_());
            this._$_bquadRef$_ = o._$GetBoundingQuad$_(), o._$SetVisible$_(i), o._$SetCollisionEnabled$_(r), 
            o._$SetOriginX$_(this._$_currentAnimationFrame$_._$GetOriginX$_()), 
            o._$SetOriginY$_(this._$_currentAnimationFrame$_._$GetOriginY$_()), 
            o._$SetSourceCollisionPoly$_(this._$_currentAnimationFrame$_._$GetCollisionPoly$_()), 
            o._$SetBboxChanged$_(), 1 === this._$_objectClass$_._$GetAnimationCount$_() && 1 === this._$_objectClass$_._$GetAnimations$_()[0]._$GetFrameCount$_() || 0 === this._$_currentAnimationSpeed$_ || this._$_StartTicking$_();
        }
        _$Release$_() {
            this._$_currentAnimation$_ = null, this._$_currentAnimationFrame$_ = null, 
            this._$_currentTexture$_ = null, this._$_animationTimer$_ = null, super._$Release$_();
        }
        _$GetCurrentImageInfo$_() {
            return this._$_currentAnimationFrame$_._$GetImageInfo$_();
        }
        _$IsOriginalSizeKnown$_() {
            return !0;
        }
        _$OnRendererContextLost$_() {
            this._$_currentTexture$_ = null;
        }
        _$OnRendererContextRestored$_() {
            this._$_UpdateCurrentTexture$_();
        }
        _$Draw$_(t) {
            const s = this._$_currentTexture$_;
            if (null !== s) {
                t._$SetTexture$_(s);
                const i = this._$GetWorldInfo$_();
                i._$HasMesh$_() ? this._$_DrawMesh$_(i, t) : this._$_DrawStandard$_(i, t);
            }
        }
        _$_DrawStandard$_(t, s) {
            let i = this._$_bquadRef$_;
            this._$_runtime$_._$IsPixelRoundingEnabled$_() && (i = t._$PixelRoundQuad$_(i)), 
            s._$Quad4$_(i, this._$_currentQuadTex$_);
        }
        _$_DrawMesh$_(s, t) {
            const i = s._$GetTransformedMesh$_();
            if (s._$IsMeshChanged$_()) {
                s._$CalculateBbox$_(su, iu, !1);
                let t = iu;
                this._$_runtime$_._$IsPixelRoundingEnabled$_() && (t = s._$PixelRoundQuad$_(t)), 
                i._$CalculateTransformedMesh$_(s._$GetSourceMesh$_(), t, this._$_currentQuadTex$_), 
                s._$SetMeshChanged$_(!1);
            }
            i._$Draw$_(t);
        }
        _$GetAnimationTime$_() {
            return this._$_animationTimer$_._$Get$_();
        }
        _$IsAnimationPlaying$_() {
            return this._$_inst$_._$GetFlag$_(2);
        }
        _$SetAnimationPlaying$_(t) {
            this._$_inst$_._$SetFlag$_(2, t);
        }
        _$IsPlayingForwards$_() {
            return this._$_inst$_._$GetFlag$_(1);
        }
        _$SetPlayingForwards$_(t) {
            this._$_inst$_._$SetFlag$_(1, t);
        }
        _$IsInAnimationTrigger$_() {
            return this._$_inst$_._$GetFlag$_(4);
        }
        _$SetInAnimationTrigger$_(t) {
            this._$_inst$_._$SetFlag$_(4, t);
        }
        _$Tick$_() {
            this._$_changeAnimationName$_ && this._$_DoChangeAnimation$_(), 0 <= this._$_changeAnimFrameIndex$_ && this._$_DoChangeAnimFrame$_();
            const t = this._$_currentAnimationSpeed$_;
            if (this._$IsAnimationPlaying$_() && 0 !== t) {
                const s = this._$_runtime$_._$GetDt$_(this._$_inst$_), i = (this._$_animationTimer$_._$Add$_(s), 
                this._$GetAnimationTime$_()), e = this._$_currentAnimationFrame$_, h = e._$GetDuration$_() / t;
                if (!(i < this._$_frameStartTime$_ + h)) {
                    const r = this._$_currentAnimation$_, n = this._$_currentAnimationRepeatTo$_, o = r._$GetFrameCount$_(), a = r._$GetRepeatCount$_(), l = r._$IsLooping$_(), u = r._$IsPingPong$_(), c = (this._$IsPlayingForwards$_() ? this._$_currentFrameIndex$_++ : this._$_currentFrameIndex$_--, 
                    this._$_frameStartTime$_ += h, this._$_currentFrameIndex$_ >= o && (u ? (this._$SetPlayingForwards$_(!1), 
                    this._$_currentFrameIndex$_ = o - 2) : !l && (this._$_animationRepeats$_++, 
                    this._$_animationRepeats$_ >= a) ? this._$_FinishAnimation$_(!1) : this._$_currentFrameIndex$_ = n), 
                    this._$_currentFrameIndex$_ < 0 && (u ? (this._$_currentFrameIndex$_ = 1, 
                    this._$SetPlayingForwards$_(!0), l || (this._$_animationRepeats$_++, 
                    this._$_animationRepeats$_ >= a && this._$_FinishAnimation$_(!0))) : !l && (this._$_animationRepeats$_++, 
                    this._$_animationRepeats$_ >= a) ? this._$_FinishAnimation$_(!0) : this._$_currentFrameIndex$_ = n), 
                    this._$_currentFrameIndex$_ = C._$clamp$_(this._$_currentFrameIndex$_, 0, o - 1), 
                    r._$GetFrameAt$_(this._$_currentFrameIndex$_));
                    i > this._$_frameStartTime$_ + c._$GetDuration$_() / t && (this._$_frameStartTime$_ = i), 
                    this._$_OnFrameChanged$_(e, c);
                }
            } else this._$_StopTicking$_();
        }
        _$_FinishAnimation$_(t) {
            this._$_currentFrameIndex$_ = t ? 0 : this._$_currentAnimation$_._$GetFrameCount$_() - 1, 
            this._$SetAnimationPlaying$_(!1), this._$_animTriggerName$_ = this._$_currentAnimation$_._$GetName$_(), 
            this._$SetInAnimationTrigger$_(!0), this._$DispatchScriptEvent$_("animationend", !1, {
                animationName: this._$_animTriggerName$_
            }), this._$Trigger$_(C._$Plugins$_._$Sprite$_._$Cnds$_._$OnAnyAnimFinished$_), 
            this._$Trigger$_(C._$Plugins$_._$Sprite$_._$Cnds$_._$OnAnimFinished$_), 
            this._$SetInAnimationTrigger$_(!1), this._$_animationRepeats$_ = 0;
        }
        _$_OnFrameChanged$_(i, e, t) {
            if (i !== e) {
                const s = this._$GetWorldInfo$_(), h = i._$GetImageInfo$_(), r = e._$GetImageInfo$_(), n = h._$GetWidth$_(), o = h._$GetHeight$_(), a = r._$GetWidth$_(), l = r._$GetHeight$_(), u = (t && t.onFrameChange ? t.onFrameChange(s, n, o, a, l) : (n !== a && s._$SetWidth$_(s._$GetWidth$_() * (a / n)), 
                o !== l && s._$SetHeight$_(s._$GetHeight$_() * (l / o))), s._$SetOriginX$_(e._$GetOriginX$_()), 
                s._$SetOriginY$_(e._$GetOriginY$_()), s._$SetSourceCollisionPoly$_(e._$GetCollisionPoly$_()), 
                s._$SetBboxChanged$_(), this._$_currentAnimationFrame$_ = e, this._$_currentTexture$_ = r._$GetTexture$_(), 
                this._$_currentRcTex$_ = r._$GetTexRect$_(), this._$_currentQuadTex$_ = r._$GetTexQuad$_(), 
                this._$GetInstance$_()._$GetBehaviorInstances$_());
                for (let t = 0, s = u.length; t < s; ++t) u[t]._$OnSpriteFrameChanged$_(i, e);
                this._$DispatchScriptEvent$_("framechange", !1, {
                    animationName: this._$_currentAnimation$_._$GetName$_(),
                    _$animationFrame$_: this._$_currentFrameIndex$_
                }), this._$Trigger$_(C._$Plugins$_._$Sprite$_._$Cnds$_._$OnFrameChanged$_), 
                this._$_runtime$_._$UpdateRender$_();
            }
        }
        _$_StartAnim$_(t) {
            this._$SetAnimationPlaying$_(!0), this._$_frameStartTime$_ = this._$GetAnimationTime$_(), 
            1 === t && 0 !== this._$_currentFrameIndex$_ && (this._$_changeAnimFrameIndex$_ = 0, 
            this._$IsInAnimationTrigger$_() || this._$_DoChangeAnimFrame$_()), this._$_StartTicking$_();
        }
        _$_SetAnim$_(t, s, i) {
            this._$_changeAnimationName$_ = t, this._$_changeAnimationFrom$_ = s, 
            this._$_StartTicking$_(), !i && this._$IsInAnimationTrigger$_() || this._$_DoChangeAnimation$_();
        }
        _$_GetCurrentAnimation$_() {
            return this._$_currentAnimation$_;
        }
        _$_GetCurrentAnimationName$_() {
            return this._$_changeAnimationName$_ || this._$_currentAnimation$_._$GetName$_();
        }
        _$_OnAnimationRemoved$_(t) {
            C._$equalsNoCase$_(t, this._$_GetCurrentAnimationName$_()) && this._$_SetAnim$_(this._$_objectClass$_._$GetFirstAnimation$_()._$GetName$_(), 1, !0);
        }
        _$_SetAnimFrame$_(t) {
            if ("string" == typeof t) if (String(Number(t)) === t) t = Number(t); else {
                const s = this._$_objectClass$_._$GetAnimationByName$_(this._$_GetCurrentAnimationName$_());
                if (!s) return;
                if (-1 === (t = s._$GetFrameIndexByTag$_(t))) return;
            }
            isFinite(t) && (this._$_changeAnimFrameIndex$_ = t, this._$IsInAnimationTrigger$_() || this._$_DoChangeAnimFrame$_());
        }
        _$_OnAnimationFramesChanged$_() {
            if (!this._$_changeAnimationName$_ && -1 === this._$_changeAnimFrameIndex$_) {
                const t = this._$_currentAnimationFrame$_, s = this._$_currentAnimation$_._$GetFrameAt$_(C._$clamp$_(this._$_currentFrameIndex$_, 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1));
                t !== s && this._$_OnFrameChanged$_(t, s), 1 < this._$_currentAnimation$_._$GetFrameCount$_() && 0 < this._$_currentAnimationSpeed$_ && this._$_StartTicking$_();
            }
        }
        _$_GetAnimFrame$_() {
            return this._$_currentFrameIndex$_;
        }
        _$_GetAnimFrameTag$_() {
            return this._$_currentAnimationFrame$_._$GetTag$_();
        }
        _$_SetAnimSpeed$_(t) {
            this._$_currentAnimationSpeed$_ = Math.abs(t), this._$SetPlayingForwards$_(0 <= t), 
            0 < this._$_currentAnimationSpeed$_ && this._$_StartTicking$_();
        }
        _$_GetAnimSpeed$_() {
            return this._$IsPlayingForwards$_() ? this._$_currentAnimationSpeed$_ : -this._$_currentAnimationSpeed$_;
        }
        _$_SetAnimRepeatToFrame$_(t) {
            "string" == typeof t && -1 === (t = this._$_currentAnimation$_._$GetFrameIndexByTag$_(t)) || (t = C._$clamp$_(Math.floor(t), 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1), 
            this._$_currentAnimationRepeatTo$_ = t);
        }
        _$_GetAnimRepeatToFrame$_() {
            return this._$_currentAnimationRepeatTo$_;
        }
        _$_DoChangeAnimation$_(t) {
            const s = this._$_currentAnimationFrame$_, i = this._$_objectClass$_._$GetAnimationByName$_(this._$_changeAnimationName$_);
            if (this._$_changeAnimationName$_ = "", i && (i !== this._$_currentAnimation$_ || !this._$IsAnimationPlaying$_())) {
                this._$_currentAnimation$_ = i, this._$SetPlayingForwards$_(0 <= i._$GetSpeed$_()), 
                this._$_currentAnimationSpeed$_ = Math.abs(i._$GetSpeed$_()), this._$_currentAnimationRepeatTo$_ = i._$GetRepeatTo$_(), 
                this._$_currentFrameIndex$_ = C._$clamp$_(this._$_currentFrameIndex$_, 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1), 
                1 === this._$_changeAnimationFrom$_ && (this._$_currentFrameIndex$_ = 0), 
                this._$SetAnimationPlaying$_(!0), this._$_frameStartTime$_ = this._$GetAnimationTime$_();
                const e = this._$_currentAnimation$_._$GetFrameAt$_(this._$_currentFrameIndex$_);
                this._$_OnFrameChanged$_(s, e, t);
            }
        }
        _$_DoChangeAnimFrame$_(t) {
            const s = this._$_currentAnimationFrame$_, i = this._$_currentFrameIndex$_;
            if (this._$_currentFrameIndex$_ = C._$clamp$_(Math.floor(this._$_changeAnimFrameIndex$_), 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1), 
            this._$_changeAnimFrameIndex$_ = -1, t || i !== this._$_currentFrameIndex$_) {
                const e = this._$_currentAnimation$_._$GetFrameAt$_(this._$_currentFrameIndex$_);
                this._$_OnFrameChanged$_(s, e), this._$_frameStartTime$_ = this._$GetAnimationTime$_();
            }
        }
        _$_UpdateCurrentTexture$_() {
            const t = this._$_currentAnimationFrame$_._$GetImageInfo$_();
            this._$_currentTexture$_ = t._$GetTexture$_(), this._$_currentRcTex$_ = t._$GetTexRect$_(), 
            this._$_currentQuadTex$_ = t._$GetTexQuad$_(), this._$GetWorldInfo$_()._$SetMeshChanged$_(!0);
        }
        _$GetTexture$_() {
            return this._$_currentTexture$_;
        }
        _$GetTexRect$_() {
            return this._$_currentRcTex$_;
        }
        _$GetTexQuad$_() {
            return this._$_currentQuadTex$_;
        }
        _$GetImagePointCount$_() {
            return this._$_currentAnimationFrame$_._$GetImagePointCount$_();
        }
        _$GetImagePoint$_(t) {
            let s = this._$_currentAnimationFrame$_, i = this._$GetWorldInfo$_(), e = null;
            if ("string" == typeof t) e = s._$GetImagePointByName$_(t); else {
                if ("number" != typeof t) throw new TypeError("expected string or number");
                e = s._$GetImagePointByIndex$_(t - 1);
            }
            let h = i._$GetTotalZElevation$_();
            if (!e) return [ i._$GetX$_(), i._$GetY$_(), h ];
            if (eu._$copy$_(e._$GetVec2$_()), i._$HasMesh$_()) {
                const [ r, n, o ] = i._$GetSourceMesh$_()._$TransformPoint$_(eu._$getX$_(), eu._$getY$_());
                eu.set(r, n), h += o;
            }
            return eu.offset(-s._$GetOriginX$_(), -s._$GetOriginY$_()), eu.scale(i._$GetWidth$_(), i._$GetHeight$_()), 
            eu.rotate(i._$GetAngle$_()), eu.offset(i._$GetX$_(), i._$GetY$_()), 
            [ eu._$getX$_(), eu._$getY$_(), h ];
        }
        _$GetCollisionPolyPointCount$_() {
            return this._$GetWorldInfo$_()._$GetTransformedCollisionPoly$_()._$pointCount$_();
        }
        _$GetCollisionPolyPoint$_(t) {
            t = Math.floor(t);
            const s = this._$GetWorldInfo$_(), i = s._$GetTransformedCollisionPoly$_(), e = i._$pointCount$_();
            if ((t = t === e ? 0 : t) < 0 || e <= t) return [ 0, 0 ];
            const h = i._$pointsArr$_();
            return [ h[2 * t + 0] + s._$GetX$_(), h[2 * t + 1] + s._$GetY$_() ];
        }
        _$GetDebuggerProperties$_() {
            const s = C._$Plugins$_._$Sprite$_._$Acts$_, t = "plugins.sprite.debugger.animation-properties";
            return [ {
                title: t + ".title",
                properties: [ {
                    name: t + ".current-animation",
                    value: this._$_currentAnimation$_._$GetName$_(),
                    _$onedit$_: t => this._$CallAction$_(s._$SetAnim$_, t, 0)
                }, {
                    name: t + ".current-frame",
                    value: this._$_currentFrameIndex$_,
                    _$onedit$_: t => this._$CallAction$_(s._$SetAnimFrame$_, t)
                }, {
                    name: t + ".is-playing",
                    value: this._$IsAnimationPlaying$_(),
                    _$onedit$_: t => t ? this._$CallAction$_(s._$StartAnim$_, 0) : this._$CallAction$_(s._$StopAnim$_)
                }, {
                    name: t + ".speed",
                    value: this._$_currentAnimationSpeed$_,
                    _$onedit$_: t => this._$CallAction$_(s._$SetAnimSpeed$_, t)
                }, {
                    name: t + ".repeats",
                    value: this._$_animationRepeats$_,
                    _$onedit$_: t => this._$_animationRepeats$_ = t
                } ]
            } ];
        }
        _$SaveToJson$_() {
            const t = {
                a: this._$_currentAnimation$_._$GetSID$_()
            }, s = (0 !== this._$_frameStartTime$_ && (t.fs = this._$_frameStartTime$_), 
            this._$GetAnimationTime$_()), i = (0 !== s && (t.at = s), 0 !== this._$_currentFrameIndex$_ && (t.f = this._$_currentFrameIndex$_), 
            0 !== this._$_currentAnimationSpeed$_ && (t.cas = this._$_currentAnimationSpeed$_), 
            1 !== this._$_animationRepeats$_ && (t.ar = this._$_animationRepeats$_), 
            0 !== this._$_currentAnimationRepeatTo$_ && (t.rt = this._$_currentAnimationRepeatTo$_), 
            this._$IsAnimationPlaying$_() || (t.ap = this._$IsAnimationPlaying$_()), 
            this._$IsPlayingForwards$_() || (t.af = this._$IsPlayingForwards$_()), 
            this._$GetWorldInfo$_());
            return i._$IsCollisionEnabled$_() && (t.ce = i._$IsCollisionEnabled$_()), 
            t;
        }
        _$LoadFromJson$_(t) {
            const s = this._$GetObjectClass$_()._$GetAnimationBySID$_(t.a), i = (s && (this._$_currentAnimation$_ = s), 
            this._$_frameStartTime$_ = t.hasOwnProperty("fs") ? t.fs : 0, this._$_animationTimer$_.Set(t.hasOwnProperty("at") ? t.at : 0), 
            t.hasOwnProperty("f") ? t.f : 0), e = (this._$_currentFrameIndex$_ = C._$clamp$_(i, 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1), 
            this._$_currentAnimationSpeed$_ = t.hasOwnProperty("cas") ? t.cas : 0, 
            this._$_animationRepeats$_ = t.hasOwnProperty("ar") ? t.ar : 1, t.hasOwnProperty("rt") ? t.rt : 0), h = (this._$_currentAnimationRepeatTo$_ = C._$clamp$_(e, 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1), 
            this._$SetAnimationPlaying$_(!t.hasOwnProperty("ap") || !!t.ap), this._$SetPlayingForwards$_(!t.hasOwnProperty("af") || !!t.af), 
            this._$_currentAnimation$_._$GetFrameAt$_(this._$_currentFrameIndex$_)), r = (this._$_currentAnimationFrame$_ = h, 
            this._$_UpdateCurrentTexture$_(), this._$GetWorldInfo$_());
            r._$SetOriginX$_(h._$GetOriginX$_()), r._$SetOriginY$_(h._$GetOriginY$_()), 
            r._$SetSourceCollisionPoly$_(h._$GetCollisionPoly$_()), r._$SetCollisionEnabled$_(!!t.ce), 
            this._$IsAnimationPlaying$_() && this._$_StartTicking$_();
        }
        _$GetPropertyValueByIndex$_(t) {
            const s = this._$GetWorldInfo$_();
            switch (t) {
              case 3:
                return s._$IsCollisionEnabled$_();

              case 2:
                return C._$clamp$_(this._$_currentFrameIndex$_, 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1);

              case 1:
                return this._$_currentAnimation$_._$GetName$_();
            }
        }
        _$SetPropertyValueByIndex$_(t, s, i) {
            const e = this._$GetWorldInfo$_();
            switch (t) {
              case 3:
                e._$SetCollisionEnabled$_(!!s);
                break;

              case 2:
                {
                    this._$SetAnimationPlaying$_(!1);
                    const h = this._$_currentAnimation$_._$GetFrameCount$_() - 1, r = s = C._$clamp$_(s, 0, h), n = this._$_currentAnimation$_._$GetFrameAt$_(this._$_currentFrameIndex$_), o = this._$_currentAnimation$_._$GetFrameAt$_(r);
                    this._$_OnFrameChanged$_(n, o, i), this._$_currentFrameIndex$_ = C._$clamp$_(r, 0, h);
                    break;
                }

              case 1:
                {
                    this._$_changeAnimationName$_ = s, this._$_DoChangeAnimation$_(i);
                    const a = this._$_currentAnimation$_._$GetFrameCount$_();
                    1 < a && 0 < this._$_currentAnimation$_._$GetSpeed$_() ? this._$_StartTicking$_() : this._$_StopTicking$_();
                    break;
                }
            }
        }
        _$GetScriptInterfaceClass$_() {
            return self._$ISpriteInstance$_;
        }
    }, new WeakMap()), hu = new Map([ [ "current-frame", 0 ], [ "beginning", 1 ] ]);
    self._$ISpriteInstance$_ = class extends self._$IWorldInstance$_ {
        constructor() {
            super(), R.set(this, self._$IInstance$_._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        _$getImagePointCount$_() {
            return R.get(this)._$GetImagePointCount$_();
        }
        _$getImagePointX$_(t) {
            return this._$getImagePoint$_(t)[0];
        }
        _$getImagePointY$_(t) {
            return this._$getImagePoint$_(t)[1];
        }
        _$getImagePointZ$_(t) {
            return this._$getImagePoint$_(t)[2];
        }
        _$getImagePoint$_(t) {
            if ("string" != typeof t && "number" != typeof t) throw new TypeError("expected string or number");
            return R.get(this)._$GetImagePoint$_(t);
        }
        _$getPolyPointCount$_() {
            return R.get(this)._$GetCollisionPolyPointCount$_();
        }
        _$getPolyPointX$_(t) {
            return tu._$RequireFiniteNumber$_(t), R.get(this)._$GetCollisionPolyPoint$_(t)[0];
        }
        _$getPolyPointY$_(t) {
            return tu._$RequireFiniteNumber$_(t), R.get(this)._$GetCollisionPolyPoint$_(t)[1];
        }
        _$getPolyPoint$_(t) {
            return tu._$RequireFiniteNumber$_(t), R.get(this)._$GetCollisionPolyPoint$_(t);
        }
        _$stopAnimation$_() {
            R.get(this)._$SetAnimationPlaying$_(!1);
        }
        _$startAnimation$_(t = "current-frame") {
            tu._$RequireString$_(t);
            const s = hu.get(t);
            if (void 0 === s) throw new Error("invalid mode");
            R.get(this)._$_StartAnim$_(s);
        }
        _$setAnimation$_(t, s = "beginning") {
            tu._$RequireString$_(t), tu._$RequireString$_(s);
            const i = hu.get(s);
            if (void 0 === i) throw new Error("invalid mode");
            const e = R.get(this);
            if (!e._$GetObjectClass$_()._$GetAnimationByName$_(t)) throw new Error(`animation name "${t}" does not exist`);
            e._$_SetAnim$_(t, i);
        }
        _$getAnimation$_(t) {
            tu._$RequireString$_(t);
            const s = R.get(this)._$GetObjectClass$_()._$GetAnimationByName$_(t);
            return s ? s._$GetIAnimation$_() : null;
        }
        get animation() {
            return R.get(this)._$_GetCurrentAnimation$_()._$GetIAnimation$_();
        }
        get animationName() {
            return R.get(this)._$_GetCurrentAnimationName$_();
        }
        set _$animationFrame$_(t) {
            tu._$RequireFiniteNumber$_(t), R.get(this)._$_SetAnimFrame$_(t);
        }
        get _$animationFrame$_() {
            return R.get(this)._$_GetAnimFrame$_();
        }
        set _$animationFrameTag$_(t) {
            tu._$RequireString$_(t), R.get(this)._$_SetAnimFrame$_(t);
        }
        get _$animationFrameTag$_() {
            return R.get(this)._$_GetAnimFrameTag$_();
        }
        set _$animationSpeed$_(t) {
            tu._$RequireFiniteNumber$_(t), R.get(this)._$_SetAnimSpeed$_(t);
        }
        get _$animationSpeed$_() {
            return R.get(this)._$_GetAnimSpeed$_();
        }
        set _$animationRepeatToFrame$_(t) {
            tu._$RequireFiniteNumber$_(t), R.get(this)._$_SetAnimRepeatToFrame$_(t);
        }
        get _$animationRepeatToFrame$_() {
            return R.get(this)._$_GetAnimRepeatToFrame$_();
        }
        get imageWidth() {
            return R.get(this)._$GetCurrentImageInfo$_()._$GetWidth$_();
        }
        get imageHeight() {
            return R.get(this)._$GetCurrentImageInfo$_()._$GetHeight$_();
        }
        _$getImageSize$_() {
            const t = R.get(this)._$GetCurrentImageInfo$_();
            return [ t._$GetWidth$_(), t._$GetHeight$_() ];
        }
        async _$replaceCurrentAnimationFrame$_(t) {
            tu._$RequireInstanceOf$_(t, Blob);
            const s = R.get(this), i = s._$GetRuntime$_(), e = s._$GetCurrentImageInfo$_(), h = C._$New$_(C._$ImageInfo$_);
            if (h._$LoadDynamicBlobAsset$_(i, t), await h._$LoadStaticTexture$_(i._$GetRenderer$_(), {
                _$sampling$_: i._$GetSampling$_()
            }), s._$WasReleased$_()) h._$Release$_(); else {
                e._$ReplaceWith$_(h);
                const r = s._$GetSdkType$_();
                r._$_UpdateAllCurrentTexture$_(), r._$GetObjectClass$_()._$Dispatcher$_().dispatchEvent(new C.Event("animationframeimagechange")), 
                i._$UpdateRender$_();
            }
        }
        _$setSolidCollisionFilter$_(t, s) {
            tu._$RequireString$_(s), R.get(this)._$GetWorldInfo$_()._$SetSolidCollisionFilter$_(!!t, s);
        }
    };
}

{
    const ru = self._$C3$_;
    ru._$Plugins$_._$Sprite$_._$Cnds$_ = {
        _$IsAnimPlaying$_(t) {
            return ru._$equalsNoCase$_(this._$_GetCurrentAnimationName$_(), t);
        },
        _$CompareFrame$_(t, s) {
            return ru.compare(this._$_currentFrameIndex$_, t, s);
        },
        _$CompareFrameTag$_(t, s) {
            if ("string" != typeof s) return !1;
            const i = this._$_currentAnimationFrame$_._$GetTag$_();
            return ru.compare(i.toLowerCase(), t, s.toLowerCase());
        },
        _$CompareAnimSpeed$_(t, s) {
            return ru.compare(this._$_GetAnimSpeed$_(), t, s);
        },
        _$OnAnimFinished$_(t) {
            return ru._$equalsNoCase$_(this._$_animTriggerName$_, t);
        },
        _$OnAnyAnimFinished$_() {
            return !0;
        },
        _$OnFrameChanged$_() {
            return !0;
        },
        _$IsMirrored$_() {
            return this._$GetWorldInfo$_()._$GetWidth$_() < 0;
        },
        _$IsFlipped$_() {
            return this._$GetWorldInfo$_()._$GetHeight$_() < 0;
        },
        _$OnURLLoaded$_() {
            return !0;
        },
        _$OnURLFailed$_() {
            return !0;
        },
        _$IsCollisionEnabled$_() {
            return this._$GetWorldInfo$_()._$IsCollisionEnabled$_();
        }
    };
}

{
    const nu = self._$C3$_;
    nu._$Plugins$_._$Sprite$_._$Acts$_ = {
        _$Spawn$_(t, s, i, e, h) {
            if (t && s) {
                const [ r, n ] = this._$GetImagePoint$_(i), o = this._$_runtime$_._$CreateInstance$_(t, s, r, n, e, h);
                if (o) {
                    if (e && s._$SortAndAddInstancesByZIndex$_(o), t._$GetPlugin$_()._$IsRotatable$_()) {
                        const l = o._$GetWorldInfo$_();
                        l._$SetAngle$_(this._$GetWorldInfo$_()._$GetAngle$_()), 
                        l._$SetBboxChanged$_();
                    }
                    const a = this._$_runtime$_._$GetEventSheetManager$_();
                    a._$BlockFlushingInstances$_(!0), o._$_TriggerOnCreatedOnSelfAndRelated$_(), 
                    a._$BlockFlushingInstances$_(!1), t !== this._$_runtime$_._$GetCurrentAction$_()._$GetObjectClass$_() && this._$_sdkType$_._$_SpawnPickInstance$_(t, o, e);
                }
            }
        },
        _$StopAnim$_() {
            this._$SetAnimationPlaying$_(!1);
        },
        _$StartAnim$_(t) {
            this._$_StartAnim$_(t);
        },
        _$SetAnim$_(t, s) {
            this._$_SetAnim$_(t, s);
        },
        _$SetAnimFrame$_(t) {
            this._$_SetAnimFrame$_(t);
        },
        _$SetAnimSpeed$_(t) {
            this._$_SetAnimSpeed$_(t);
        },
        _$SetAnimRepeatToFrame$_(t) {
            this._$_SetAnimRepeatToFrame$_(t);
        },
        _$AddRemoveAnimation$_(s, t) {
            try {
                0 === s ? this._$GetSdkType$_()._$_AddAnimation$_(t) : this._$GetSdkType$_()._$_RemoveAnimation$_(t);
            } catch (t) {
                console.error(`[Construct] Error ${0 === s ? "adding" : "removing"} animation: `, t);
            }
        },
        _$AddRemoveAnimationFrame$_(s, t, i) {
            try {
                0 === s ? this._$GetSdkType$_()._$_AddAnimationFrame$_(t, i) : this._$GetSdkType$_()._$_RemoveAnimationFrame$_(t, i);
            } catch (t) {
                console.error(`[Construct] Error ${0 === s ? "adding" : "removing"} animation frame: `, t);
            }
        },
        _$SetMirrored$_(t) {
            const s = this._$GetWorldInfo$_(), i = s._$GetWidth$_(), e = Math.abs(i) * (0 === t ? -1 : 1);
            i !== e && (s._$SetWidth$_(e), s._$SetBboxChanged$_());
        },
        _$SetFlipped$_(t) {
            const s = this._$GetWorldInfo$_(), i = s._$GetHeight$_(), e = Math.abs(i) * (0 === t ? -1 : 1);
            i !== e && (s._$SetHeight$_(e), s._$SetBboxChanged$_());
        },
        _$SetScale$_(t) {
            const s = this._$_currentAnimationFrame$_, i = s._$GetImageInfo$_(), e = this._$GetWorldInfo$_(), h = e._$GetWidth$_() < 0 ? -1 : 1, r = e._$GetHeight$_() < 0 ? -1 : 1, n = i._$GetWidth$_() * t * h, o = i._$GetHeight$_() * t * r;
            e._$GetWidth$_() === n && e._$GetHeight$_() === o || (e._$SetSize$_(n, o), 
            e._$SetBboxChanged$_());
        },
        async _$LoadURL$_(t, s, i) {
            const e = this._$_currentAnimationFrame$_, h = e._$GetImageInfo$_(), r = this._$GetWorldInfo$_(), n = this._$_runtime$_, o = this._$_sdkType$_;
            if (h._$GetURL$_() === t) 0 === s && (r._$SetSize$_(h._$GetWidth$_(), h._$GetHeight$_()), 
            r._$SetBboxChanged$_()), this._$Trigger$_(nu._$Plugins$_._$Sprite$_._$Cnds$_._$OnURLLoaded$_); else {
                const a = nu._$New$_(nu._$ImageInfo$_);
                try {
                    if (await a._$LoadDynamicAsset$_(n, t), !a._$IsLoaded$_()) throw new Error("image failed to load");
                    if (this._$WasReleased$_()) return void a._$Release$_();
                    await a._$LoadStaticTexture$_(n._$GetRenderer$_(), {
                        _$sampling$_: n._$GetSampling$_()
                    });
                } catch (t) {
                    return console.error("Load image from URL failed: ", t), void (this._$WasReleased$_() || this._$Trigger$_(nu._$Plugins$_._$Sprite$_._$Cnds$_._$OnURLFailed$_));
                }
                this._$WasReleased$_() ? a._$Release$_() : (h._$ReplaceWith$_(a), 
                o._$_UpdateAllCurrentTexture$_(), o._$GetObjectClass$_()._$Dispatcher$_().dispatchEvent(new nu.Event("animationframeimagechange")), 
                n._$UpdateRender$_(), 0 === s && (r._$SetSize$_(h._$GetWidth$_(), h._$GetHeight$_()), 
                r._$SetBboxChanged$_()), await this._$TriggerAsync$_(nu._$Plugins$_._$Sprite$_._$Cnds$_._$OnURLLoaded$_));
            }
        },
        _$SetCollisions$_(t) {
            this._$GetWorldInfo$_()._$SetCollisionEnabled$_(t);
        },
        _$SetSolidCollisionFilter$_(t, s) {
            this._$GetWorldInfo$_()._$SetSolidCollisionFilter$_(0 === t, s);
        },
        _$SetEffect$_(t) {
            this._$GetWorldInfo$_()._$SetBlendMode$_(t), this._$_runtime$_._$UpdateRender$_();
        }
    };
}

{
    const ou = self._$C3$_;
    ou._$Plugins$_._$Sprite$_._$Exps$_ = {
        _$AnimationFrame$_() {
            return this._$_GetAnimFrame$_();
        },
        _$AnimationFrameTag$_() {
            return this._$_GetAnimFrameTag$_();
        },
        _$AnimationFrameCount$_() {
            return this._$_currentAnimation$_._$GetFrameCount$_();
        },
        _$AnimationName$_() {
            return this._$_currentAnimation$_._$GetName$_();
        },
        _$AnimationSpeed$_() {
            return this._$_GetAnimSpeed$_();
        },
        _$OriginalAnimationSpeed$_() {
            return this._$_currentAnimation$_._$GetSpeed$_();
        },
        _$ImagePointX$_(t) {
            return this._$GetImagePoint$_(t)[0];
        },
        _$ImagePointY$_(t) {
            return this._$GetImagePoint$_(t)[1];
        },
        _$ImagePointZ$_(t) {
            return this._$GetImagePoint$_(t)[2];
        },
        _$ImagePointCount$_() {
            return this._$GetImagePointCount$_();
        },
        _$ImageWidth$_() {
            return this._$GetCurrentImageInfo$_()._$GetWidth$_();
        },
        _$ImageHeight$_() {
            return this._$GetCurrentImageInfo$_()._$GetHeight$_();
        },
        _$PolyPointXAt$_(t) {
            return this._$GetCollisionPolyPoint$_(t)[0];
        },
        _$PolyPointYAt$_(t) {
            return this._$GetCollisionPolyPoint$_(t)[1];
        },
        _$PolyPointCount$_() {
            return this._$GetCollisionPolyPointCount$_();
        }
    };
}

{
    const au = self._$C3$_;
    au._$Plugins$_._$Tilemap$_ = class extends au._$SDKPluginBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    }, au._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_HORIZONTAL$_ = -2147483648, au._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_VERTICAL$_ = 1073741824, 
    au._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_DIAGONAL$_ = 536870912, au._$Plugins$_._$Tilemap$_._$TILE_FLAGS_MASK$_ = 3758096384, 
    au._$Plugins$_._$Tilemap$_._$TILE_ID_MASK$_ = 536870911;
}

{
    const lu = self._$C3$_, uu = lu._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_HORIZONTAL$_, cu = lu._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_VERTICAL$_, fu = lu._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_DIAGONAL$_, du = lu._$Plugins$_._$Tilemap$_._$TILE_ID_MASK$_;
    lu._$Plugins$_._$Tilemap$_._$Type$_ = class extends lu._$SDKTypeBase$_ {
        constructor(t) {
            super(t), this._$_tilePolys$_ = [], this._$_areTilePolysCached$_ = !1, 
            this._$_maxTileIndex$_ = 0, this._$_brushesData$_ = [], this._$_nameToIndexMap$_ = null;
        }
        _$Release$_() {
            this._$_nameToIndexMap$_.clear(), this._$_nameToIndexMap$_ = null, super._$Release$_();
        }
        _$OnCreate$_() {
            this._$GetImageInfo$_()._$LoadAsset$_(this._$_runtime$_);
        }
        _$LoadTextures$_(t) {
            return this._$GetImageInfo$_()._$LoadStaticTexture$_(t, {
                _$sampling$_: this._$_runtime$_._$GetSampling$_()
            });
        }
        _$ReleaseTextures$_() {
            this._$GetImageInfo$_()._$ReleaseTexture$_();
        }
        _$OnDynamicTextureLoadComplete$_() {
            for (const t of this._$GetObjectClass$_()._$instancesIncludingPendingCreate$_()) t._$GetSdkInstance$_()._$_OnDynamicTextureLoadComplete$_();
        }
        _$LoadTilemapData$_(t, s, i) {
            this._$_maxTileIndex$_ = s;
            for (const e of t) if (e) {
                const h = e[0], r = !!e[1];
                this._$_tilePolys$_.push({
                    _$poly$_: h,
                    use: r,
                    _$flipmap$_: [ [ [ null, null ], [ null, null ] ], [ [ null, null ], [ null, null ] ] ]
                });
            } else this._$_tilePolys$_.push(null);
            for (const n of i) {
                const o = n[0], a = n[1], l = n[2];
                this._$_brushesData$_.push({
                    name: o,
                    type: a,
                    _$tileData$_: l
                });
            }
        }
        _$_ForceCacheOfTileCollisionPolys$_(t, s) {
            this._$_areTilePolysCached$_ = !1, this._$_MaybeCacheTileCollisionPolys$_(t, s);
        }
        _$_MaybeCacheTileCollisionPolys$_(i, e) {
            if (!this._$_areTilePolysCached$_) {
                this._$_areTilePolysCached$_ = !0;
                for (let t = 0, s = this._$_tilePolys$_.length; t < s; ++t) this._$_tilePolys$_[t] && (this._$_CacheTilePoly$_(t, i, e, !1, !1, !1), 
                this._$_CacheTilePoly$_(t, i, e, !1, !1, !0), this._$_CacheTilePoly$_(t, i, e, !1, !0, !1), 
                this._$_CacheTilePoly$_(t, i, e, !1, !0, !0), this._$_CacheTilePoly$_(t, i, e, !0, !1, !1), 
                this._$_CacheTilePoly$_(t, i, e, !0, !1, !0), this._$_CacheTilePoly$_(t, i, e, !0, !0, !1), 
                this._$_CacheTilePoly$_(t, i, e, !0, !0, !0));
            }
        }
        _$_CacheTilePoly$_(t, s, i, e, h, r) {
            if (!(t < 0 || t >= this._$_tilePolys$_.length)) {
                const n = this._$_tilePolys$_[t];
                if (n) {
                    const o = lu._$New$_(lu._$CollisionPoly$_, n._$poly$_, n.use);
                    o.transform(s, i, 0), r && o._$diag$_(), e && o._$mirror$_(s / 2), 
                    h && o._$flip$_(i / 2), n._$flipmap$_[e ? 1 : 0][h ? 1 : 0][r ? 1 : 0] = null, 
                    n._$flipmap$_[e ? 1 : 0][h ? 1 : 0][r ? 1 : 0] = o;
                }
            }
        }
        _$GetTilePoly$_(t) {
            if (-1 === t) return null;
            const s = t & du;
            if (s < 0 || s >= this._$_tilePolys$_.length) return null;
            const i = this._$_tilePolys$_[s];
            if (!i) return null;
            const e = t & uu ? 1 : 0, h = t & cu ? 1 : 0, r = t & fu ? 1 : 0;
            return i._$flipmap$_[e][h][r];
        }
        _$IsTilePolyEnabled$_(t) {
            return !t || t._$IsEnabled$_();
        }
        _$GetMaxTileIndex$_() {
            return this._$_maxTileIndex$_;
        }
        _$GetBrushData$_(s) {
            this._$_nameToIndexMap$_ || (this._$_nameToIndexMap$_ = new Map());
            const t = this._$_nameToIndexMap$_.get(s);
            if ("number" == typeof t && 0 <= t) return this._$_brushesData$_[t];
            for (let t = 0; t < this._$_brushesData$_.length; t++) if (this._$_brushesData$_[t].name === s) return this._$_nameToIndexMap$_.set(s, t), 
            this._$_brushesData$_[t];
        }
    };
}

{
    let s = function(t) {
        const e = [], i = t.split(",");
        for (let t = 0, s = i.length; t < s; ++t) {
            const h = i[t], r = h.indexOf("x");
            if (-1 < r) {
                let t = parseInt(h.substring(0, r), 10), s = h.substring(r + 1), i = parseInt(s, 10);
                for (s.includes("h") && (i |= gu), s.includes("v") && (i |= yu), 
                s.includes("d") && (i |= wu); 0 < t; --t) e.push(i);
            } else {
                let t = parseInt(h, 10);
                h.includes("h") && (t |= gu), h.includes("v") && (t |= yu), h.includes("d") && (t |= wu), 
                e.push(t);
            }
        }
        return e;
    };
    s;
    const pu = self._$C3$_, mu = self._$C3X$_, gu = pu._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_HORIZONTAL$_, yu = pu._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_VERTICAL$_, wu = pu._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_DIAGONAL$_, Su = pu._$Plugins$_._$Tilemap$_._$TILE_FLAGS_MASK$_, bu = pu._$Plugins$_._$Tilemap$_._$TILE_ID_MASK$_, Mu = pu._$New$_(pu.Rect), vu = pu._$New$_(pu.Rect), xu = pu._$New$_(pu.Rect), Gu = (pu._$Plugins$_._$Tilemap$_.Instance = class extends pu._$SDKWorldInstanceBase$_ {
        constructor(t, s) {
            super(t);
            const i = this._$GetWorldInfo$_();
            this._$_tileWidth$_ = 32, this._$_tileHeight$_ = 32, this._$_tileXoffset$_ = 0, 
            this._$_tileYoffset$_ = 0, this._$_tileXspacing$_ = 0, this._$_tileYspacing$_ = 0, 
            this._$_mapWidth$_ = 0, this._$_mapHeight$_ = 0, this._$_lastWidth$_ = i._$GetWidth$_(), 
            this._$_lastHeight$_ = i._$GetHeight$_(), this._$_cellWidth$_ = 0, this._$_cellHeight$_ = 0, 
            this._$_tileCells$_ = [], this._$_tileTexQuads$_ = new Map(), this._$_isAnyQuadMapChanged$_ = !0, 
            this._$_ownImageInfo$_ = null, s && (i._$SetVisible$_(s[0]), this._$_tileWidth$_ = Math.max(s[1], 1), 
            this._$_tileHeight$_ = Math.max(s[2], 1), this._$_tileXoffset$_ = s[3], 
            this._$_tileYoffset$_ = s[4], this._$_tileXspacing$_ = s[5], this._$_tileYspacing$_ = s[6]), 
            this._$_cellWidth$_ = Math.ceil(this._$_runtime$_._$GetOriginalViewportWidth$_() / this._$_tileWidth$_), 
            this._$_cellHeight$_ = Math.ceil(this._$_runtime$_._$GetOriginalViewportHeight$_() / this._$_tileHeight$_), 
            this._$_sdkType$_._$_MaybeCacheTileCollisionPolys$_(this._$_tileWidth$_, this._$_tileHeight$_), 
            this._$_autoTiling$_ = null;
        }
        _$Release$_() {
            this._$_ReleaseOwnImage$_(), pu._$clearArray$_(this._$_tileCells$_), 
            this._$_tileCells$_ = null, this._$_tileTexQuads$_.clear(), this._$_tileTexQuads$_ = null, 
            super._$Release$_();
        }
        _$_ReleaseOwnImage$_() {
            this._$_ownImageInfo$_ && (this._$_ownImageInfo$_._$Release$_(), this._$_ownImageInfo$_ = null);
        }
        _$LoadTilemapData$_(t, s, i) {
            this._$_mapWidth$_ = s, this._$_mapHeight$_ = i, this._$_MaybeResizeTilemap$_(!0), 
            this._$SetTilesFromRLECSV$_(t), this._$_MaybeBuildAllQuadMap$_();
        }
        _$_MaybeResizeTilemap$_(t) {
            const [ s, h ] = this._$GetMapDisplaySize$_();
            if (!(s <= this._$_mapWidth$_ && h <= this._$_mapHeight$_) || t) {
                let i = 0, e = 0;
                t ? (i = Math.ceil(this._$_mapHeight$_ / this._$_cellHeight$_), 
                e = Math.ceil(this._$_mapWidth$_ / this._$_cellWidth$_)) : (i = this._$_tileCells$_.length, 
                e = Math.ceil(this._$_mapWidth$_ / this._$_cellWidth$_), h > this._$_mapHeight$_ && (this._$_mapHeight$_ = h, 
                i = Math.ceil(this._$_mapHeight$_ / this._$_cellHeight$_)), s > this._$_mapWidth$_ && (this._$_mapWidth$_ = s, 
                e = Math.ceil(this._$_mapWidth$_ / this._$_cellWidth$_)), this._$_SetAllQuadMapChanged$_(), 
                this._$_SetPhysicsChanged$_(), this._$_runtime$_._$UpdateRender$_());
                const r = this._$_tileCells$_;
                if (r.length < i) for (let t = r.length; t < i; ++t) r.push([]);
                for (let s = 0; s < i; ++s) {
                    const n = r[s];
                    for (let t = n.length; t < e; ++t) n.push(pu._$New$_(pu._$Plugins$_._$Tilemap$_._$TileCell$_, this, t, s));
                }
            }
        }
        _$SetTilesFromRLECSV$_(t) {
            let i = s(t), e = 0, h = this._$_mapWidth$_, r = this._$_cellWidth$_, n = this._$_cellHeight$_;
            for (let s = 0, t = this._$_mapHeight$_; s < t; ++s) for (let t = 0; t < h; ++t) {
                const o = i[e++], a = this._$GetCellAt$_(t, s);
                a && a._$SetTileAt$_(t % r, s % n, o);
            }
        }
        _$GetTilesAsRLECSV$_() {
            let l = "";
            if (!(this._$_mapWidth$_ <= 0 || this._$_mapHeight$_ <= 0)) {
                let i = 1, e = this._$GetTileAt$_(0, 0), [ h, t ] = this._$GetMapDisplaySize$_(), r = -1, n = !1, o = !1, a = !1;
                for (let s = 0; s < t; ++s) for (let t = 0 === s ? 1 : 0; t < h; ++t) {
                    const u = this._$GetTileAt$_(t, s);
                    u === e ? ++i : (a = -1 === e ? (r = -1, n = !1, o = !1) : (r = e & bu, 
                    n = 0 != (e & gu), o = 0 != (e & yu), 0 != (e & wu)), 1 === i ? l += "" + r : l += i + "x" + r, 
                    n && (l += "h"), o && (l += "v"), a && (l += "d"), l += ",", 
                    i = 1, e = u);
                }
                a = -1 === e ? (r = -1, n = !1, o = !1) : (r = e & bu, n = 0 != (e & gu), 
                o = 0 != (e & yu), 0 != (e & wu)), 1 === i ? l += "" + r : l += i + "x" + r, 
                n && (l += "h"), o && (l += "v"), a && (l += "d");
            }
            return l;
        }
        _$_SetAllQuadMapChanged$_() {
            const i = this._$_tileCells$_;
            for (let t = 0, s = i.length; t < s; ++t) {
                const e = i[t];
                for (let t = 0, s = e.length; t < s; ++t) e[t]._$_SetQuadMapChanged$_();
            }
            this._$_isAnyQuadMapChanged$_ = !0;
        }
        _$_MaybeBuildAllQuadMap$_() {
            if (this._$_isAnyQuadMapChanged$_) {
                this._$_isAnyQuadMapChanged$_ = !1;
                const i = this._$_tileCells$_;
                for (let t = 0, s = i.length; t < s; ++t) {
                    const e = i[t];
                    for (let t = 0, s = e.length; t < s; ++t) e[t]._$MaybeBuildQuadMap$_();
                }
            }
        }
        _$SetTileChanged$_() {
            this._$_isAnyQuadMapChanged$_ = !0, this._$_SetPhysicsChanged$_(), this._$_runtime$_._$UpdateRender$_();
        }
        _$_SetPhysicsChanged$_() {
            this._$GetWorldInfo$_()._$SetPhysicsBodyChanged$_(!0);
        }
        _$GetCellAt$_(t, s) {
            if (t < 0 || s < 0) return null;
            const i = Math.floor(s / this._$_cellHeight$_);
            if (i >= this._$_tileCells$_.length) return null;
            const e = this._$_tileCells$_[i], h = Math.floor(t / this._$_cellWidth$_);
            return h >= e.length ? null : e[h];
        }
        _$GetCellAtIndex$_(t, s) {
            if (t < 0 || s < 0 || s >= this._$_tileCells$_.length) return null;
            const i = this._$_tileCells$_[s];
            return t >= i.length ? null : i[t];
        }
        _$GetTileAt$_(t, s) {
            if (t = Math.floor(t), s = Math.floor(s), t < 0 || s < 0 || t >= this._$_mapWidth$_ || s >= this._$_mapHeight$_) return -1;
            const i = this._$GetCellAt$_(t, s);
            return i ? i._$GetTilesArr$_()[s % this._$_cellHeight$_][t % this._$_cellWidth$_] : -1;
        }
        _$SetTileAt$_(t, s, i) {
            if (t = Math.floor(t), s = Math.floor(s), !(t < 0 || s < 0 || t >= this._$_mapWidth$_ || s >= this._$_mapHeight$_ || -1 !== i && (i & bu) > this._$GetMaxTileIndex$_())) {
                const e = this._$GetCellAt$_(t, s);
                e && e._$SetTileAt$_(t % this._$_cellWidth$_, s % this._$_cellHeight$_, i);
            }
        }
        _$GetMaxTileIndex$_() {
            return this._$_sdkType$_._$GetMaxTileIndex$_();
        }
        _$WorldToCellX$_(t) {
            return Math.floor((t - this._$GetWorldInfo$_()._$GetX$_()) / (this._$_cellWidth$_ * this._$_tileWidth$_));
        }
        _$WorldToCellY$_(t) {
            return Math.floor((t - this._$GetWorldInfo$_()._$GetY$_()) / (this._$_cellHeight$_ * this._$_tileHeight$_));
        }
        _$WorldToTileX$_(t) {
            return Math.floor((t - this._$GetWorldInfo$_()._$GetX$_()) / this._$_tileWidth$_);
        }
        _$WorldToTileY$_(t) {
            return Math.floor((t - this._$GetWorldInfo$_()._$GetY$_()) / this._$_tileHeight$_);
        }
        _$GetMapWidth$_() {
            return this._$_mapWidth$_;
        }
        _$GetMapHeight$_() {
            return this._$_mapHeight$_;
        }
        _$GetMapDisplayWidth$_() {
            return Math.floor(this._$GetWorldInfo$_()._$GetWidth$_() / this._$GetTileWidth$_());
        }
        _$GetMapDisplayHeight$_() {
            return Math.floor(this._$GetWorldInfo$_()._$GetHeight$_() / this._$GetTileHeight$_());
        }
        _$GetMapDisplaySize$_() {
            const t = this._$GetWorldInfo$_();
            return [ Math.floor(t._$GetWidth$_() / this._$GetTileWidth$_()), Math.floor(t._$GetHeight$_() / this._$GetTileHeight$_()) ];
        }
        _$GetTileWidth$_() {
            return this._$_tileWidth$_;
        }
        _$GetTileHeight$_() {
            return this._$_tileHeight$_;
        }
        _$GetCellWidth$_() {
            return this._$_cellWidth$_;
        }
        _$GetCellHeight$_() {
            return this._$_cellHeight$_;
        }
        _$GetCollisionRectCandidates$_(t, i) {
            const e = this._$WorldToCellX$_(t._$getLeft$_()), h = this._$WorldToCellY$_(t._$getTop$_()), r = this._$WorldToCellX$_(t._$getRight$_()), n = this._$WorldToCellY$_(t._$getBottom$_());
            for (let s = e; s <= r; ++s) for (let t = h; t <= n; ++t) {
                const o = this._$GetCellAtIndex$_(s, t);
                o && (o._$MaybeBuildQuadMap$_(), pu._$appendArray$_(i, o._$GetCollisionRects$_()));
            }
        }
        _$TestPointOverlapTile$_(t, s) {
            const i = this._$WorldToTileX$_(t), e = this._$WorldToTileY$_(s), h = this._$GetTileAt$_(i, e);
            if (-1 === h) return !1;
            const r = this._$_sdkType$_._$GetTilePoly$_(h);
            if (!r) return !0;
            if (!this._$_sdkType$_._$IsTilePolyEnabled$_(r)) return !1;
            const n = this._$GetWorldInfo$_(), o = Math.floor((t - n._$GetX$_()) / this._$_tileWidth$_) * this._$_tileWidth$_ + n._$GetX$_(), a = Math.floor((s - n._$GetY$_()) / this._$_tileHeight$_) * this._$_tileHeight$_ + n._$GetY$_();
            return t -= o, s -= a, r._$containsPoint$_(t, s);
        }
        _$GetAllCollisionRects$_(i) {
            const e = this._$_tileCells$_;
            for (let t = 0, s = e.length; t < s; ++t) {
                const h = e[t];
                for (let t = 0, s = h.length; t < s; ++t) {
                    const r = h[t];
                    r._$MaybeBuildQuadMap$_(), pu._$appendArray$_(i, r._$GetCollisionRects$_());
                }
            }
        }
        _$GetCurrentImageInfo$_() {
            return this._$_ownImageInfo$_ || this._$_objectClass$_._$GetImageInfo$_();
        }
        _$GetTileUvQuad$_(t) {
            const s = this._$_tileTexQuads$_, i = s.get(t);
            if (i) return i;
            const e = t & bu, h = 0 != (t & gu), r = 0 != (t & yu), n = 0 != (t & wu), o = this._$GetCurrentImageInfo$_(), a = o._$GetWidth$_(), l = this._$_tileWidth$_, u = this._$_tileXoffset$_, c = this._$_tileXspacing$_, f = Math.floor((a - u) / (l + c) * l) + c, d = Math.floor(f / l), p = e % d, m = Math.floor(e / d), g = o._$GetOffsetX$_() + this._$_tileXoffset$_ + (this._$_tileWidth$_ + this._$_tileXspacing$_) * p, y = o._$GetOffsetY$_() + this._$_tileYoffset$_ + (this._$_tileHeight$_ + this._$_tileYspacing$_) * m, w = (Mu._$setWH$_(g, y, this._$_tileWidth$_, this._$_tileHeight$_), 
            Mu._$divide$_(o._$GetSheetWidth$_(), o._$GetSheetHeight$_()), pu._$New$_(pu._$Quad$_));
            return w._$setFromRect$_(Mu), n && w._$diag$_(), h && w._$mirror$_(), 
            r && w._$flip$_(), w.offset(p, m), s.set(t, w), w;
        }
        _$_OnDynamicTextureLoadComplete$_() {
            this._$_tileTexQuads$_.clear(), this._$_SetAllQuadMapChanged$_();
        }
        _$Draw$_(h) {
            const t = this._$GetCurrentImageInfo$_(), s = t._$GetTexture$_();
            if (s) {
                Mu._$copy$_(t._$GetTexRect$_()), Mu.offsetLeft(this._$_tileXoffset$_ / s._$GetWidth$_()), 
                Mu.offsetTop(this._$_tileYoffset$_ / s._$GetHeight$_()), h._$SetTilemapFillMode$_(), 
                h._$SetTilemapInfo$_(Mu, s._$GetWidth$_(), s._$GetHeight$_(), this._$_tileWidth$_, this._$_tileHeight$_, this._$_tileXspacing$_, this._$_tileYspacing$_), 
                h._$SetTexture$_(s);
                const r = this._$GetWorldInfo$_(), n = r._$GetLayer$_();
                r._$GetWidth$_() === this._$_lastWidth$_ && r._$GetHeight$_() === this._$_lastHeight$_ || (this._$_SetPhysicsChanged$_(), 
                this._$_SetAllQuadMapChanged$_(), this._$_lastWidth$_ = r._$GetWidth$_(), 
                this._$_lastHeight$_ = r._$GetHeight$_());
                let i = r._$GetX$_(), e = r._$GetY$_();
                this._$_runtime$_._$IsPixelRoundingEnabled$_() && (i = Math.round(i), 
                e = Math.round(e));
                const o = this._$_cellWidth$_ * this._$_tileWidth$_, a = this._$_cellHeight$_ * this._$_tileHeight$_, l = r._$GetTotalZElevation$_(), u = vu;
                if (n._$Has3DCamera$_()) {
                    u.set(-1 / 0, -1 / 0, 1 / 0, 1 / 0);
                    const c = xu, f = n._$_GetViewFrustum$_();
                    for (const d of this._$_tileCells$_) for (const p of d) p._$GetLayoutRect$_(c), 
                    f._$ContainsAABB$_(c._$getLeft$_(), c._$getTop$_(), l, c._$getRight$_(), c._$getBottom$_(), l) && (p._$MaybeBuildQuadMap$_(), 
                    p._$Draw$_(h, u, i, e));
                } else {
                    n._$GetViewportForZ$_(l, u);
                    const m = Math.floor((u._$getLeft$_() - i) / o), g = Math.floor((u._$getRight$_() - i) / o), y = Math.floor((u._$getTop$_() - e) / a), w = Math.floor((u._$getBottom$_() - e) / a);
                    for (let s = m; s <= g; ++s) for (let t = y; t <= w; ++t) {
                        const S = this._$GetCellAtIndex$_(s, t);
                        S && (S._$MaybeBuildQuadMap$_(), S._$Draw$_(h, u, i, e));
                    }
                }
            }
        }
        _$SaveToJson$_() {
            this._$_MaybeResizeTilemap$_();
            const [ t, s ] = this._$GetMapDisplaySize$_();
            return {
                tw: this._$_tileWidth$_,
                th: this._$_tileHeight$_,
                tox: this._$_tileXoffset$_,
                toy: this._$_tileYoffset$_,
                tsx: this._$_tileXspacing$_,
                tsy: this._$_tileYspacing$_,
                w: t,
                h: s,
                d: this._$GetTilesAsRLECSV$_()
            };
        }
        _$LoadFromJson$_(t) {
            this._$_tileWidth$_ = t.tw, this._$_tileHeight$_ = t.th, this._$_tileXoffset$_ = t.tox, 
            this._$_tileYoffset$_ = t.toy, this._$_tileXspacing$_ = t.tsx, this._$_tileYspacing$_ = t.tsy, 
            this._$_mapWidth$_ = t.w, this._$_mapHeight$_ = t.h, this._$_MaybeResizeTilemap$_(!0), 
            this._$SetTilesFromRLECSV$_(t.d), this._$_SetPhysicsChanged$_(), this._$_SetAllQuadMapChanged$_();
        }
        _$GetAsJsonString$_() {
            this._$_MaybeResizeTilemap$_();
            const [ t, s ] = this._$GetMapDisplaySize$_();
            return JSON.stringify({
                c2tilemap: !0,
                width: t,
                height: s,
                data: this._$GetTilesAsRLECSV$_()
            });
        }
        _$StateComboToFlags$_(t) {
            switch (t) {
              case 0:
                return 0;

              case 1:
                return gu;

              case 2:
                return yu;

              case 3:
                return gu | wu;

              case 4:
                return gu | yu;

              case 5:
                return yu | wu;

              case 6:
                return gu | yu | wu;

              case 7:
                return wu;

              default:
                return 0;
            }
        }
        _$GetPropertyValueByIndex$_(t) {
            switch (t) {
              case 1:
                return this._$_tileWidth$_;

              case 2:
                return this._$_tileHeight$_;

              case 3:
                return this._$_tileXoffset$_;

              case 4:
                return this._$_tileYoffset$_;

              case 5:
                return this._$_tileXspacing$_;

              case 6:
                return this._$_tileYspacing$_;
            }
        }
        _$SetPropertyValueByIndex$_(t, s) {
            switch (t) {
              case 1:
                this._$_tileWidth$_ !== s && (this._$_tileWidth$_ = Math.max(s, 1), 
                this._$_cellWidth$_ = Math.ceil(this._$_runtime$_._$GetOriginalViewportWidth$_() / this._$_tileWidth$_), 
                this._$_sdkType$_._$_ForceCacheOfTileCollisionPolys$_(), this._$_UpdateQuadMaps$_());
                break;

              case 2:
                this._$_tileHeight$_ !== s && (this._$_tileHeight$_ = Math.max(s, 1), 
                this._$_cellHeight$_ = Math.ceil(this._$_runtime$_._$GetOriginalViewportHeight$_() / this._$_tileHeight$_), 
                this._$_sdkType$_._$_ForceCacheOfTileCollisionPolys$_(), this._$_UpdateQuadMaps$_());
                break;

              case 3:
                this._$_tileXoffset$_ !== s && (this._$_tileXoffset$_ = s, this._$_UpdateQuadMaps$_());
                break;

              case 4:
                this._$_tileYoffset$_ !== s && (this._$_tileYoffset$_ = s, this._$_UpdateQuadMaps$_());
                break;

              case 5:
                this._$_tileXspacing$_ !== s && (this._$_tileXspacing$_ = s, this._$_UpdateQuadMaps$_());
                break;

              case 6:
                this._$_tileYspacing$_ !== s && (this._$_tileYspacing$_ = s, this._$_UpdateQuadMaps$_());
            }
        }
        _$_UpdateQuadMaps$_() {
            this._$_tileTexQuads$_.clear(), this._$_SetAllQuadMapChanged$_(), this._$_MaybeBuildAllQuadMap$_();
        }
        _$GetScriptInterfaceClass$_() {
            return Tu;
        }
    }, new WeakMap()), Tu = self._$ITilemapInstance$_ = class extends self._$IWorldInstance$_ {
        constructor() {
            super(), Gu.set(this, self._$IInstance$_._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        get _$mapWidth$_() {
            return Gu.get(this)._$GetMapWidth$_();
        }
        get _$mapHeight$_() {
            return Gu.get(this)._$GetMapHeight$_();
        }
        _$getMapSize$_() {
            const t = Gu.get(this);
            return [ t._$GetMapWidth$_(), t._$GetMapHeight$_() ];
        }
        get _$mapDisplayWidth$_() {
            return Gu.get(this)._$GetMapDisplayWidth$_();
        }
        get _$mapDisplayHeight$_() {
            return Gu.get(this)._$GetMapDisplayHeight$_();
        }
        _$getMapDisplaySize$_() {
            const t = Gu.get(this);
            return [ t._$GetMapDisplayWidth$_(), t._$GetMapDisplayHeight$_() ];
        }
        get _$tileWidth$_() {
            return Gu.get(this)._$GetTileWidth$_();
        }
        get _$tileHeight$_() {
            return Gu.get(this)._$GetTileHeight$_();
        }
        _$getTileSize$_() {
            const t = Gu.get(this);
            return [ t._$GetTileWidth$_(), t._$GetTileHeight$_() ];
        }
        _$getTileAt$_(t, s) {
            return mu._$RequireFiniteNumber$_(t), mu._$RequireFiniteNumber$_(s), 
            Gu.get(this)._$GetTileAt$_(t, s);
        }
        _$setTileAt$_(t, s, i) {
            mu._$RequireFiniteNumber$_(t), mu._$RequireFiniteNumber$_(s), mu._$RequireFiniteNumber$_(i);
            const e = Gu.get(this);
            e._$_MaybeResizeTilemap$_(), e._$SetTileAt$_(t, s, i);
        }
        async _$replaceImage$_(t) {
            mu._$RequireInstanceOf$_(t, Blob);
            const s = Gu.get(this), i = s._$GetRuntime$_(), e = pu._$New$_(pu._$ImageInfo$_);
            e._$LoadDynamicBlobAsset$_(i, t), await e._$LoadStaticTexture$_(i._$GetRenderer$_(), {
                _$sampling$_: i._$GetSampling$_()
            }), s._$WasReleased$_() ? e._$Release$_() : (s._$_ReleaseOwnImage$_(), 
            s._$_ownImageInfo$_ = e, s._$_tileTexQuads$_.clear(), s._$_SetAllQuadMapChanged$_(), 
            i._$UpdateRender$_());
        }
    };
    Tu._$TILE_FLIPPED_HORIZONTAL$_ = gu, Tu._$TILE_FLIPPED_VERTICAL$_ = yu, Tu._$TILE_FLIPPED_DIAGONAL$_ = wu, 
    Tu._$TILE_FLAGS_MASK$_ = Su, Tu._$TILE_ID_MASK$_ = bu;
}

{
    const _u = self._$C3$_, Iu = _u._$Plugins$_._$Tilemap$_._$TILE_FLAGS_MASK$_, Cu = _u._$Plugins$_._$Tilemap$_._$TILE_ID_MASK$_;
    _u._$Plugins$_._$Tilemap$_._$Cnds$_ = {
        _$CompareTileAt$_(t, s, i, e) {
            let h = this._$GetTileAt$_(t, s);
            return -1 !== h && (h &= Cu), _u.compare(h, i, e);
        },
        _$CompareTileStateAt$_(t, s, i) {
            let e = this._$GetTileAt$_(t, s), h = 0;
            return (h = -1 !== e ? e & Iu : h) === this._$StateComboToFlags$_(i);
        },
        _$OnURLLoaded$_() {
            return !0;
        },
        _$OnURLFailed$_() {
            return !0;
        },
        _$BrushExists$_(t) {
            return this._$_autoTiling$_ || (this._$_autoTiling$_ = new _u._$Plugins$_._$Tilemap$_._$AutoTiling$_(this, this._$_sdkType$_)), 
            this._$_autoTiling$_._$BrushExists$_(t);
        }
    };
}

{
    const Ru = self._$C3$_, Pu = Ru._$Plugins$_._$Tilemap$_._$TILE_ID_MASK$_;
    Ru._$Plugins$_._$Tilemap$_._$Acts$_ = {
        _$EraseTile$_(t, s) {
            this._$_MaybeResizeTilemap$_(), this._$SetTileAt$_(t, s, -1);
        },
        _$SetTile$_(t, s, i, e) {
            this._$_MaybeResizeTilemap$_(), this._$SetTileAt$_(t, s, i & Pu | this._$StateComboToFlags$_(e));
        },
        _$SetTileState$_(t, s, i) {
            const e = this._$GetTileAt$_(t, s);
            -1 !== e && (this._$_MaybeResizeTilemap$_(), this._$SetTileAt$_(t, s, e & Pu | this._$StateComboToFlags$_(i)));
        },
        _$EraseTileRange$_(t, s, i, e) {
            const h = Math.floor(Math.max(t, 0)), r = Math.floor(Math.max(s, 0)), n = Math.floor(Math.min(t + i, this._$_mapWidth$_)), o = Math.floor(Math.min(s + e, this._$_mapHeight$_));
            for (let s = r; s < o; ++s) for (let t = h; t < n; ++t) this._$SetTileAt$_(t, s, -1);
        },
        _$SetTileRange$_(t, s, i, e, h, r) {
            this._$_MaybeResizeTilemap$_();
            const n = Math.floor(Math.max(t, 0)), o = Math.floor(Math.max(s, 0)), a = Math.floor(Math.min(t + i, this._$_mapWidth$_)), l = Math.floor(Math.min(s + e, this._$_mapHeight$_)), u = h & Pu | this._$StateComboToFlags$_(r);
            for (let s = o; s < l; ++s) for (let t = n; t < a; ++t) this._$SetTileAt$_(t, s, u);
        },
        _$SetTileStateRange$_(t, s, i, e, h) {
            this._$_MaybeResizeTilemap$_();
            const r = Math.floor(Math.max(t, 0)), n = Math.floor(Math.max(s, 0)), o = Math.floor(Math.min(t + i, this._$_mapWidth$_)), a = Math.floor(Math.min(s + e, this._$_mapHeight$_)), l = this._$StateComboToFlags$_(h);
            for (let s = n; s < a; ++s) for (let t = r; t < o; ++t) {
                const u = this._$GetTileAt$_(t, s);
                -1 !== u && this._$SetTileAt$_(t, s, u & Pu | l);
            }
        },
        _$LoadFromJSON$_(t) {
            let s = null;
            try {
                s = JSON.parse(t);
            } catch (t) {
                return void console.error("[Construct] Failed to parse tilemap JSON: ", t);
            }
            s.c2tilemap ? (this._$_mapWidth$_ = s.width, this._$_mapHeight$_ = s.height, 
            this._$_MaybeResizeTilemap$_(!0), this._$SetTilesFromRLECSV$_(s.data), 
            this._$_SetAllQuadMapChanged$_(), this._$_SetPhysicsChanged$_()) : console.error("[Construct] Unrecognized JSON data format");
        },
        _$JSONDownload$_(t) {
            const s = URL.createObjectURL(new Blob([ this._$GetAsJsonString$_() ], {
                type: "application/json"
            }));
            this._$_runtime$_._$InvokeDownload$_(s, t);
        },
        async _$LoadURL$_(t, s) {
            if (!this._$_ownImageInfo$_ || this._$_ownImageInfo$_._$GetURL$_() !== t) {
                const i = this._$_runtime$_, e = Ru._$New$_(Ru._$ImageInfo$_);
                try {
                    if (await e._$LoadDynamicAsset$_(i, t), !e._$IsLoaded$_()) throw new Error("image failed to load");
                    if (this._$WasReleased$_()) return e._$Release$_(), null;
                    const h = await e._$LoadStaticTexture$_(i._$GetRenderer$_(), {
                        _$sampling$_: i._$GetSampling$_()
                    });
                    if (!h) return;
                } catch (t) {
                    return console.error("Load image from URL failed: ", t), void (this._$WasReleased$_() || this._$Trigger$_(Ru._$Plugins$_._$Tilemap$_._$Cnds$_._$OnURLFailed$_));
                }
                this._$WasReleased$_() ? e._$Release$_() : (this._$_ReleaseOwnImage$_(), 
                this._$_ownImageInfo$_ = e, i._$UpdateRender$_(), this._$_tileTexQuads$_.clear(), 
                this._$_SetAllQuadMapChanged$_(), await this._$TriggerAsync$_(Ru._$Plugins$_._$Tilemap$_._$Cnds$_._$OnURLLoaded$_));
            }
        },
        _$SetEffect$_(t) {
            2 <= t && t++, this._$GetWorldInfo$_()._$SetBlendMode$_(t), this._$_runtime$_._$UpdateRender$_();
        },
        _$SetTileWithBrush$_(t, s, i) {
            this._$_MaybeResizeTilemap$_(), this._$_autoTiling$_ || (this._$_autoTiling$_ = new Ru._$Plugins$_._$Tilemap$_._$AutoTiling$_(this, this._$_sdkType$_)), 
            this._$_autoTiling$_._$SetAutoTile$_(t, s, i);
        },
        _$EraseTileWithBrush$_(t, s, i) {
            this._$_MaybeResizeTilemap$_(), this._$_autoTiling$_ || (this._$_autoTiling$_ = new Ru._$Plugins$_._$Tilemap$_._$AutoTiling$_(this, this._$_sdkType$_)), 
            this._$_autoTiling$_._$EraseAutoTile$_(t, s, i);
        },
        _$SetTileWithBrushByName$_(t, s, i) {
            Ru._$Plugins$_._$Tilemap$_._$Acts$_._$SetTileWithBrush$_.call(this, t, s, i);
        },
        _$EraseTileWithBrushByName$_(t, s, i) {
            Ru._$Plugins$_._$Tilemap$_._$Acts$_._$EraseTileWithBrush$_.call(this, t, s, i);
        }
    };
}

{
    const Eu = self._$C3$_, Au = Eu._$Plugins$_._$Tilemap$_._$TILE_ID_MASK$_;
    Eu._$Plugins$_._$Tilemap$_._$Exps$_ = {
        _$TileAt$_(t, s) {
            const i = this._$GetTileAt$_(t, s);
            return -1 === i ? -1 : i & Au;
        },
        _$PositionToTileX$_(t) {
            return this._$WorldToTileX$_(t);
        },
        _$PositionToTileY$_(t) {
            return this._$WorldToTileY$_(t);
        },
        _$TileToPositionX$_(t) {
            return t * this._$_tileWidth$_ + this._$GetWorldInfo$_()._$GetX$_() + this._$_tileWidth$_ / 2;
        },
        _$TileToPositionY$_(t) {
            return t * this._$_tileHeight$_ + this._$GetWorldInfo$_()._$GetY$_() + this._$_tileHeight$_ / 2;
        },
        _$SnapX$_(t) {
            const s = this._$GetWorldInfo$_()._$GetX$_();
            return Math.floor((t - s) / this._$_tileWidth$_) * this._$_tileWidth$_ + s + this._$_tileWidth$_ / 2;
        },
        _$SnapY$_(t) {
            const s = this._$GetWorldInfo$_()._$GetY$_();
            return Math.floor((t - s) / this._$_tileHeight$_) * this._$_tileHeight$_ + s + this._$_tileHeight$_ / 2;
        },
        _$TilesJSON$_() {
            return this._$GetAsJsonString$_();
        },
        _$TileWidth$_() {
            return this._$GetTileWidth$_();
        },
        _$TileHeight$_() {
            return this._$GetTileHeight$_();
        },
        _$MapDisplayWidth$_() {
            return this._$GetMapDisplayWidth$_();
        },
        _$MapDisplayHeight$_() {
            return this._$GetMapDisplayHeight$_();
        }
    };
}

{
    const Fu = self._$C3$_, Ou = Fu._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_HORIZONTAL$_, Du = Fu._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_VERTICAL$_, ku = Fu._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_DIAGONAL$_, Lu = Fu._$Plugins$_._$Tilemap$_._$TILE_ID_MASK$_, Bu = Fu._$New$_(Fu.Rect), Nu = Fu._$New$_(Fu._$Quad$_);
    Fu._$Plugins$_._$Tilemap$_._$TileQuad$_ = class extends Fu._$DefendedBase$_ {
        constructor() {
            super(), this._$_id$_ = -1, this._$_tileId$_ = -1, this._$_isHorizFlip$_ = !1, 
            this._$_isVertFlip$_ = !1, this._$_isDiagFlip$_ = !1, this._$_rc$_ = Fu._$New$_(Fu.Rect), 
            this._$_uv$_ = null;
        }
        _$Update$_(t, s, i, e, h, r, n, o) {
            this._$_id$_ = t, this._$_tileId$_ = t & Lu, this._$_isHorizFlip$_ = 0 != (t & Ou), 
            this._$_isVertFlip$_ = 0 != (t & Du), this._$_isDiagFlip$_ = 0 != (t & ku), 
            this._$_rc$_._$setWH$_(e * s + r, h * i + n, s, i), this._$_uv$_ = o._$GetTileUvQuad$_(this._$_id$_);
        }
        _$Draw$_(t, s, i, e, h) {
            Bu._$copy$_(this._$_rc$_), Bu.offset(i, e), Bu._$intersectsRect$_(s) && (Nu._$setFromRect$_(Bu), 
            t._$Quad4$_(Nu, this._$_uv$_));
        }
    };
}

{
    const Wu = self._$C3$_;
    Wu._$Plugins$_._$Tilemap$_._$TileCollisionRect$_ = class extends Wu._$DefendedBase$_ {
        constructor() {
            super(), this._$_id$_ = -1, this._$_poly$_ = null, this._$_rc$_ = Wu._$New$_(Wu.Rect);
        }
        _$Update$_(t, s, i, e, h, r, n, o) {
            this._$_id$_ = t, this._$_poly$_ = s, this._$_rc$_._$setWH$_(h * i + n, r * e + o, i, e);
        }
        _$ExtendRight$_(t) {
            this._$_rc$_._$setRight$_(this._$_rc$_._$getRight$_() + t);
        }
        _$GetTileId$_() {
            return this._$_id$_;
        }
        _$HasPoly$_() {
            return !!this._$_poly$_;
        }
        _$GetPoly$_() {
            return this._$_poly$_;
        }
        _$GetRect$_() {
            return this._$_rc$_;
        }
    };
}

{
    const ju = self._$C3$_, Vu = ju._$Plugins$_._$Tilemap$_._$TILE_ID_MASK$_;
    ju._$Plugins$_._$Tilemap$_._$TileCell$_ = class extends ju._$DefendedBase$_ {
        constructor(t, s, i) {
            super();
            const e = t._$GetCellWidth$_(), h = t._$GetCellHeight$_();
            this._$_sdkInst$_ = t, this._$_x$_ = s, this._$_y$_ = i, this._$_left$_ = this._$_x$_ * e * t._$GetTileWidth$_(), 
            this._$_top$_ = this._$_y$_ * h * t._$GetTileHeight$_(), this._$_tiles$_ = [], 
            this._$_quads$_ = [], this._$_collisionRects$_ = [], this._$_isQuadMapValid$_ = !1;
            for (let t = 0; t < h; ++t) {
                const r = new Int32Array(e);
                r.fill(-1), this._$_tiles$_.push(r);
            }
        }
        _$Clear$_() {
            const i = this._$_sdkInst$_._$GetCellWidth$_(), s = this._$_sdkInst$_._$GetCellHeight$_(), e = this._$_tiles$_;
            if (e.length < s) for (let t = e.length; t < s; ++t) e.push(new Int32Array(i)); else e.length > s && ju._$truncateArray$_(e, s);
            for (let s = 0, t = e.length; s < t; ++s) {
                let t = e[s];
                t.length !== i && (t = new Int32Array(i), e[s] = t), t.fill(-1);
            }
        }
        _$GetLayoutRect$_(t) {
            const s = this._$_sdkInst$_, i = s._$GetWorldInfo$_(), e = s._$GetCellWidth$_() * s._$GetTileWidth$_(), h = s._$GetCellHeight$_() * s._$GetTileHeight$_(), r = i._$GetX$_() + this._$_left$_, n = i._$GetY$_() + this._$_top$_;
            t.set(r, n, r + e, n + h);
        }
        _$_SetQuadMapChanged$_() {
            this._$_isQuadMapValid$_ = !1;
        }
        _$MaybeBuildQuadMap$_() {
            if (!this._$_isQuadMapValid$_) {
                const u = this._$_sdkInst$_, c = u._$GetSdkType$_(), s = u._$GetWorldInfo$_(), f = u._$GetTileWidth$_(), d = u._$GetTileHeight$_(), p = u._$GetCellWidth$_(), m = u._$GetCellHeight$_(), g = this._$_left$_, y = this._$_top$_;
                if (!(f <= 0 || d <= 0)) {
                    let e = Math.min(u._$GetMapWidth$_(), Math.floor(s._$GetWidth$_() / f)), t = Math.min(u._$GetMapHeight$_(), Math.floor(s._$GetHeight$_() / d)), h = (e -= g / f, 
                    t -= y / d, e > p && (e = p), t > m && (t = m), this._$_tiles$_), r = this._$_quads$_, n = 0;
                    for (let i = 0; i < t; ++i) {
                        const w = h[i];
                        for (let s = 0; s < e; ++s) {
                            const S = w[s];
                            if (-1 !== S) {
                                let t = null;
                                n < r.length ? t = r[n] : (t = ju._$New$_(ju._$Plugins$_._$Tilemap$_._$TileQuad$_), 
                                r.push(t)), t._$Update$_(S, f, d, s, i, g, y, u), 
                                ++n;
                            }
                        }
                    }
                    n < r.length && ju._$truncateArray$_(r, n);
                    let i = null, o = !1, a = this._$_collisionRects$_;
                    ju._$clearArray$_(a);
                    for (let s = 0; s < t; ++s) {
                        const b = h[s];
                        for (let t = 0; t < e; ++t) {
                            const M = b[t], v = (Vu, c._$GetTilePoly$_(M)), x = c._$IsTilePolyEnabled$_(v);
                            -1 !== M && x ? !i || v || o ? (i && a.push(i), (i = ju._$New$_(ju._$Plugins$_._$Tilemap$_._$TileCollisionRect$_))._$Update$_(M, v, f, d, t, s, g, y), 
                            o = !!v) : i._$ExtendRight$_(f) : i && (a.push(i), i = null, 
                            o = !1);
                        }
                        i && (a.push(i), i = null, o = !1);
                    }
                    let l = a.length;
                    for (let s = 0; s < l; ++s) {
                        const G = a[s];
                        if (!G._$HasPoly$_()) {
                            const T = G._$GetRect$_();
                            for (let t = s + 1; t < l; ++t) {
                                const _ = a[t], I = _._$GetRect$_();
                                I._$getTop$_() < T._$getBottom$_() || I._$getTop$_() > T._$getBottom$_() || I._$getRight$_() > T._$getRight$_() || I._$getLeft$_() > T._$getLeft$_() || _._$HasPoly$_() || I._$getLeft$_() === T._$getLeft$_() && I._$getRight$_() === T._$getRight$_() && (a.splice(t, 1), 
                                --l, T._$setBottom$_(T._$getBottom$_() + d), --t);
                            }
                        }
                    }
                    this._$_isQuadMapValid$_ = !0;
                }
            }
        }
        _$SetTileAt$_(t, s, i) {
            this._$_tiles$_[s][t] !== i && (this._$_tiles$_[s][t] = i, this._$_isQuadMapValid$_ = !1, 
            this._$_sdkInst$_._$SetTileChanged$_());
        }
        _$GetTilesArr$_() {
            return this._$_tiles$_;
        }
        _$GetCollisionRects$_() {
            return this._$_collisionRects$_;
        }
        _$Draw$_(i, e, h, r) {
            const n = this._$_sdkInst$_, o = this._$_quads$_;
            for (let t = 0, s = o.length; t < s; ++t) o[t]._$Draw$_(i, e, h, r, n);
        }
    };
}

{
    const Uu = self._$C3$_, Hu = Object.freeze([ [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ]);
    Uu._$Plugins$_._$Tilemap$_._$AutoTiling$_ = class {
        constructor(t, s) {
            this._$_sdkInst$_ = t, this._$_sdkType$_ = s, this._$_brushAdapterInstances$_ = [ null, null ], 
            this._$_brushAdapterConstructors$_ = [ Uu._$Plugins$_._$Tilemap$_._$AutoTiling16$_, Uu._$Plugins$_._$Tilemap$_._$AutoTiling47$_ ], 
            this._$_probabilityTable$_ = new Uu._$ProbabilityTable$_();
        }
        get _$AUTO_TILING_PATCH$_() {
            return Hu;
        }
        get _$IGNORE_INDEX$_() {
            return -999;
        }
        get _$FORCE_INDEX$_() {
            return -998;
        }
        get _$EMPTY_INDEX$_() {
            return -1;
        }
        get _$PAINT_MODE$_() {
            return 0;
        }
        get _$ERASE_MODE$_() {
            return 1;
        }
        _$GetSdkIntance$_() {
            return this._$_sdkInst$_;
        }
        _$GetSdkType$_() {
            return this._$_sdkType$_;
        }
        _$SetAutoTile$_(t, s, i) {
            this._$BrushExists$_(i) && (this._$_SetAutoTileMode$_(i, 0), this._$_SetAutoTilePatch$_(t, s, this._$_GetAutoTilePatch$_(t, s, i)));
        }
        _$EraseAutoTile$_(t, s, i) {
            this._$BrushExists$_(i) && (this._$_SetAutoTileMode$_(i, 1), this._$_EraseTile$_(t, s), 
            this._$_SetAutoTilePatch$_(t, s, this._$_GetAutoTilePatch$_(t, s, i)));
        }
        _$BrushExists$_(t) {
            return !!this._$GetSdkType$_()._$GetBrushData$_(t);
        }
        _$GetTile$_(t, s) {
            return this._$GetSdkIntance$_()._$GetTileAt$_(t, s);
        }
        _$DoesTileExist$_(t, s, i) {
            const e = this._$GetTile$_(t, s);
            return !!this._$IsTileValid$_(e, !0, e, i);
        }
        _$IsTileValid$_(t, s, i, e) {
            return -1 === t || (!s || -998 !== t) && s && e && !this._$_IsTileIndexInBrush$_(i, e) ? 0 : 1;
        }
        _$GetTileIndex$_(t, s, i, e) {
            const h = e._$tileData$_[t];
            if (!h.length) return -1;
            if (1 === h.length) return h[0][0];
            const r = this._$GetTile$_(s, i);
            if (this._$IsTileValid$_(r)) {
                const n = h.some(t => r === t[0]);
                if (n) return r;
            }
            this._$_probabilityTable$_._$Clear$_();
            for (let [ t, s ] of h) "number" != typeof s && (s = 1), this._$_probabilityTable$_._$AddItem$_(s, t);
            return this._$_probabilityTable$_._$Sample$_();
        }
        _$_SetTile$_(t, s, i) {
            -1 !== t && this._$GetSdkIntance$_()._$SetTileAt$_(t, s, i);
        }
        _$_EraseTile$_(t, s) {
            this._$GetSdkIntance$_()._$SetTileAt$_(t, s, -1);
        }
        _$_IsTileIndexInBrush$_(t, s) {
            for (const i of s._$tileData$_) for (const [ e ] of i) if (e === t) return !0;
            return !1;
        }
        _$_SetAutoTilePatch$_(t, s, i) {
            i && (this._$_SetTile$_(t - 1, s - 1, i[0][0]), this._$_SetTile$_(t, s - 1, i[1][0]), 
            this._$_SetTile$_(t + 1, s - 1, i[2][0]), this._$_SetTile$_(t - 1, s, i[0][1]), 
            this._$_SetTile$_(t, s, i[1][1]), this._$_SetTile$_(t + 1, s, i[2][1]), 
            this._$_SetTile$_(t - 1, s + 1, i[0][2]), this._$_SetTile$_(t, s + 1, i[1][2]), 
            this._$_SetTile$_(t + 1, s + 1, i[2][2]));
        }
        _$_GetBrushType$_(t) {
            const s = this._$GetSdkType$_()._$GetBrushData$_(t);
            return s.type;
        }
        _$_MaybeCreateBrushAdapter$_(t) {
            const s = this._$_GetBrushType$_(t);
            this._$_brushAdapterInstances$_[s] || (this._$_brushAdapterInstances$_[s] = new this._$_brushAdapterConstructors$_[s](this));
        }
        _$_SetAutoTileMode$_(t, s) {
            this._$_MaybeCreateBrushAdapter$_(t);
            const i = this._$_GetBrushType$_(t);
            this._$_brushAdapterInstances$_[i] && this._$_brushAdapterInstances$_[i]._$SetMode$_(s);
        }
        _$_GetAutoTilePatch$_(t, s, i) {
            this._$_MaybeCreateBrushAdapter$_(i);
            const e = this._$GetSdkType$_()._$GetBrushData$_(i);
            if (this._$_brushAdapterInstances$_[e.type]) return this._$_brushAdapterInstances$_[e.type]._$BuildPatch$_(t, s, e);
        }
    };
}

{
    const zu = self._$C3$_;
    zu._$Plugins$_._$Tilemap$_._$AutoTiling16$_ = class {
        constructor(t) {
            this._$_auto$_ = t, this._$_mode$_ = t._$PAINT_MODE$_;
        }
        _$SetMode$_(t) {
            this._$_mode$_ = t;
        }
        _$BuildPatch$_(t, s, i) {
            return this._$_Build4BitAutoTilePatch$_(t, s, i);
        }
        _$_Build4BitAutoTilePatch$_(t, s, i) {
            const e = this._$_mode$_ === this._$_auto$_._$PAINT_MODE$_ ? this._$_4BitAutoTiling$_(t, s, void 0, i) : this._$_auto$_._$EMPTY_INDEX$_, h = this._$_Get4BitAutoTile$_(t, s - 1, "s", i), r = this._$_Get4BitAutoTile$_(t - 1, s, "e", i), n = this._$_Get4BitAutoTile$_(t + 1, s, "w", i), o = this._$_Get4BitAutoTile$_(t, s + 1, "n", i), a = this._$_auto$_._$AUTO_TILING_PATCH$_;
            return a[0][0] = this._$_auto$_._$IGNORE_INDEX$_, a[1][0] = this._$_Get4BitTileIndex$_(h, t, s - 1, i), 
            a[2][0] = this._$_auto$_._$IGNORE_INDEX$_, a[0][1] = this._$_Get4BitTileIndex$_(r, t - 1, s, i), 
            a[1][1] = this._$_Get4BitTileIndex$_(e, t, s, i), a[2][1] = this._$_Get4BitTileIndex$_(n, t + 1, s, i), 
            a[0][2] = this._$_auto$_._$IGNORE_INDEX$_, a[1][2] = this._$_Get4BitTileIndex$_(o, t, s + 1, i), 
            a[2][2] = this._$_auto$_._$IGNORE_INDEX$_, a;
        }
        _$_Get4BitAutoTile$_(t, s, i, e) {
            return this._$_auto$_._$DoesTileExist$_(t, s, e) ? this._$_4BitAutoTiling$_(t, s, i, e) : this._$_auto$_._$IGNORE_INDEX$_;
        }
        _$_4BitAutoTiling$_(t, s, i, e) {
            this._$_mode$_ === this._$_auto$_._$ERASE_MODE$_ && (i = void 0);
            const h = this._$_auto$_._$GetTile$_(t, s - 1), r = this._$_auto$_._$GetTile$_(t - 1, s), n = this._$_auto$_._$GetTile$_(t + 1, s), o = this._$_auto$_._$GetTile$_(t, s + 1), a = "n" === i ? this._$_auto$_._$FORCE_INDEX$_ : h, l = "w" === i ? this._$_auto$_._$FORCE_INDEX$_ : r, u = "e" === i ? this._$_auto$_._$FORCE_INDEX$_ : n, c = "s" === i ? this._$_auto$_._$FORCE_INDEX$_ : o, f = this._$_auto$_._$IsTileValid$_(a, !0, h, e), d = this._$_auto$_._$IsTileValid$_(l, !0, r, e), p = this._$_auto$_._$IsTileValid$_(u, !0, n, e), m = this._$_auto$_._$IsTileValid$_(c, !0, o, e);
            return +f + 2 * d + 4 * p + 8 * m;
        }
        _$_Get4BitTileIndex$_(t, s, i, e) {
            return t === this._$_auto$_._$IGNORE_INDEX$_ || t === this._$_auto$_._$EMPTY_INDEX$_ ? t : this._$_auto$_._$GetTileIndex$_(t, s, i, e);
        }
    };
}

{
    const Ju = self._$C3$_, qu = new Map([ [ 2, 1 ], [ 8, 2 ], [ 10, 3 ], [ 11, 4 ], [ 16, 5 ], [ 18, 6 ], [ 22, 7 ], [ 24, 8 ], [ 26, 9 ], [ 27, 10 ], [ 30, 11 ], [ 31, 12 ], [ 64, 13 ], [ 66, 14 ], [ 72, 15 ], [ 74, 16 ], [ 75, 17 ], [ 80, 18 ], [ 82, 19 ], [ 86, 20 ], [ 88, 21 ], [ 90, 22 ], [ 91, 23 ], [ 94, 24 ], [ 95, 25 ], [ 104, 26 ], [ 106, 27 ], [ 107, 28 ], [ 120, 29 ], [ 122, 30 ], [ 123, 31 ], [ 126, 32 ], [ 127, 33 ], [ 208, 34 ], [ 210, 35 ], [ 214, 36 ], [ 216, 37 ], [ 218, 38 ], [ 219, 39 ], [ 222, 40 ], [ 223, 41 ], [ 248, 42 ], [ 250, 43 ], [ 251, 44 ], [ 254, 45 ], [ 255, 46 ], [ 0, 47 ] ]);
    Ju._$Plugins$_._$Tilemap$_._$AutoTiling47$_ = class {
        constructor(t) {
            this._$_auto$_ = t, this._$_mode$_ = t._$PAINT_MODE$_;
        }
        _$SetMode$_(t) {
            this._$_mode$_ = t;
        }
        _$BuildPatch$_(t, s, i) {
            return this._$_Build8BitAutoTilePatch$_(t, s, i);
        }
        _$_Build8BitAutoTilePatch$_(t, s, i) {
            const e = this._$_mode$_ === this._$_auto$_._$PAINT_MODE$_ ? this._$_8BitAutoTiling$_(t, s, void 0, i) : this._$_auto$_._$EMPTY_INDEX$_, h = this._$_Get8BitAutoTile$_(t - 1, s - 1, "se", i), r = this._$_Get8BitAutoTile$_(t, s - 1, "s", i), n = this._$_Get8BitAutoTile$_(t + 1, s - 1, "sw", i), o = this._$_Get8BitAutoTile$_(t - 1, s, "e", i), a = this._$_Get8BitAutoTile$_(t + 1, s, "w", i), l = this._$_Get8BitAutoTile$_(t - 1, s + 1, "ne", i), u = this._$_Get8BitAutoTile$_(t, s + 1, "n", i), c = this._$_Get8BitAutoTile$_(t + 1, s + 1, "nw", i), f = this._$_auto$_._$AUTO_TILING_PATCH$_;
            return f[0][0] = this._$_Get8BitTileIndex$_(h, t - 1, s - 1, i), f[1][0] = this._$_Get8BitTileIndex$_(r, t, s - 1, i), 
            f[2][0] = this._$_Get8BitTileIndex$_(n, t + 1, s - 1, i), f[0][1] = this._$_Get8BitTileIndex$_(o, t - 1, s, i), 
            f[1][1] = this._$_Get8BitTileIndex$_(e, t, s, i), f[2][1] = this._$_Get8BitTileIndex$_(a, t + 1, s, i), 
            f[0][2] = this._$_Get8BitTileIndex$_(l, t - 1, s + 1, i), f[1][2] = this._$_Get8BitTileIndex$_(u, t, s + 1, i), 
            f[2][2] = this._$_Get8BitTileIndex$_(c, t + 1, s + 1, i), f;
        }
        _$_Get8BitAutoTile$_(t, s, i, e) {
            return this._$_auto$_._$DoesTileExist$_(t, s, e) ? this._$_8BitAutoTiling$_(t, s, i, e) : this._$_auto$_._$IGNORE_INDEX$_;
        }
        _$_8BitAutoTiling$_(t, s, i, e) {
            this._$_mode$_ === this._$_auto$_._$ERASE_MODE$_ && (i = void 0);
            const h = this._$_auto$_._$GetTile$_(t, s - 1), r = this._$_auto$_._$GetTile$_(t - 1, s), n = this._$_auto$_._$GetTile$_(t + 1, s), o = this._$_auto$_._$GetTile$_(t, s + 1), a = this._$_auto$_._$GetTile$_(t - 1, s - 1), l = this._$_auto$_._$GetTile$_(t + 1, s - 1), u = this._$_auto$_._$GetTile$_(t - 1, s + 1), c = this._$_auto$_._$GetTile$_(t + 1, s + 1), f = "n" === i ? this._$_auto$_._$FORCE_INDEX$_ : h, d = "w" === i ? this._$_auto$_._$FORCE_INDEX$_ : r, p = "e" === i ? this._$_auto$_._$FORCE_INDEX$_ : n, m = "s" === i ? this._$_auto$_._$FORCE_INDEX$_ : o, g = "nw" === i ? this._$_auto$_._$FORCE_INDEX$_ : a, y = "ne" === i ? this._$_auto$_._$FORCE_INDEX$_ : l, w = "sw" === i ? this._$_auto$_._$FORCE_INDEX$_ : u, S = "se" === i ? this._$_auto$_._$FORCE_INDEX$_ : c, b = this._$_auto$_._$IsTileValid$_(f, !0, h, e), M = this._$_auto$_._$IsTileValid$_(d, !0, r, e), v = this._$_auto$_._$IsTileValid$_(p, !0, n, e), x = this._$_auto$_._$IsTileValid$_(m, !0, o, e), G = b && M ? this._$_auto$_._$IsTileValid$_(g, !0, a, e) : 0, T = b && v ? this._$_auto$_._$IsTileValid$_(y, !0, l, e) : 0, _ = x && M ? this._$_auto$_._$IsTileValid$_(w, !0, u, e) : 0, I = x && v ? this._$_auto$_._$IsTileValid$_(S, !0, c, e) : 0;
            return +G + 2 * b + 4 * T + 8 * M + 16 * v + 32 * _ + 64 * x + 128 * I;
        }
        _$_Get8BitTileIndex$_(t, s, i, e) {
            return t === this._$_auto$_._$IGNORE_INDEX$_ || t === this._$_auto$_._$EMPTY_INDEX$_ ? t : this._$_auto$_._$GetTileIndex$_(qu.get(t), s, i, e);
        }
    };
}

{
    const Xu = self._$C3$_;
    Xu._$Plugins$_._$Spritefont2$_ = class extends Xu._$SDKPluginBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const Yu = self._$C3$_;
    Yu._$Plugins$_._$Spritefont2$_._$Type$_ = class extends Yu._$SDKTypeBase$_ {
        constructor(t) {
            super(t), this._$_spriteFont$_ = Yu._$New$_(self._$SpriteFont$_);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {
            this._$GetImageInfo$_()._$LoadAsset$_(this._$_runtime$_);
        }
        _$LoadTextures$_(t) {
            return this._$GetImageInfo$_()._$LoadStaticTexture$_(t, {
                _$sampling$_: this._$_runtime$_._$GetSampling$_()
            });
        }
        _$ReleaseTextures$_() {
            this._$GetImageInfo$_()._$ReleaseTexture$_();
        }
        _$GetSpriteFont$_() {
            return this._$_spriteFont$_;
        }
        _$UpdateSettings$_(t, s, i, e) {
            const h = this._$GetImageInfo$_(), r = this._$_spriteFont$_;
            r._$SetWidth$_(h._$GetWidth$_()), r._$SetHeight$_(h._$GetHeight$_()), 
            r._$SetCharacterWidth$_(t), r._$SetCharacterHeight$_(s), r._$SetCharacterSet$_(i), 
            r._$SetSpacingData$_(e), r._$UpdateCharacterMap$_();
        }
    };
}

{
    const $u = self._$C3$_, Ku = self._$C3X$_, Zu = $u._$New$_($u._$Vector2$_), Qu = [ "left", "center", "right" ], tc = [ "top", "center", "bottom" ], sc = [ "word", "cjk", "character" ], P = ($u._$Plugins$_._$Spritefont2$_.Instance = class extends $u._$SDKWorldInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_text$_ = "", this._$_enableBBcode$_ = !0, this._$_characterWidth$_ = 16, 
            this._$_characterHeight$_ = 16, this._$_characterSet$_ = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,;:?!-_~#\"'&()[]|`\\/@+=*$<>";
            let i = "";
            if (this._$_characterScale$_ = 1, this._$_characterSpacing$_ = 0, this._$_lineHeight$_ = 0, 
            this._$_horizontalAlign$_ = 0, this._$_verticalAlign$_ = 0, this._$_wrapMode$_ = "word", 
            this._$_needsTextLayout$_ = !0, this._$_readAloud$_ = !1, this._$_screenReaderText$_ = null, 
            this._$_spriteFontText$_ = null, this._$_typewriterStartTime$_ = -1, 
            this._$_typewriterEndTime$_ = -1, this._$_typewriterLength$_ = 0, s) {
                this._$_text$_ = s[0], this._$_enableBBcode$_ = s[1], this._$_characterWidth$_ = s[2], 
                this._$_characterHeight$_ = s[3], this._$_characterSet$_ = s[4], 
                i = s[5], this._$_characterScale$_ = s[6], this._$_characterSpacing$_ = s[7], 
                this._$_lineHeight$_ = s[8], this._$_horizontalAlign$_ = s[9], this._$_verticalAlign$_ = s[10], 
                this._$_wrapMode$_ = sc[s[11]];
                const h = this._$GetWorldInfo$_();
                h._$SetVisible$_(s[12]), this._$_readAloud$_ = !!s[14];
            }
            this._$_sdkType$_._$UpdateSettings$_(this._$_characterWidth$_, this._$_characterHeight$_, this._$_characterSet$_, i), 
            this._$_spriteFontText$_ = $u._$New$_(self._$SpriteFontText$_, this._$_sdkType$_._$GetSpriteFont$_());
            const e = this._$GetWorldInfo$_();
            this._$_spriteFontText$_._$SetSize$_(e._$GetWidth$_(), e._$GetHeight$_()), 
            this._$_UpdateSettings$_(), this._$_UpdateScreenReaderText$_(), this._$_inst$_._$SetMustMitigateZFighting$_();
        }
        _$Release$_() {
            this._$_CancelTypewriter$_(), this._$_screenReaderText$_ && (this._$_screenReaderText$_._$Release$_(), 
            this._$_screenReaderText$_ = null), this._$_spriteFontText$_._$Release$_(), 
            this._$_spriteFontText$_ = null, super._$Release$_();
        }
        _$_UpdateSettings$_() {
            const t = this._$_spriteFontText$_;
            t && (t._$SetBBCodeEnabled$_(this._$_enableBBcode$_), t._$SetText$_(this._$_text$_), 
            t._$SetWordWrapMode$_(this._$_wrapMode$_), t._$SetHorizontalAlign$_(Qu[this._$_horizontalAlign$_]), 
            t._$SetVerticalAlign$_(tc[this._$_verticalAlign$_]), t._$SetSpacing$_(this._$_characterSpacing$_), 
            t._$SetLineHeight$_(this._$_lineHeight$_));
        }
        _$_UpdateTextSize$_() {
            const t = this._$GetWorldInfo$_();
            this._$_spriteFontText$_._$SetSize$_(t._$GetWidth$_(), t._$GetHeight$_()), 
            this._$_spriteFontText$_._$SetScale$_(this._$_characterScale$_);
        }
        _$_UpdateScreenReaderText$_() {
            if (this._$_readAloud$_) {
                let t = this._$_text$_;
                this._$_enableBBcode$_ && (t = $u._$BBString$_._$StripAnyTags$_(t)), 
                this._$_screenReaderText$_ ? this._$_screenReaderText$_._$SetText$_(t) : this._$_screenReaderText$_ = $u._$New$_($u._$ScreenReaderText$_, this._$_runtime$_, t);
            } else this._$_screenReaderText$_ && (this._$_screenReaderText$_._$Release$_(), 
            this._$_screenReaderText$_ = null);
        }
        _$Draw$_(e) {
            const h = this._$_objectClass$_._$GetImageInfo$_(), r = h._$GetTexture$_();
            if (r) {
                e._$SetTexture$_(r);
                let t = this._$GetWorldInfo$_(), s = t._$GetBoundingQuad$_(), i = this._$_spriteFontText$_;
                i._$SetScale$_(this._$_characterScale$_), i._$SetSceneGraphScale$_(t._$GetSceneGraphScale$_()), 
                this._$_runtime$_._$IsPixelRoundingEnabled$_() && (s = t._$PixelRoundQuad$_(s)), 
                i._$SetSize$_(t._$GetWidth$_(), t._$GetHeight$_()), i._$GetSpriteFont$_()._$SetTexRect$_(h._$GetTexRect$_()), 
                i._$SetColor$_(t._$GetUnpremultipliedColor$_()), i._$Draw$_(e, s._$getTlx$_(), s._$getTly$_(), t._$GetAngle$_()), 
                this._$_needsTextLayout$_ = !1;
            }
        }
        _$SaveToJson$_() {
            const t = {
                t: this._$_text$_,
                ebbc: this._$_enableBBcode$_,
                csc: this._$_characterScale$_,
                csp: this._$_characterSpacing$_,
                lh: this._$_lineHeight$_,
                ha: this._$_horizontalAlign$_,
                va: this._$_verticalAlign$_,
                w: this._$_wrapMode$_,
                cw: this._$_sdkType$_._$GetSpriteFont$_()._$GetCharacterWidth$_(),
                ch: this._$_sdkType$_._$GetSpriteFont$_()._$GetCharacterHeight$_(),
                cs: this._$_sdkType$_._$GetSpriteFont$_()._$GetCharacterSet$_(),
                sd: this._$_sdkType$_._$GetSpriteFont$_()._$GetSpacingData$_()
            };
            return -1 !== this._$_typewriterEndTime$_ && (t.tw = {
                st: this._$_typewriterStartTime$_,
                en: this._$_typewriterEndTime$_,
                l: this._$_typewriterLength$_
            }), t;
        }
        _$LoadFromJson$_(t) {
            if (this._$_CancelTypewriter$_(), this._$_text$_ = t.t, this._$_enableBBcode$_ = t.ebbc, 
            this._$_characterScale$_ = t.csc, this._$_characterSpacing$_ = t.csp, 
            this._$_lineHeight$_ = t.lh, this._$_horizontalAlign$_ = t.ha, this._$_verticalAlign$_ = t.va, 
            t.hasOwnProperty("w")) {
                const i = t.w;
                this._$_wrapMode$_ = "boolean" == typeof i ? i ? "word" : "character" : i;
            } else this._$_wrapMode$_ = "word";
            if (t.hasOwnProperty("tw")) {
                const e = t.tw;
                this._$_typewriterStartTime$_ = e.st, this._$_typewriterEndTime$_ = e.en, 
                this._$_typewriterLength$_ = t.l;
            }
            const s = this._$_sdkType$_._$GetSpriteFont$_();
            s._$SetCharacterWidth$_(t.cw), s._$SetCharacterHeight$_(t.ch), s._$SetCharacterSet$_(t.cs), 
            s._$SetSpacingData$_(t.sd), this._$_UpdateSettings$_(), this._$_UpdateScreenReaderText$_(), 
            -1 !== this._$_typewriterEndTime$_ && this._$_StartTicking$_();
        }
        _$GetPropertyValueByIndex$_(t) {
            switch (t) {
              case 0:
                return this._$GetText$_();

              case 1:
                return this._$_enableBBcode$_;

              case 2:
                return this._$_sdkType$_._$GetSpriteFont$_()._$GetCharacterWidth$_();

              case 3:
                return this._$_sdkType$_._$GetSpriteFont$_()._$GetCharacterHeight$_();

              case 4:
                return this._$_sdkType$_._$GetSpriteFont$_()._$GetCharacterSet$_();

              case 5:
                return this._$_sdkType$_._$GetSpriteFont$_()._$GetSpacingData$_();

              case 6:
                return this._$_GetScale$_();

              case 7:
                return this._$_GetCharacterSpacing$_();

              case 8:
                return this._$_GetLineHeight$_();

              case 9:
                return this._$_GetHAlign$_();

              case 10:
                return this._$_GetVAlign$_();

              case 11:
                return this._$_GetWrapMode$_();
            }
        }
        _$SetPropertyValueByIndex$_(t, s) {
            switch (t) {
              case 0:
                this._$_SetText$_(s);
                break;

              case 1:
                this._$_enableBBcode$_ !== !!s && (this._$_enableBBcode$_ = !!s, 
                this._$_UpdateSettings$_());
                break;

              case 2:
                this._$_sdkType$_._$GetSpriteFont$_()._$SetCharacterWidth$_(s);
                break;

              case 3:
                this._$_sdkType$_._$GetSpriteFont$_()._$SetCharacterHeight$_(s);
                break;

              case 4:
                this._$_sdkType$_._$GetSpriteFont$_()._$SetCharacterSet$_(s);
                break;

              case 5:
                this._$_sdkType$_._$GetSpriteFont$_()._$SetSpacingData$_(s);
                break;

              case 6:
                this._$_SetScale$_(s);
                break;

              case 7:
                this._$_SetCharacterSpacing$_(s);
                break;

              case 8:
                this._$_SetLineHeight$_(s);
                break;

              case 9:
                this._$_SetHAlign$_(s);
                break;

              case 10:
                this._$_SetVAlign$_(s);
                break;

              case 11:
                this._$_SetWrapMode$_(s);
            }
        }
        _$_SetText$_(t) {
            this._$_text$_ !== t && (this._$_text$_ = t, this._$_spriteFontText$_._$SetText$_(t), 
            this._$_UpdateScreenReaderText$_(), this._$_runtime$_._$UpdateRender$_());
        }
        _$GetText$_() {
            return this._$_text$_;
        }
        _$_StartTypewriter$_(t, s) {
            this._$_SetText$_(t), this._$_typewriterStartTime$_ = this._$_runtime$_._$GetWallTime$_(), 
            this._$_typewriterEndTime$_ = this._$_typewriterStartTime$_ + s / this._$GetInstance$_()._$GetActiveTimeScale$_(), 
            this._$_typewriterLength$_ = $u._$CountGraphemes$_($u._$BBString$_._$StripAnyTags$_(t)), 
            this._$_spriteFontText$_._$SetDrawMaxCharacterCount$_(0), this._$_StartTicking$_();
        }
        _$_CancelTypewriter$_() {
            this._$_typewriterStartTime$_ = -1, this._$_typewriterEndTime$_ = -1, 
            this._$_typewriterLength$_ = 0, this._$_spriteFontText$_._$SetDrawMaxCharacterCount$_(-1), 
            this._$_StopTicking$_();
        }
        _$_FinishTypewriter$_() {
            -1 !== this._$_typewriterEndTime$_ && (this._$_CancelTypewriter$_(), 
            this._$Trigger$_($u._$Plugins$_._$Spritefont2$_._$Cnds$_._$OnTypewriterTextFinished$_), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$_SetScale$_(t) {
            this._$_characterScale$_ !== t && (this._$_characterScale$_ = t, this._$_spriteFontText$_._$SetScale$_(this._$_characterScale$_), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetScale$_() {
            return this._$_characterScale$_;
        }
        _$_SetCharacterSpacing$_(t) {
            this._$_characterSpacing$_ !== t && (this._$_characterSpacing$_ = t, 
            this._$_spriteFontText$_._$SetSpacing$_(this._$_characterSpacing$_), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetCharacterSpacing$_() {
            return this._$_characterSpacing$_;
        }
        _$_SetLineHeight$_(t) {
            this._$_lineHeight$_ !== t && (this._$_lineHeight$_ = t, this._$_spriteFontText$_._$SetLineHeight$_(this._$_lineHeight$_), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetLineHeight$_() {
            return this._$_lineHeight$_;
        }
        _$_SetHAlign$_(t) {
            this._$_horizontalAlign$_ !== t && (this._$_horizontalAlign$_ = t, this._$_UpdateSettings$_(), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetHAlign$_() {
            return this._$_horizontalAlign$_;
        }
        _$_SetVAlign$_(t) {
            this._$_verticalAlign$_ !== t && (this._$_verticalAlign$_ = t, this._$_UpdateSettings$_(), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetVAlign$_() {
            return this._$_verticalAlign$_;
        }
        _$_SetWrapModeByIndex$_(t) {
            this._$_SetWrapMode$_(sc[t]);
        }
        _$_SetWrapMode$_(t) {
            this._$_wrapMode$_ !== t && (this._$_wrapMode$_ = t, this._$_UpdateSettings$_(), 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$_GetWrapMode$_() {
            return this._$_wrapMode$_;
        }
        _$_SetReadAloud$_(t) {
            this._$_readAloud$_ = !!t, this._$_UpdateScreenReaderText$_();
        }
        _$_IsReadAloud$_() {
            return this._$_readAloud$_;
        }
        _$_GetTextWidth$_() {
            return this._$_UpdateTextSize$_(), this._$_spriteFontText$_._$GetTextWidth$_();
        }
        _$_GetTextHeight$_() {
            return this._$_UpdateTextSize$_(), this._$_spriteFontText$_._$GetTextHeight$_();
        }
        _$_GetTagAtPosition$_(t, s) {
            this._$_UpdateTextSize$_();
            const i = this._$GetWorldInfo$_(), e = (Zu.set(t - i._$GetX$_(), s - i._$GetY$_()), 
            Zu.rotate(-i._$GetAngle$_()), Zu.offset(i._$GetWidth$_() * i._$GetOriginX$_(), i._$GetHeight$_() * i._$GetOriginY$_()), 
            this._$_spriteFontText$_._$HitTestFragment$_(Zu._$getX$_(), Zu._$getY$_()));
            if (e) {
                const h = e._$GetStyleTag$_("tag");
                if (h) return h.param;
            }
            return "";
        }
        _$_HasTagAtPosition$_(t, s, i) {
            const e = this._$_GetTagAtPosition$_(s, i);
            return e && $u._$equalsNoCase$_(t, e);
        }
        _$_GetTagPosition$_(t, s) {
            this._$_UpdateTextSize$_(), s = Math.floor(s);
            const i = this._$_spriteFontText$_._$FindFragmentWithTag$_(t, s);
            if (!i) return null;
            const e = this._$GetWorldInfo$_();
            return Zu.set(i._$GetPosX$_(), i._$GetPosY$_()), Zu.offset(-e._$GetWidth$_() * e._$GetOriginX$_(), -e._$GetHeight$_() * e._$GetOriginY$_()), 
            Zu.rotate(e._$GetAngle$_()), Zu.offset(e._$GetX$_(), e._$GetY$_()), 
            {
                x: Zu._$getX$_(),
                y: Zu._$getY$_(),
                width: i._$GetWidth$_(),
                height: i._$GetHeight$_()
            };
        }
        _$_GetTagCount$_(t) {
            return this._$_UpdateTextSize$_(), this._$_spriteFontText$_._$CountFragmentsWithTag$_(t);
        }
        _$Tick$_() {
            const s = this._$_runtime$_._$GetWallTime$_();
            if (s >= this._$_typewriterEndTime$_) this._$_CancelTypewriter$_(), 
            this._$Trigger$_($u._$Plugins$_._$Spritefont2$_._$Cnds$_._$OnTypewriterTextFinished$_), 
            this._$_runtime$_._$UpdateRender$_(); else {
                let t = $u._$relerp$_(this._$_typewriterStartTime$_, this._$_typewriterEndTime$_, s, 0, this._$_typewriterLength$_);
                (t = Math.floor(t)) !== this._$_spriteFontText$_._$GetDrawMaxCharacterCount$_() && (this._$_spriteFontText$_._$SetDrawMaxCharacterCount$_(t), 
                this._$_runtime$_._$UpdateRender$_());
            }
        }
        _$GetDebuggerProperties$_() {
            const t = "plugins.spritefont2";
            return [ {
                title: t + ".name",
                properties: [ {
                    name: t + ".properties.text.name",
                    value: this._$GetText$_(),
                    _$onedit$_: t => this._$_SetText$_(t)
                }, {
                    name: t + ".properties.scale.name",
                    value: this._$_GetScale$_(),
                    _$onedit$_: t => this._$_SetScale$_(t)
                }, {
                    name: t + ".properties.character-spacing.name",
                    value: this._$_GetCharacterSpacing$_(),
                    _$onedit$_: t => this._$_SetCharacterSpacing$_(t)
                }, {
                    name: t + ".properties.line-height.name",
                    value: this._$_GetLineHeight$_(),
                    _$onedit$_: t => this._$_SetLineHeight$_(t)
                } ]
            } ];
        }
        _$GetScriptInterfaceClass$_() {
            return self._$ISpriteFontInstance$_;
        }
    }, new WeakMap()), ic = new Map([ [ "left", 0 ], [ "center", 1 ], [ "right", 2 ] ]), ec = new Map([ [ "top", 0 ], [ "center", 1 ], [ "bottom", 2 ] ]);
    self._$ISpriteFontInstance$_ = class extends self._$IWorldInstance$_ {
        constructor() {
            super(), P.set(this, self._$IInstance$_._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        get text() {
            return P.get(this)._$GetText$_();
        }
        set text(t) {
            Ku._$RequireString$_(t);
            const s = P.get(this);
            s._$_CancelTypewriter$_(), s._$_SetText$_(t);
        }
        _$typewriterText$_(t, s) {
            Ku._$RequireString$_(t), Ku._$RequireFiniteNumber$_(s);
            const i = P.get(this);
            i._$_CancelTypewriter$_(), i._$_StartTypewriter$_(t, s);
        }
        _$typewriterFinish$_() {
            P.get(this)._$_FinishTypewriter$_();
        }
        set _$characterScale$_(t) {
            Ku._$RequireFiniteNumber$_(t), P.get(this)._$_SetScale$_(t);
        }
        get _$characterScale$_() {
            return P.get(this)._$_GetScale$_();
        }
        set _$characterSpacing$_(t) {
            Ku._$RequireFiniteNumber$_(t), P.get(this)._$_SetCharacterSpacing$_(t);
        }
        get _$characterSpacing$_() {
            return P.get(this)._$_GetCharacterSpacing$_();
        }
        set lineHeight(t) {
            Ku._$RequireFiniteNumber$_(t), P.get(this)._$_SetLineHeight$_(t);
        }
        get lineHeight() {
            return P.get(this)._$_GetLineHeight$_();
        }
        set _$horizontalAlign$_(t) {
            Ku._$RequireString$_(t);
            const s = ic.get(t);
            if (void 0 === s) throw new Error("invalid mode");
            P.get(this)._$_SetHAlign$_(s);
        }
        get _$horizontalAlign$_() {
            return Qu[P.get(this)._$_GetHAlign$_()];
        }
        set verticalAlign(t) {
            Ku._$RequireString$_(t);
            const s = ec.get(t);
            if (void 0 === s) throw new Error("invalid mode");
            P.get(this)._$_SetVAlign$_(s);
        }
        get verticalAlign() {
            return tc[P.get(this)._$_GetVAlign$_()];
        }
        set _$wordWrapMode$_(t) {
            if (!sc.includes(t)) throw new Error("invalid mode");
            P.get(this)._$_SetWrapMode$_(t);
        }
        get _$wordWrapMode$_() {
            return P.get(this)._$_GetWrapMode$_();
        }
        set _$readAloud$_(t) {
            P.get(this)._$_SetReadAloud$_(!!t);
        }
        get _$readAloud$_() {
            return P.get(this)._$_IsReadAloud$_();
        }
        get _$textWidth$_() {
            return P.get(this)._$_GetTextWidth$_();
        }
        get _$textHeight$_() {
            return P.get(this)._$_GetTextHeight$_();
        }
        _$getTextSize$_() {
            const t = P.get(this);
            return [ t._$_GetTextWidth$_(), t._$_GetTextHeight$_() ];
        }
        _$hasTagAtPosition$_(t, s, i) {
            return Ku._$RequireString$_(t), Ku._$RequireFiniteNumber$_(s), Ku._$RequireFiniteNumber$_(i), 
            P.get(this)._$_HasTagAtPosition$_(t, s, i);
        }
        _$getTagAtPosition$_(t, s) {
            return Ku._$RequireFiniteNumber$_(t), Ku._$RequireFiniteNumber$_(s), 
            P.get(this)._$_GetTagAtPosition$_(t, s);
        }
        _$getTagPositionAndSize$_(t, s = 0) {
            return Ku._$RequireString$_(t), Ku._$RequireFiniteNumber$_(s), P.get(this)._$_GetTagPosition$_(t, s);
        }
        _$getTagCount$_(t) {
            return Ku._$RequireString$_(t), P.get(this)._$_GetTagCount$_(t);
        }
    };
}

{
    const hc = self._$C3$_;
    hc._$Plugins$_._$Spritefont2$_._$Cnds$_ = {
        _$CompareText$_(t, s) {
            return s ? this._$_text$_ === t : hc._$equalsNoCase$_(this._$_text$_, t);
        },
        _$IsRunningTypewriterText$_() {
            return -1 !== this._$_typewriterEndTime$_;
        },
        _$OnTypewriterTextFinished$_() {
            return !0;
        },
        _$HasTagAtPosition$_(t, s, i) {
            return this._$_HasTagAtPosition$_(t, s, i);
        }
    };
}

{
    const rc = self._$C3$_;
    rc._$Plugins$_._$Spritefont2$_._$Acts$_ = {
        _$SetText$_(t) {
            this._$_CancelTypewriter$_(), "number" == typeof t && t < 1e9 && (t = Math.round(1e10 * t) / 1e10), 
            this._$_SetText$_(t.toString());
        },
        _$AppendText$_(t) {
            this._$_CancelTypewriter$_(), (t = (t = "number" == typeof t && t < 1e9 ? Math.round(1e10 * t) / 1e10 : t).toString()) && this._$_SetText$_(this._$_text$_ + t);
        },
        _$TypewriterText$_(t, s) {
            this._$_CancelTypewriter$_(), "number" == typeof t && t < 1e9 && (t = Math.round(1e10 * t) / 1e10), 
            this._$_StartTypewriter$_(t.toString(), s);
        },
        _$TypewriterFinish$_() {
            this._$_FinishTypewriter$_();
        },
        _$SetScale$_(t) {
            this._$_SetScale$_(t);
        },
        _$SetCharacterSpacing$_(t) {
            this._$_SetCharacterSpacing$_(t);
        },
        _$SetLineHeight$_(t) {
            this._$_SetLineHeight$_(t);
        },
        _$SetCharacterWidth$_(t, s) {
            let i = !1, e = this._$_sdkType$_._$GetSpriteFont$_();
            for (const h of t) if (" " === h) e._$SetSpaceWidth$_(s), i = !0; else {
                const r = e._$GetCharacter$_(h);
                r && (r._$SetDisplayWidth$_(s), i = !0);
            }
            i && e._$SetCharacterWidthsChanged$_(), this._$_runtime$_._$UpdateRender$_();
        },
        _$SetEffect$_(t) {
            this._$GetWorldInfo$_()._$SetBlendMode$_(t), this._$_runtime$_._$UpdateRender$_();
        },
        _$SetHAlign$_(t) {
            this._$_SetHAlign$_(t);
        },
        _$SetVAlign$_(t) {
            this._$_SetVAlign$_(t);
        },
        _$SetWrapping$_(t) {
            this._$_SetWrapModeByIndex$_(t);
        },
        _$SetReadAloud$_(t) {
            this._$_SetReadAloud$_(t);
        }
    };
}

{
    const nc = self._$C3$_;
    nc._$Plugins$_._$Spritefont2$_._$Exps$_ = {
        _$CharacterWidth$_(t) {
            const s = this._$_sdkType$_._$GetSpriteFont$_()._$GetCharacter$_(t);
            return s ? s._$GetDisplayWidth$_() : this._$_sdkType$_._$GetSpriteFont$_()._$GetCharacterWidth$_();
        },
        _$CharacterHeight$_() {
            return this._$_characterHeight$_;
        },
        _$CharacterScale$_() {
            return this._$_characterScale$_;
        },
        _$CharacterSpacing$_() {
            return this._$_characterSpacing$_;
        },
        _$LineHeight$_() {
            return this._$_lineHeight$_;
        },
        Text() {
            return this._$_text$_;
        },
        _$PlainText$_() {
            return this._$_enableBBcode$_ ? nc._$BBString$_._$StripAnyTags$_(this._$_text$_) : this._$_text$_;
        },
        _$TextWidth$_() {
            return this._$_GetTextWidth$_();
        },
        _$TextHeight$_() {
            return this._$_GetTextHeight$_();
        },
        _$TagAtPosition$_(t, s) {
            return this._$_GetTagAtPosition$_(t, s);
        },
        _$TagCount$_(t) {
            return this._$_GetTagCount$_(t);
        },
        _$TagX$_(t, s) {
            const i = this._$_GetTagPosition$_(t, s);
            return i ? i.x : 0;
        },
        _$TagY$_(t, s) {
            const i = this._$_GetTagPosition$_(t, s);
            return i ? i.y : 0;
        },
        _$TagWidth$_(t, s) {
            const i = this._$_GetTagPosition$_(t, s);
            return i ? i.width : 0;
        },
        _$TagHeight$_(t, s) {
            const i = this._$_GetTagPosition$_(t, s);
            return i ? i.height : 0;
        }
    };
}

{
    const oc = self._$C3$_;
    self._$SpriteFontCharacter$_ = class {
        constructor(t, s, i, e) {
            let h = t._$GetCharacterWidth$_(), r = t._$GetCharacterHeight$_();
            this._$_spriteFont$_ = t, this._$_char$_ = s, this._$_pxRect$_ = new oc.Rect(i, e, i + h, e + r), 
            this._$_texRect$_ = new oc.Rect(), this._$_displayWidth$_ = -1, this._$_UpdateTexRect$_();
        }
        _$Release$_() {
            this._$_spriteFont$_ = null, this._$_pxRect$_ = null, this._$_texRect$_ = null;
        }
        _$_UpdateTexRect$_() {
            let t = this._$_spriteFont$_._$GetWidth$_(), s = this._$_spriteFont$_._$GetHeight$_();
            this._$_texRect$_._$copy$_(this._$_pxRect$_), this._$_texRect$_._$divide$_(t, s), 
            this._$_texRect$_._$lerpInto$_(this._$_spriteFont$_._$GetTexRect$_());
        }
        _$GetSpriteFont$_() {
            return this._$_spriteFont$_;
        }
        _$GetChar$_() {
            return this._$_char$_;
        }
        _$GetTexRect$_() {
            return this._$_texRect$_;
        }
        _$SetDisplayWidth$_(t) {
            this._$_displayWidth$_ = t;
        }
        _$GetDisplayWidth$_() {
            return this._$_displayWidth$_ < 0 ? this._$_spriteFont$_._$GetCharacterWidth$_() : this._$_displayWidth$_;
        }
    };
}

{
    let r = function(t, s) {
        t = t.trim();
        const i = parseFloat(t);
        return isFinite(i) ? t.endsWith("%") ? s * i / 100 : i : 0;
    }, C = function(t) {
        return (h = h || R._$CreateCanvas$_(32, 32).getContext("2d")).fillStyle = "#FFFFFF", 
        h.fillStyle = t, h.fillStyle;
    }, R = (r, C, self._$C3$_), P = new R.Rect(), E = new R._$Quad$_(), A = new R._$Color$_(), s = new Set([ "left", "center", "right" ]), i = new Set([ "top", "center", "bottom" ]), e = new Set([ "word", "cjk", "character" ]), h = null;
    self._$SpriteFontText$_ = class {
        constructor(t) {
            this._$_spriteFont$_ = t, this._$_cssWidth$_ = 0, this._$_cssHeight$_ = 0, 
            this._$_text$_ = "", this._$_isBBcodeEnabled$_ = !1, this._$_bbString$_ = null, 
            this._$_wrappedText$_ = R._$New$_(R._$WordWrap$_), this._$_wrapMode$_ = "word", 
            this._$_wordWrapChanged$_ = !1, this._$_textLayoutChanged$_ = !1, this._$_horizontalAlign$_ = "left", 
            this._$_verticalAlign$_ = "top", this._$_scale$_ = 1, this._$_sceneGraphScale$_ = 1, 
            this._$_spacing$_ = 0, this._$_lineHeight$_ = 0, this._$_color$_ = R._$New$_(R._$Color$_), 
            this._$_drawMaxCharCount$_ = -1, this._$_drawCharCount$_ = 0, this._$_measureTextCallback$_ = t => this._$_MeasureText$_(t), 
            this._$_spriteFont$_._$_AddSpriteFontText$_(this);
        }
        _$Release$_() {
            this._$_spriteFont$_._$_RemoveSpriteFontText$_(this), this._$_color$_ = null, 
            this._$_measureTextCallback$_ = null, this._$_wrappedText$_._$Clear$_(), 
            this._$_wrappedText$_ = null, this._$_spriteFont$_ = null, this._$_bbString$_ = null;
        }
        _$_MeasureText$_(t) {
            if (t._$IsIcon$_()) return {
                width: 0,
                height: 0
            };
            const s = t._$GetCharacterArray$_(), i = t._$GetStyleTag$_("scale"), e = (i ? parseFloat(i.param) : this._$_scale$_) * this._$_sceneGraphScale$_, h = t._$GetStyleTag$_("scalex"), r = (h ? parseFloat(h.param) : 1) * e, n = t._$GetStyleTag$_("scaley"), o = (n ? parseFloat(n.param) : 1) * e, a = this._$_spriteFont$_._$GetCharacterHeight$_() * o + this._$_lineHeight$_, l = this._$GetSpriteFont$_(), u = l._$GetCharacterWidth$_() * r, c = this._$GetSpacing$_();
            if (l._$HasAnyCustomWidths$_()) {
                let i = 0, e = 0;
                for (const f of s) {
                    let t = u, s = l._$GetCharacter$_(f);
                    s ? t = s._$GetDisplayWidth$_() * r : " " === f && (t = l._$GetSpaceWidth$_() * r), 
                    e += t, ++i;
                }
                return {
                    width: e + i * c,
                    height: a
                };
            }
            {
                const d = s.length, p = Math.max(d, 0);
                return {
                    width: u * d + p * c,
                    height: a
                };
            }
        }
        _$_SetTextLayoutChanged$_() {
            this._$_textLayoutChanged$_ = !0;
        }
        _$_SetWordWrapChanged$_() {
            this._$_SetTextLayoutChanged$_(), this._$_wordWrapChanged$_ = !0, this._$_wrappedText$_._$Clear$_();
        }
        _$SetSize$_(t, s) {
            t <= 0 || s <= 0 || this._$_cssWidth$_ === t && this._$_cssHeight$_ === s || (this._$_cssWidth$_ !== t ? this._$_SetWordWrapChanged$_() : this._$_SetTextLayoutChanged$_(), 
            this._$_cssWidth$_ = t, this._$_cssHeight$_ = s);
        }
        _$SetDrawMaxCharacterCount$_(t) {
            this._$_drawMaxCharCount$_ = Math.floor(t);
        }
        _$GetDrawMaxCharacterCount$_() {
            return this._$_drawMaxCharCount$_;
        }
        _$HitTestFragment$_(t, s) {
            this._$_UpdateTextMeasurements$_();
            const i = this._$_wrappedText$_._$GetLines$_();
            for (const e of i) if (s > e._$GetPosY$_() && s < e._$GetPosY$_() + e._$GetHeight$_()) for (const h of e._$fragments$_()) if (t >= h._$GetPosX$_() && t < h._$GetPosX$_() + h._$GetWidth$_()) return h;
            return null;
        }
        *_$fragmentsWithTag$_(t) {
            this._$_UpdateTextMeasurements$_();
            const s = this._$_wrappedText$_._$GetLines$_();
            for (const i of s) for (const e of i._$fragments$_()) {
                const h = e._$GetStyleTag$_("tag");
                h && R._$equalsNoCase$_(h.param, t) && (yield e);
            }
        }
        _$FindFragmentWithTag$_(t, s) {
            for (const i of this._$fragmentsWithTag$_(t)) {
                if (0 === s) return i;
                --s;
            }
            return null;
        }
        _$CountFragmentsWithTag$_(t) {
            let s = 0;
            for (const i of this._$fragmentsWithTag$_(t)) ++s;
            return s;
        }
        _$_UpdateTextMeasurements$_() {
            this._$_UpdateWordWrap$_(), this._$_UpdateTextLayout$_();
        }
        _$_UpdateWordWrap$_() {
            if (this._$_wordWrapChanged$_) {
                !this._$_isBBcodeEnabled$_ || this._$_bbString$_ && this._$_bbString$_.toString() === this._$_text$_ || (this._$_bbString$_ = new R._$BBString$_(this._$_text$_, {
                    _$noEscape$_: !0
                }));
                const t = -this._$GetSpacing$_();
                this._$_wrappedText$_._$WordWrap$_(this._$_isBBcodeEnabled$_ ? this._$_bbString$_._$toFragmentList$_() : this._$_text$_, this._$_measureTextCallback$_, this._$_cssWidth$_, this._$_wrapMode$_, t), 
                this._$_wordWrapChanged$_ = !1;
            }
        }
        _$_UpdateTextLayout$_() {
            this._$_textLayoutChanged$_ && (this._$_LayoutText$_(), this._$_textLayoutChanged$_ = !1);
        }
        _$_LayoutText$_() {
            let i = 0, e = this._$_lineHeight$_, h = R._$cloneArray$_(this._$_wrappedText$_._$GetLines$_());
            for (const s of h) {
                s._$SetPosX$_(NaN), s._$SetPosY$_(NaN);
                for (const r of s._$fragments$_()) r._$SetPosX$_(NaN), r._$SetPosY$_(NaN);
            }
            const t = h.reduce((t, s) => t + s._$GetHeight$_(), 0) - e;
            "center" === this._$_verticalAlign$_ ? i = Math.max(Math.floor(this._$_cssHeight$_ / 2 - t / 2), 0) : "bottom" === this._$_verticalAlign$_ && (i = Math.floor(this._$_cssHeight$_ - t));
            for (let t = 0, s = h.length; t < s; ++t) {
                const n = h[t], o = n._$GetHeight$_();
                if (0 < t && i > this._$_cssHeight$_ - (o - e)) break;
                0 <= i && this._$_LayoutTextLine$_(n, i), i += o;
            }
        }
        _$_LayoutTextLine$_(t, s) {
            let i = 0;
            "center" === this._$_horizontalAlign$_ ? i = Math.max(Math.floor((this._$_cssWidth$_ - t._$GetWidth$_()) / 2), 0) : "right" === this._$_horizontalAlign$_ && (i = Math.max(Math.floor(this._$_cssWidth$_ - t._$GetWidth$_()), 0)), 
            t._$SetPosX$_(i), t._$SetPosY$_(s);
            for (const e of t._$fragments$_()) e._$IsIcon$_() || (this._$_LayoutTextFragment$_(e, i, s), 
            i += e._$GetWidth$_());
        }
        _$_LayoutTextFragment$_(t, s, i) {
            const e = t._$GetStyleTag$_("offsetx"), h = (s += e ? r(e.param, t._$GetHeight$_()) : 0, 
            t._$GetStyleTag$_("offsety"));
            i += h ? r(h.param, t._$GetHeight$_()) : 0, t._$SetPosX$_(s), t._$SetPosY$_(i);
        }
        _$Draw$_(t, s, i, e) {
            this._$_UpdateTextMeasurements$_(), this._$_drawCharCount$_ = 0;
            const h = R._$cloneArray$_(this._$_wrappedText$_._$GetLines$_()), r = Math.sin(e), n = Math.cos(e);
            for (const o of h) this._$_DrawLine$_(t, o, s, i, r, n);
        }
        _$_DrawLine$_(t, s, i, e, h, r) {
            const n = s._$GetPosX$_(), o = s._$GetPosY$_();
            if (Number.isFinite(n) && Number.isFinite(o)) {
                const a = s._$GetHeight$_();
                for (const l of s._$fragments$_()) this._$_DrawFragment$_(t, l, i, e, h, r, a);
            }
        }
        _$_DrawFragment$_(h, r, n, o, a, l, u) {
            let c = r._$GetPosX$_(), f = r._$GetPosY$_();
            if (Number.isFinite(c) && Number.isFinite(f)) {
                let i = r._$GetCharacterArray$_(), e = r._$GetWidth$_();
                if (-1 !== this._$_drawMaxCharCount$_) {
                    if (this._$_drawCharCount$_ >= this._$_drawMaxCharCount$_) return;
                    this._$_drawCharCount$_ + i.length > this._$_drawMaxCharCount$_ && (i = i.slice(0, this._$_drawMaxCharCount$_ - this._$_drawCharCount$_), 
                    e = this._$_MeasureText$_(r).width), this._$_drawCharCount$_ += i.length;
                }
                const d = r._$GetStyleTag$_("background");
                if (!(R._$IsCharArrayAllWhitespace$_(i) && !d || r._$HasStyleTag$_("hide"))) {
                    const p = r._$GetStyleTag$_("scale"), m = (p ? parseFloat(p.param) : this._$_scale$_) * this._$_sceneGraphScale$_, g = r._$GetStyleTag$_("scalex"), y = (g ? parseFloat(g.param) : 1) * m, w = r._$GetStyleTag$_("scaley"), S = (w ? parseFloat(w.param) : 1) * m, b = this._$_spriteFont$_._$GetCharacterHeight$_() * S, M = this._$_lineHeight$_;
                    f += u - M - b;
                    let t = 1, s = r._$GetStyleTag$_("opacity");
                    s && (t = parseFloat(s.param) / 100), d && (h._$SetColorFillMode$_(), 
                    A._$parseString$_(C(d.param)), A._$setA$_(A._$getA$_() * t * this._$_color$_._$getA$_()), 
                    A._$premultiply$_(), h._$SetColor$_(A), P.set(c, f, c + e, f + b), 
                    P._$getRight$_() > this._$_cssWidth$_ && P._$setRight$_(this._$_cssWidth$_), 
                    E._$setFromRotatedRectPrecalc$_(P, a, l), E.offset(n, o), h._$Quad$_(E), 
                    h._$SetTextureFillMode$_());
                    const v = r._$GetStyleTag$_("color"), x = (v ? (A._$parseString$_(C(v.param)), 
                    A._$setA$_(this._$_color$_._$getA$_())) : A._$copy$_(this._$_color$_), 
                    A._$setA$_(A._$getA$_() * t), A._$premultiply$_(), h._$SetColor$_(A), 
                    this._$_spriteFont$_._$GetCharacterWidth$_() * y), G = Math.abs(this._$GetSpacing$_());
                    for (const T of i) {
                        const _ = this._$_spriteFont$_._$GetCharacter$_(T);
                        if (_) {
                            const I = _._$GetDisplayWidth$_() * y;
                            if (c + I > this._$_cssWidth$_ + G + 1e-5) return;
                            P.set(c, f, c + x, f + b), E._$setFromRotatedRectPrecalc$_(P, a, l), 
                            E.offset(n, o), h._$Quad3$_(E, _._$GetTexRect$_()), 
                            c += I + this._$_spacing$_;
                        } else c += this._$_spriteFont$_._$GetSpaceWidth$_() * y + this._$_spacing$_;
                    }
                }
            }
        }
        _$GetSpriteFont$_() {
            return this._$_spriteFont$_;
        }
        _$SetBBCodeEnabled$_(t) {
            this._$_isBBcodeEnabled$_ !== (t = !!t) && (this._$_isBBcodeEnabled$_ = t, 
            this._$_SetWordWrapChanged$_());
        }
        _$IsBBCodeEnabled$_() {
            return this._$_isBBcodeEnabled$_;
        }
        _$SetText$_(t) {
            this._$_text$_ !== t && (this._$_text$_ = t, this._$_SetWordWrapChanged$_());
        }
        _$SetWordWrapMode$_(t) {
            if (!e.has(t)) throw new Error("invalid word wrap mode");
            this._$_wrapMode$_ !== t && (this._$_wrapMode$_ = t, this._$_SetWordWrapChanged$_());
        }
        _$SetHorizontalAlign$_(t) {
            if (!s.has(t)) throw new Error("invalid alignment");
            this._$_horizontalAlign$_ !== t && (this._$_horizontalAlign$_ = t, this._$_SetTextLayoutChanged$_());
        }
        _$SetVerticalAlign$_(t) {
            if (!i.has(t)) throw new Error("invalid alignment");
            this._$_verticalAlign$_ !== t && (this._$_verticalAlign$_ = t, this._$_SetTextLayoutChanged$_());
        }
        _$SetScale$_(t) {
            this._$_scale$_ !== t && (this._$_scale$_ = t, this._$_SetWordWrapChanged$_());
        }
        _$GetScale$_() {
            return this._$_scale$_;
        }
        _$SetSceneGraphScale$_(t) {
            this._$_sceneGraphScale$_ !== t && (this._$_sceneGraphScale$_ = t, this._$_SetWordWrapChanged$_());
        }
        _$GetSceneGraphScale$_() {
            return this._$_sceneGraphScale$_;
        }
        _$SetSpacing$_(t) {
            this._$_spacing$_ !== t && (this._$_spacing$_ = t, this._$_SetWordWrapChanged$_());
        }
        _$GetSpacing$_() {
            return this._$_spacing$_;
        }
        _$SetLineHeight$_(t) {
            this._$_lineHeight$_ = t, this._$_SetWordWrapChanged$_();
        }
        _$GetLineHeight$_() {
            return this._$_lineHeight$_;
        }
        _$SetOpacity$_(t) {
            t = R._$clamp$_(t, 0, 1), this._$_color$_.a = t;
        }
        _$SetColor$_(t) {
            this._$_color$_.equals(t) || this._$_color$_._$copy$_(t);
        }
        _$GetColor$_() {
            return this._$_color$_;
        }
        _$GetTextWidth$_() {
            return this._$_UpdateTextMeasurements$_(), this._$_wrappedText$_._$GetMaxLineWidth$_();
        }
        _$GetTextHeight$_() {
            this._$_UpdateTextMeasurements$_();
            const t = this._$_spriteFont$_._$GetCharacterHeight$_() * this._$_scale$_, s = this._$_lineHeight$_, i = t + s;
            return this._$_wrappedText$_._$GetLineCount$_() * i - s;
        }
    };
}

{
    const ac = self._$C3$_, lc = {
        width: 256,
        height: 256,
        _$characterWidth$_: 16,
        _$characterHeight$_: 16,
        characterSet: ""
    };
    self._$SpriteFont$_ = class {
        constructor(t) {
            if ((t = Object.assign({}, lc, t)).width <= 0 || t.height <= 0 || t._$characterWidth$_ <= 0 || t._$characterHeight$_ <= 0) throw new Error("invalid size");
            this._$_width$_ = t.width, this._$_height$_ = t.height, this._$_characterWidth$_ = t._$characterWidth$_, 
            this._$_characterHeight$_ = t._$characterHeight$_, this._$_characterSet$_ = t.characterSet, 
            this._$_spacingData$_ = "", this._$_spacingParsed$_ = null, this._$_hasAnyCustomWidths$_ = !1, 
            this._$_spaceWidth$_ = -1, this._$_texRect$_ = new ac.Rect(0, 0, 1, 1), 
            this._$_characterMap$_ = new Map(), this._$_mapChanged$_ = !0, this._$_allTexts$_ = new Set();
        }
        _$Release$_() {
            this._$_texRect$_ = null, this._$_ReleaseCharacters$_(), this._$_characterMap$_ = null, 
            this._$_allTexts$_ && this._$_allTexts$_.clear(), this._$_allTexts$_ = null;
        }
        _$_ReleaseCharacters$_() {
            for (let t of this._$_characterMap$_.values()) t._$Release$_();
            this._$_characterMap$_.clear();
        }
        _$_AddSpriteFontText$_(t) {
            this._$_allTexts$_.add(t);
        }
        _$_RemoveSpriteFontText$_(t) {
            this._$_allTexts$_.delete(t);
        }
        _$UpdateCharacterMap$_() {
            if (this._$_mapChanged$_) {
                this._$_ReleaseCharacters$_();
                let s = ac._$SplitGraphemes$_(this._$_characterSet$_), h = Math.floor(this._$_width$_ / this._$_characterWidth$_), t = Math.floor(this._$_height$_ / this._$_characterHeight$_), i = h * t;
                for (let e = 0, t = s.length; e < t && !(e >= i); ++e) {
                    let i = s[e];
                    if (!this._$_characterMap$_.has(i)) {
                        let t = e % h, s = Math.floor(e / h);
                        this._$_characterMap$_.set(i, ac._$New$_(self._$SpriteFontCharacter$_, this, i, t * this._$_characterWidth$_, s * this._$_characterHeight$_));
                    }
                }
                if (this._$_hasAnyCustomWidths$_ = !1, this._$_spaceWidth$_ = -1, 
                Array.isArray(this._$_spacingParsed$_)) for (let s of this._$_spacingParsed$_) if (Array.isArray(s) && 2 === s.length) {
                    let i = s[0], t = s[1];
                    if ("number" == typeof i && isFinite(i) && "string" == typeof t && i !== this._$_characterWidth$_) for (let s of t) {
                        let t = this._$_characterMap$_.get(s);
                        t ? (t._$SetDisplayWidth$_(i), this._$_hasAnyCustomWidths$_ = !0) : " " === s && (this._$_spaceWidth$_ = i, 
                        this._$_hasAnyCustomWidths$_ = !0);
                    }
                }
                this._$_mapChanged$_ = !1;
                for (let t of this._$_allTexts$_) t._$_SetWordWrapChanged$_();
            }
        }
        _$SetCharacterWidthsChanged$_() {
            this._$_hasAnyCustomWidths$_ = !0;
            for (const t of this._$_allTexts$_) t._$_SetWordWrapChanged$_();
        }
        _$GetCharacter$_(t) {
            return this._$UpdateCharacterMap$_(), this._$_characterMap$_.get(t) || null;
        }
        _$HasAnyCustomWidths$_() {
            return this._$_hasAnyCustomWidths$_;
        }
        _$SetWidth$_(t) {
            if ((t = Math.floor(t)) <= 0) throw new Error("invalid size");
            this._$_width$_ !== t && (this._$_width$_ = t, this._$_mapChanged$_ = !0);
        }
        _$GetWidth$_() {
            return this._$_width$_;
        }
        _$SetHeight$_(t) {
            if ((t = Math.floor(t)) <= 0) throw new Error("invalid size");
            this._$_height$_ !== t && (this._$_height$_ = t, this._$_mapChanged$_ = !0);
        }
        _$GetHeight$_() {
            return this._$_height$_;
        }
        _$SetTexRect$_(t) {
            if (!this._$_texRect$_.equals(t)) {
                this._$_texRect$_._$copy$_(t);
                for (const s of this._$_characterMap$_.values()) s._$_UpdateTexRect$_();
            }
        }
        _$GetTexRect$_() {
            return this._$_texRect$_;
        }
        _$SetCharacterWidth$_(t) {
            if ((t = Math.floor(t)) <= 0) throw new Error("invalid size");
            this._$_characterWidth$_ !== t && (this._$_characterWidth$_ = t, this._$_mapChanged$_ = !0);
        }
        _$GetCharacterWidth$_() {
            return this._$_characterWidth$_;
        }
        _$SetCharacterHeight$_(t) {
            if ((t = Math.floor(t)) <= 0) throw new Error("invalid size");
            this._$_characterHeight$_ !== t && (this._$_characterHeight$_ = t, this._$_mapChanged$_ = !0);
        }
        _$GetCharacterHeight$_() {
            return this._$_characterHeight$_;
        }
        _$SetCharacterSet$_(t) {
            this._$_characterSet$_ !== t && (this._$_characterSet$_ = t, this._$_mapChanged$_ = !0);
        }
        _$GetCharacterSet$_() {
            return this._$_characterSet$_;
        }
        _$SetSpacingData$_(t) {
            if (this._$_spacingData$_ !== t && (this._$_spacingData$_ = t, this._$_mapChanged$_ = !0, 
            this._$_spacingParsed$_ = null, this._$_spacingData$_.length)) try {
                this._$_spacingParsed$_ = JSON.parse(this._$_spacingData$_);
            } catch (t) {
                this._$_spacingParsed$_ = null;
            }
        }
        _$GetSpacingData$_() {
            return this._$_spacingData$_;
        }
        _$SetSpaceWidth$_(t) {
            this._$_spaceWidth$_ !== (t = t < 0 ? -1 : t) && (this._$_spaceWidth$_ = t, 
            0 <= this._$_spaceWidth$_) && (this._$_hasAnyCustomWidths$_ = !0);
        }
        _$GetSpaceWidth$_() {
            return this._$_spaceWidth$_ < 0 ? this._$_characterWidth$_ : this._$_spaceWidth$_;
        }
    };
}

{
    const uc = self._$C3$_;
    uc._$Plugins$_._$TiledBg$_ = class extends uc._$SDKPluginBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    let i = function(t) {
        switch (t) {
          case 0:
            return "clamp-to-edge";

          case 1:
            return "repeat";

          case 2:
            return "mirror-repeat";
        }
        return "repeat";
    };
    i;
    const cc = self._$C3$_;
    cc._$Plugins$_._$TiledBg$_._$Type$_ = class extends cc._$SDKTypeBase$_ {
        constructor(t, s) {
            super(t), this._$_wrapX$_ = "repeat", this._$_wrapY$_ = "repeat", s && (this._$_wrapX$_ = i(s[0]), 
            this._$_wrapY$_ = i(s[1]));
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {
            this._$GetImageInfo$_()._$LoadAsset$_(this._$_runtime$_);
        }
        _$LoadTextures$_(t) {
            return this._$GetImageInfo$_()._$LoadStaticTexture$_(t, {
                _$sampling$_: this._$_runtime$_._$GetSampling$_(),
                _$wrapX$_: this._$_wrapX$_,
                _$wrapY$_: this._$_wrapY$_
            });
        }
        _$ReleaseTextures$_() {
            this._$GetImageInfo$_()._$ReleaseTexture$_();
        }
    };
}

{
    const fc = self._$C3$_, dc = self._$C3X$_, pc = fc._$New$_(fc.Rect), mc = fc._$New$_(fc._$Quad$_), gc = fc._$New$_(fc.Rect), yc = fc._$New$_(fc._$Quad$_), E = (fc._$Plugins$_._$TiledBg$_.Instance = class extends fc._$SDKWorldInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_imageOffsetX$_ = 0, this._$_imageOffsetY$_ = 0, this._$_imageScaleX$_ = 1, 
            this._$_imageScaleY$_ = 1, this._$_imageAngle$_ = 0, this._$_enableTileRandomization$_ = !1, 
            this._$_tileXRandom$_ = 0, this._$_tileYRandom$_ = 0, this._$_tileAngleRandom$_ = 0, 
            this._$_tileBlendMarginX$_ = 0, this._$_tileBlendMarginY$_ = 0, this._$_ownImageInfo$_ = null, 
            s && (this._$GetWorldInfo$_()._$SetVisible$_(!!s[0]), this._$_imageOffsetX$_ = s[4], 
            this._$_imageOffsetY$_ = s[5], this._$_imageScaleX$_ = s[6], this._$_imageScaleY$_ = s[7], 
            this._$_imageAngle$_ = fc._$toRadians$_(s[8]), this._$_enableTileRandomization$_ = !!s[9], 
            this._$_tileXRandom$_ = s[10], this._$_tileYRandom$_ = s[11], this._$_tileAngleRandom$_ = s[12], 
            this._$_tileBlendMarginX$_ = s[13], this._$_tileBlendMarginY$_ = s[14]);
        }
        _$Release$_() {
            this._$_ReleaseOwnImage$_(), super._$Release$_();
        }
        _$_ReleaseOwnImage$_() {
            this._$_ownImageInfo$_ && (this._$_ownImageInfo$_._$Release$_(), this._$_ownImageInfo$_ = null);
        }
        _$CalculateTextureCoordsFor3DFace$_(t, s, i) {
            const e = this._$GetCurrentImageInfo$_(), h = e._$GetWidth$_(), r = e._$GetHeight$_(), n = this._$_imageOffsetX$_ / h, o = this._$_imageOffsetY$_ / r, a = this._$_imageAngle$_;
            gc.set(0, 0, t / (h * this._$_imageScaleX$_), s / (r * this._$_imageScaleY$_)), 
            gc.offset(-n, -o), 0 === a ? i._$setFromRect$_(gc) : i._$setFromRotatedRect$_(gc, -a);
        }
        _$SetTilingShaderProgram$_(t, s = !0) {
            if (this._$_enableTileRandomization$_) {
                const i = this._$GetCurrentImageInfo$_();
                t._$SetTileRandomizationMode$_(), t._$SetTileRandomizationInfo$_(i._$GetWidth$_() * this._$_imageScaleX$_, i._$GetHeight$_() * this._$_imageScaleY$_, this._$_tileXRandom$_, this._$_tileYRandom$_, this._$_tileAngleRandom$_, this._$_tileBlendMarginX$_, this._$_tileBlendMarginY$_);
            } else s && t._$SetTextureFillMode$_();
        }
        _$Draw$_(t) {
            const s = this._$GetCurrentImageInfo$_(), i = s._$GetTexture$_();
            if (null !== i) {
                this._$SetTilingShaderProgram$_(t), t._$SetTexture$_(i);
                const e = s._$GetWidth$_(), h = s._$GetHeight$_(), r = this._$_imageOffsetX$_ / e, n = this._$_imageOffsetY$_ / h, o = this._$GetWorldInfo$_();
                gc.set(0, 0, o._$GetWidth$_() / (e * this._$_imageScaleX$_), o._$GetHeight$_() / (h * this._$_imageScaleY$_)), 
                gc.offset(-r, -n), o._$HasMesh$_() ? this._$_DrawMesh$_(o, t) : this._$_DrawStandard$_(o, t);
            }
        }
        _$_DrawStandard$_(t, s) {
            let i = t._$GetBoundingQuad$_();
            this._$_runtime$_._$IsPixelRoundingEnabled$_() && (i = t._$PixelRoundQuad$_(i)), 
            0 === this._$_imageAngle$_ ? s._$Quad3$_(i, gc) : (yc._$setFromRotatedRect$_(gc, -this._$_imageAngle$_), 
            s._$Quad4$_(i, yc));
        }
        _$_DrawMesh$_(i, t) {
            const e = i._$GetTransformedMesh$_();
            if (i._$IsMeshChanged$_()) {
                i._$CalculateBbox$_(pc, mc, !1);
                let t = mc, s = (this._$_runtime$_._$IsPixelRoundingEnabled$_() && (t = i._$PixelRoundQuad$_(t)), 
                gc);
                0 !== this._$_imageAngle$_ && (yc._$setFromRotatedRect$_(gc, -this._$_imageAngle$_), 
                s = yc), e._$CalculateTransformedMesh$_(i._$GetSourceMesh$_(), t, s), 
                i._$SetMeshChanged$_(!1);
            }
            e._$Draw$_(t);
        }
        _$GetCurrentImageInfo$_() {
            return this._$_ownImageInfo$_ || this._$_objectClass$_._$GetImageInfo$_();
        }
        _$IsOriginalSizeKnown$_() {
            return !0;
        }
        _$GetTexture$_() {
            return this._$GetCurrentImageInfo$_()._$GetTexture$_();
        }
        _$_SetMeshChanged$_() {
            this._$GetWorldInfo$_()._$SetMeshChanged$_(!0);
        }
        _$_SetImageOffsetX$_(t) {
            this._$_imageOffsetX$_ !== t && (this._$_imageOffsetX$_ = t, this._$_runtime$_._$UpdateRender$_(), 
            this._$_SetMeshChanged$_());
        }
        _$_GetImageOffsetX$_() {
            return this._$_imageOffsetX$_;
        }
        _$_SetImageOffsetY$_(t) {
            this._$_imageOffsetY$_ !== t && (this._$_imageOffsetY$_ = t, this._$_runtime$_._$UpdateRender$_(), 
            this._$_SetMeshChanged$_());
        }
        _$_GetImageOffsetY$_() {
            return this._$_imageOffsetY$_;
        }
        _$_SetImageScaleX$_(t) {
            this._$_imageScaleX$_ !== t && (this._$_imageScaleX$_ = t, this._$_runtime$_._$UpdateRender$_(), 
            this._$_SetMeshChanged$_());
        }
        _$_GetImageScaleX$_() {
            return this._$_imageScaleX$_;
        }
        _$_SetImageScaleY$_(t) {
            this._$_imageScaleY$_ !== t && (this._$_imageScaleY$_ = t, this._$_runtime$_._$UpdateRender$_(), 
            this._$_SetMeshChanged$_());
        }
        _$_GetImageScaleY$_() {
            return this._$_imageScaleY$_;
        }
        _$_SetImageAngle$_(t) {
            this._$_imageAngle$_ !== t && (this._$_imageAngle$_ = t, this._$_runtime$_._$UpdateRender$_(), 
            this._$_SetMeshChanged$_());
        }
        _$_GetImageAngle$_() {
            return this._$_imageAngle$_;
        }
        _$_SetTileRandomizationEnabled$_(t) {
            this._$_enableTileRandomization$_ !== (t = !!t) && (this._$_enableTileRandomization$_ = t, 
            this._$_runtime$_._$UpdateRender$_());
        }
        _$_IsTileRandomizationEnabled$_() {
            return this._$_enableTileRandomization$_;
        }
        _$_SetTileXRandom$_(t) {
            this._$_tileXRandom$_ !== t && (this._$_tileXRandom$_ = t, this._$_IsTileRandomizationEnabled$_()) && this._$_runtime$_._$UpdateRender$_();
        }
        _$_GetTileXRandom$_() {
            return this._$_tileXRandom$_;
        }
        _$_SetTileYRandom$_(t) {
            this._$_tileYRandom$_ !== t && (this._$_tileYRandom$_ = t, this._$_IsTileRandomizationEnabled$_()) && this._$_runtime$_._$UpdateRender$_();
        }
        _$_GetTileYRandom$_() {
            return this._$_tileYRandom$_;
        }
        _$_SetTileAngleRandom$_(t) {
            this._$_tileAngleRandom$_ !== t && (this._$_tileAngleRandom$_ = t, this._$_IsTileRandomizationEnabled$_()) && this._$_runtime$_._$UpdateRender$_();
        }
        _$_GetTileAngleRandom$_() {
            return this._$_tileAngleRandom$_;
        }
        _$_SetTileBlendMarginX$_(t) {
            this._$_tileBlendMarginX$_ !== t && (this._$_tileBlendMarginX$_ = t, 
            this._$_IsTileRandomizationEnabled$_()) && this._$_runtime$_._$UpdateRender$_();
        }
        _$_GetTileBlendMarginX$_() {
            return this._$_tileBlendMarginX$_;
        }
        _$_SetTileBlendMarginY$_(t) {
            this._$_tileBlendMarginY$_ !== t && (this._$_tileBlendMarginY$_ = t, 
            this._$_IsTileRandomizationEnabled$_()) && this._$_runtime$_._$UpdateRender$_();
        }
        _$_GetTileBlendMarginY$_() {
            return this._$_tileBlendMarginY$_;
        }
        _$SaveToJson$_() {
            const t = {};
            return 0 !== this._$_imageOffsetX$_ && (t.iox = this._$_imageOffsetX$_), 
            0 !== this._$_imageOffsetY$_ && (t.ioy = this._$_imageOffsetY$_), 1 !== this._$_imageScaleX$_ && (t.isx = this._$_imageScaleX$_), 
            1 !== this._$_imageScaleY$_ && (t.isy = this._$_imageScaleY$_), 0 !== this._$_imageAngle$_ && (t.ia = this._$_imageAngle$_), 
            this._$_enableTileRandomization$_ && (t.tr = !0), 1 !== this._$_tileXRandom$_ && (t.trx = this._$_tileXRandom$_), 
            1 !== this._$_tileYRandom$_ && (t.try = this._$_tileYRandom$_), 1 !== this._$_tileAngleRandom$_ && (t.tra = this._$_tileAngleRandom$_), 
            .1 !== this._$_tileBlendMarginX$_ && (t.trbmx = this._$_tileBlendMarginX$_), 
            .1 !== this._$_tileBlendMarginY$_ && (t.trbmy = this._$_tileBlendMarginY$_), 
            t;
        }
        _$LoadFromJson$_(t) {
            this._$_imageOffsetX$_ = t.iox || 0, this._$_imageOffsetY$_ = t.ioy || 0, 
            this._$_imageScaleX$_ = t.hasOwnProperty("isx") ? t.isx : 1, this._$_imageScaleY$_ = t.hasOwnProperty("isy") ? t.isy : 1, 
            this._$_imageAngle$_ = t.ia || 0, this._$_enableTileRandomization$_ = !!t.tr, 
            this._$_tileXRandom$_ = t.hasOwnProperty("trx") ? t.trx : 1, this._$_tileYRandom$_ = t.hasOwnProperty("try") ? t.try : 1, 
            this._$_tileAngleRandom$_ = t.hasOwnProperty("tra") ? t.tra : 1, this._$_tileBlendMarginX$_ = t.hasOwnProperty("trbmx") ? t.trbmx : .1, 
            this._$_tileBlendMarginY$_ = t.hasOwnProperty("trbmy") ? t.trbmy : .1;
        }
        _$GetDebuggerProperties$_() {
            const t = "plugins.tiledbg.properties";
            return [ {
                title: t + ".image-transform.name",
                properties: [ {
                    name: t + ".image-offset-x.name",
                    value: this._$_GetImageOffsetX$_(),
                    _$onedit$_: t => this._$_SetImageOffsetX$_(t)
                }, {
                    name: t + ".image-offset-y.name",
                    value: this._$_GetImageOffsetY$_(),
                    _$onedit$_: t => this._$_SetImageOffsetY$_(t)
                }, {
                    name: t + ".image-scale-x.name",
                    value: 100 * this._$_GetImageScaleX$_(),
                    _$onedit$_: t => this._$_SetImageScaleX$_(t / 100)
                }, {
                    name: t + ".image-scale-y.name",
                    value: 100 * this._$_GetImageScaleY$_(),
                    _$onedit$_: t => this._$_SetImageScaleY$_(t / 100)
                }, {
                    name: t + ".image-angle.name",
                    value: fc._$toDegrees$_(this._$_GetImageAngle$_()),
                    _$onedit$_: t => this._$_SetImageAngle$_(fc._$toRadians$_(t))
                } ]
            }, {
                title: t + ".tile-randomization.name",
                properties: [ {
                    name: t + ".enable-tile-randomization.name",
                    value: this._$_IsTileRandomizationEnabled$_(),
                    _$onedit$_: t => this._$_SetTileRandomizationEnabled$_(t)
                }, {
                    name: t + ".x-random.name",
                    value: 100 * this._$_GetTileXRandom$_(),
                    _$onedit$_: t => this._$_SetTileXRandom$_(t / 100)
                }, {
                    name: t + ".y-random.name",
                    value: 100 * this._$_GetTileYRandom$_(),
                    _$onedit$_: t => this._$_SetTileYRandom$_(t / 100)
                }, {
                    name: t + ".angle-random.name",
                    value: 100 * this._$_GetTileAngleRandom$_(),
                    _$onedit$_: t => this._$_SetTileAngleRandom$_(t / 100)
                }, {
                    name: t + ".blend-margin-x.name",
                    value: 100 * this._$_GetTileBlendMarginX$_(),
                    _$onedit$_: t => this._$_SetTileBlendMarginX$_(t / 100)
                }, {
                    name: t + ".blend-margin-y.name",
                    value: 100 * this._$_GetTileBlendMarginY$_(),
                    _$onedit$_: t => this._$_SetTileBlendMarginY$_(t / 100)
                } ]
            } ];
        }
        _$GetPropertyValueByIndex$_(t) {
            switch (t) {
              case 4:
                return this._$_GetImageOffsetX$_();

              case 5:
                return this._$_GetImageOffsetY$_();

              case 6:
                return this._$_GetImageScaleX$_();

              case 7:
                return this._$_GetImageScaleY$_();

              case 8:
                return this._$_GetImageAngle$_();

              case 9:
                return this._$_IsTileRandomizationEnabled$_();

              case 10:
                return this._$_GetTileXRandom$_();

              case 11:
                return this._$_GetTileYRandom$_();

              case 12:
                return this._$_GetTileAngleRandom$_();

              case 13:
                return this._$_GetTileBlendMarginX$_();

              case 14:
                return this._$_GetTileBlendMarginY$_();
            }
        }
        _$SetPropertyValueByIndex$_(t, s) {
            switch (t) {
              case 4:
                this._$_SetImageOffsetX$_(s);
                break;

              case 5:
                this._$_SetImageOffsetY$_(s);
                break;

              case 6:
                this._$_SetImageScaleX$_(s);
                break;

              case 7:
                this._$_SetImageScaleY$_(s);
                break;

              case 8:
                this._$_SetImageAngle$_(s);
                break;

              case 9:
                this._$_SetTileRandomizationEnabled$_(!!s);
                break;

              case 10:
                this._$_SetTileXRandom$_(s);
                break;

              case 11:
                this._$_SetTileYRandom$_(s);
                break;

              case 12:
                this._$_SetTileAngleRandom$_(s);
                break;

              case 13:
                this._$_SetTileBlendMarginX$_(s);
                break;

              case 14:
                this._$_SetTileBlendMarginY$_(s);
            }
        }
        _$GetScriptInterfaceClass$_() {
            return self._$ITiledBackgroundInstance$_;
        }
    }, new WeakMap());
    self._$ITiledBackgroundInstance$_ = class extends self._$IWorldInstance$_ {
        constructor() {
            super(), E.set(this, self._$IInstance$_._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        set _$imageOffsetX$_(t) {
            dc._$RequireFiniteNumber$_(t), E.get(this)._$_SetImageOffsetX$_(t);
        }
        get _$imageOffsetX$_() {
            return E.get(this)._$_GetImageOffsetX$_();
        }
        set _$imageOffsetY$_(t) {
            dc._$RequireFiniteNumber$_(t), E.get(this)._$_SetImageOffsetY$_(t);
        }
        get _$imageOffsetY$_() {
            return E.get(this)._$_GetImageOffsetY$_();
        }
        _$setImageOffset$_(t, s) {
            dc._$RequireFiniteNumber$_(t), dc._$RequireFiniteNumber$_(s);
            const i = E.get(this);
            i._$_SetImageOffsetX$_(t), i._$_SetImageOffsetY$_(s);
        }
        _$getImageOffset$_() {
            const t = E.get(this);
            return [ t._$_GetImageOffsetX$_(), t._$_GetImageOffsetY$_() ];
        }
        set _$imageScaleX$_(t) {
            dc._$RequireFiniteNumber$_(t), E.get(this)._$_SetImageScaleX$_(t);
        }
        get _$imageScaleX$_() {
            return E.get(this)._$_GetImageScaleX$_();
        }
        set _$imageScaleY$_(t) {
            dc._$RequireFiniteNumber$_(t), E.get(this)._$_SetImageScaleY$_(t);
        }
        get _$imageScaleY$_() {
            return E.get(this)._$_GetImageScaleY$_();
        }
        _$setImageScale$_(t, s) {
            dc._$RequireFiniteNumber$_(t), dc._$RequireFiniteNumber$_(s);
            const i = E.get(this);
            i._$_SetImageScaleX$_(t), i._$_SetImageScaleY$_(s);
        }
        _$getImageScale$_() {
            const t = E.get(this);
            return [ t._$_GetImageScaleX$_(), t._$_GetImageScaleY$_() ];
        }
        set _$imageAngle$_(t) {
            dc._$RequireFiniteNumber$_(t), E.get(this)._$_SetImageAngle$_(t);
        }
        get _$imageAngle$_() {
            return E.get(this)._$_GetImageAngle$_();
        }
        set _$imageAngleDegrees$_(t) {
            dc._$RequireFiniteNumber$_(t), E.get(this)._$_SetImageAngle$_(fc._$toRadians$_(t));
        }
        get _$imageAngleDegrees$_() {
            return fc._$toDegrees$_(E.get(this)._$_GetImageAngle$_());
        }
        get imageWidth() {
            return E.get(this)._$GetCurrentImageInfo$_()._$GetWidth$_();
        }
        get imageHeight() {
            return E.get(this)._$GetCurrentImageInfo$_()._$GetHeight$_();
        }
        _$getImageSize$_() {
            const t = E.get(this)._$GetCurrentImageInfo$_();
            return [ t._$GetWidth$_(), t._$GetHeight$_() ];
        }
        set _$enableTileRandomization$_(t) {
            E.get(this)._$_SetTileRandomizationEnabled$_(!!t);
        }
        get _$enableTileRandomization$_() {
            return E.get(this)._$_IsTileRandomizationEnabled$_();
        }
        set _$tileXRandom$_(t) {
            dc._$RequireFiniteNumber$_(t), E.get(this)._$_SetTileXRandom$_(t);
        }
        get _$tileXRandom$_() {
            return E.get(this)._$_GetTileXRandom$_();
        }
        set _$tileYRandom$_(t) {
            dc._$RequireFiniteNumber$_(t), E.get(this)._$_SetTileYRandom$_(t);
        }
        get _$tileYRandom$_() {
            return E.get(this)._$_GetTileYRandom$_();
        }
        _$setTileRandom$_(t, s) {
            dc._$RequireFiniteNumber$_(t), dc._$RequireFiniteNumber$_(s);
            const i = E.get(this);
            i._$_SetTileXRandom$_(t), i._$_SetTileYRandom$_(s);
        }
        _$getTileRandom$_() {
            const t = E.get(this);
            return [ t._$_GetTileXRandom$_(), t._$_GetTileYRandom$_() ];
        }
        set _$tileAngleRandom$_(t) {
            dc._$RequireFiniteNumber$_(t), E.get(this)._$_SetTileAngleRandom$_(t);
        }
        get _$tileAngleRandom$_() {
            return E.get(this)._$_GetTileAngleRandom$_();
        }
        set _$tileBlendMarginX$_(t) {
            dc._$RequireFiniteNumber$_(t), E.get(this)._$_SetTileBlendMarginX$_(t);
        }
        get _$tileBlendMarginX$_() {
            return E.get(this)._$_GetTileBlendMarginX$_();
        }
        set _$tileBlendMarginY$_(t) {
            dc._$RequireFiniteNumber$_(t), E.get(this)._$_SetTileBlendMarginY$_(t);
        }
        get _$tileBlendMarginY$_() {
            return E.get(this)._$_GetTileBlendMarginY$_();
        }
        _$setTileBlendMargin$_(t, s) {
            dc._$RequireFiniteNumber$_(t), dc._$RequireFiniteNumber$_(s);
            const i = E.get(this);
            i._$_SetTileBlendMarginX$_(t), i._$_SetTileBlendMarginY$_(s);
        }
        _$getTileBlendMargin$_() {
            const t = E.get(this);
            return [ t._$_GetTileBlendMarginX$_(), t._$_GetTileBlendMarginY$_() ];
        }
        async _$replaceImage$_(t) {
            dc._$RequireInstanceOf$_(t, Blob);
            const s = E.get(this), i = s._$GetRuntime$_(), e = fc._$New$_(fc._$ImageInfo$_);
            e._$LoadDynamicBlobAsset$_(i, t), await e._$LoadStaticTexture$_(i._$GetRenderer$_(), {
                _$sampling$_: i._$GetSampling$_(),
                _$wrapX$_: "repeat",
                _$wrapY$_: "repeat"
            }), s._$WasReleased$_() ? e._$Release$_() : (s._$_ReleaseOwnImage$_(), 
            s._$_ownImageInfo$_ = e, i._$UpdateRender$_());
        }
    };
}

{
    const wc = self._$C3$_;
    wc._$Plugins$_._$TiledBg$_._$Cnds$_ = {
        _$OnURLLoaded$_() {
            return !0;
        },
        _$OnURLFailed$_() {
            return !0;
        },
        _$IsTileRandomizationEnabled$_() {
            return this._$_IsTileRandomizationEnabled$_();
        }
    };
}

{
    const Sc = self._$C3$_;
    Sc._$Plugins$_._$TiledBg$_._$Acts$_ = {
        _$SetImageOffsetX$_(t) {
            this._$_SetImageOffsetX$_(t);
        },
        _$SetImageOffsetY$_(t) {
            this._$_SetImageOffsetY$_(t);
        },
        _$SetImageScaleX$_(t) {
            this._$_SetImageScaleX$_(t / 100);
        },
        _$SetImageScaleY$_(t) {
            this._$_SetImageScaleY$_(t / 100);
        },
        _$SetImageAngle$_(t) {
            this._$_SetImageAngle$_(Sc._$toRadians$_(t));
        },
        _$SetTileRandomizationEnabled$_(t) {
            this._$_SetTileRandomizationEnabled$_(t);
        },
        _$SetTilePosRandom$_(t, s) {
            this._$_SetTileXRandom$_(t / 100), this._$_SetTileYRandom$_(s / 100);
        },
        _$SetTileAngleRandom$_(t) {
            this._$_SetTileAngleRandom$_(t / 100);
        },
        _$SetTileBlendMargin$_(t, s) {
            this._$_SetTileBlendMarginX$_(t / 100), this._$_SetTileBlendMarginY$_(s / 100);
        },
        _$SetEffect$_(t) {
            this._$GetWorldInfo$_()._$SetBlendMode$_(t), this._$_runtime$_._$UpdateRender$_();
        },
        async _$LoadURL$_(t, s) {
            if (!this._$_ownImageInfo$_ || this._$_ownImageInfo$_._$GetURL$_() !== t) {
                const i = this._$_runtime$_, e = Sc._$New$_(Sc._$ImageInfo$_);
                try {
                    if (await e._$LoadDynamicAsset$_(i, t), !e._$IsLoaded$_()) throw new Error("image failed to load");
                    if (this._$WasReleased$_()) return e._$Release$_(), null;
                    const h = await e._$LoadStaticTexture$_(i._$GetRenderer$_(), {
                        _$sampling$_: i._$GetSampling$_(),
                        _$wrapX$_: "repeat",
                        _$wrapY$_: "repeat"
                    });
                    if (!h) return;
                } catch (t) {
                    return console.error("Load image from URL failed: ", t), void (this._$WasReleased$_() || this._$Trigger$_(Sc._$Plugins$_._$TiledBg$_._$Cnds$_._$OnURLFailed$_));
                }
                this._$WasReleased$_() ? e._$Release$_() : (this._$_ReleaseOwnImage$_(), 
                this._$_ownImageInfo$_ = e, i._$UpdateRender$_(), await this._$TriggerAsync$_(Sc._$Plugins$_._$TiledBg$_._$Cnds$_._$OnURLLoaded$_));
            }
        }
    };
}

{
    const bc = self._$C3$_;
    bc._$Plugins$_._$TiledBg$_._$Exps$_ = {
        _$ImageWidth$_() {
            return this._$GetCurrentImageInfo$_()._$GetWidth$_();
        },
        _$ImageHeight$_() {
            return this._$GetCurrentImageInfo$_()._$GetHeight$_();
        },
        _$ImageOffsetX$_() {
            return this._$_imageOffsetX$_;
        },
        _$ImageOffsetY$_() {
            return this._$_imageOffsetY$_;
        },
        _$ImageScaleX$_() {
            return 100 * this._$_imageScaleX$_;
        },
        _$ImageScaleY$_() {
            return 100 * this._$_imageScaleY$_;
        },
        _$ImageAngle$_() {
            return bc._$toDegrees$_(this._$_imageAngle$_);
        },
        _$TileXRandom$_() {
            return 100 * this._$_GetTileXRandom$_();
        },
        _$TileYRandom$_() {
            return 100 * this._$_GetTileYRandom$_();
        },
        _$TileAngleRandom$_() {
            return 100 * this._$_GetTileAngleRandom$_();
        },
        _$TileBlendMarginX$_() {
            return 100 * this._$_GetTileBlendMarginX$_();
        },
        _$TileBlendMarginY$_() {
            return 100 * this._$_GetTileBlendMarginY$_();
        }
    };
}

{
    const Mc = self._$C3$_;
    Mc._$Plugins$_._$Particles$_ = class extends Mc._$SDKPluginBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const vc = self._$C3$_;
    vc._$Plugins$_._$Particles$_._$Type$_ = class extends vc._$SDKTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {
            this._$GetImageInfo$_()._$LoadAsset$_(this._$_runtime$_);
        }
        _$LoadTextures$_(t) {
            return this._$GetImageInfo$_()._$LoadStaticTexture$_(t, {
                _$sampling$_: this._$_runtime$_._$GetSampling$_()
            });
        }
        _$ReleaseTextures$_() {
            this._$GetImageInfo$_()._$ReleaseTexture$_();
        }
    };
}

{
    let s = function(t) {
        return _c.get(t)._$GetParticleEngine$_();
    };
    s;
    const xc = self._$C3$_, Gc = self._$C3X$_, Tc = xc._$New$_(xc.Rect), _c = (xc._$Plugins$_._$Particles$_.Instance = class extends xc._$SDKWorldInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_isFirstTick$_ = !0;
            const i = xc._$New$_(self._$ParticleEngine$_);
            (this._$_particleEngine$_ = i)._$ononeshotfinish$_ = () => this._$_OnOneShotFinish$_(), 
            this._$_spawnObjectClass$_ = null, this._$_particleUpdateCallback$_ = (t, s, i, e, h, r) => this._$_OnParticleUpdate$_(t, s, i, e, h, r), 
            this._$_particleDestroyCallback$_ = t => this._$_OnParticleDestroy$_(t);
            let e = this._$_hasAnyDefaultParticle$_ = !0;
            s && (i._$SetRate$_(s[0]), i._$SetSprayCone$_(xc._$toRadians$_(s[1])), 
            i._$SetSprayType$_(s[2] ? "one-shot" : "continuous-spray"), this._$_SetParticleObjectClass$_(this._$_runtime$_._$GetObjectClassBySID$_(s[3])), 
            e = s[4], i._$SetInitSpeed$_(s[5]), i._$SetInitSize$_(s[6]), i._$SetInitOpacity$_(s[7] / 100), 
            i._$SetGrowRate$_(s[8]), i._$SetInitXRandom$_(s[9]), i._$SetInitYRandom$_(s[10]), 
            i._$SetInitSpeedRandom$_(s[11]), i._$SetInitSizeRandom$_(s[12]), i._$SetGrowRandom$_(s[13]), 
            i._$SetAcceleration$_(s[14]), i._$SetGravity$_(s[15]), i._$SetLifeAngleRandom$_(s[16]), 
            i._$SetLifeSpeedRandom$_(s[17]), i._$SetLifeOpacityRandom$_(s[18]), 
            i._$SetDestroyModeIndex$_(s[19]), i._$SetTimeout$_(s[20])), this._$_UpdateEngineParameters$_(), 
            this._$_spawnObjectClass$_ && (this._$_hasAnyDefaultParticle$_ = !1), 
            "one-shot" === i._$GetSprayType$_() ? i._$CreateOneShotSpray$_() : i._$SetSpraying$_(!0);
            const h = this._$GetWorldInfo$_();
            h._$SetVisible$_(e), h._$SetBboxChangeEventEnabled$_(!0), this._$_inst$_._$Dispatcher$_().addEventListener("bboxchange", () => {
                h._$OverwriteBoundingBox$_(this._$_particleEngine$_._$GetBoundingBox$_());
            }), this._$GetRuntime$_()._$GetRenderer$_()._$IsWebGPU$_() && h._$SetUsePointsShaderProgram$_(), 
            this._$_afterLoad$_ = t => this._$_OnAfterLoad$_(t), this._$GetRuntime$_()._$Dispatcher$_().addEventListener("afterload", this._$_afterLoad$_), 
            this._$_StartTicking$_();
        }
        _$Release$_() {
            this._$GetRuntime$_()._$Dispatcher$_().removeEventListener("afterload", this._$_afterLoad$_), 
            this._$_afterLoad$_ = null, this._$_particleEngine$_._$Release$_(), 
            this._$_particleEngine$_ = null, this._$_particleUpdateCallback$_ = null, 
            this._$_particleDestroyCallback$_ = null, super._$Release$_();
        }
        _$GetParticleEngine$_() {
            return this._$_particleEngine$_;
        }
        _$_SetRate$_(t) {
            this._$_particleEngine$_._$SetRate$_(t), "one-shot" === this._$_particleEngine$_._$GetSprayType$_() && this._$_isFirstTick$_ && this._$_particleEngine$_._$SetParticleCount$_(t);
        }
        _$_SetParticleObjectClass$_(t) {
            (t = t === this._$GetObjectClass$_() ? null : t) === this._$_spawnObjectClass$_ || (this._$_spawnObjectClass$_ = t, 
            this._$_particleEngine$_._$onparticlecreate$_ = t ? t => this._$_OnParticleCreate$_(t) : null, 
            this._$_spawnObjectClass$_) || (this._$_hasAnyDefaultParticle$_ = !0);
        }
        _$_UpdateEngineParameters$_() {
            const t = this._$_particleEngine$_, s = this._$GetWorldInfo$_();
            t._$SetMasterOpacity$_(s._$GetOpacity$_()), t._$SetPixelRounding$_(this._$_runtime$_._$IsPixelRoundingEnabled$_()), 
            t._$SetSpawnX$_(s._$GetX$_()), t._$SetSpawnY$_(s._$GetY$_()), t._$SetSpawnAngle$_(s._$GetAngle$_()), 
            t._$SetInitSizeScale$_(Math.abs(s._$GetSceneGraphScale$_()));
        }
        _$_OnOneShotFinish$_() {
            this._$_runtime$_._$DestroyInstance$_(this._$_inst$_);
        }
        _$Draw$_(t) {
            if (this._$_hasAnyDefaultParticle$_) {
                const s = this._$_objectClass$_._$GetImageInfo$_(), i = s._$GetTexture$_();
                if (i) {
                    const e = this._$GetWorldInfo$_(), h = e._$GetLayer$_(), r = Tc, n = (this._$_runtime$_._$GetCanvasManager$_()._$IsPastingToDrawingCanvas$_() ? r.set(-1 / 0, -1 / 0, 1 / 0, 1 / 0) : h._$Has3DCamera$_() ? h._$CalculateViewport3D$_(e._$GetTotalZElevation$_(), r) : h._$GetViewportForZ$_(e._$GetTotalZElevation$_(), r), 
                    t._$SetTexture$_(i), h._$Get2DScaleFactorToZ$_(e._$GetTotalZElevation$_()));
                    this._$_particleEngine$_._$SetParticleScale$_(h._$GetRenderScale$_() * n), 
                    this._$_particleEngine$_._$Draw$_(t, s._$GetTexQuad$_(), r, h._$Has3DCamera$_());
                }
            }
        }
        _$SaveToJson$_() {
            const t = this._$_particleEngine$_;
            return {
                r: t._$GetRate$_(),
                sc: t._$GetSprayCone$_(),
                st: t._$GetSprayType$_(),
                isp: t._$GetInitSpeed$_(),
                isz: t._$GetInitSize$_(),
                io: t._$GetInitOpacity$_(),
                gr: t._$GetGrowRate$_(),
                xr: t._$GetInitXRandom$_(),
                yr: t._$GetInitYRandom$_(),
                spr: t._$GetInitSpeedRandom$_(),
                szr: t._$GetInitSizeRandom$_(),
                grnd: t._$GetGrowRandom$_(),
                acc: t._$GetAcceleration$_(),
                g: t._$GetGravity$_(),
                lar: t._$GetLifeAngleRandom$_(),
                lsr: t._$GetLifeSpeedRandom$_(),
                lor: t._$GetLifeOpacityRandom$_(),
                dm: t._$GetDestroyModeIndex$_(),
                to: t._$GetTimeout$_(),
                s: t._$IsSpraying$_(),
                pcc: t._$_GetCreateCounter$_(),
                ft: this._$_isFirstTick$_,
                soc: this._$_spawnObjectClass$_ ? this._$_spawnObjectClass$_._$GetSID$_() : null,
                p: t._$GetParticles$_().map(t => t.toJSON())
            };
        }
        _$LoadFromJson$_(t, s) {
            const i = this._$_particleEngine$_;
            if (i._$SetRate$_(t.r), i._$SetSprayCone$_(t.sc), i._$SetSprayType$_(t.st), 
            i._$SetInitSpeed$_(t.isp), i._$SetInitSize$_(t.isz), i._$SetInitOpacity$_(t.io), 
            i._$SetGrowRate$_(t.gr), i._$SetInitXRandom$_(t.xr), i._$SetInitYRandom$_(t.yr), 
            i._$SetInitSpeedRandom$_(t.spr), i._$SetInitSizeRandom$_(t.szr), i._$SetGrowRandom$_(t.grnd), 
            i._$SetAcceleration$_(t.acc), i._$SetGravity$_(t.g), i._$SetLifeAngleRandom$_(t.lar), 
            i._$SetLifeSpeedRandom$_(t.lsr), i._$SetLifeOpacityRandom$_(t.lor), 
            i._$SetDestroyModeIndex$_(t.dm), i._$SetTimeout$_(t.to), i._$SetSpraying$_(t.s), 
            i._$_SetCreateCounter$_(t.pcc), this._$_isFirstTick$_ = t.ft, t.hasOwnProperty("soc")) {
                const r = this._$GetRuntime$_()._$GetObjectClassBySID$_(t.soc);
                r && this._$_SetParticleObjectClass$_(r);
            }
            const e = t.p, h = (i._$SetParticleCount$_(e.length, !1), i._$GetParticles$_());
            for (let t = 0, s = h.length; t < s; ++t) h[t]._$setFromJSON$_(e[t]);
            "state" === s && this._$_spawnObjectClass$_ && (i._$UpdateAllParticlesUserData$_(), 
            i._$ApplyParticleDataToUserData$_(this));
        }
        _$_OnAfterLoad$_() {
            const t = this._$_particleEngine$_, i = (t._$UpdateAllParticlesUserData$_(), 
            t._$ApplyParticleDataToUserData$_(this), t._$GetParticles$_());
            for (let t = 0, s = i.length; t < s; ++t) {
                const e = i[t], h = e._$GetUserData$_();
                if (h) {
                    const r = h._$GetWorldInfo$_();
                    if (r) {
                        const n = r._$GetInstance$_();
                        if (n) {
                            const o = e._$GetUserDataUID$_(), a = n._$GetUID$_();
                            if (("number" != typeof o || "number" != typeof a || o !== a) && "number" == typeof o) {
                                const l = this._$GetRuntime$_(), u = l._$GetInstanceByUID$_(o);
                                u && l._$DestroyInstance$_(u);
                            }
                        }
                    }
                }
            }
        }
        _$Tick$_() {
            const t = this._$_runtime$_._$GetDt$_(this._$_inst$_);
            this._$_UpdateEngineParameters$_(), this._$_isFirstTick$_ && "one-shot" === this._$_particleEngine$_._$GetSprayType$_() && this._$_particleEngine$_._$ReInitAllParticles$_(), 
            this._$_particleEngine$_._$Tick$_(t), this._$_particleEngine$_._$IsSpraying$_() && this._$_runtime$_._$UpdateRender$_(), 
            this._$GetWorldInfo$_()._$SetBboxChanged$_(), this._$_isFirstTick$_ = !1;
        }
        _$_FastForward$_(t) {
            for (this._$_isFirstTick$_ && "one-shot" === this._$_particleEngine$_._$GetSprayType$_() && this._$_particleEngine$_._$ReInitAllParticles$_(); 0 < t; ) this._$_particleEngine$_._$Tick$_(1 / 60), 
            t -= 1 / 60;
            this._$_particleEngine$_._$IsSpraying$_() && this._$_runtime$_._$UpdateRender$_(), 
            this._$GetWorldInfo$_()._$SetBboxChanged$_(), this._$_isFirstTick$_ = !1;
        }
        _$_OnParticleCreate$_(t, s) {
            let i, e = (i = (i = (i = "number" == typeof s ? this._$_runtime$_._$GetInstanceByUID$_(s) : i) && i._$GetObjectClass$_() !== this._$_spawnObjectClass$_ ? null : i) || this._$_runtime$_._$CreateInstance$_(this._$_spawnObjectClass$_, this._$GetWorldInfo$_()._$GetLayer$_(), t._$GetX$_(), t._$GetY$_()))._$GetWorldInfo$_();
            return e._$SetSize$_(t._$GetSize$_(), t._$GetSize$_()), e._$SetAngle$_(t._$GetAngle$_()), 
            e._$SetOpacity$_(t._$GetOpacity$_()), e._$SetUnpremultipliedColor$_(this._$GetWorldInfo$_()._$GetUnpremultipliedColor$_()), 
            e._$SetBboxChanged$_(), e._$ZOrderMoveAdjacentToInstance$_(this._$GetInstance$_(), !0), 
            i._$_TriggerOnCreated$_(), t._$SetUpdateCallback$_(this._$_particleUpdateCallback$_), 
            t._$SetDestroyCallback$_(this._$_particleDestroyCallback$_), i;
        }
        _$_OnParticleUpdate$_(t, s, i, e, h, r) {
            if (!t._$IsDestroyed$_()) {
                const n = t._$GetWorldInfo$_();
                n._$OffsetXY$_(s, i), n._$SetSize$_(n._$GetWidth$_() + e, n._$GetHeight$_() + e), 
                n._$SetAngle$_(n._$GetAngle$_() + h), n._$SetOpacity$_(n._$GetOpacity$_() + r), 
                n._$SetBboxChanged$_();
            }
        }
        _$_OnParticleDestroy$_(t) {
            t._$IsDestroyed$_() || this._$_runtime$_._$DestroyInstance$_(t);
        }
        _$GetPropertyValueByIndex$_(t) {
            const s = this._$_particleEngine$_;
            switch (t) {
              case 0:
                return s._$GetRate$_();

              case 1:
                return xc._$toDegrees$_(s._$GetSprayCone$_());

              case 2:
                return "one-shot" === s._$GetSprayType$_() ? 1 : 0;

              case 5:
                return s._$GetInitSpeed$_();

              case 6:
                return s._$GetInitSize$_();

              case 7:
                return 100 * s._$GetInitOpacity$_();

              case 8:
                return s._$GetGrowRate$_();

              case 9:
                return s._$GetInitXRandom$_();

              case 10:
                return s._$GetInitYRandom$_();

              case 11:
                return s._$GetInitSpeedRandom$_();

              case 12:
                return s._$GetInitSizeRandom$_();

              case 13:
                return s._$GetGrowRandom$_();

              case 14:
                return s._$GetAcceleration$_();

              case 15:
                return s._$GetGravity$_();

              case 16:
                return s._$GetLifeAngleRandom$_();

              case 17:
                return s._$GetLifeSpeedRandom$_();

              case 18:
                return s._$GetLifeOpacityRandom$_();

              case 19:
                return s._$GetDestroyModeIndex$_();

              case 20:
                return s._$GetTimeout$_();
            }
        }
        _$SetPropertyValueByIndex$_(t, s) {
            const i = this._$_particleEngine$_;
            switch (t) {
              case 0:
                i._$SetRate$_(s);
                break;

              case 1:
                i._$SetSprayCone$_(xc._$toRadians$_(s));
                break;

              case 2:
                i._$SetSprayType$_(s ? "one-shot" : "continuous-spray");
                break;

              case 5:
                i._$SetInitSpeed$_(s);
                break;

              case 6:
                i._$SetInitSize$_(s);
                break;

              case 7:
                i._$SetInitOpacity$_(s / 100);
                break;

              case 8:
                i._$SetGrowRate$_(s);
                break;

              case 9:
                i._$SetInitXRandom$_(s);
                break;

              case 10:
                i._$SetInitYRandom$_(s);
                break;

              case 11:
                i._$SetInitSpeedRandom$_(s);
                break;

              case 12:
                i._$SetInitSizeRandom$_(s);
                break;

              case 13:
                i._$SetGrowRandom$_(s);
                break;

              case 14:
                i._$SetAcceleration$_(s);
                break;

              case 15:
                i._$SetGravity$_(s);
                break;

              case 16:
                i._$SetLifeAngleRandom$_(s);
                break;

              case 17:
                i._$SetLifeSpeedRandom$_(s);
                break;

              case 18:
                i._$SetLifeOpacityRandom$_(s);
                break;

              case 19:
                i._$SetDestroyModeIndex$_(s);
                break;

              case 20:
                i._$SetTimeout$_(s);
            }
        }
        _$GetDebuggerProperties$_() {
            const t = "plugins.particles", s = t + ".properties", i = t + ".debugger", e = this._$_particleEngine$_;
            return [ {
                title: t + ".name",
                properties: [ {
                    name: i + ".particle-count",
                    value: e._$GetParticleCount$_()
                }, {
                    name: s + ".type.name",
                    value: [ s + ".type.items." + e._$GetSprayType$_() ]
                }, {
                    name: i + ".is-spraying",
                    value: e._$IsSpraying$_(),
                    _$onedit$_: t => e._$SetSpraying$_(t)
                }, {
                    name: s + ".rate.name",
                    value: e._$GetRate$_(),
                    _$onedit$_: t => e._$SetRate$_(t)
                }, {
                    name: s + ".spray-cone.name",
                    value: xc._$toDegrees$_(e._$GetSprayCone$_()),
                    _$onedit$_: t => e._$SetSprayCone$_(xc._$toRadians$_(t))
                }, {
                    name: s + ".speed.name",
                    value: e._$GetInitSpeed$_(),
                    _$onedit$_: t => e._$SetInitSpeed$_(t)
                }, {
                    name: s + ".size.name",
                    value: e._$GetInitSize$_(),
                    _$onedit$_: t => e._$SetInitSize$_(t)
                }, {
                    name: s + ".opacity.name",
                    value: e._$GetInitOpacity$_(),
                    _$onedit$_: t => e._$SetInitOpacity$_(t)
                }, {
                    name: s + ".grow-rate.name",
                    value: e._$GetGrowRate$_(),
                    _$onedit$_: t => e._$SetGrowRate$_(t)
                }, {
                    name: s + ".x-randomiser.name",
                    value: e._$GetInitXRandom$_(),
                    _$onedit$_: t => e._$SetInitXRandom$_(t)
                }, {
                    name: s + ".y-randomiser.name",
                    value: e._$GetInitYRandom$_(),
                    _$onedit$_: t => e._$SetInitYRandom$_(t)
                }, {
                    name: s + ".initial-speed-randomiser.name",
                    value: e._$GetInitSpeedRandom$_(),
                    _$onedit$_: t => e._$SetInitSpeedRandom$_(t)
                }, {
                    name: s + ".size-randomiser.name",
                    value: e._$GetInitSizeRandom$_(),
                    _$onedit$_: t => e._$SetInitSizeRandom$_(t)
                }, {
                    name: s + ".grow-rate-randomiser.name",
                    value: e._$GetGrowRandom$_(),
                    _$onedit$_: t => e._$SetGrowRandom$_(t)
                }, {
                    name: s + ".acceleration.name",
                    value: e._$GetAcceleration$_(),
                    _$onedit$_: t => e._$SetAcceleration$_(t)
                }, {
                    name: s + ".gravity.name",
                    value: e._$GetGravity$_(),
                    _$onedit$_: t => e._$SetGravity$_(t)
                }, {
                    name: s + ".angle-randomiser.name",
                    value: e._$GetLifeAngleRandom$_(),
                    _$onedit$_: t => e._$SetLifeAngleRandom$_(t)
                }, {
                    name: s + ".life-speed-randomiser.name",
                    value: e._$GetLifeSpeedRandom$_(),
                    _$onedit$_: t => e._$SetLifeSpeedRandom$_(t)
                }, {
                    name: s + ".opacity-randomiser.name",
                    value: e._$GetLifeOpacityRandom$_(),
                    _$onedit$_: t => e._$SetLifeOpacityRandom$_(t)
                }, {
                    name: s + ".timeout.name",
                    value: e._$GetTimeout$_(),
                    _$onedit$_: t => e._$SetTimeout$_(t)
                } ]
            } ];
        }
        _$GetScriptInterfaceClass$_() {
            return self._$IParticlesInstance$_;
        }
    }, new WeakMap());
    self._$IParticlesInstance$_ = class extends self._$IWorldInstance$_ {
        constructor() {
            super(), _c.set(this, self._$IInstance$_._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        set _$isSpraying$_(t) {
            s(this)._$SetSpraying$_(!!t);
        }
        get _$isSpraying$_() {
            return s(this)._$IsSpraying$_();
        }
        set rate(t) {
            Gc._$RequireFiniteNumber$_(t), _c.get(this)._$_SetRate$_(t);
        }
        get rate() {
            return s(this)._$GetRate$_();
        }
        set _$sprayCone$_(t) {
            Gc._$RequireFiniteNumber$_(t), s(this)._$SetSprayCone$_(t);
        }
        get _$sprayCone$_() {
            return s(this)._$GetSprayCone$_();
        }
        set _$initSpeed$_(t) {
            Gc._$RequireFiniteNumber$_(t), s(this)._$SetInitSpeed$_(t);
        }
        get _$initSpeed$_() {
            return s(this)._$GetInitSpeed$_();
        }
        set _$initSize$_(t) {
            Gc._$RequireFiniteNumber$_(t), s(this)._$SetInitSize$_(t);
        }
        get _$initSize$_() {
            return s(this)._$GetInitSize$_();
        }
        set _$initOpacity$_(t) {
            Gc._$RequireFiniteNumber$_(t), s(this)._$SetInitOpacity$_(t);
        }
        get _$initOpacity$_() {
            return s(this)._$GetInitOpacity$_();
        }
        set _$initXRandom$_(t) {
            Gc._$RequireFiniteNumber$_(t), s(this)._$SetInitXRandom$_(t);
        }
        get _$initXRandom$_() {
            return s(this)._$GetInitXRandom$_();
        }
        set _$initYRandom$_(t) {
            Gc._$RequireFiniteNumber$_(t), s(this)._$SetInitYRandom$_(t);
        }
        get _$initYRandom$_() {
            return s(this)._$GetInitYRandom$_();
        }
        set _$initSpeedRandom$_(t) {
            Gc._$RequireFiniteNumber$_(t), s(this)._$SetInitSpeedRandom$_(t);
        }
        get _$initSpeedRandom$_() {
            return s(this)._$GetInitSpeedRandom$_();
        }
        set _$initSizeRandom$_(t) {
            Gc._$RequireFiniteNumber$_(t), s(this)._$SetInitSizeRandom$_(t);
        }
        get _$initSizeRandom$_() {
            return s(this)._$GetInitSizeRandom$_();
        }
        set _$initGrowRate$_(t) {
            Gc._$RequireFiniteNumber$_(t), s(this)._$SetGrowRate$_(t);
        }
        get _$initGrowRate$_() {
            return s(this)._$GetGrowRate$_();
        }
        set _$initGrowRandom$_(t) {
            Gc._$RequireFiniteNumber$_(t), s(this)._$SetGrowRandom$_(t);
        }
        get _$initGrowRandom$_() {
            return s(this)._$GetGrowRandom$_();
        }
        set acceleration(t) {
            Gc._$RequireFiniteNumber$_(t), s(this)._$SetAcceleration$_(t);
        }
        get acceleration() {
            return s(this)._$GetAcceleration$_();
        }
        set _$gravity$_(t) {
            Gc._$RequireFiniteNumber$_(t), s(this)._$SetGravity$_(t);
        }
        get _$gravity$_() {
            return s(this)._$GetGravity$_();
        }
        set _$lifeAngleRandom$_(t) {
            Gc._$RequireFiniteNumber$_(t), s(this)._$SetLifeAngleRandom$_(t);
        }
        get _$lifeAngleRandom$_() {
            return s(this)._$GetLifeAngleRandom$_();
        }
        set _$lifeSpeedRandom$_(t) {
            Gc._$RequireFiniteNumber$_(t), s(this)._$SetLifeSpeedRandom$_(t);
        }
        get _$lifeSpeedRandom$_() {
            return s(this)._$GetLifeSpeedRandom$_();
        }
        set _$lifeOpacityRandom$_(t) {
            Gc._$RequireFiniteNumber$_(t), s(this)._$SetLifeOpacityRandom$_(t);
        }
        get _$lifeOpacityRandom$_() {
            return s(this)._$GetLifeOpacityRandom$_();
        }
        set timeout(t) {
            Gc._$RequireFiniteNumber$_(t), s(this)._$SetTimeout$_(t);
        }
        get timeout() {
            return s(this)._$GetTimeout$_();
        }
        _$fastForward$_(t) {
            Gc._$RequireFiniteNumber$_(t), _c.get(this)._$_FastForward$_(t);
        }
        _$setParticleObjectClass$_(t) {
            const s = _c.get(this);
            t ? s._$_SetParticleObjectClass$_(s._$GetRuntime$_()._$_UnwrapIObjectClass$_(t)) : s._$_SetParticleObjectClass$_(null);
        }
    };
}

{
    const Ic = self._$C3$_;
    Ic._$Plugins$_._$Particles$_._$Cnds$_ = {
        _$IsSpraying$_() {
            return this._$_particleEngine$_._$IsSpraying$_();
        }
    };
}

{
    const Cc = self._$C3$_;
    Cc._$Plugins$_._$Particles$_._$Acts$_ = {
        _$SetSpraying$_(t) {
            this._$_particleEngine$_._$SetSpraying$_(0 !== t);
        },
        _$SetRate$_(t) {
            this._$_SetRate$_(t);
        },
        _$SetParticleObject$_(t) {
            this._$_SetParticleObjectClass$_(t);
        },
        _$UnsetParticleObject$_() {
            this._$_SetParticleObjectClass$_(null);
        },
        _$SetSprayCone$_(t) {
            this._$_particleEngine$_._$SetSprayCone$_(Cc._$toRadians$_(t));
        },
        _$SetInitSpeed$_(t) {
            this._$_particleEngine$_._$SetInitSpeed$_(t);
        },
        _$SetInitSize$_(t) {
            this._$_particleEngine$_._$SetInitSize$_(t);
        },
        _$SetInitOpacity$_(t) {
            this._$_particleEngine$_._$SetInitOpacity$_(t / 100);
        },
        _$SetGrowRate$_(t) {
            this._$_particleEngine$_._$SetGrowRate$_(t);
        },
        _$SetXRandomiser$_(t) {
            this._$_particleEngine$_._$SetInitXRandom$_(t);
        },
        _$SetYRandomiser$_(t) {
            this._$_particleEngine$_._$SetInitYRandom$_(t);
        },
        _$SetSpeedRandomiser$_(t) {
            this._$_particleEngine$_._$SetInitSpeedRandom$_(t);
        },
        _$SetSizeRandomiser$_(t) {
            this._$_particleEngine$_._$SetInitSizeRandom$_(t);
        },
        _$SetGrowRateRandomiser$_(t) {
            this._$_particleEngine$_._$SetGrowRandom$_(t);
        },
        _$SetParticleAcc$_(t) {
            this._$_particleEngine$_._$SetAcceleration$_(t);
        },
        _$SetGravity$_(t) {
            this._$_particleEngine$_._$SetGravity$_(t);
        },
        _$SetAngleRandomiser$_(t) {
            this._$_particleEngine$_._$SetLifeAngleRandom$_(t);
        },
        _$SetLifeSpeedRandomiser$_(t) {
            this._$_particleEngine$_._$SetLifeSpeedRandom$_(t);
        },
        _$SetOpacityRandomiser$_(t) {
            this._$_particleEngine$_._$SetLifeOpacityRandom$_(t);
        },
        _$SetTimeout$_(t) {
            this._$_particleEngine$_._$SetTimeout$_(t);
        },
        _$FastForward$_(t) {
            this._$_FastForward$_(t);
        },
        _$SetEffect$_(t) {
            this._$GetWorldInfo$_()._$SetBlendMode$_(t), this._$_runtime$_._$UpdateRender$_();
        }
    };
}

{
    const Rc = self._$C3$_;
    Rc._$Plugins$_._$Particles$_._$Exps$_ = {
        _$ParticleCount$_() {
            return this._$_particleEngine$_._$GetParticleCount$_();
        },
        _$Rate$_() {
            return this._$_particleEngine$_._$GetRate$_();
        },
        _$SprayCone$_() {
            return Rc._$toDegrees$_(this._$_particleEngine$_._$GetSprayCone$_());
        },
        _$InitSpeed$_() {
            return this._$_particleEngine$_._$GetInitSpeed$_();
        },
        _$InitSize$_() {
            return this._$_particleEngine$_._$GetInitSize$_();
        },
        _$InitOpacity$_() {
            return 100 * this._$_particleEngine$_._$GetInitOpacity$_();
        },
        _$InitGrowRate$_() {
            return this._$_particleEngine$_._$GetGrowRate$_();
        },
        _$XRandom$_() {
            return this._$_particleEngine$_._$GetInitXRandom$_();
        },
        _$YRandom$_() {
            return this._$_particleEngine$_._$GetInitYRandom$_();
        },
        _$InitSizeRandom$_() {
            return this._$_particleEngine$_._$GetInitSizeRandom$_();
        },
        _$InitSpeedRandom$_() {
            return this._$_particleEngine$_._$GetInitSpeedRandom$_();
        },
        _$InitGrowRandom$_() {
            return this._$_particleEngine$_._$GetGrowRandom$_();
        },
        _$ParticleAcceleration$_() {
            return this._$_particleEngine$_._$GetAcceleration$_();
        },
        _$Gravity$_() {
            return this._$_particleEngine$_._$GetGravity$_();
        },
        _$ParticleAngleRandom$_() {
            return this._$_particleEngine$_._$GetLifeAngleRandom$_();
        },
        _$ParticleSpeedRandom$_() {
            return this._$_particleEngine$_._$GetLifeSpeedRandom$_();
        },
        _$ParticleOpacityRandom$_() {
            return this._$_particleEngine$_._$GetLifeOpacityRandom$_();
        },
        _$Timeout$_() {
            return this._$_particleEngine$_._$GetTimeout$_();
        }
    };
}

{
    const Pc = self._$C3$_, Ec = [], Ac = new Set([ "continuous-spray", "one-shot" ]), Fc = [ "fade-to-invisible", "timeout-expired", "particle-stopped" ], Oc = Pc._$New$_(Pc.Rect);
    self._$ParticleEngine$_ = class {
        constructor() {
            this._$_rate$_ = 0, this._$_sprayCone$_ = 0, this._$_sprayType$_ = "continuous-spray", 
            this._$_isSpraying$_ = !1, this._$_masterOpacity$_ = 0, this._$_isPixelRounding$_ = !1, 
            this._$_spawnX$_ = 0, this._$_spawnY$_ = 0, this._$_spawnAngle$_ = 0, 
            this._$_initSpeed$_ = 0, this._$_initSize$_ = 0, this._$_initSizeScale$_ = 1, 
            this._$_initOpacity$_ = 0, this._$_growRate$_ = 0, this._$_xRandom$_ = 0, 
            this._$_yRandom$_ = 0, this._$_initSpeedRandom$_ = 0, this._$_initSizeRandom$_ = 0, 
            this._$_growRandom$_ = 0, this._$_acceleration$_ = 0, this._$_gravity$_ = 0, 
            this._$_lifeAngleRandom$_ = 0, this._$_lifeSpeedRandom$_ = 0, this._$_lifeOpacityRandom$_ = 0, 
            this._$_destroyMode$_ = 0, this._$_timeout$_ = 0, this._$_createCounter$_ = 0, 
            this._$_particleScale$_ = 1, this._$ononeshotfinish$_ = null, this._$onparticlecreate$_ = null, 
            this._$_particles$_ = [], this._$_boundingBox$_ = new Pc.Rect(), this._$_color$_ = new Pc._$Color$_();
        }
        _$Release$_() {
            this._$Cancel$_(), Pc._$clearArray$_(this._$_particles$_), this._$_particles$_ = null, 
            this._$ononeshotfinish$_ = null, this._$onparticlecreate$_ = null, this._$_boundingBox$_ = null, 
            this._$_color$_ = null;
        }
        _$Cancel$_() {
            const i = this._$_particles$_;
            for (let t = 0, s = i.length; t < s; ++t) i[t]._$Destroy$_();
            Pc._$appendArray$_(Ec, i), Pc._$clearArray$_(i), 1e3 < Ec.length && Pc._$truncateArray$_(Ec, 1e3), 
            this._$_isSpraying$_ = !1;
        }
        _$CreateOneShotSpray$_() {
            for (let t = 0, s = this._$_rate$_; t < s; ++t) this._$_CreateParticle$_();
            this._$_particles$_.length && (this._$_isSpraying$_ = !0);
        }
        _$_CreateParticle$_(t = !0) {
            let s = null;
            return Ec.length ? (s = Ec.pop())._$SetEngine$_(this) : s = Pc._$New$_(self._$Particle$_, this), 
            this._$_particles$_.push(s), t ? s._$Init$_(this._$onparticlecreate$_) : s._$Init$_(), 
            s;
        }
        _$ReInitAllParticles$_() {
            const i = this._$_particles$_, e = this._$onparticlecreate$_;
            for (let t = 0, s = i.length; t < s; ++t) i[t]._$Init$_(e);
        }
        _$UpdateAllParticlesUserData$_() {
            const i = this._$_particles$_, e = this._$onparticlecreate$_;
            for (let t = 0, s = i.length; t < s; ++t) i[t]._$UpdateUserData$_(e);
        }
        _$ApplyParticleDataToUserData$_(i) {
            const e = this._$_particles$_;
            for (let t = 0, s = e.length; t < s; ++t) {
                const h = e[t], r = h._$GetUserData$_();
                if (r) {
                    const n = r._$GetWorldInfo$_();
                    n._$SetX$_(h._$GetX$_()), n._$SetY$_(h._$GetY$_()), n._$SetSize$_(h._$GetSize$_(), h._$GetSize$_()), 
                    n._$SetOpacity$_(h._$GetOpacity$_()), n._$SetAngle$_(h._$GetAngle$_()), 
                    n._$SetUnpremultipliedColor$_(i._$GetWorldInfo$_()._$GetUnpremultipliedColor$_()), 
                    n._$SetBboxChanged$_();
                }
            }
        }
        _$SetParticleCount$_(t, s = !0) {
            const i = this._$_particles$_;
            if (t < i.length) {
                const e = i.length - t;
                for (let t = 0; t < e; ++t) {
                    const h = i.pop();
                    h._$Destroy$_(), Ec.push(h);
                }
                1e3 < Ec.length && Pc._$truncateArray$_(Ec, 1e3);
            } else if (t > i.length) {
                const r = t - i.length;
                for (let t = 0; t < r; ++t) this._$_CreateParticle$_(s);
            }
        }
        _$GetParticles$_() {
            return this._$_particles$_;
        }
        _$GetParticleCount$_() {
            return this._$_particles$_.length;
        }
        _$Tick$_(t) {
            this._$_SpawnContinuous$_(t), this._$_TickParticles$_(t), this._$_MaybeFinishOneShot$_();
        }
        _$_SpawnContinuous$_(t) {
            if ("continuous-spray" === this._$_sprayType$_ && this._$_isSpraying$_) {
                this._$_createCounter$_ += t * this._$_rate$_;
                const s = Math.floor(this._$_createCounter$_);
                this._$_createCounter$_ -= s;
                for (let t = 0; t < s; ++t) this._$_CreateParticle$_();
            }
        }
        _$_SetCreateCounter$_(t) {
            this._$_createCounter$_ = t;
        }
        _$_GetCreateCounter$_() {
            return this._$_createCounter$_;
        }
        _$_TickParticles$_(i) {
            let e = this._$_boundingBox$_, h = (e.set(this._$_spawnX$_, this._$_spawnY$_, this._$_spawnX$_, this._$_spawnY$_), 
            this._$_particles$_), r = 0;
            for (let t = 0, s = h.length; t < s; ++t) {
                const n = h[t];
                (h[r] = n)._$Tick$_(i), n._$IsActive$_() ? (++r, e._$expandToContain$_(n._$GetBoundingBox$_())) : (n._$Destroy$_(), 
                Ec.push(n));
            }
            Pc._$truncateArray$_(h, r), 1e3 < Ec.length && Pc._$truncateArray$_(Ec, 1e3);
        }
        _$_MaybeFinishOneShot$_() {
            "one-shot" === this._$_sprayType$_ && 0 === this._$_particles$_.length && this._$_isSpraying$_ && (this._$ononeshotfinish$_ && this._$ononeshotfinish$_(), 
            this._$_isSpraying$_ = !1);
        }
        _$Draw$_(i, e, h, r) {
            Oc.set(e._$getTlx$_(), e._$getTly$_(), e._$getBrx$_(), e._$getBry$_()), 
            i._$StartRenderingPoints$_(Oc), this._$_color$_._$copy$_(i._$GetColor$_());
            const n = this._$_particles$_;
            for (let t = 0, s = n.length; t < s; ++t) {
                const o = n[t];
                h._$intersectsRect$_(o._$GetBoundingBox$_()) && o._$Draw$_(i, e, r);
            }
            i._$FinishRenderingPoints$_();
        }
        _$GetColor$_() {
            return this._$_color$_;
        }
        _$SetRate$_(t) {
            this._$_rate$_ = +t;
        }
        _$GetRate$_() {
            return this._$_rate$_;
        }
        _$SetSprayCone$_(t) {
            this._$_sprayCone$_ = +t;
        }
        _$GetSprayCone$_() {
            return this._$_sprayCone$_;
        }
        _$SetSprayType$_(t) {
            if (!Ac.has(t)) throw new Error("invalid spray type");
            this._$_sprayType$_ = t;
        }
        _$GetSprayType$_() {
            return this._$_sprayType$_;
        }
        _$SetSpraying$_(t) {
            this._$_isSpraying$_ = !!t;
        }
        _$IsSpraying$_() {
            return this._$_isSpraying$_;
        }
        _$SetMasterOpacity$_(t) {
            this._$_masterOpacity$_ = +t;
        }
        _$GetMasterOpacity$_() {
            return this._$_masterOpacity$_;
        }
        _$SetPixelRounding$_(t) {
            this._$_isPixelRounding$_ = !!t;
        }
        _$IsPixelRounding$_() {
            return this._$_isPixelRounding$_;
        }
        _$SetSpawnX$_(t) {
            this._$_spawnX$_ = +t;
        }
        _$GetSpawnX$_() {
            return this._$_spawnX$_;
        }
        _$SetSpawnY$_(t) {
            this._$_spawnY$_ = +t;
        }
        _$GetSpawnY$_() {
            return this._$_spawnY$_;
        }
        _$SetSpawnAngle$_(t) {
            this._$_spawnAngle$_ = +t;
        }
        _$GetInitAngle$_() {
            return this._$_spawnAngle$_;
        }
        _$SetInitSpeed$_(t) {
            this._$_initSpeed$_ = +t;
        }
        _$GetInitSpeed$_() {
            return this._$_initSpeed$_;
        }
        _$SetInitSize$_(t) {
            this._$_initSize$_ = +t;
        }
        _$GetInitSize$_() {
            return this._$_initSize$_;
        }
        _$SetInitSizeScale$_(t) {
            this._$_initSizeScale$_ = +t;
        }
        _$GetInitSizeScale$_() {
            return this._$_initSizeScale$_;
        }
        _$SetInitOpacity$_(t) {
            this._$_initOpacity$_ = +t;
        }
        _$GetInitOpacity$_() {
            return this._$_initOpacity$_;
        }
        _$SetGrowRate$_(t) {
            this._$_growRate$_ = +t;
        }
        _$GetGrowRate$_() {
            return this._$_growRate$_;
        }
        _$SetInitXRandom$_(t) {
            this._$_xRandom$_ = +t;
        }
        _$GetInitXRandom$_() {
            return this._$_xRandom$_;
        }
        _$SetInitYRandom$_(t) {
            this._$_yRandom$_ = +t;
        }
        _$GetInitYRandom$_() {
            return this._$_yRandom$_;
        }
        _$SetInitSpeedRandom$_(t) {
            this._$_initSpeedRandom$_ = +t;
        }
        _$GetInitSpeedRandom$_() {
            return this._$_initSpeedRandom$_;
        }
        _$SetInitSizeRandom$_(t) {
            this._$_initSizeRandom$_ = +t;
        }
        _$GetInitSizeRandom$_() {
            return this._$_initSizeRandom$_;
        }
        _$SetGrowRandom$_(t) {
            this._$_growRandom$_ = +t;
        }
        _$GetGrowRandom$_() {
            return this._$_growRandom$_;
        }
        _$SetAcceleration$_(t) {
            this._$_acceleration$_ = +t;
        }
        _$GetAcceleration$_() {
            return this._$_acceleration$_;
        }
        _$SetGravity$_(t) {
            this._$_gravity$_ = +t;
        }
        _$GetGravity$_() {
            return this._$_gravity$_;
        }
        _$SetLifeAngleRandom$_(t) {
            this._$_lifeAngleRandom$_ = +t;
        }
        _$GetLifeAngleRandom$_() {
            return this._$_lifeAngleRandom$_;
        }
        _$SetLifeSpeedRandom$_(t) {
            this._$_lifeSpeedRandom$_ = +t;
        }
        _$GetLifeSpeedRandom$_() {
            return this._$_lifeSpeedRandom$_;
        }
        _$SetLifeOpacityRandom$_(t) {
            this._$_lifeOpacityRandom$_ = +t;
        }
        _$GetLifeOpacityRandom$_() {
            return this._$_lifeOpacityRandom$_;
        }
        _$SetDestroyMode$_(t) {
            let s = Fc.indexOf(t);
            if (-1 === s) throw new Error("invalid destroy mode");
            this._$_destroyMode$_ = s;
        }
        _$SetDestroyModeIndex$_(t) {
            this._$SetDestroyMode$_(Fc[t]);
        }
        _$GetDestroyMode$_() {
            return Fc[this._$_destroyMode$_];
        }
        _$GetDestroyModeIndex$_() {
            return this._$_destroyMode$_;
        }
        _$SetTimeout$_(t) {
            this._$_timeout$_ = +t;
        }
        _$GetTimeout$_() {
            return this._$_timeout$_;
        }
        _$SetParticleScale$_(t) {
            this._$_particleScale$_ = +t;
        }
        _$GetParticleScale$_() {
            return this._$_particleScale$_;
        }
        _$GetBoundingBox$_() {
            return this._$_boundingBox$_;
        }
    };
}

{
    let p = function(t) {
        return Math.random() * t - t / 2;
    }, m = (p, self._$C3$_), l = new m._$Quad$_(), u = new m._$Color$_(), t = self.devicePixelRatio || 1, c = !1;
    self._$Particle$_ = class {
        constructor(t) {
            this._$_engine$_ = t, this._$_isActive$_ = !1, this._$_x$_ = 0, this._$_y$_ = 0, 
            this._$_speed$_ = 0, this._$_angle$_ = 0, this._$_opacity$_ = 1, this._$_lastOpacity$_ = 0, 
            this._$_grow$_ = 0, this._$_size$_ = 0, this._$_halfSize$_ = 0, this._$_gs$_ = 0, 
            this._$_age$_ = 0, this._$_bbox$_ = new m.Rect(), this._$_userData$_ = null, 
            this._$_userDataUid$_ = NaN, this._$_updateCallback$_ = null, this._$_destroyCallback$_ = null;
        }
        _$SetEngine$_(t) {
            this._$_engine$_ = t;
        }
        _$Init$_(t) {
            const s = this._$_engine$_;
            this._$_isActive$_ = !0, this._$_x$_ = s._$GetSpawnX$_() + p(s._$GetInitXRandom$_()), 
            this._$_y$_ = s._$GetSpawnY$_() + p(s._$GetInitYRandom$_()), this._$_speed$_ = s._$GetInitSpeed$_() + p(s._$GetInitSpeedRandom$_()), 
            this._$_angle$_ = s._$GetInitAngle$_() + p(s._$GetSprayCone$_()), this._$_opacity$_ = s._$GetInitOpacity$_(), 
            this._$_lastOpacity$_ = this._$_opacity$_, this._$_size$_ = (s._$GetInitSize$_() + p(s._$GetInitSizeRandom$_())) * s._$GetInitSizeScale$_(), 
            this._$_halfSize$_ = this._$_size$_ / 2, this._$_grow$_ = s._$GetGrowRate$_() + p(s._$GetGrowRandom$_()), 
            this._$_gs$_ = 0, this._$_age$_ = 0, this._$_UpdateBoundingBox$_(), 
            t ? this._$_userData$_ || (this._$_userData$_ = t(this)) : (this._$_userData$_ = null, 
            this._$_updateCallback$_ = null, this._$_destroyCallback$_ = null);
        }
        _$UpdateUserData$_(t) {
            t ? this._$_userData$_ && !this._$_userData$_._$IsDestroyed$_() || (this._$_userData$_ = t(this, this._$_userDataUid$_)) : (this._$_userData$_ = null, 
            this._$_updateCallback$_ = null, this._$_destroyCallback$_ = null);
        }
        _$SetUpdateCallback$_(t) {
            this._$_updateCallback$_ = t;
        }
        _$SetDestroyCallback$_(t) {
            this._$_destroyCallback$_ = t;
        }
        _$Destroy$_() {
            const t = this._$_destroyCallback$_;
            t && t(this._$_userData$_), this._$_userData$_ = null, this._$_updateCallback$_ = null, 
            this._$_destroyCallback$_ = null;
        }
        toJSON() {
            let t;
            return this._$_userData$_ && this._$_userData$_._$GetWorldInfo$_() && (t = this._$_userData$_._$GetWorldInfo$_()._$GetInstance$_()._$GetUID$_()), 
            [ this._$_x$_, this._$_y$_, this._$_speed$_, this._$_angle$_, this._$_opacity$_, this._$_grow$_, this._$_size$_, this._$_gs$_, this._$_age$_, t ];
        }
        _$setFromJSON$_(t) {
            this._$_x$_ = t[0], this._$_y$_ = t[1], this._$_speed$_ = t[2], this._$_angle$_ = t[3], 
            this._$_opacity$_ = t[4], this._$_lastOpacity$_ = this._$_opacity$_, 
            this._$_grow$_ = t[5], this._$_size$_ = t[6], this._$_gs$_ = t[7], this._$_age$_ = t[8], 
            this._$_userDataUid$_ = t[9], this._$_halfSize$_ = this._$_size$_ / 2, 
            this._$_UpdateBoundingBox$_();
        }
        _$Tick$_(t) {
            let s = this._$_engine$_, i = this._$_speed$_ * t, e = this._$_angle$_, h = Math.cos(e) * i, r = Math.sin(e) * i + this._$_gs$_ * t, n = (this._$_x$_ += h, 
            this._$_y$_ += r, this._$_grow$_ * t), o = (this._$_size$_ += n, this._$_halfSize$_ = this._$_size$_ / 2, 
            this._$_speed$_ += s._$GetAcceleration$_() * t, this._$_gs$_ += s._$GetGravity$_() * t, 
            this._$_age$_ += t, this._$_UpdateBoundingBox$_(), s._$GetLifeAngleRandom$_()), a = s._$GetLifeSpeedRandom$_(), l = s._$GetLifeOpacityRandom$_(), u = 0;
            0 !== o && (u = p(o * t), this._$_angle$_ += u), 0 !== a && (this._$_speed$_ += p(a * t)), 
            0 !== l && (this._$_opacity$_ = m._$clamp$_(this._$_opacity$_ + p(l * t), 0, 1));
            const c = 1 <= this._$_size$_ && (2 === s._$GetDestroyModeIndex$_() ? 0 < this._$_speed$_ : this._$_age$_ < s._$GetTimeout$_()), f = this._$_updateCallback$_;
            if (f && c) {
                let t = s._$GetMasterOpacity$_() * this._$_opacity$_;
                0 === s._$GetDestroyModeIndex$_() && (t *= 1 - this._$_age$_ / s._$GetTimeout$_());
                const d = t - this._$_lastOpacity$_;
                this._$_lastOpacity$_ = t, f(this._$_userData$_, h, r, n, u, d);
            }
            this._$_isActive$_ = c;
        }
        _$IsActive$_() {
            return this._$_isActive$_;
        }
        _$GetBoundingBox$_() {
            return this._$_bbox$_;
        }
        _$_UpdateBoundingBox$_() {
            const t = this._$_x$_, s = this._$_y$_, i = this._$_halfSize$_;
            this._$_bbox$_.set(t - i, s - i, t + i, s + i);
        }
        _$Draw$_(h, r, n) {
            if (!this._$_userData$_) {
                let i = this._$_engine$_, e = i._$GetMasterOpacity$_() * this._$_opacity$_;
                if (0 === i._$GetDestroyModeIndex$_() && (e *= 1 - this._$_age$_ / i._$GetTimeout$_()), 
                !(e <= 0)) {
                    const o = this._$_size$_, a = o * i._$GetParticleScale$_() * t;
                    if (!(a < 1)) {
                        let t = this._$_x$_, s = this._$_y$_;
                        i._$IsPixelRounding$_() && (t = t + .5 | 0, s = s + .5 | 0), 
                        h._$IsWebGPU$_() ? h._$Point$_(t, s, o, e) : n || a > h._$GetMaxPointSize$_() || a < h._$GetMinPointSize$_() ? (u._$copy$_(i._$GetColor$_()), 
                        u._$multiplyAlpha$_(e), h._$SetColor$_(u), c = !0, l._$setFromRect$_(this._$_bbox$_), 
                        h._$Quad4$_(l, r)) : (c && (h._$SetColor$_(i._$GetColor$_()), 
                        c = !1), h._$Point$_(t, s, a, e));
                    }
                }
            }
        }
        _$GetUserData$_() {
            return this._$_userData$_;
        }
        _$GetUserDataUID$_() {
            return this._$_userDataUid$_;
        }
        _$GetX$_() {
            return this._$_x$_;
        }
        _$GetY$_() {
            return this._$_y$_;
        }
        _$GetSize$_() {
            return this._$_size$_;
        }
        _$GetAngle$_() {
            return this._$_angle$_;
        }
        _$GetOpacity$_() {
            return this._$_opacity$_;
        }
    };
}

{
    const Dc = self._$C3$_;
    Dc._$Behaviors$_._$Pin$_ = class extends Dc._$SDKBehaviorBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const kc = self._$C3$_;
    kc._$Behaviors$_._$Pin$_._$Type$_ = class extends kc._$SDKBehaviorTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    const Lc = self._$C3$_;
    Lc._$Behaviors$_._$Pin$_.Instance = class extends Lc._$SDKBehaviorInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_pinInst$_ = null, this._$_pinUid$_ = -1, this._$_mode$_ = "", 
            this._$_propSet$_ = new Set(), this._$_pinDist$_ = 0, this._$_pinAngle$_ = 0, 
            this._$_pinImagePoint$_ = 0, this._$_dx$_ = 0, this._$_dy$_ = 0, this._$_dWidth$_ = 0, 
            this._$_dHeight$_ = 0, this._$_dAngle$_ = 0, this._$_dz$_ = 0, this._$_lastKnownAngle$_ = 0, 
            this._$_destroy$_ = !1, s && (this._$_destroy$_ = s[0]);
            const i = this._$_runtime$_._$Dispatcher$_();
            this._$_disposables$_ = new Lc._$CompositeDisposable$_(Lc._$Disposable$_._$From$_(i, "instancedestroy", t => this._$_OnInstanceDestroyed$_(t._$instance$_)), Lc._$Disposable$_._$From$_(i, "afterload", t => this._$_OnAfterLoad$_()));
        }
        _$Release$_() {
            this._$_pinInst$_ = null, super._$Release$_();
        }
        _$_SetPinInst$_(t) {
            t ? (this._$_pinInst$_ = t, this._$_StartTicking2$_()) : (this._$_pinInst$_ = null, 
            this._$_StopTicking2$_());
        }
        _$_Pin$_(t, s, i) {
            if (t) {
                const e = t._$GetFirstPicked$_(this._$_inst$_);
                if (e) {
                    this._$_mode$_ = s, this._$_SetPinInst$_(e);
                    const h = this._$_inst$_._$GetWorldInfo$_(), r = e._$GetWorldInfo$_();
                    if ("properties" === this._$_mode$_) {
                        const n = this._$_propSet$_;
                        n.clear();
                        for (const o of i) n.add(o);
                        this._$_dx$_ = h._$GetX$_() - r._$GetX$_(), this._$_dy$_ = h._$GetY$_() - r._$GetY$_(), 
                        this._$_dAngle$_ = h._$GetAngle$_() - r._$GetAngle$_(), 
                        this._$_lastKnownAngle$_ = h._$GetAngle$_(), this._$_dz$_ = h._$GetZElevation$_() - r._$GetZElevation$_(), 
                        n.has("x") && n.has("y") && (this._$_pinAngle$_ = Lc._$angleTo$_(r._$GetX$_(), r._$GetY$_(), h._$GetX$_(), h._$GetY$_()) - r._$GetAngle$_(), 
                        this._$_pinDist$_ = Lc._$distanceTo$_(r._$GetX$_(), r._$GetY$_(), h._$GetX$_(), h._$GetY$_())), 
                        n.has("width-abs") ? this._$_dWidth$_ = h._$GetWidth$_() - r._$GetWidth$_() : n.has("width-scale") && (this._$_dWidth$_ = h._$GetWidth$_() / r._$GetWidth$_()), 
                        n.has("height-abs") ? this._$_dHeight$_ = h._$GetHeight$_() - r._$GetHeight$_() : n.has("height-scale") && (this._$_dHeight$_ = h._$GetHeight$_() / r._$GetHeight$_());
                    } else this._$_pinDist$_ = Lc._$distanceTo$_(r._$GetX$_(), r._$GetY$_(), h._$GetX$_(), h._$GetY$_());
                }
            }
        }
        _$SaveToJson$_() {
            const t = this._$_propSet$_, s = this._$_mode$_, i = {
                uid: this._$_pinInst$_ && !this._$_pinInst$_._$IsDestroyed$_() ? this._$_pinInst$_._$GetUID$_() : -1,
                m: s,
                d: this._$_destroy$_
            };
            return "rope" === s || "bar" === s ? i.pd = this._$_pinDist$_ : "properties" === s && (i.ps = [ ...this._$_propSet$_ ], 
            t.has("imagepoint") ? i.ip = this._$_pinImagePoint$_ : t.has("x") && t.has("y") ? (i.pa = this._$_pinAngle$_, 
            i.pd = this._$_pinDist$_) : (t.has("x") && (i.dx = this._$_dx$_), t.has("y") && (i.dy = this._$_dy$_)), 
            t.has("angle") && (i.da = this._$_dAngle$_, i.lka = this._$_lastKnownAngle$_), 
            (t.has("width-abs") || t.has("width-scale")) && (i.dw = this._$_dWidth$_), 
            (t.has("height-abs") || t.has("height-scale")) && (i.dh = this._$_dHeight$_), 
            t.has("z")) && (i.dz = this._$_dz$_), i;
        }
        _$LoadFromJson$_(t) {
            const s = t.m, i = this._$_propSet$_;
            if (i.clear(), this._$_pinUid$_ = t.uid, "number" == typeof s) this._$_LoadFromJson_Legacy$_(t); else if (this._$_mode$_ = s, 
            t.hasOwnProperty("d") && (this._$_destroy$_ = !!t.d), "rope" === s || "bar" === s) this._$_pinDist$_ = t.pd; else if ("properties" === s) {
                for (const e of t.ps) i.add(e);
                i.has("imagepoint") ? this._$_pinImagePoint$_ = t.ip : i.has("x") && i.has("y") ? (this._$_pinAngle$_ = t.pa, 
                this._$_pinDist$_ = t.pd) : (i.has("x") && (this._$_dx$_ = t.dx), 
                i.has("y") && (this._$_dy$_ = t.dy)), i.has("angle") && (this._$_dAngle$_ = t.da, 
                this._$_lastKnownAngle$_ = t.lka || 0), (i.has("width-abs") || i.has("width-scale")) && (this._$_dWidth$_ = t.dw), 
                (i.has("height-abs") || i.has("height-scale")) && (this._$_dHeight$_ = t.dh), 
                i.has("z") && (this._$_dz$_ = t.dz);
            }
        }
        _$_LoadFromJson_Legacy$_(t) {
            const s = this._$_propSet$_, i = t.msa, e = t.tsa, h = t.pa, r = t.pd, n = t.m;
            switch (n) {
              case 0:
                this._$_mode$_ = "properties", s.add("x").add("y").add("angle"), 
                this._$_pinAngle$_ = h, this._$_pinDist$_ = r, this._$_dAngle$_ = i - e, 
                this._$_lastKnownAngle$_ = t.lka;
                break;

              case 1:
                this._$_mode$_ = "properties", s.add("x").add("y"), this._$_pinAngle$_ = h, 
                this._$_pinDist$_ = r;
                break;

              case 2:
                this._$_mode$_ = "properties", s.add("angle"), this._$_dAngle$_ = i - e, 
                this._$_lastKnownAngle$_ = t.lka;
                break;

              case 3:
                this._$_mode$_ = "rope", this._$_pinDist$_ = t.pd;
                break;

              case 4:
                this._$_mode$_ = "bar", this._$_pinDist$_ = t.pd;
            }
        }
        _$_OnAfterLoad$_() {
            -1 === this._$_pinUid$_ ? this._$_SetPinInst$_(null) : (this._$_SetPinInst$_(this._$_runtime$_._$GetInstanceByUID$_(this._$_pinUid$_)), 
            this._$_pinUid$_ = -1);
        }
        _$_OnInstanceDestroyed$_(t) {
            this._$_pinInst$_ === t && (this._$_SetPinInst$_(null), this._$_destroy$_) && this._$_runtime$_._$DestroyInstance$_(this._$_inst$_);
        }
        _$Tick2$_() {
            const r = this._$_pinInst$_;
            if (r && !r._$IsDestroyed$_()) {
                let i = r._$GetWorldInfo$_(), t = this._$_inst$_, e = t._$GetWorldInfo$_(), s = this._$_mode$_, h = !1;
                if ("rope" === s || "bar" === s) {
                    const n = Lc._$distanceTo$_(e._$GetX$_(), e._$GetY$_(), i._$GetX$_(), i._$GetY$_());
                    if (n > this._$_pinDist$_ || "bar" === s && n < this._$_pinDist$_) {
                        const o = Lc._$angleTo$_(i._$GetX$_(), i._$GetY$_(), e._$GetX$_(), e._$GetY$_());
                        e._$SetXY$_(i._$GetX$_() + Math.cos(o) * this._$_pinDist$_, i._$GetY$_() + Math.sin(o) * this._$_pinDist$_), 
                        h = !0;
                    }
                } else {
                    let t = this._$_propSet$_, s = 0;
                    if (t.has("imagepoint")) {
                        const [ a, l ] = r._$GetImagePoint$_(this._$_pinImagePoint$_);
                        e._$EqualsXY$_(a, l) || (e._$SetXY$_(a, l), h = !0);
                    } else if (t.has("x") && t.has("y")) {
                        const u = i._$GetX$_() + Math.cos(i._$GetAngle$_() + this._$_pinAngle$_) * this._$_pinDist$_, c = i._$GetY$_() + Math.sin(i._$GetAngle$_() + this._$_pinAngle$_) * this._$_pinDist$_;
                        e._$EqualsXY$_(u, c) || (e._$SetXY$_(u, c), h = !0);
                    } else s = i._$GetX$_() + this._$_dx$_, t.has("x") && s !== e._$GetX$_() && (e._$SetX$_(s), 
                    h = !0), s = i._$GetY$_() + this._$_dy$_, t.has("y") && s !== e._$GetY$_() && (e._$SetY$_(s), 
                    h = !0);
                    t.has("angle") && (this._$_lastKnownAngle$_ !== e._$GetAngle$_() && (this._$_dAngle$_ = Lc._$clampAngle$_(this._$_dAngle$_ + (e._$GetAngle$_() - this._$_lastKnownAngle$_))), 
                    (s = Lc._$clampAngle$_(i._$GetAngle$_() + this._$_dAngle$_)) !== e._$GetAngle$_() && (e._$SetAngle$_(s), 
                    h = !0), this._$_lastKnownAngle$_ = e._$GetAngle$_()), t.has("width-abs") && (s = i._$GetWidth$_() + this._$_dWidth$_) !== e._$GetWidth$_() && (e._$SetWidth$_(s), 
                    h = !0), t.has("width-scale") && (s = i._$GetWidth$_() * this._$_dWidth$_) !== e._$GetWidth$_() && (e._$SetWidth$_(s), 
                    h = !0), t.has("height-abs") && (s = i._$GetHeight$_() + this._$_dHeight$_) !== e._$GetHeight$_() && (e._$SetHeight$_(s), 
                    h = !0), t.has("height-scale") && (s = i._$GetHeight$_() * this._$_dHeight$_) !== e._$GetHeight$_() && (e._$SetHeight$_(s), 
                    h = !0), t.has("z") && (s = i._$GetZElevation$_() + this._$_dz$_) !== e._$GetZElevation$_() && (e._$SetZElevation$_(s), 
                    this._$_runtime$_._$UpdateRender$_());
                }
                h && e._$SetBboxChanged$_();
            }
        }
        _$GetDebuggerProperties$_() {
            const t = "behaviors.pin.debugger";
            return [ {
                title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                properties: [ {
                    name: t + ".is-pinned",
                    value: !!this._$_pinInst$_
                }, {
                    name: t + ".pinned-uid",
                    value: this._$_pinInst$_ ? this._$_pinInst$_._$GetUID$_() : 0
                } ]
            } ];
        }
    };
}

{
    const Bc = self._$C3$_;
    Bc._$Behaviors$_._$Pin$_._$Cnds$_ = {
        _$IsPinned$_() {
            return !!this._$_pinInst$_;
        },
        _$WillDestroy$_() {
            return this._$_destroy$_;
        }
    };
}

{
    const Nc = self._$C3$_;
    Nc._$Behaviors$_._$Pin$_._$Acts$_ = {
        _$PinByDistance$_(t, s) {
            this._$_Pin$_(t, 0 === s ? "rope" : "bar");
        },
        _$PinByProperties$_(t, s, i, e, h, r, n) {
            const o = [];
            s && o.push("x"), i && o.push("y"), e && o.push("angle"), n && o.push("z"), 
            1 === h ? o.push("width-abs") : 2 === h && o.push("width-scale"), 1 === r ? o.push("height-abs") : 2 === r && o.push("height-scale"), 
            0 !== o.length && this._$_Pin$_(t, "properties", o);
        },
        _$PinByImagePoint$_(t, s, i, e, h, r) {
            const n = [ "imagepoint" ];
            i && n.push("angle"), r && n.push("z"), 1 === e ? n.push("width-abs") : 2 === e && n.push("width-scale"), 
            1 === h ? n.push("height-abs") : 2 === h && n.push("height-scale"), 
            this._$_pinImagePoint$_ = s, this._$_Pin$_(t, "properties", n);
        },
        _$SetPinDistance$_(t) {
            "rope" !== this._$_mode$_ && "bar" !== this._$_mode$_ || (this._$_pinDist$_ = Math.max(t, 0));
        },
        _$SetDestroy$_(t) {
            this._$_destroy$_ = t;
        },
        _$Unpin$_() {
            this._$_SetPinInst$_(null), this._$_mode$_ = "", this._$_propSet$_.clear(), 
            this._$_pinImagePoint$_ = "";
        },
        _$Pin$_(t, s) {
            switch (s) {
              case 0:
                this._$_Pin$_(t, "properties", [ "x", "y", "angle" ]);
                break;

              case 1:
                this._$_Pin$_(t, "properties", [ "x", "y" ]);
                break;

              case 2:
                this._$_Pin$_(t, "properties", [ "angle" ]);
                break;

              case 3:
                this._$_Pin$_(t, "rope");
                break;

              case 4:
                this._$_Pin$_(t, "bar");
            }
        }
    };
}

{
    const Wc = self._$C3$_;
    Wc._$Behaviors$_._$Pin$_._$Exps$_ = {
        _$PinnedUID$_() {
            return this._$_pinInst$_ ? this._$_pinInst$_._$GetUID$_() : -1;
        }
    };
}

{
    const jc = self._$C3$_;
    jc._$Behaviors$_._$Sin$_ = class extends jc._$SDKBehaviorBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const Vc = self._$C3$_;
    Vc._$Behaviors$_._$Sin$_._$Type$_ = class extends Vc._$SDKBehaviorTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    const Uc = self._$C3$_, Hc = self._$C3X$_, zc = self._$IBehaviorInstance$_, Jc = 2 * Math.PI, qc = Math.PI / 2, Xc = 3 * Math.PI / 2, Yc = [ 0, 1, 8, 3, 4, 2, 5, 6, 9, 7 ], $c = (Uc._$Behaviors$_._$Sin$_.Instance = class extends Uc._$SDKBehaviorInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_i$_ = 0, this._$_movement$_ = 0, this._$_wave$_ = 0, 
            this._$_period$_ = 0, this._$_mag$_ = 0, this._$_isEnabled$_ = !0, this._$_basePeriod$_ = 0, 
            this._$_basePeriodOffset$_ = 0, this._$_baseMag$_ = 0, this._$_periodRandom$_ = 0, 
            this._$_periodOffsetRandom$_ = 0, this._$_magnitudeRandom$_ = 0, this._$_initialValue$_ = 0, 
            this._$_initialValue2$_ = 0, this._$_lastKnownValue$_ = 0, this._$_lastKnownValue2$_ = 0, 
            this._$_ratio$_ = 0, s && (this._$_movement$_ = Yc[s[0]], this._$_wave$_ = s[1], 
            this._$_periodRandom$_ = this._$_runtime$_._$Random$_() * s[3], this._$_basePeriod$_ = s[2], 
            this._$_period$_ = s[2], this._$_period$_ += this._$_periodRandom$_, 
            this._$_basePeriodOffset$_ = s[4], 0 !== this._$_period$_ && (this._$_periodOffsetRandom$_ = this._$_runtime$_._$Random$_() * s[5], 
            this._$_i$_ = s[4] / this._$_period$_ * Jc, this._$_i$_ += this._$_periodOffsetRandom$_ / this._$_period$_ * Jc), 
            this._$_magnitudeRandom$_ = this._$_runtime$_._$Random$_() * s[7], this._$_baseMag$_ = s[6], 
            this._$_mag$_ = s[6], this._$_mag$_ += this._$_magnitudeRandom$_, this._$_isEnabled$_ = !!s[8]), 
            5 === this._$_movement$_ && (this._$_mag$_ = Uc._$toRadians$_(this._$_mag$_)), 
            this._$Init$_(), this._$_isEnabled$_ && this._$_StartTicking$_();
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$SaveToJson$_() {
            return {
                i: this._$_i$_,
                e: this._$_isEnabled$_,
                mv: this._$_movement$_,
                w: this._$_wave$_,
                p: this._$_period$_,
                mag: this._$_mag$_,
                iv: this._$_initialValue$_,
                iv2: this._$_initialValue2$_,
                r: this._$_ratio$_,
                lkv: this._$_lastKnownValue$_,
                lkv2: this._$_lastKnownValue2$_
            };
        }
        _$LoadFromJson$_(t) {
            this._$_i$_ = t.i, this._$_SetEnabled$_(t.e), this._$_movement$_ = t.mv, 
            this._$_wave$_ = t.w, this._$_period$_ = t.p, this._$_mag$_ = t.mag, 
            this._$_initialValue$_ = t.iv, this._$_initialValue2$_ = t.iv2, this._$_ratio$_ = t.r, 
            this._$_lastKnownValue$_ = t.lkv, this._$_lastKnownValue2$_ = t.lkv2;
        }
        _$Init$_() {
            const t = this._$_inst$_._$GetWorldInfo$_();
            switch (this._$_movement$_) {
              case 0:
                this._$_initialValue$_ = t._$GetX$_();
                break;

              case 1:
                this._$_initialValue$_ = t._$GetY$_();
                break;

              case 2:
                this._$_initialValue$_ = t._$GetWidth$_(), this._$_ratio$_ = t._$GetHeight$_() / t._$GetWidth$_();
                break;

              case 3:
                this._$_initialValue$_ = t._$GetWidth$_();
                break;

              case 4:
                this._$_initialValue$_ = t._$GetHeight$_();
                break;

              case 5:
                this._$_initialValue$_ = t._$GetAngle$_();
                break;

              case 6:
                this._$_initialValue$_ = t._$GetOpacity$_();
                break;

              case 7:
                this._$_initialValue$_ = 0;
                break;

              case 8:
                this._$_initialValue$_ = t._$GetX$_(), this._$_initialValue2$_ = t._$GetY$_();
                break;

              case 9:
                this._$_initialValue$_ = t._$GetZElevation$_();
            }
            this._$_lastKnownValue$_ = this._$_initialValue$_, this._$_lastKnownValue2$_ = this._$_initialValue2$_;
        }
        _$WaveFunc$_(t) {
            switch (t %= Jc, this._$_wave$_) {
              case 0:
                return Math.sin(t);

              case 1:
                return t <= qc ? t / qc : t <= Xc ? 1 - 2 * (t - qc) / Math.PI : (t - Xc) / qc - 1;

              case 2:
                return 2 * t / Jc - 1;

              case 3:
                return -2 * t / Jc + 1;

              case 4:
                return t < Math.PI ? -1 : 1;
            }
            return 0;
        }
        _$Tick$_() {
            const t = this._$_runtime$_._$GetDt$_(this._$_inst$_);
            this._$_isEnabled$_ && 0 !== t && (0 === this._$_period$_ ? this._$_i$_ = 0 : this._$_i$_ = (this._$_i$_ + t / this._$_period$_ * Jc) % Jc, 
            this._$_UpdateFromPhase$_());
        }
        _$_UpdateFromPhase$_() {
            const t = this._$_inst$_._$GetWorldInfo$_();
            switch (this._$_movement$_) {
              case 0:
                t._$GetX$_() !== this._$_lastKnownValue$_ && (this._$_initialValue$_ += t._$GetX$_() - this._$_lastKnownValue$_), 
                t._$SetX$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_), 
                this._$_lastKnownValue$_ = t._$GetX$_();
                break;

              case 1:
                t._$GetY$_() !== this._$_lastKnownValue$_ && (this._$_initialValue$_ += t._$GetY$_() - this._$_lastKnownValue$_), 
                t._$SetY$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_), 
                this._$_lastKnownValue$_ = t._$GetY$_();
                break;

              case 2:
                t._$SetWidth$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_), 
                t._$SetHeight$_(t._$GetWidth$_() * this._$_ratio$_);
                break;

              case 3:
                t._$SetWidth$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_);
                break;

              case 4:
                t._$SetHeight$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_);
                break;

              case 5:
                t._$GetAngle$_() !== this._$_lastKnownValue$_ && (this._$_initialValue$_ = Uc._$clampAngle$_(this._$_initialValue$_ + (t._$GetAngle$_() - this._$_lastKnownValue$_))), 
                t._$SetAngle$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_), 
                this._$_lastKnownValue$_ = t._$GetAngle$_();
                break;

              case 6:
                t._$SetOpacity$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_ / 100);
                break;

              case 8:
                t._$GetX$_() !== this._$_lastKnownValue$_ && (this._$_initialValue$_ += t._$GetX$_() - this._$_lastKnownValue$_), 
                t._$GetY$_() !== this._$_lastKnownValue2$_ && (this._$_initialValue2$_ += t._$GetY$_() - this._$_lastKnownValue2$_), 
                t._$SetX$_(this._$_initialValue$_ + Math.cos(t._$GetAngle$_()) * this._$WaveFunc$_(this._$_i$_) * this._$_mag$_), 
                t._$SetY$_(this._$_initialValue2$_ + Math.sin(t._$GetAngle$_()) * this._$WaveFunc$_(this._$_i$_) * this._$_mag$_), 
                this._$_lastKnownValue$_ = t._$GetX$_(), this._$_lastKnownValue2$_ = t._$GetY$_();
                break;

              case 9:
                t._$SetZElevation$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_);
            }
            t._$SetBboxChanged$_();
        }
        _$_OnSpriteFrameChanged$_(t, s) {}
        _$_SetPeriod$_(t) {
            this._$_period$_ = t;
        }
        _$_GetPeriod$_() {
            return this._$_period$_;
        }
        _$_SetMagnitude$_(t) {
            this._$_mag$_ = t;
        }
        _$_SetMagnitude_ConvertAngle$_(t) {
            5 === this._$_movement$_ && (t = Uc._$toRadians$_(t)), this._$_SetMagnitude$_(t);
        }
        _$_GetMagnitude$_() {
            return this._$_mag$_;
        }
        _$_GetMagnitude_ConvertAngle$_() {
            let t = this._$_GetMagnitude$_();
            return t = 5 === this._$_movement$_ ? Uc._$toDegrees$_(t) : t;
        }
        _$_SetMovement$_(t) {
            5 === this._$_movement$_ && 5 !== t && (this._$_mag$_ = Uc._$toDegrees$_(this._$_mag$_)), 
            this._$_movement$_ = t, this._$Init$_();
        }
        _$_GetMovement$_() {
            return this._$_movement$_;
        }
        _$_SetWave$_(t) {
            this._$_wave$_ = t;
        }
        _$_GetWave$_() {
            return this._$_wave$_;
        }
        _$_SetPhase$_(t) {
            this._$_i$_ = Uc._$clamp$_(t, 0, 2 * Math.PI), this._$_UpdateFromPhase$_();
        }
        _$_GetPhase$_() {
            return this._$_i$_;
        }
        _$_SetEnabled$_(t) {
            this._$_isEnabled$_ = !!t, this._$_isEnabled$_ ? this._$_StartTicking$_() : this._$_StopTicking$_();
        }
        _$_IsEnabled$_() {
            return this._$_isEnabled$_;
        }
        _$GetPropertyValueByIndex$_(t) {
            switch (t) {
              case 0:
                return this._$_movement$_;

              case 1:
                return this._$_wave$_;

              case 2:
                return this._$_basePeriod$_;

              case 6:
                return this._$_baseMag$_;

              case 8:
                return this._$_isEnabled$_;
            }
        }
        _$SetPropertyValueByIndex$_(t, s) {
            switch (t) {
              case 0:
                this._$_movement$_ = Yc[s], this._$Init$_();
                break;

              case 1:
                this._$_wave$_ = s;
                break;

              case 2:
                this._$_basePeriod$_ = s, this._$_period$_ = this._$_basePeriod$_ + this._$_periodRandom$_, 
                this._$_isEnabled$_ || (0 !== this._$_period$_ ? (this._$_i$_ = this._$_basePeriodOffset$_ / this._$_period$_ * Jc, 
                this._$_i$_ += this._$_periodOffsetRandom$_ / this._$_period$_ * Jc) : this._$_i$_ = 0);
                break;

              case 6:
                this._$_baseMag$_ = s, this._$_mag$_ = this._$_baseMag$_ + this._$_magnitudeRandom$_, 
                5 === this._$_movement$_ && (this._$_mag$_ = Uc._$toRadians$_(this._$_mag$_));
                break;

              case 8:
                this._$_isEnabled$_ = !!s;
            }
        }
        _$GetDebuggerProperties$_() {
            const t = "behaviors.sin";
            return [ {
                title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                properties: [ {
                    name: t + ".properties.enabled.name",
                    value: this._$_IsEnabled$_(),
                    _$onedit$_: t => this._$_SetEnabled$_(t)
                }, {
                    name: t + ".properties.period.name",
                    value: this._$_GetPeriod$_(),
                    _$onedit$_: t => this._$_SetPeriod$_(t)
                }, {
                    name: t + ".properties.magnitude.name",
                    value: this._$_GetMagnitude_ConvertAngle$_(),
                    _$onedit$_: t => this._$_SetMagnitude_ConvertAngle$_(t)
                }, {
                    name: t + ".debugger.value",
                    value: this._$WaveFunc$_(this._$_GetPhase$_()) * this._$_GetMagnitude_ConvertAngle$_()
                } ]
            } ];
        }
        _$GetScriptInterfaceClass$_() {
            return self._$ISineBehaviorInstance$_;
        }
    }, new WeakMap()), Kc = [ "horizontal", "vertical", "size", "width", "height", "angle", "opacity", "value-only", "forwards-backwards", "z-elevation" ], Zc = [ "sine", "triangle", "sawtooth", "reverse-sawtooth", "square" ];
    self._$ISineBehaviorInstance$_ = class extends zc {
        constructor() {
            super(), $c.set(this, zc._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        set _$period$_(t) {
            Hc._$RequireFiniteNumber$_(t), $c.get(this)._$_SetPeriod$_(t);
        }
        get _$period$_() {
            return $c.get(this)._$_GetPeriod$_();
        }
        set _$magnitude$_(t) {
            Hc._$RequireFiniteNumber$_(t), $c.get(this)._$_SetMagnitude$_(t);
        }
        get _$magnitude$_() {
            return $c.get(this)._$_GetMagnitude$_();
        }
        set _$phase$_(t) {
            $c.get(this)._$_SetPhase$_(t);
        }
        get _$phase$_() {
            return $c.get(this)._$_GetPhase$_();
        }
        set _$movement$_(t) {
            Hc._$RequireString$_(t);
            const s = Kc.indexOf(t);
            if (-1 === s) throw new Error("invalid movement");
            $c.get(this)._$_SetMovement$_(s);
        }
        get _$movement$_() {
            return Kc[$c.get(this)._$_GetMovement$_()];
        }
        set _$wave$_(t) {
            Hc._$RequireString$_(t);
            const s = Zc.indexOf(t);
            if (-1 === s) throw new Error("invalid wave");
            $c.get(this)._$_SetWave$_(s);
        }
        get _$wave$_() {
            return Zc[$c.get(this)._$_GetWave$_()];
        }
        get value() {
            const t = $c.get(this);
            return t._$WaveFunc$_(t._$_GetPhase$_()) * t._$_GetMagnitude$_();
        }
        _$updateInitialState$_() {
            $c.get(this)._$Init$_();
        }
        set isEnabled(t) {
            $c.get(this)._$_SetEnabled$_(!!t);
        }
        get isEnabled() {
            return $c.get(this)._$_IsEnabled$_();
        }
    };
}

{
    const Qc = self._$C3$_;
    Qc._$Behaviors$_._$Sin$_._$Cnds$_ = {
        _$IsEnabled$_() {
            return this._$_IsEnabled$_();
        },
        _$CompareMovement$_(t) {
            return this._$_GetMovement$_() === t;
        },
        _$ComparePeriod$_(t, s) {
            return Qc.compare(this._$_GetPeriod$_(), t, s);
        },
        _$CompareMagnitude$_(t, s) {
            return Qc.compare(this._$_GetMagnitude_ConvertAngle$_(), t, s);
        },
        _$CompareWave$_(t) {
            return this._$_GetWave$_() === t;
        }
    };
}

{
    const tf = self._$C3$_;
    tf._$Behaviors$_._$Sin$_._$Acts$_ = {
        _$SetEnabled$_(t) {
            this._$_SetEnabled$_(0 !== t);
        },
        _$SetPeriod$_(t) {
            this._$_SetPeriod$_(t);
        },
        _$SetMagnitude$_(t) {
            this._$_SetMagnitude_ConvertAngle$_(t);
        },
        _$SetMovement$_(t) {
            this._$_SetMovement$_(t);
        },
        _$SetWave$_(t) {
            this._$_wave$_ = t;
        },
        _$SetPhase$_(t) {
            const s = 2 * Math.PI;
            this._$_SetPhase$_(t * s % s);
        },
        _$UpdateInitialState$_() {
            this._$Init$_();
        }
    };
}

{
    const sf = self._$C3$_;
    sf._$Behaviors$_._$Sin$_._$Exps$_ = {
        _$CyclePosition$_() {
            return this._$_GetPhase$_() / (2 * Math.PI);
        },
        _$Period$_() {
            return this._$_GetPeriod$_();
        },
        _$Magnitude$_() {
            return this._$_GetMagnitude_ConvertAngle$_();
        },
        _$Value$_() {
            return this._$WaveFunc$_(this._$_GetPhase$_()) * this._$_GetMagnitude_ConvertAngle$_();
        }
    };
}

{
    const ef = self._$C3$_;
    ef._$Behaviors$_._$Fade$_ = class extends ef._$SDKBehaviorBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const hf = self._$C3$_;
    hf._$Behaviors$_._$Fade$_._$Type$_ = class extends hf._$SDKBehaviorTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    const rf = self._$C3$_, nf = self._$C3X$_, of = self._$IBehaviorInstance$_, af = (rf._$Behaviors$_._$Fade$_.Instance = class extends rf._$SDKBehaviorInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_fadeInTime$_ = 0, this._$_waitTime$_ = 0, this._$_fadeOutTime$_ = 0, 
            this._$_destroy$_ = !0, this._$_activeAtStart$_ = !0, this._$_setMaxOpacity$_ = !1, 
            this._$_stage$_ = 0, this._$_stageTime$_ = rf._$New$_(rf._$KahanSum$_), 
            this._$_maxOpacity$_ = this._$_inst$_._$GetWorldInfo$_()._$GetOpacity$_() || 1, 
            s && (this._$_fadeInTime$_ = s[0], this._$_waitTime$_ = s[1], this._$_fadeOutTime$_ = s[2], 
            this._$_destroy$_ = !!s[3], this._$_activeAtStart$_ = !!s[4], this._$_stage$_ = this._$_activeAtStart$_ ? 0 : 3), 
            this._$_activeAtStart$_ && (0 === this._$_fadeInTime$_ ? (this._$_stage$_ = 1, 
            0 === this._$_waitTime$_ && (this._$_stage$_ = 2)) : (this._$_inst$_._$GetWorldInfo$_()._$SetOpacity$_(0), 
            this._$_runtime$_._$UpdateRender$_())), this._$_StartTicking$_();
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$SaveToJson$_() {
            return {
                fit: this._$_fadeInTime$_,
                wt: this._$_waitTime$_,
                fot: this._$_fadeOutTime$_,
                d: this._$_destroy$_,
                s: this._$_stage$_,
                st: this._$_stageTime$_._$Get$_(),
                mo: this._$_maxOpacity$_
            };
        }
        _$LoadFromJson$_(t) {
            this._$_fadeInTime$_ = t.fit, this._$_waitTime$_ = t.wt, this._$_fadeOutTime$_ = t.fot, 
            this._$_destroy$_ = t.d, this._$_stage$_ = t.s, this._$_stageTime$_.Set(t.st), 
            this._$_maxOpacity$_ = t.mo, 3 === this._$_stage$_ ? this._$_StopTicking$_() : this._$_StartTicking$_();
        }
        _$Tick$_() {
            const t = this._$_runtime$_._$GetDt$_(this._$_inst$_), s = (this._$_stageTime$_._$Add$_(t), 
            this._$_inst$_._$GetWorldInfo$_());
            0 === this._$_stage$_ && (s._$SetOpacity$_(this._$_stageTime$_._$Get$_() / this._$_fadeInTime$_ * this._$_maxOpacity$_), 
            this._$_runtime$_._$UpdateRender$_(), s._$GetOpacity$_() >= this._$_maxOpacity$_) && (s._$SetOpacity$_(this._$_maxOpacity$_), 
            this._$_stage$_ = 1, this._$_stageTime$_._$Reset$_(), this._$DispatchScriptEvent$_("fadeinend"), 
            this._$Trigger$_(rf._$Behaviors$_._$Fade$_._$Cnds$_._$OnFadeInEnd$_)), 
            1 === this._$_stage$_ && this._$_stageTime$_._$Get$_() >= this._$_waitTime$_ && (this._$_stage$_ = 2, 
            this._$_stageTime$_._$Reset$_(), this._$DispatchScriptEvent$_("waitend"), 
            this._$Trigger$_(rf._$Behaviors$_._$Fade$_._$Cnds$_._$OnWaitEnd$_)), 
            2 === this._$_stage$_ && (0 !== this._$_fadeOutTime$_ ? (s._$SetOpacity$_(this._$_maxOpacity$_ - this._$_stageTime$_._$Get$_() / this._$_fadeOutTime$_ * this._$_maxOpacity$_), 
            this._$_runtime$_._$UpdateRender$_(), s._$GetOpacity$_() <= 0 && (this._$_stage$_ = 3, 
            this._$_stageTime$_._$Reset$_(), this._$DispatchScriptEvent$_("fadeoutend"), 
            this._$Trigger$_(rf._$Behaviors$_._$Fade$_._$Cnds$_._$OnFadeOutEnd$_), 
            this._$_destroy$_) && this._$_runtime$_._$DestroyInstance$_(this._$_inst$_)) : (this._$_stage$_ = 3, 
            this._$_stageTime$_._$Reset$_())), 3 === this._$_stage$_ && this._$_StopTicking$_();
        }
        _$_StartFade$_() {
            this._$_activeAtStart$_ || this._$_setMaxOpacity$_ || (this._$_maxOpacity$_ = this._$_inst$_._$GetWorldInfo$_()._$GetOpacity$_() || 1, 
            this._$_setMaxOpacity$_ = !0), 3 === this._$_stage$_ && this._$Start$_();
        }
        _$_RestartFade$_() {
            this._$Start$_();
        }
        _$Start$_() {
            this._$_stage$_ = 0, this._$_stageTime$_._$Reset$_(), 0 === this._$_fadeInTime$_ ? (this._$_stage$_ = 1, 
            0 === this._$_waitTime$_ && (this._$_stage$_ = 2)) : (this._$_inst$_._$GetWorldInfo$_()._$SetOpacity$_(0), 
            this._$_runtime$_._$UpdateRender$_()), this._$_StartTicking$_();
        }
        _$_SetFadeInTime$_(t) {
            this._$_fadeInTime$_ = Math.max(t, 0);
        }
        _$_GetFadeInTime$_() {
            return this._$_fadeInTime$_;
        }
        _$_SetWaitTime$_(t) {
            this._$_waitTime$_ = Math.max(t, 0);
        }
        _$_GetWaitTime$_() {
            return this._$_waitTime$_;
        }
        _$_SetFadeOutTime$_(t) {
            this._$_fadeOutTime$_ = Math.max(t, 0);
        }
        _$_GetFadeOutTime$_() {
            return this._$_fadeOutTime$_;
        }
        _$GetPropertyValueByIndex$_(t) {
            switch (t) {
              case 0:
                return this._$_GetFadeInTime$_();

              case 1:
                return this._$_GetWaitTime$_();

              case 2:
                return this._$_GetFadeOutTime$_();

              case 3:
                return this._$_destroy$_;
            }
        }
        _$SetPropertyValueByIndex$_(t, s) {
            switch (t) {
              case 0:
                this._$_SetFadeInTime$_(s);
                break;

              case 1:
                this._$_SetWaitTime$_(s);
                break;

              case 2:
                this._$_SetFadeOutTime$_(s);
                break;

              case 3:
                this._$_destroy$_ = !!s;
            }
        }
        _$GetDebuggerProperties$_() {
            const t = "behaviors.fade";
            return [ {
                title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                properties: [ {
                    name: t + ".properties.fade-in-time.name",
                    value: this._$_GetFadeInTime$_(),
                    _$onedit$_: t => this._$_SetFadeInTime$_(t)
                }, {
                    name: t + ".properties.wait-time.name",
                    value: this._$_GetWaitTime$_(),
                    _$onedit$_: t => this._$_SetWaitTime$_(t)
                }, {
                    name: t + ".properties.fade-out-time.name",
                    value: this._$_GetFadeOutTime$_(),
                    _$onedit$_: t => this._$_SetFadeOutTime$_(t)
                }, {
                    name: t + ".debugger.stage",
                    value: [ t + ".debugger." + [ "fade-in", "wait", "fade-out", "done" ][this._$_stage$_] ]
                } ]
            } ];
        }
        _$GetScriptInterfaceClass$_() {
            return self._$IFadeBehaviorInstance$_;
        }
    }, new WeakMap());
    self._$IFadeBehaviorInstance$_ = class extends of {
        constructor() {
            super(), af.set(this, of._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        _$startFade$_() {
            af.get(this)._$_StartFade$_();
        }
        _$restartFade$_() {
            af.get(this)._$_RestartFade$_();
        }
        set _$fadeInTime$_(t) {
            nf._$RequireFiniteNumber$_(t), af.get(this)._$_SetFadeInTime$_(t);
        }
        get _$fadeInTime$_() {
            return af.get(this)._$_GetFadeInTime$_();
        }
        set _$waitTime$_(t) {
            nf._$RequireFiniteNumber$_(t), af.get(this)._$_SetWaitTime$_(t);
        }
        get _$waitTime$_() {
            return af.get(this)._$_GetWaitTime$_();
        }
        set _$fadeOutTime$_(t) {
            nf._$RequireFiniteNumber$_(t), af.get(this)._$_SetFadeOutTime$_(t);
        }
        get _$fadeOutTime$_() {
            return af.get(this)._$_GetFadeOutTime$_();
        }
    };
}

{
    const lf = self._$C3$_;
    lf._$Behaviors$_._$Fade$_._$Cnds$_ = {
        _$OnFadeOutEnd$_() {
            return !0;
        },
        _$OnFadeInEnd$_() {
            return !0;
        },
        _$OnWaitEnd$_() {
            return !0;
        }
    };
}

{
    const uf = self._$C3$_;
    uf._$Behaviors$_._$Fade$_._$Acts$_ = {
        _$StartFade$_() {
            this._$_StartFade$_();
        },
        _$RestartFade$_() {
            this._$_RestartFade$_();
        },
        _$SetFadeInTime$_(t) {
            this._$_SetFadeInTime$_(t);
        },
        _$SetWaitTime$_(t) {
            this._$_SetWaitTime$_(t);
        },
        _$SetFadeOutTime$_(t) {
            this._$_SetFadeOutTime$_(t);
        }
    };
}

{
    const cf = self._$C3$_;
    cf._$Behaviors$_._$Fade$_._$Exps$_ = {
        _$FadeInTime$_() {
            return this._$_GetFadeInTime$_();
        },
        _$WaitTime$_() {
            return this._$_GetWaitTime$_();
        },
        _$FadeOutTime$_() {
            return this._$_GetFadeOutTime$_();
        }
    };
}

{
    const ff = self._$C3$_;
    ff._$Behaviors$_._$destroy$_ = class extends ff._$SDKBehaviorBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const df = self._$C3$_;
    df._$Behaviors$_._$destroy$_._$Type$_ = class extends df._$SDKBehaviorTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    const pf = self._$C3$_;
    pf._$Behaviors$_._$destroy$_.Instance = class extends pf._$SDKBehaviorInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_StartTicking$_();
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$Tick$_() {
            const t = this._$_inst$_._$GetWorldInfo$_(), s = t._$GetBoundingBox$_(), i = t._$GetLayout$_();
            (s._$getRight$_() < 0 || s._$getBottom$_() < 0 || s._$getLeft$_() > i._$GetWidth$_() || s._$getTop$_() > i._$GetHeight$_()) && this._$_runtime$_._$DestroyInstance$_(this._$_inst$_);
        }
    };
}

{
    const mf = self._$C3$_;
    mf._$Behaviors$_._$destroy$_._$Cnds$_ = {};
}

{
    const gf = self._$C3$_;
    gf._$Behaviors$_._$destroy$_._$Acts$_ = {};
}

{
    const yf = self._$C3$_;
    yf._$Behaviors$_._$destroy$_._$Exps$_ = {};
}

{
    const wf = self._$C3$_;
    wf._$Behaviors$_._$Bullet$_ = class extends wf._$SDKBehaviorBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const Sf = self._$C3$_;
    Sf._$Behaviors$_._$Bullet$_._$Type$_ = class extends Sf._$SDKBehaviorTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    const bf = self._$C3$_, Mf = self._$C3X$_, vf = self._$IBehaviorInstance$_, xf = (bf._$Behaviors$_._$Bullet$_.Instance = class extends bf._$SDKBehaviorInstanceBase$_ {
        constructor(t, s) {
            super(t);
            const i = this._$GetWorldInfo$_(), e = (this._$_speed$_ = 0, this._$_acc$_ = 0, 
            this._$_g$_ = 0, this._$_bounceOffSolid$_ = !1, this._$_setAngle$_ = !1, 
            this._$_isStepping$_ = !1, this._$_isEnabled$_ = !0, this._$_dx$_ = 0, 
            this._$_dy$_ = 0, this._$_lastX$_ = i._$GetX$_(), this._$_lastY$_ = i._$GetY$_(), 
            this._$_lastKnownAngle$_ = i._$GetAngle$_(), this._$_travelled$_ = 0, 
            this._$_stepSize$_ = Math.min(Math.abs(i._$GetWidth$_()), Math.abs(i._$GetHeight$_()) / 2), 
            this._$_stopStepping$_ = !1, s && (this._$_speed$_ = s[0], this._$_acc$_ = s[1], 
            this._$_g$_ = s[2], this._$_bounceOffSolid$_ = !!s[3], this._$_setAngle$_ = !!s[4], 
            this._$_isStepping$_ = !!s[5], this._$_isEnabled$_ = !!s[6]), i._$GetAngle$_());
            this._$_dx$_ = Math.cos(e) * this._$_speed$_, this._$_dy$_ = Math.sin(e) * this._$_speed$_, 
            this._$_isEnabled$_ && (this._$_StartTicking$_(), this._$_bounceOffSolid$_) && this._$_StartPostTicking$_();
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$SaveToJson$_() {
            const t = {
                dx: this._$_dx$_,
                dy: this._$_dy$_,
                lx: this._$_lastX$_,
                ly: this._$_lastY$_,
                lka: this._$_lastKnownAngle$_,
                t: this._$_travelled$_
            };
            return 0 !== this._$_acc$_ && (t.acc = this._$_acc$_), 0 !== this._$_g$_ && (t.g = this._$_g$_), 
            this._$_isStepping$_ && (t.st = this._$_isStepping$_), this._$_isEnabled$_ || (t.e = this._$_isEnabled$_), 
            this._$_bounceOffSolid$_ && (t.bos = this._$_bounceOffSolid$_), this._$_setAngle$_ && (t.sa = this._$_setAngle$_), 
            t;
        }
        _$LoadFromJson$_(t) {
            this._$_dx$_ = t.dx, this._$_dy$_ = t.dy, this._$_lastX$_ = t.lx, this._$_lastY$_ = t.ly, 
            this._$_lastKnownAngle$_ = t.lka, this._$_travelled$_ = t.t, this._$_acc$_ = t.hasOwnProperty("acc") ? t.acc : 0, 
            this._$_g$_ = t.hasOwnProperty("g") ? t.g : 0, this._$_isStepping$_ = !!t.hasOwnProperty("st") && t.st, 
            this._$_bounceOffSolid$_ = !!t.hasOwnProperty("bos") && t.bos, this._$_setAngle$_ = !!t.hasOwnProperty("sa") && t.sa, 
            this._$_SetEnabled$_(!t.hasOwnProperty("e") || t.e);
        }
        _$Tick$_() {
            if (this._$_isEnabled$_) {
                const h = this._$_runtime$_._$GetDt$_(this._$_inst$_), r = this._$_inst$_._$GetWorldInfo$_();
                if (r._$GetAngle$_() !== this._$_lastKnownAngle$_) {
                    const t = r._$GetAngle$_();
                    if (this._$_setAngle$_) {
                        const s = bf._$distanceTo$_(0, 0, this._$_dx$_, this._$_dy$_);
                        this._$_dx$_ = Math.cos(t) * s, this._$_dy$_ = Math.sin(t) * s;
                    }
                    this._$_lastKnownAngle$_ = t;
                }
                let i = 0, e = 0;
                if (0 !== this._$_acc$_) {
                    let t = bf._$distanceTo$_(0, 0, this._$_dx$_, this._$_dy$_), s = 0;
                    s = 0 === this._$_dx$_ && 0 === this._$_dy$_ ? r._$GetAngle$_() : bf._$angleTo$_(0, 0, this._$_dx$_, this._$_dy$_), 
                    t += this._$_acc$_ * h, i = Math.cos(s) * this._$_acc$_, e = Math.sin(s) * this._$_acc$_, 
                    t < 0 && (t = 0, i = 0, e = 0), this._$_dx$_ = Math.cos(s) * t, 
                    this._$_dy$_ = Math.sin(s) * t;
                }
                if (0 !== this._$_g$_ && (this._$_dy$_ += this._$_g$_ * h, e += this._$_g$_), 
                this._$_lastX$_ = r._$GetX$_(), this._$_lastY$_ = r._$GetY$_(), 
                0 !== this._$_dx$_ || 0 !== this._$_dy$_) {
                    const n = this._$_dx$_ * h + .5 * i * h * h, o = this._$_dy$_ * h + .5 * e * h * h, a = bf._$distanceTo$_(0, 0, n, o);
                    if (this._$_MoveBy$_(n, o, a), this._$_travelled$_ += a, this._$_setAngle$_ && (0 != n || 0 != o)) {
                        const l = bf._$angleTo$_(0, 0, n, o);
                        r._$SetAngle$_(l), this._$_lastKnownAngle$_ = r._$GetAngle$_();
                    }
                    r._$SetBboxChanged$_();
                }
            }
        }
        _$_MoveBy$_(t, s, i) {
            const e = this._$GetWorldInfo$_();
            if (!this._$_isStepping$_ || i <= this._$_stepSize$_) e._$OffsetXY$_(t, s), 
            e._$SetBboxChanged$_(), this._$_isStepping$_ && this._$Trigger$_(bf._$Behaviors$_._$Bullet$_._$Cnds$_._$OnStep$_); else {
                this._$_stopStepping$_ = !1;
                const h = e._$GetX$_(), r = e._$GetY$_(), n = h + t, o = r + s, a = bf._$angleTo$_(0, 0, t, s), l = Math.cos(a) * this._$_stepSize$_, u = Math.sin(a) * this._$_stepSize$_, c = Math.floor(i / this._$_stepSize$_);
                for (let t = 1; t <= c; ++t) if (e._$SetXY$_(h + l * t, r + u * t), 
                e._$SetBboxChanged$_(), this._$Trigger$_(bf._$Behaviors$_._$Bullet$_._$Cnds$_._$OnStep$_), 
                this._$_inst$_._$IsDestroyed$_() || this._$_stopStepping$_) return;
                e._$SetXY$_(n, o), e._$SetBboxChanged$_(), this._$Trigger$_(bf._$Behaviors$_._$Bullet$_._$Cnds$_._$OnStep$_);
            }
        }
        _$PostTick$_() {
            if (this._$_isEnabled$_ && this._$_bounceOffSolid$_ && (0 !== this._$_dx$_ || 0 !== this._$_dy$_)) {
                const t = this._$_runtime$_._$GetDt$_(this._$_inst$_), s = this._$_inst$_._$GetWorldInfo$_(), i = this._$_runtime$_._$GetCollisionEngine$_(), e = i._$TestOverlapSolid$_(this._$_inst$_);
                if (e) {
                    i._$RegisterCollision$_(this._$_inst$_, e);
                    const h = bf._$distanceTo$_(0, 0, this._$_dx$_, this._$_dy$_), r = i._$CalculateBounceAngle$_(this._$_inst$_, this._$_lastX$_, this._$_lastY$_);
                    this._$_dx$_ = Math.cos(r) * h, this._$_dy$_ = Math.sin(r) * h, 
                    s._$OffsetXY$_(this._$_dx$_ * t, this._$_dy$_ * t), s._$SetBboxChanged$_(), 
                    this._$_setAngle$_ && (s._$SetAngle$_(r), this._$_lastKnownAngle$_ = s._$GetAngle$_(), 
                    s._$SetBboxChanged$_()), i._$PushOutSolid$_(this._$_inst$_, this._$_dx$_ / h, this._$_dy$_ / h, Math.max(2.5 * h * t, 30)) || i._$PushOutSolidNearest$_(this._$_inst$_, 100);
                }
            }
        }
        _$GetPropertyValueByIndex$_(t) {
            switch (t) {
              case 0:
                return this._$_GetSpeed$_();

              case 1:
                return this._$_GetAcceleration$_();

              case 2:
                return this._$_GetGravity$_();

              case 4:
                return this._$_setAngle$_;

              case 5:
                return this._$_isStepping$_;

              case 6:
                return this._$_IsEnabled$_();
            }
        }
        _$SetPropertyValueByIndex$_(t, s) {
            switch (t) {
              case 0:
                this._$_SetSpeed$_(s);
                break;

              case 1:
                this._$_acc$_ = s;
                break;

              case 2:
                this._$_g$_ = s;
                break;

              case 4:
                this._$_setAngle$_ = !!s;
                break;

              case 5:
                this._$_isStepping$_ = !!s;
                break;

              case 6:
                this._$_SetEnabled$_(!!s);
            }
        }
        _$_SetSpeed$_(t) {
            const s = bf._$angleTo$_(0, 0, this._$_dx$_, this._$_dy$_);
            this._$_dx$_ = Math.cos(s) * t, this._$_dy$_ = Math.sin(s) * t;
        }
        _$_GetSpeed$_() {
            return bf._$roundToDp$_(bf._$distanceTo$_(0, 0, this._$_dx$_, this._$_dy$_), 6);
        }
        _$_SetAcceleration$_(t) {
            this._$_acc$_ = t;
        }
        _$_GetAcceleration$_() {
            return this._$_acc$_;
        }
        _$_SetGravity$_(t) {
            this._$_g$_ = t;
        }
        _$_GetGravity$_() {
            return this._$_g$_;
        }
        _$_SetAngleOfMotion$_(t) {
            const s = bf._$distanceTo$_(0, 0, this._$_dx$_, this._$_dy$_);
            this._$_dx$_ = Math.cos(t) * s, this._$_dy$_ = Math.sin(t) * s;
        }
        _$_GetAngleOfMotion$_() {
            return bf._$angleTo$_(0, 0, this._$_dx$_, this._$_dy$_);
        }
        _$_SetBounceOffSolids$_(t) {
            this._$_bounceOffSolid$_ !== (t = !!t) && (this._$_bounceOffSolid$_ = t, 
            this._$_isEnabled$_) && (this._$_bounceOffSolid$_ ? this._$_StartPostTicking$_() : this._$_StopPostTicking$_());
        }
        _$_IsBounceOffSolids$_() {
            return this._$_bounceOffSolid$_;
        }
        _$_SetDistanceTravelled$_(t) {
            this._$_travelled$_ = t;
        }
        _$_GetDistanceTravelled$_() {
            return this._$_travelled$_;
        }
        _$_SetEnabled$_(t) {
            this._$_isEnabled$_ = !!t, this._$_isEnabled$_ ? (this._$_StartTicking$_(), 
            this._$_bounceOffSolid$_ && this._$_StartPostTicking$_()) : (this._$_StopTicking$_(), 
            this._$_StopPostTicking$_());
        }
        _$_IsEnabled$_() {
            return this._$_isEnabled$_;
        }
        _$GetDebuggerProperties$_() {
            const t = "behaviors.bullet";
            return [ {
                title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                properties: [ {
                    name: t + ".debugger.vector-x",
                    value: this._$_dx$_,
                    _$onedit$_: t => this._$_dx$_ = t
                }, {
                    name: t + ".debugger.vector-y",
                    value: this._$_dy$_,
                    _$onedit$_: t => this._$_dy$_ = t
                }, {
                    name: t + ".properties.speed.name",
                    value: this._$_GetSpeed$_(),
                    _$onedit$_: t => this._$_SetSpeed$_(t)
                }, {
                    name: t + ".debugger.angle-of-motion",
                    value: bf._$toDegrees$_(this._$_GetAngleOfMotion$_())
                }, {
                    name: t + ".properties.gravity.name",
                    value: this._$_GetGravity$_(),
                    _$onedit$_: t => this._$_SetGravity$_(t)
                }, {
                    name: t + ".properties.acceleration.name",
                    value: this._$_GetAcceleration$_(),
                    _$onedit$_: t => this._$_SetAcceleration$_(t)
                }, {
                    name: t + ".debugger.distance-travelled",
                    value: this._$_GetDistanceTravelled$_()
                }, {
                    name: t + ".properties.enabled.name",
                    value: this._$_IsEnabled$_(),
                    _$onedit$_: t => this._$_SetEnabled$_(t)
                } ]
            } ];
        }
        _$GetScriptInterfaceClass$_() {
            return self._$IBulletBehaviorInstance$_;
        }
    }, new WeakMap());
    self._$IBulletBehaviorInstance$_ = class extends vf {
        constructor() {
            super(), xf.set(this, vf._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        get speed() {
            return xf.get(this)._$_GetSpeed$_();
        }
        set speed(t) {
            Mf._$RequireFiniteNumber$_(t), xf.get(this)._$_SetSpeed$_(t);
        }
        get acceleration() {
            return xf.get(this)._$_GetAcceleration$_();
        }
        set acceleration(t) {
            Mf._$RequireFiniteNumber$_(t), xf.get(this)._$_SetAcceleration$_(t);
        }
        get _$gravity$_() {
            return xf.get(this)._$_GetGravity$_();
        }
        set _$gravity$_(t) {
            Mf._$RequireFiniteNumber$_(t), xf.get(this)._$_SetGravity$_(t);
        }
        get _$angleOfMotion$_() {
            return xf.get(this)._$_GetAngleOfMotion$_();
        }
        set _$angleOfMotion$_(t) {
            Mf._$RequireFiniteNumber$_(t), xf.get(this)._$_SetAngleOfMotion$_(t);
        }
        get _$bounceOffSolids$_() {
            return xf.get(this)._$_IsBounceOffSolids$_();
        }
        set _$bounceOffSolids$_(t) {
            xf.get(this)._$_SetBounceOffSolids$_(!!t);
        }
        get _$distanceTravelled$_() {
            return xf.get(this)._$_GetDistanceTravelled$_();
        }
        set _$distanceTravelled$_(t) {
            Mf._$RequireFiniteNumber$_(t), xf.get(this)._$_SetDistanceTravelled$_(t);
        }
        get isEnabled() {
            return xf.get(this)._$_IsEnabled$_();
        }
        set isEnabled(t) {
            xf.get(this)._$_SetEnabled$_(t);
        }
    };
}

{
    const Gf = self._$C3$_;
    Gf._$Behaviors$_._$Bullet$_._$Cnds$_ = {
        _$CompareSpeed$_(t, s) {
            const i = Math.hypot(this._$_dx$_, this._$_dy$_);
            return Gf.compare(i, t, s);
        },
        _$CompareTravelled$_(t, s) {
            return Gf.compare(this._$_GetDistanceTravelled$_(), t, s);
        },
        _$OnStep$_() {
            return !0;
        },
        _$IsEnabled$_() {
            return this._$_IsEnabled$_();
        }
    };
}

{
    const Tf = self._$C3$_;
    Tf._$Behaviors$_._$Bullet$_._$Acts$_ = {
        _$SetSpeed$_(t) {
            this._$_SetSpeed$_(t);
        },
        _$SetAcceleration$_(t) {
            this._$_SetAcceleration$_(t);
        },
        _$SetGravity$_(t) {
            this._$_SetGravity$_(t);
        },
        _$SetAngleOfMotion$_(t) {
            this._$_SetAngleOfMotion$_(Tf._$toRadians$_(t));
        },
        _$Bounce$_(t) {
            if (t) {
                const s = t._$GetFirstPicked$_(this._$_inst$_);
                if (s) {
                    const i = this._$_inst$_._$GetWorldInfo$_(), e = this._$_runtime$_._$GetCollisionEngine$_(), h = this._$_runtime$_._$GetDt$_(this._$_inst$_), r = Tf._$distanceTo$_(0, 0, this._$_dx$_, this._$_dy$_), n = e._$CalculateBounceAngle$_(this._$_inst$_, this._$_lastX$_, this._$_lastY$_, s);
                    this._$_dx$_ = Math.cos(n) * r, this._$_dy$_ = Math.sin(n) * r, 
                    i._$OffsetXY$_(this._$_dx$_ * h, this._$_dy$_ * h), i._$SetBboxChanged$_(), 
                    this._$_setAngle$_ && (i._$SetAngle$_(n), this._$_lastKnownAngle$_ = i._$GetAngle$_(), 
                    i._$SetBboxChanged$_()), 0 !== r && (this._$_bounceOffSolid$_ ? e._$PushOutSolid$_(this._$_inst$_, this._$_dx$_ / r, this._$_dy$_ / r, Math.max(2.5 * r * h, 30)) || e._$PushOutSolidNearest$_(this._$_inst$_, 100) : e._$PushOut$_(this._$_inst$_, this._$_dx$_ / r, this._$_dy$_ / r, Math.max(2.5 * r * h, 30), s));
                }
            }
        },
        _$SetBounceOffSolids$_(t) {
            this._$_SetBounceOffSolids$_(t);
        },
        _$SetDistanceTravelled$_(t) {
            this._$_SetDistanceTravelled$_(t);
        },
        _$SetEnabled$_(t) {
            this._$_SetEnabled$_(t);
        },
        _$StopStepping$_() {
            this._$_stopStepping$_ = !0;
        }
    };
}

{
    const _f = self._$C3$_;
    _f._$Behaviors$_._$Bullet$_._$Exps$_ = {
        _$Speed$_() {
            return this._$_GetSpeed$_();
        },
        _$Acceleration$_() {
            return this._$_GetAcceleration$_();
        },
        _$AngleOfMotion$_() {
            return _f._$toDegrees$_(this._$_GetAngleOfMotion$_());
        },
        _$DistanceTravelled$_() {
            return this._$_GetDistanceTravelled$_();
        },
        _$Gravity$_() {
            return this._$_GetGravity$_();
        }
    };
}

{
    const If = self._$C3$_;
    If._$Behaviors$_._$Tween$_ = class extends If._$SDKBehaviorBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const Cf = self._$C3$_;
    Cf._$Behaviors$_._$Tween$_._$Type$_ = class extends Cf._$SDKBehaviorTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    const Rf = self._$C3$_, Pf = Rf._$Behaviors$_._$Tween$_;
    Pf.Instance = class extends Rf._$SDKBehaviorInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_allowMultiple$_ = !1, this._$_enabled$_ = !0, s && (this._$_allowMultiple$_ = !1, 
            this._$_enabled$_ = !!s[0]), this._$_activeTweens$_ = new Map(), this._$_disabledTweens$_ = [], 
            this._$_waitingForReleaseTweens$_ = new Map(), this._$_finishingTween$_ = null, 
            this._$_activeTweensJson$_ = null, this._$_disabledTweensJson$_ = null, 
            this._$_waitingForReleaseTweensJson$_ = null, this._$_finishingTweenName$_ = "", 
            this._$_triggerTweens$_ = [], this._$_afterLoad$_ = t => this._$_OnAfterLoad$_(), 
            this._$GetRuntime$_()._$Dispatcher$_().addEventListener("afterload", this._$_afterLoad$_);
        }
        _$Release$_() {
            this._$GetRuntime$_()._$Dispatcher$_().removeEventListener("afterload", this._$_afterLoad$_), 
            this._$_afterLoad$_ = null, this._$_finishingTween$_ && (this._$ReleaseAndCompleteTween$_(this._$_finishingTween$_), 
            this._$_finishingTween$_ = null), this._$ReleaseAndCompleteTweens$_(), 
            this._$_tweens$_ = null, this._$ClearDisabledList$_(), this._$_disabledTweens$_ = null, 
            this._$_ReleaseWaitingTweens$_(), this._$_waitingForReleaseTweens$_ = null, 
            this._$_triggerTweens$_ = null, super._$Release$_();
        }
        _$PushTriggerTween$_(t) {
            this._$_triggerTweens$_.push(t);
        }
        _$PopTriggerTween$_() {
            this._$_triggerTweens$_.pop();
        }
        _$GetTriggerTween$_() {
            return this._$_triggerTweens$_[this._$_triggerTweens$_.length - 1];
        }
        _$SetEnabled$_(t) {
            this._$_enabled$_ = !!t, t ? this._$_waitingForReleaseTweens$_ && this._$_waitingForReleaseTweens$_.size && this._$_StartTicking2$_() : this._$_StopTicking2$_();
            for (const s of this._$AllTweens$_()) t ? this._$IsInDisabledList$_(s) && s._$Resume$_() : ((s.IsPlaying() || s._$IsScheduled$_()) && this._$AddToDisabledList$_(s), 
            s._$Stop$_());
            t && this._$ClearDisabledList$_();
        }
        _$IsEnabled$_() {
            return this._$_enabled$_;
        }
        _$AddToDisabledList$_(t) {
            this._$_disabledTweens$_.push(t);
        }
        _$IsInDisabledList$_(t) {
            return this._$_disabledTweens$_.includes(t);
        }
        _$ClearDisabledList$_() {
            Rf._$clearArray$_(this._$_disabledTweens$_);
        }
        _$GetFinishingTween$_() {
            return this._$_finishingTween$_;
        }
        _$IsInstanceValid$_() {
            const t = this._$GetObjectInstance$_();
            return !!t && !t._$IsDestroyed$_();
        }
        _$GetTween$_(t, s, i = !1) {
            const e = s ? this._$PropertyTweens$_(s, i) : this._$AllTweens$_(i);
            if (e && e.length) for (const h of e) if (h._$HasTags$_(t)) return h;
        }
        _$CheckTweensWithTags$_(t, s) {
            for (const i of this._$_activeTweens$_.values()) for (const e of i) if (!e._$IsReleased$_() && e._$HasTags$_(t) && s(e)) return !0;
            for (const h of this._$_waitingForReleaseTweens$_.values()) for (const r of h) if (!r._$IsReleased$_() && r._$HasTags$_(t) && s(r)) return !0;
            return !1;
        }
        _$CheckTweens$_(t) {
            for (const s of this._$_activeTweens$_.values()) for (const i of s) if (!i._$IsReleased$_() && t(i)) return !0;
            for (const e of this._$_waitingForReleaseTweens$_.values()) for (const h of e) if (!h._$IsReleased$_() && t(h)) return !0;
            return !1;
        }
        _$GetTweenIncludingWaitingForRelease$_(t, s) {
            return this._$GetTween$_(t, s, !0);
        }
        *_$GetTweens$_(t, s, i = !1) {
            const e = s ? this._$PropertyTweens$_(s, i) : this._$AllTweens$_(i);
            if (e && e.length) for (const h of e) h._$HasTags$_(t) && (yield h);
        }
        *_$GetTweensIncludingWaitingForRelease$_(t, s) {
            yield* this._$GetTweens$_(t, s, !0);
        }
        _$PropertyTweens$_(i, t) {
            if (t) {
                let t = this._$_activeTweens$_.get(i), s = this._$_waitingForReleaseTweens$_.get(i);
                return t = t || [], s = s || [], t.concat(s).filter(t => t).filter(t => !t._$IsReleased$_());
            }
            {
                let t = this._$_activeTweens$_.get(i);
                return (t = t || []).filter(t => t).filter(t => !t._$IsReleased$_());
            }
        }
        _$AllTweens$_(t) {
            if (t) {
                const s = [ ...this._$_activeTweens$_.values() ].flat(), i = [ ...this._$_waitingForReleaseTweens$_.values() ].flat();
                return s.concat(i).filter(t => t).filter(t => !t._$IsReleased$_());
            }
            {
                const e = [ ...this._$_activeTweens$_.values() ].flat();
                return e.filter(t => t).filter(t => !t._$IsReleased$_());
            }
        }
        _$AllTweensIncludingWaitingForRelease$_() {
            return this._$AllTweens$_(!0);
        }
        _$SaveToJson$_(t = 0) {
            return {
                s: !1,
                e: !!this._$_enabled$_,
                at: this._$_SaveActiveTweensToJson$_(),
                dt: this._$_SaveDisabledTweensToJson$_(),
                wt: this._$_SaveWaitingForReleaseTweensToJson$_(),
                ft: this._$_SaveFinishingTweenToJson$_()
            };
        }
        _$LoadFromJson$_(t, s = "full") {
            t && (this._$_activeTweensJson$_ = t.at, this._$_disabledTweensJson$_ = t.dt, 
            this._$_waitingForReleaseTweensJson$_ = t.wt, this._$_finishingTweenName$_ = t.ft, 
            this._$_allowMultiple$_ = !1, this._$_enabled$_ = !!t.e, "state" === s) && this._$_OnAfterLoad$_();
        }
        _$_OnAfterLoad$_() {
            const t = this._$GetRuntime$_()._$GetTimelineManager$_();
            if (this._$_PopulateTweenMap$_(this._$_activeTweensJson$_, this._$_activeTweens$_, t), 
            this._$_disabledTweensJson$_) {
                Rf._$clearArray$_(this._$_disabledTweens$_);
                for (const s of this._$_disabledTweensJson$_) this._$_PopulateTweenArray$_(this._$_disabledTweens$_, s, t);
            }
            this._$_PopulateTweenMap$_(this._$_waitingForReleaseTweensJson$_, this._$_waitingForReleaseTweens$_, t), 
            this._$_finishingTween$_ = this._$_GetTween$_(this._$_finishingTweenName$_, t), 
            this._$_enabled$_ ? this._$_waitingForReleaseTweens$_ && this._$_waitingForReleaseTweens$_.size && this._$_StartTicking2$_() : this._$_StopTicking2$_();
        }
        _$_PopulateTweenMap$_(s, i, e) {
            if (s) for (const h in s) {
                let t = i.get(h);
                t ? Rf._$clearArray$_(t) : t = [];
                const r = s[h];
                for (const n of r) {
                    const o = this._$_PopulateTweenArray$_(t, n.name, e);
                    if (o) this._$_LoadTweenFromJson$_(n.name, n, e); else {
                        const a = Rf._$TweenState$_._$Build$_({
                            runtime: this._$GetRuntime$_(),
                            json: n
                        });
                        Rf._$TweenState$_._$SetInstanceUID$_(a, this._$GetObjectInstance$_()._$GetUID$_()), 
                        a._$AddCompletedCallback$_(t => this._$_FinishTriggers$_(t)), 
                        e._$AddScheduledTimeline$_(a), this._$_PopulateTweenArray$_(t, a, e);
                    }
                }
                i.set(h, t);
            }
        }
        _$_GetTween$_(t, s) {
            return s._$GetScheduledOrPlayingTimelineByName$_(t);
        }
        _$_PopulateTweenArray$_(t, s, i) {
            if ("string" != typeof s) return !!t.push(s);
            {
                const e = this._$_GetTween$_(s, i);
                if (e) return !!t.push(e);
            }
            return !1;
        }
        _$_LoadTweenFromJson$_(t, s, i) {
            if ("string" == typeof t) {
                const e = this._$_GetTween$_(t, i);
                e && (e._$_LoadFromJson$_(s), Rf._$TweenState$_._$SetInstanceUID$_(e, this._$GetObjectInstance$_()._$GetUID$_()));
            } else t._$_LoadFromJson$_(s), Rf._$TweenState$_._$SetInstanceUID$_(t, this._$GetObjectInstance$_()._$GetUID$_());
        }
        _$_SaveActiveTweensToJson$_() {
            const t = {};
            for (const [ s, i ] of this._$_activeTweens$_) t[s] = i.filter(t => !t._$IsReleased$_()).map(t => t._$_SaveToJson$_());
            return t;
        }
        _$_SaveDisabledTweensToJson$_() {
            return this._$_disabledTweens$_.filter(t => !t._$IsReleased$_()).map(t => t._$GetName$_());
        }
        _$_SaveWaitingForReleaseTweensToJson$_() {
            const t = {};
            for (const [ s, i ] of this._$_waitingForReleaseTweens$_) t[s] = i.map(t => t._$_SaveToJson$_());
            return t;
        }
        _$_SaveFinishingTweenToJson$_() {
            return this._$_finishingTween$_ ? this._$_finishingTween$_._$GetName$_() : "";
        }
        _$Tick2$_() {
            this._$_ReleaseWaitingTweens$_();
        }
        _$CreateTween$_(t) {
            const s = Pf._$Config$_._$GetPropertyTracksConfig$_(t.property, t._$startValue$_, t._$endValue$_, t.ease, t.resultMode, this._$GetObjectInstance$_()), i = Pf._$Maps$_._$GetPropertyFromIndex$_(t.property), e = (Pf._$Maps$_._$IsValueId$_(i) || this._$ReleaseTweens$_(t.property), 
            Rf._$TweenState$_._$Build$_({
                runtime: this._$GetRuntime$_(),
                id: i,
                tags: t.tags,
                time: t.time,
                _$instance$_: this._$GetObjectInstance$_(),
                _$releaseOnComplete$_: !!t._$releaseOnComplete$_,
                loop: !!t.loop,
                pingPong: !!t.pingPong,
                repeatCount: t.repeatCount,
                initialValueMode: t.initialValueMode,
                _$propertyTracksConfig$_: s
            }));
            return e._$AddCompletedCallback$_(t => this._$_FinishTriggers$_(t)), 
            this._$_AddTween$_(e, t.property), e;
        }
        _$_MaybeRemoveFromActiveTweenMap$_(t) {
            const s = t._$GetId$_();
            if (this._$_activeTweens$_.has(s)) {
                const i = this._$_activeTweens$_.get(s);
                if (i) {
                    const e = i.indexOf(t);
                    -1 !== e && i.splice(e, 1);
                }
            }
        }
        _$ReleaseTween$_(t, s = !1) {
            this._$_MaybeRemoveFromActiveTweenMap$_(t), t._$IsReleased$_() || this._$_IsInWaitingList$_(t) || (t._$Stop$_(s), 
            this._$_AddToWaitingList$_(t));
        }
        _$ReleaseTweens$_(t, s = !1) {
            if (Rf._$IsFiniteNumber$_(t)) {
                const i = Pf._$Maps$_._$GetPropertyFromIndex$_(t);
                if (this._$_activeTweens$_.has(i)) {
                    const e = this._$_activeTweens$_.get(i), h = this._$GetFinishingTween$_();
                    for (const r of e) r === h || r._$IsReleased$_() || this._$_IsInWaitingList$_(r) || (r._$Stop$_(s), 
                    r._$Release$_());
                    Rf._$clearArray$_(e);
                }
            } else {
                const n = this._$GetFinishingTween$_();
                for (const o of this._$AllTweens$_()) o === n || o._$IsReleased$_() || this._$_IsInWaitingList$_(o) || (o._$Stop$_(s), 
                o._$Release$_());
                for (const a of this._$_activeTweens$_.keys()) Rf._$clearArray$_(this._$_activeTweens$_.get(a)), 
                this._$_activeTweens$_.delete(a);
                this._$_activeTweens$_.clear();
            }
        }
        _$ReleaseAndCompleteTween$_(t) {
            this._$ReleaseTween$_(t, !0);
        }
        _$ReleaseAndCompleteTweens$_() {
            this._$ReleaseTweens$_(NaN, !0);
        }
        _$GetPropertyValueByIndex$_(t) {
            if (0 === t) return this._$_enabled$_;
        }
        _$SetPropertyValueByIndex$_(t, s) {
            0 === t && (this._$_enabled$_ = !!s);
        }
        _$_GetBehaviorType$_(t) {
            const s = t._$GetInstance$_(), i = s._$GetBehaviorInstances$_();
            for (const e of i) {
                const h = e._$GetBehaviorType$_();
                if (h._$GetInstanceSdkCtor$_() === this.constructor) return h;
            }
        }
        _$Trigger$_(t, s, i, e) {
            return this._$_runtime$_ ? super._$Trigger$_(t) : s._$Trigger$_(t, i, e);
        }
        _$_FinishTriggers$_(t) {
            this._$_finishingTween$_ = t, Pf._$Cnds$_._$SetFinishingTween$_(t);
            let s, i;
            if (this._$GetRuntime$_()) s = this._$_inst$_, i = this._$_runtime$_, 
            this._$Trigger$_(Pf._$Cnds$_._$OnTweensFinished$_), this._$Trigger$_(Pf._$Cnds$_._$OnAnyTweensFinished$_), 
            this._$ReleaseTween$_(t); else {
                if (!(s = t._$GetInstance$_())) return;
                if (s && s._$IsDestroyed$_()) return;
                i = s._$GetRuntime$_();
                const e = this._$_GetBehaviorType$_(t);
                this._$Trigger$_(Pf._$Cnds$_._$OnTweensFinished$_, i, s, e), this._$Trigger$_(Pf._$Cnds$_._$OnAnyTweensFinished$_, i, s, e), 
                t._$Stop$_();
            }
            this._$_finishingTween$_ = null, Pf._$Cnds$_._$SetFinishingTween$_(null), 
            t._$GetDestroyInstanceOnComplete$_() && i._$DestroyInstance$_(s);
        }
        _$_AddTween$_(t, s) {
            const i = Pf._$Maps$_._$GetPropertyFromIndex$_(s), e = (this._$_activeTweens$_.has(i) || this._$_activeTweens$_.set(i, []), 
            this._$_activeTweens$_.get(i));
            e.push(t);
        }
        _$_AddToWaitingList$_(t) {
            const s = t._$GetId$_();
            this._$_waitingForReleaseTweens$_.has(s) || this._$_waitingForReleaseTweens$_.set(s, []), 
            this._$_waitingForReleaseTweens$_.get(s).push(t), this._$IsTicking2$_() || this._$_StartTicking2$_();
        }
        _$_IsInWaitingList$_(t) {
            const s = t._$GetId$_();
            return !!this._$_waitingForReleaseTweens$_.has(s) && this._$_waitingForReleaseTweens$_.get(s).includes(t);
        }
        _$_ReleaseWaitingTweens$_() {
            if (this._$_waitingForReleaseTweens$_.size) {
                for (const t of this._$_waitingForReleaseTweens$_.values()) {
                    for (const s of t) s._$IsReleased$_() || s._$Release$_();
                    Rf._$clearArray$_(t);
                }
                this._$_waitingForReleaseTweens$_.clear(), this._$IsTicking2$_() && this._$_StopTicking2$_();
            }
        }
        _$GetDebuggerProperties$_() {
            return [ {
                title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                properties: [ {
                    name: "behaviors.tween.properties.enabled.name",
                    value: this._$IsEnabled$_(),
                    _$onedit$_: t => this._$SetEnabled$_(t)
                } ]
            } ];
        }
        _$GetScriptInterfaceClass$_() {
            return self._$ITweenBehaviorInstance$_;
        }
    };
}

{
    let i = self._$C3$_, s = null;
    i._$Behaviors$_._$Tween$_._$Cnds$_ = {
        _$OnAnyTweenLoop$_() {
            return !0;
        },
        _$OnTweensLoop$_(t) {
            const s = this._$GetTriggerTween$_();
            return !!s && s._$HasTags$_(t);
        },
        _$OnAnyTweenPingPong$_(t) {
            const s = this._$GetTriggerTween$_();
            return !!s && (s._$GetPingPongState$_() === t || 2 === t);
        },
        _$OnTweensPingPong$_(t, s) {
            const i = this._$GetTriggerTween$_();
            return !!i && (i._$GetPingPongState$_() === s || 2 === s) && i._$HasTags$_(t);
        },
        _$SetFinishingTween$_(t) {
            s = t;
        },
        _$OnTweensFinished$_(t) {
            return s._$HasTags$_(t);
        },
        _$OnAnyTweensFinished$_() {
            return !0;
        },
        IsPlaying(t) {
            return this._$CheckTweensWithTags$_(t, i._$TweenState$_.IsPlaying);
        },
        _$IsAnyPlaying$_() {
            return this._$CheckTweens$_(i._$TweenState$_.IsPlaying);
        },
        _$IsPaused$_(t) {
            return this._$CheckTweensWithTags$_(t, i._$TweenState$_._$IsPaused$_);
        },
        _$IsAnyPaused$_() {
            return this._$CheckTweens$_(i._$TweenState$_._$IsPaused$_);
        },
        _$IsPingPong$_(t, s) {
            return 0 === s ? this._$CheckTweensWithTags$_(t, i._$TweenState$_._$IsPing$_) : 1 === s && this._$CheckTweensWithTags$_(t, i._$TweenState$_._$IsPong$_);
        },
        _$IsAnyPingPong$_(t) {
            return 0 === t ? this._$CheckTweens$_(i._$TweenState$_._$IsPing$_) : 1 === t && this._$CheckTweens$_(i._$TweenState$_._$IsPong$_);
        }
    };
}

{
    const Ef = self._$C3$_, Af = self._$Ease$_, Ff = Ef._$Behaviors$_._$Tween$_;
    Ff._$Acts$_ = {
        _$SetEnabled$_(t) {
            this._$SetEnabled$_(!!t);
        },
        async _$TweenOneProperty$_(...t) {
            if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) {
                const s = this._$CreateTween$_(Ff._$TweenArguments$_._$OneProperty$_(this, ...t));
                s.Play() && await s._$GetPlayPromise$_();
            }
        },
        async _$TweenTwoProperties$_(...t) {
            if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) {
                const s = this._$CreateTween$_(Ff._$TweenArguments$_._$TwoProperties$_(this, ...t));
                s.Play() && await s._$GetPlayPromise$_();
            }
        },
        async _$TweenValue$_(...t) {
            if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) {
                const s = this._$CreateTween$_(Ff._$TweenArguments$_._$ValueProperty$_(this, ...t));
                s.Play() && await s._$GetPlayPromise$_();
            }
        },
        _$PauseTweens$_(t) {
            if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const s of this._$GetTweens$_(t)) s._$Stop$_();
        },
        _$PauseAllTweens$_() {
            if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const t of this._$AllTweens$_()) t._$Stop$_();
        },
        _$ResumeTweens$_(t) {
            if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const s of this._$GetTweens$_(t)) s._$Resume$_();
        },
        _$ResumeAllTweens$_() {
            if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const t of this._$AllTweens$_()) t._$Resume$_();
        },
        _$StopTweens$_(t) {
            if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const s of this._$GetTweens$_(t)) this._$ReleaseTween$_(s);
        },
        _$StopAllTweens$_() {
            if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const t of this._$AllTweens$_()) this._$ReleaseTween$_(t);
        },
        _$SetOnePropertyTweensEndValue$_(t, s, i) {
            if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) {
                const e = Ef._$Behaviors$_._$Tween$_._$Maps$_._$GetSinglePropertyFromIndex$_(s);
                for (const h of this._$GetTweens$_(t)) h._$BeforeSetEndValues$_([ e ]), 
                h._$SetEndValue$_(i, e);
            }
        },
        _$SetTwoPropertiesTweensEndValue$_(t, s, i, e) {
            if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) {
                const h = Ef._$Behaviors$_._$Tween$_._$Maps$_._$GetRealProperties$_(s);
                for (const r of this._$GetTweens$_(t)) r._$BeforeSetEndValues$_(h), 
                r._$SetEndValue$_(i, h[0]), r._$SetEndValue$_(e, h[1]);
            }
        },
        _$SetValuePropertyTweensStartValue$_(t, s) {
            if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const i of this._$GetTweens$_(t, "value")) i._$SetStartValue$_(s, "value");
        },
        _$SetValuePropertyTweensEndValue$_(t, s) {
            if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const i of this._$GetTweens$_(t, "value")) i._$BeforeSetEndValues$_([ "value" ]), 
            i._$SetEndValue$_(s, "value");
        },
        _$SetTweensEase$_(t, s) {
            if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) {
                const i = Af._$GetEaseFromIndex$_(s);
                for (const e of this._$GetTweens$_(t)) e._$SetEase$_(i);
            }
        },
        _$SetAllTweensEase$_(t) {
            if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) {
                const s = Af._$GetEaseFromIndex$_(t);
                for (const i of this._$AllTweens$_()) i._$SetEase$_(s);
            }
        },
        _$SetTweensTime$_(t, s) {
            if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const i of this._$GetTweens$_(t)) i._$SetTime$_(s);
        },
        _$SetAllTweensTime$_(t) {
            if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const s of this._$AllTweens$_()) s._$SetTime$_(t);
        },
        _$SetTweensPlaybackRate$_(t, s) {
            if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const i of this._$GetTweens$_(t)) i._$SetPlaybackRate$_(s);
        },
        _$SetAllTweensPlaybackRate$_(t) {
            if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const s of this._$AllTweens$_()) s._$SetPlaybackRate$_(t);
        },
        _$SetTweensDestroyOnComplete$_(t, s) {
            if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const i of this._$GetTweens$_(t)) i._$SetDestroyInstanceOnComplete$_(!!s);
        },
        _$SetAllTweensDestroyOnComplete$_(t) {
            if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const s of this._$AllTweens$_()) s._$SetDestroyInstanceOnComplete$_(!!t);
        }
    };
}

{
    const Of = self._$C3$_;
    Of._$Behaviors$_._$Tween$_._$Exps$_ = {
        _$Time$_(t) {
            const s = this._$GetTweenIncludingWaitingForRelease$_(t);
            return s ? s._$GetTime$_() : 0;
        },
        _$Progress$_(t) {
            const s = this._$GetTweenIncludingWaitingForRelease$_(t);
            return s ? s._$GetTime$_() / s._$GetTotalTime$_() : 0;
        },
        _$PlaybackRate$_(t) {
            const s = this._$GetTweenIncludingWaitingForRelease$_(t);
            return s ? s._$GetPlaybackRate$_() : 0;
        },
        _$Value$_(t) {
            const s = this._$GetTweenIncludingWaitingForRelease$_(t, "value");
            return s ? s._$GetPropertyTrack$_("value")._$GetSourceAdapterValue$_() : 0;
        },
        _$Tags$_() {
            let t = this._$GetFinishingTween$_();
            return (t = t || this._$GetTriggerTween$_()) ? t._$GetStringTags$_() : "";
        }
    };
}

{
    const Df = self._$C3$_, kf = self._$Ease$_, Lf = [ "position", "size", "scale" ], Bf = [ "offsetX", "offsetY", "offsetWidth", "offsetHeight", "offsetAngle", "offsetOpacity", "offsetColor", "offsetZElevation", "offsetScaleX", "offsetScaleY" ], Nf = [ "value" ], Wf = [].concat(Lf).concat(Bf).concat(Nf), jf = {
        position: [ "offsetX", "offsetY" ],
        size: [ "offsetWidth", "offsetHeight" ],
        scale: [ "offsetScaleX", "offsetScaleY" ]
    }, Vf = Object.assign({}, Wf.reduce((t, s) => Object.assign({}, t, {
        [s]: [ s ]
    }), {}), jf);
    Df._$Behaviors$_._$Tween$_._$Maps$_ = class {
        constructor() {}
        static _$GetEases$_() {
            return [ ...kf._$GetRuntimeEaseNames$_() ];
        }
        static _$GetEaseFromIndex$_(t) {
            return [ ...kf._$GetRuntimeEaseNames$_() ][t];
        }
        static _$GetPropertyFromIndex$_(t) {
            return Wf[t];
        }
        static _$GetPropertyIndexFromName$_(t) {
            return Wf.indexOf(t);
        }
        static _$GetPairPropertyFromIndex$_(t) {
            return Lf[t];
        }
        static _$GetSinglePropertyFromIndex$_(t) {
            return Bf[t];
        }
        static _$GetValuePropertyFromIndex$_(t) {
            return Nf[t];
        }
        static _$GetPairProperties$_(t) {
            return jf[t];
        }
        static _$GetRealProperties$_(t) {
            return Df._$IsString$_(t) ? Vf[t] : Vf[Wf[t]];
        }
        static _$IsPairId$_(t) {
            return !!jf[t];
        }
        static _$IsColorId$_(t) {
            return "offsetColor" === t;
        }
        static _$IsAngleId$_(t) {
            return "offsetAngle" === t;
        }
        static _$IsOpacityId$_(t) {
            return "offsetOpacity" === t;
        }
        static _$IsValueId$_(t) {
            return "value" === t;
        }
    };
}

{
    const Uf = self._$C3$_, Hf = Uf._$Behaviors$_._$Tween$_, zf = new Map();
    Hf._$Config$_ = class {
        constructor() {}
        static _$GetPropertyTracksConfig$_(t, s, i, e, h, r) {
            0 === zf.size && this._$_CreateConfigObjects$_();
            let n = Hf._$PropertyTypes$_._$Pick$_(t), o = zf.get(n);
            return Uf._$IsFiniteNumber$_(t) && (t = Hf._$Maps$_._$GetPropertyFromIndex$_(t)), 
            this._$_GetConfig$_(o, t, s, i, e, h, r);
        }
        static _$TransformValue$_(t, s) {
            const i = Uf._$Behaviors$_._$Tween$_._$GetPropertyTracksConfig$_(t);
            return i._$valueGetter$_(s);
        }
        static _$_CreateConfigObjects$_() {
            const t = Hf._$PropertyTypes$_, s = Hf._$ValueGetters$_;
            this._$_AddConfigObject$_(t._$PAIR$_, this._$_GetPairConfig$_, s._$_GetPropertyValue$_), 
            this._$_AddConfigObject$_(t.COLOR, this._$_GetColorConfig$_, s._$_GetColorPropertyValue$_), 
            this._$_AddConfigObject$_(t._$ANGLE$_, this._$_GetAngleConfig$_, s._$_GetPropertyAngleValue$_), 
            this._$_AddConfigObject$_(t._$VALUE$_, this._$_GetValueConfig$_, s._$_GetPropertyValue$_), 
            this._$_AddConfigObject$_(t._$OTHER$_, this._$_GetCommonConfig$_, s._$_GetPropertyValue$_);
        }
        static _$_AddConfigObject$_(t, s, i) {
            zf.set(t, this._$_CreateConfigObject$_(t, s, i));
        }
        static _$_CreateConfigObject$_(t, s, i) {
            return {
                name: t,
                _$configFunc$_: s,
                _$valueGetter$_: i
            };
        }
        static _$_GetConfig$_(t, s, i, e, h, r, n) {
            return t._$configFunc$_(s, t._$valueGetter$_(i), t._$valueGetter$_(e), h, r, n);
        }
        static _$_GetPairConfig$_(t, i, e, h, r, s) {
            const n = Hf._$Maps$_._$GetPairProperties$_(t);
            return n.map((t, s) => ({
                _$sourceId$_: "world-instance",
                property: t,
                type: "float",
                valueType: "numeric",
                _$startValue$_: i[s],
                _$endValue$_: e[s],
                ease: Hf._$Maps$_._$GetEaseFromIndex$_(h),
                resultMode: r
            }));
        }
        static _$_GetColorConfig$_(t, s, i, e, h, r) {
            return Uf._$Plugins$_.Text && r._$GetPlugin$_() instanceof Uf._$Plugins$_.Text ? {
                _$sourceId$_: "plugin",
                _$sourceArgs$_: [ 7 ],
                property: "color",
                type: "color",
                valueType: "color",
                _$startValue$_: s,
                _$endValue$_: i,
                ease: Hf._$Maps$_._$GetEaseFromIndex$_(e),
                resultMode: h
            } : {
                _$sourceId$_: "world-instance",
                property: t,
                type: "color",
                valueType: "color",
                _$startValue$_: s,
                _$endValue$_: i,
                ease: Hf._$Maps$_._$GetEaseFromIndex$_(e),
                resultMode: h
            };
        }
        static _$_GetAngleConfig$_(t, s, i, e, h, r) {
            return {
                _$sourceId$_: "world-instance",
                property: t,
                type: "angle",
                valueType: "angle",
                _$startValue$_: s,
                _$endValue$_: i,
                ease: Hf._$Maps$_._$GetEaseFromIndex$_(e),
                resultMode: h
            };
        }
        static _$_GetCommonConfig$_(t, s, i, e, h, r) {
            return {
                _$sourceId$_: "world-instance",
                property: t,
                type: "float",
                valueType: "numeric",
                _$startValue$_: s,
                _$endValue$_: i,
                ease: Hf._$Maps$_._$GetEaseFromIndex$_(e),
                resultMode: h
            };
        }
        static _$_GetValueConfig$_(t, s, i, e, h, r) {
            return {
                _$sourceId$_: "value",
                property: t,
                type: "float",
                valueType: "numeric",
                _$startValue$_: s,
                _$endValue$_: i,
                ease: Hf._$Maps$_._$GetEaseFromIndex$_(e),
                resultMode: h
            };
        }
    };
}

{
    const Jf = self._$C3$_, qf = Jf._$Behaviors$_._$Tween$_, Xf = {
        resultMode: "absolute"
    }, Yf = Object.assign({}, Xf, {
        tags: "",
        property: "",
        time: 0,
        ease: 0,
        _$releaseOnComplete$_: 0,
        loop: !1,
        pingPong: !1,
        repeatCount: 1
    }), $f = Object.assign({}, Yf, {
        initialValueMode: "current-state",
        _$startValue$_: 0,
        _$endValue$_: 0
    }), Kf = Object.assign({}, Yf, {
        initialValueMode: "current-state",
        _$startValue$_: [ 0, 0 ],
        _$endValue$_: [ 0, 0 ]
    }), Zf = Object.assign({}, Yf, {
        initialValueMode: "current-state",
        _$startValue$_: [ 0, 0, 0 ],
        _$endValue$_: [ 0, 0, 0 ]
    }), Qf = Object.assign({}, $f, {
        initialValueMode: "start-value"
    });
    qf._$TweenArguments$_ = class {
        constructor() {}
        static _$_SetCommonProperties$_(t, s, i, e, h, r, n, o) {
            t.tags = s, t.time = i, t.ease = e, t._$releaseOnComplete$_ = h, t.loop = r, 
            t.pingPong = n, t.repeatCount = o;
        }
        static _$OneProperty$_(t, s, i, e, h, r, n, o, a, l) {
            const u = "string" == typeof i ? i : qf._$Maps$_._$GetSinglePropertyFromIndex$_(i), c = qf._$Maps$_._$IsColorId$_(u) ? Zf : $f;
            return this._$_SetCommonProperties$_(c, s, h, r, n, o, a, l), qf._$Maps$_._$IsColorId$_(u) ? (Zf._$endValue$_[0] = Jf._$GetRValue$_(e), 
            Zf._$endValue$_[1] = Jf._$GetGValue$_(e), Zf._$endValue$_[2] = Jf._$GetBValue$_(e), 
            Zf.property = qf._$Maps$_._$GetPropertyIndexFromName$_(u)) : qf._$Maps$_._$IsOpacityId$_(u) ? $f._$endValue$_ = e / 100 : $f._$endValue$_ = e, 
            c.property = qf._$Maps$_._$GetPropertyIndexFromName$_(u), c;
        }
        static _$TwoProperties$_(t, s, i, e, h, r, n, o, a, l, u) {
            this._$_SetCommonProperties$_(Kf, s, r, n, o, a, l, u);
            const c = "string" == typeof i ? i : qf._$Maps$_._$GetPairPropertyFromIndex$_(i);
            return Kf._$endValue$_[0] = e, Kf._$endValue$_[1] = h, Kf.property = qf._$Maps$_._$GetPropertyIndexFromName$_(c), 
            Kf;
        }
        static _$ValueProperty$_(t, s, i, e, h, r, n, o, a, l) {
            return this._$_SetCommonProperties$_(Qf, s, h, r, n, o, a, l), Qf._$startValue$_ = i, 
            Qf._$endValue$_ = e, Qf.property = qf._$Maps$_._$GetPropertyIndexFromName$_("value"), 
            Qf;
        }
    };
}

{
    const t0 = self._$C3$_, s0 = t0._$Behaviors$_._$Tween$_, i0 = [];
    s0._$PropertyTypes$_ = class {
        constructor() {}
        static _$Pick$_(t) {
            if (0 === i0.length) {
                const s = i0;
                s.push({
                    _$checkFunc$_: s0._$Maps$_._$IsPairId$_,
                    result: this._$PAIR$_
                }), s.push({
                    _$checkFunc$_: s0._$Maps$_._$IsColorId$_,
                    result: this.COLOR
                }), s.push({
                    _$checkFunc$_: s0._$Maps$_._$IsAngleId$_,
                    result: this._$ANGLE$_
                }), s.push({
                    _$checkFunc$_: s0._$Maps$_._$IsValueId$_,
                    result: this._$VALUE$_
                }), s.push({
                    _$checkFunc$_: () => !0,
                    result: this._$OTHER$_
                });
            }
            t0._$IsFiniteNumber$_(t) && (t = t0._$Behaviors$_._$Tween$_._$Maps$_._$GetPropertyFromIndex$_(t));
            for (const i of i0) if (i._$checkFunc$_(t)) return i.result;
        }
        static get _$PAIR$_() {
            return "pair";
        }
        static get COLOR() {
            return "color";
        }
        static get _$ANGLE$_() {
            return "angle";
        }
        static get _$VALUE$_() {
            return "value";
        }
        static get _$OTHER$_() {
            return "other";
        }
    };
}

{
    const e0 = self._$C3$_, h0 = e0._$Behaviors$_._$Tween$_;
    h0._$ValueGetters$_ = class {
        constructor() {}
        static _$_GetPropertyAngleValue$_(t) {
            const s = e0._$toRadians$_(parseFloat(t));
            return e0._$clampAngle$_(s);
        }
        static _$_GetColorPropertyValue$_(t) {
            return t.slice(0);
        }
        static _$_GetPropertyValue$_(t) {
            return t;
        }
    };
}

{
    let l = function(t) {
        n0._$RequireString$_(t);
        let s = a0._$ToInternal$_(t), i;
        if (-1 === (i = s ? a0._$GetIndexForEase$_(s, null) : a0._$GetIndexForEase$_(t, null))) throw new Error(`invalid ease name '${t}'`);
        return i;
    }, u = function(t, s = !1) {
        if (!(s && null == t || "string" == typeof t || Array.isArray(t))) throw new Error("invalid tags");
    };
    l, u;
    const r0 = self._$C3$_, n0 = self._$C3X$_, o0 = self._$IBehaviorInstance$_, a0 = self._$Ease$_, l0 = r0._$Behaviors$_._$Tween$_, u0 = new WeakMap(), c0 = new Map([ [ "x", {
        name: "offsetX",
        type: "one"
    } ], [ "y", {
        name: "offsetY",
        type: "one"
    } ], [ "width", {
        name: "offsetWidth",
        type: "one"
    } ], [ "height", {
        name: "offsetHeight",
        type: "one"
    } ], [ "angle", {
        name: "offsetAngle",
        type: "one"
    } ], [ "opacity", {
        name: "offsetOpacity",
        type: "one"
    } ], [ "color", {
        name: "offsetColor",
        type: "color"
    } ], [ "z-elevation", {
        name: "offsetZElevation",
        type: "one"
    } ], [ "x-scale", {
        name: "offsetScaleX",
        type: "one"
    } ], [ "y-scale", {
        name: "offsetScaleY",
        type: "one"
    } ], [ "position", {
        name: "position",
        type: "two"
    } ], [ "size", {
        name: "size",
        type: "two"
    } ], [ "scale", {
        name: "scale",
        type: "two"
    } ], [ "value", {
        name: "value",
        type: "value"
    } ] ]), f0 = {
        tags: "",
        _$destroyOnComplete$_: !1,
        loop: !1,
        pingPong: !1,
        repeatCount: 1,
        _$startValue$_: 0
    }, d0 = {
        _$easeToIndexFunc$_: l
    };
    self._$ITweenBehaviorInstance$_ = class extends o0 {
        constructor() {
            super(), u0.set(this, o0._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        _$startTween$_(t, s, i, e, h) {
            const r = u0.get(this);
            if (!r._$IsEnabled$_() || !r._$IsInstanceValid$_()) return null;
            const n = c0.get(t);
            if (!n) throw new Error("invalid tween property");
            "one" === n.type || "value" === n.type ? n0._$RequireNumber$_(s) : (n0._$RequireArray$_(s), 
            "two" === n.type ? (n0._$RequireNumber$_(s[0]), n0._$RequireNumber$_(s[1])) : "color" === n.type && (n0._$RequireNumber$_(s[0]), 
            n0._$RequireNumber$_(s[1]), n0._$RequireNumber$_(s[2]))), "angle" === t ? s = r0._$toDegrees$_(s) : "opacity" === t ? s *= 100 : "color" === t && (s = r0._$PackRGBEx$_(s[0], s[1], s[2]));
            const o = l(e);
            n0._$RequireFiniteNumber$_(i), h = Object.assign({}, f0, h), "value" === n.type && n0._$RequireNumber$_(h._$startValue$_), 
            u(h.tags, !0);
            let a;
            if ("one" === n.type || "color" === n.type ? a = r._$CreateTween$_(l0._$TweenArguments$_._$OneProperty$_(r, h.tags, n.name, s, i, o, !!h._$destroyOnComplete$_, !!h.loop, !!h.pingPong, h.repeatCount)) : "two" === n.type ? a = r._$CreateTween$_(l0._$TweenArguments$_._$TwoProperties$_(r, h.tags, n.name, s[0], s[1], i, o, !!h._$destroyOnComplete$_, !!h.loop, !!h.pingPong, h.repeatCount)) : "value" === n.type && (a = r._$CreateTween$_(l0._$TweenArguments$_._$ValueProperty$_(r, h.tags, h._$startValue$_, s, i, o, !!h._$destroyOnComplete$_, !!h.loop, !!h.pingPong, h.repeatCount))), 
            a.Play()) return a._$GetITweenState$_(r, d0);
            throw new Error("failed to start tween");
        }
        *_$allTweens$_() {
            const t = u0.get(this);
            for (const s of t._$AllTweens$_()) yield s._$GetITweenState$_(t, d0);
        }
        *_$tweensByTags$_(t) {
            u(t);
            const s = u0.get(this);
            for (const i of s._$GetTweens$_(t)) yield i._$GetITweenState$_(s, d0);
        }
        get isEnabled() {
            return u0.get(this)._$IsEnabled$_();
        }
        set isEnabled(t) {
            u0.get(this)._$SetEnabled$_(t);
        }
    };
}

{
    const p0 = self._$C3$_;
    p0._$Behaviors$_._$scrollto$_ = class extends p0._$SDKBehaviorBase$_ {
        constructor(t) {
            super(t), this._$_shakeMag$_ = 0, this._$_shakeStart$_ = 0, this._$_shakeEnd$_ = 0, 
            this._$_shakeMode$_ = 0;
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$SetShakeMagnitude$_(t) {
            this._$_shakeMag$_ = t;
        }
        _$GetShakeMagnitude$_() {
            return this._$_shakeMag$_;
        }
        _$SetShakeStart$_(t) {
            this._$_shakeStart$_ = t;
        }
        _$GetShakeStart$_() {
            return this._$_shakeStart$_;
        }
        _$SetShakeEnd$_(t) {
            this._$_shakeEnd$_ = t;
        }
        _$GetShakeEnd$_() {
            return this._$_shakeEnd$_;
        }
        _$SetShakeMode$_(t) {
            this._$_shakeMode$_ = t;
        }
        _$GetShakeMode$_() {
            return this._$_shakeMode$_;
        }
    };
}

{
    const m0 = self._$C3$_;
    m0._$Behaviors$_._$scrollto$_._$Type$_ = class extends m0._$SDKBehaviorTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    const g0 = self._$C3$_;
    g0._$Behaviors$_._$scrollto$_.Instance = class extends g0._$SDKBehaviorInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_isEnabled$_ = !0, s && (this._$_isEnabled$_ = s[0]), 
            this._$_isEnabled$_ && this._$_StartTicking2$_();
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$SaveToJson$_() {
            const t = this._$GetBehavior$_();
            return {
                e: this._$_isEnabled$_,
                smg: t._$GetShakeMagnitude$_(),
                ss: t._$GetShakeStart$_(),
                se: t._$GetShakeEnd$_(),
                smd: t._$GetShakeMode$_()
            };
        }
        _$LoadFromJson$_(t) {
            const s = this._$GetBehavior$_();
            s._$SetShakeMagnitude$_(t.smg), s._$SetShakeStart$_(t.ss), s._$SetShakeEnd$_(t.se), 
            s._$SetShakeMode$_(t.smd), this._$_isEnabled$_ = t.e, this._$_isEnabled$_ ? this._$_StartTicking2$_() : this._$_StopTicking2$_();
        }
        _$_SetEnabled$_(t) {
            this._$_isEnabled$_ = !!t, this._$_isEnabled$_ ? this._$_StartTicking2$_() : this._$_StopTicking2$_();
        }
        _$IsEnabled$_() {
            return this._$_isEnabled$_;
        }
        _$Tick2$_() {
            if (this._$IsEnabled$_()) {
                this._$_runtime$_._$GetDt$_(this._$_inst$_);
                let s = this._$GetBehavior$_(), t = s._$GetInstances$_(), i = 0, e = 0, h = 0;
                for (const l of t) {
                    const u = l._$GetBehaviorInstanceFromCtor$_(g0._$Behaviors$_._$scrollto$_);
                    if (u && u._$GetSdkInstance$_()._$IsEnabled$_()) {
                        const c = l._$GetWorldInfo$_();
                        i += c._$GetX$_(), e += c._$GetY$_(), ++h;
                    }
                }
                let r = this._$_inst$_._$GetWorldInfo$_()._$GetLayout$_(), n = this._$_runtime$_._$GetGameTime$_(), o = 0, a = 0;
                if (n >= s._$GetShakeStart$_() && n < s._$GetShakeEnd$_()) {
                    let t = s._$GetShakeMagnitude$_() * Math.min(this._$_runtime$_._$GetTimeScale$_(), 1);
                    0 === s._$GetShakeMode$_() && (t *= 1 - (n - s._$GetShakeStart$_()) / (s._$GetShakeEnd$_() - s._$GetShakeStart$_()));
                    const f = this._$_runtime$_._$Random$_() * Math.PI * 2, d = this._$_runtime$_._$Random$_() * t;
                    o = Math.cos(f) * d, a = Math.sin(f) * d;
                }
                r._$SetScrollX$_(i / h + o), r._$SetScrollY$_(e / h + a);
            }
        }
        _$GetPropertyValueByIndex$_(t) {
            if (0 === t) return this._$_isEnabled$_;
        }
        _$SetPropertyValueByIndex$_(t, s) {
            0 === t && (this._$_isEnabled$_ = !!s, this._$_isEnabled$_ ? this._$_StartTicking2$_() : this._$_StopTicking2$_());
        }
        _$GetDebuggerProperties$_() {
            return [ {
                title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                properties: [ {
                    name: "behaviors.scrollto.properties.enabled.name",
                    value: this._$IsEnabled$_(),
                    _$onedit$_: t => this._$_SetEnabled$_(t)
                } ]
            } ];
        }
    };
}

{
    const y0 = self._$C3$_;
    y0._$Behaviors$_._$scrollto$_._$Cnds$_ = {
        _$IsEnabled$_() {
            return this._$IsEnabled$_();
        }
    };
}

{
    const w0 = self._$C3$_;
    w0._$Behaviors$_._$scrollto$_._$Acts$_ = {
        _$Shake$_(t, s, i) {
            const e = this._$GetBehavior$_();
            e._$SetShakeMagnitude$_(t), e._$SetShakeStart$_(this._$_runtime$_._$GetGameTime$_()), 
            e._$SetShakeEnd$_(this._$_runtime$_._$GetGameTime$_() + s), e._$SetShakeMode$_(i);
        },
        _$SetEnabled$_(t) {
            this._$_SetEnabled$_(0 !== t);
        }
    };
}

{
    const S0 = self._$C3$_;
    S0._$Behaviors$_._$scrollto$_._$Exps$_ = {};
}

{
    const b0 = self._$C3$_;
    b0._$Behaviors$_._$solid$_ = class extends b0._$SDKBehaviorBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const M0 = self._$C3$_;
    M0._$Behaviors$_._$solid$_._$Type$_ = class extends M0._$SDKBehaviorTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    const v0 = self._$C3$_, x0 = self._$C3X$_, G0 = self._$IBehaviorInstance$_, T0 = new Set(), _0 = (v0._$Behaviors$_._$solid$_.Instance = class extends v0._$SDKBehaviorInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$SetEnabled$_(!0), s && (this._$SetEnabled$_(s[0]), 
            this._$SetTags$_(s[1]));
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$SetEnabled$_(t) {
            this._$_inst$_._$_SetSolidEnabled$_(!!t);
        }
        _$IsEnabled$_() {
            return this._$_inst$_._$_IsSolidEnabled$_();
        }
        _$SetTags$_(s) {
            const i = this._$_inst$_._$GetSavedDataMap$_();
            if (s.trim()) {
                let t = i.get("solidTags");
                t || (t = new Set(), i.set("solidTags", t)), t.clear();
                for (const e of s.split(" ")) e && t.add(e.toLowerCase());
            } else i.delete("solidTags");
        }
        _$GetTags$_() {
            return this._$_inst$_._$GetSavedDataMap$_().get("solidTags") || T0;
        }
        _$_GetTagsString$_() {
            return [ ...this._$GetTags$_() ].join(" ");
        }
        _$SaveToJson$_() {
            return {
                e: this._$IsEnabled$_()
            };
        }
        _$LoadFromJson$_(t) {
            this._$SetEnabled$_(t.e);
        }
        _$GetPropertyValueByIndex$_(t) {
            if (0 === t) return this._$IsEnabled$_();
        }
        _$SetPropertyValueByIndex$_(t, s) {
            0 === t && this._$SetEnabled$_(s);
        }
        _$GetDebuggerProperties$_() {
            return [ {
                title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                properties: [ {
                    name: "behaviors.solid.properties.enabled.name",
                    value: this._$IsEnabled$_(),
                    _$onedit$_: t => this._$SetEnabled$_(t)
                }, {
                    name: "behaviors.solid.properties.tags.name",
                    value: this._$_GetTagsString$_(),
                    _$onedit$_: t => this._$SetTags$_(t)
                } ]
            } ];
        }
        _$GetScriptInterfaceClass$_() {
            return self._$ISolidBehaviorInstance$_;
        }
    }, new WeakMap());
    self._$ISolidBehaviorInstance$_ = class extends G0 {
        constructor() {
            super(), _0.set(this, G0._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        set isEnabled(t) {
            _0.get(this)._$SetEnabled$_(!!t);
        }
        get isEnabled() {
            return _0.get(this)._$IsEnabled$_();
        }
        set tags(t) {
            x0._$RequireString$_(t), _0.get(this)._$SetTags$_(t);
        }
        get tags() {
            return _0.get(this)._$_GetTagsString$_();
        }
    };
}

{
    const I0 = self._$C3$_;
    I0._$Behaviors$_._$solid$_._$Cnds$_ = {
        _$IsEnabled$_() {
            return this._$IsEnabled$_();
        }
    };
}

{
    const C0 = self._$C3$_;
    C0._$Behaviors$_._$solid$_._$Acts$_ = {
        _$SetEnabled$_(t) {
            this._$SetEnabled$_(t);
        },
        _$SetTags$_(t) {
            this._$SetTags$_(t);
        }
    };
}

{
    const R0 = self._$C3$_;
    R0._$Behaviors$_._$solid$_._$Exps$_ = {};
}

{
    const P0 = self._$C3$_;
    P0._$Behaviors$_._$jumpthru$_ = class extends P0._$SDKBehaviorBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const E0 = self._$C3$_;
    E0._$Behaviors$_._$jumpthru$_._$Type$_ = class extends E0._$SDKBehaviorTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    const A0 = self._$C3$_, F0 = self._$IBehaviorInstance$_, O0 = (A0._$Behaviors$_._$jumpthru$_.Instance = class extends A0._$SDKBehaviorInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$SetEnabled$_(!0), s && this._$SetEnabled$_(s[0]);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$SetEnabled$_(t) {
            this._$_inst$_._$_SetJumpthruEnabled$_(!!t);
        }
        _$IsEnabled$_() {
            return this._$_inst$_._$_IsJumpthruEnabled$_();
        }
        _$SaveToJson$_() {
            return {
                e: this._$IsEnabled$_()
            };
        }
        _$LoadFromJson$_(t) {
            this._$SetEnabled$_(t.e);
        }
        _$GetPropertyValueByIndex$_(t) {
            if (0 === t) return this._$IsEnabled$_();
        }
        _$SetPropertyValueByIndex$_(t, s) {
            0 === t && this._$SetEnabled$_(s);
        }
        _$GetDebuggerProperties$_() {
            return [ {
                title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                properties: [ {
                    name: "behaviors.jumpthru.properties.enabled.name",
                    value: this._$IsEnabled$_(),
                    _$onedit$_: t => this._$SetEnabled$_(t)
                } ]
            } ];
        }
        _$GetScriptInterfaceClass$_() {
            return self._$IJumpthruBehaviorInstance$_;
        }
    }, new WeakMap());
    self._$IJumpthruBehaviorInstance$_ = class extends F0 {
        constructor() {
            super(), O0.set(this, F0._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        set isEnabled(t) {
            O0.get(this)._$SetEnabled$_(!!t);
        }
        get isEnabled() {
            return O0.get(this)._$IsEnabled$_();
        }
    };
}

{
    const D0 = self._$C3$_;
    D0._$Behaviors$_._$jumpthru$_._$Cnds$_ = {
        _$IsEnabled$_() {
            return this._$IsEnabled$_();
        }
    };
}

{
    const k0 = self._$C3$_;
    k0._$Behaviors$_._$jumpthru$_._$Acts$_ = {
        _$SetEnabled$_(t) {
            this._$SetEnabled$_(t);
        }
    };
}

{
    const L0 = self._$C3$_;
    L0._$Behaviors$_._$jumpthru$_._$Exps$_ = {};
}

{
    const B0 = self._$C3$_;
    B0._$Behaviors$_._$Flash$_ = class extends B0._$SDKBehaviorBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const N0 = self._$C3$_;
    N0._$Behaviors$_._$Flash$_._$Type$_ = class extends N0._$SDKBehaviorTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    const W0 = self._$C3$_, j0 = self._$C3X$_, V0 = self._$IBehaviorInstance$_, U0 = (W0._$Behaviors$_._$Flash$_.Instance = class extends W0._$SDKBehaviorInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_onTime$_ = 0, this._$_offTime$_ = 0, this._$_stage$_ = 0, 
            this._$_stageTimeLeft$_ = 0, this._$_timeLeft$_ = 0, this._$_StartTicking$_();
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$_Flash$_(t, s, i) {
            this._$_onTime$_ = t, this._$_offTime$_ = s, this._$_stage$_ = 1, this._$_stageTimeLeft$_ = s, 
            this._$_timeLeft$_ = i, this._$_inst$_._$GetWorldInfo$_()._$SetVisible$_(!1), 
            this._$_runtime$_._$UpdateRender$_();
        }
        _$_StopFlashing$_() {
            this._$_timeLeft$_ = 0, this._$_inst$_._$GetWorldInfo$_()._$SetVisible$_(!0), 
            this._$_runtime$_._$UpdateRender$_();
        }
        _$_IsFlashing$_() {
            return 0 < this._$_timeLeft$_;
        }
        _$SaveToJson$_() {
            return {
                on: this._$_onTime$_,
                off: this._$_offTime$_,
                s: this._$_stage$_,
                stl: this._$_stageTimeLeft$_,
                tl: this._$_timeLeft$_
            };
        }
        _$LoadFromJson$_(t) {
            this._$_onTime$_ = t.on, this._$_offTime$_ = t.off, this._$_stage$_ = t.s, 
            this._$_stageTimeLeft$_ = t.stl, this._$_timeLeft$_ = null === t.tl ? 1 / 0 : t.tl;
        }
        _$Tick$_() {
            if (!(this._$_timeLeft$_ <= 0)) {
                const t = this._$_runtime$_._$GetDt$_(this._$_inst$_);
                if (this._$_timeLeft$_ -= t, this._$_timeLeft$_ <= 0) return this._$_timeLeft$_ = 0, 
                this._$_inst$_._$GetWorldInfo$_()._$SetVisible$_(!0), this._$_runtime$_._$UpdateRender$_(), 
                this._$DispatchScriptEvent$_("flashend"), this._$DebugTrigger$_(W0._$Behaviors$_._$Flash$_._$Cnds$_._$OnFlashEnded$_);
                this._$_stageTimeLeft$_ -= t, this._$_stageTimeLeft$_ <= 0 && (0 === this._$_stage$_ ? (this._$_inst$_._$GetWorldInfo$_()._$SetVisible$_(!1), 
                this._$_stage$_ = 1, this._$_stageTimeLeft$_ += this._$_offTime$_) : (this._$_inst$_._$GetWorldInfo$_()._$SetVisible$_(!0), 
                this._$_stage$_ = 0, this._$_stageTimeLeft$_ += this._$_onTime$_), 
                this._$_runtime$_._$UpdateRender$_());
            }
        }
        _$GetDebuggerProperties$_() {
            const t = "behaviors.flash.debugger";
            return [ {
                title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                properties: [ {
                    name: t + ".on-time",
                    value: this._$_onTime$_,
                    _$onedit$_: t => this._$_onTime$_ = t
                }, {
                    name: t + ".off-time",
                    value: this._$_offTime$_,
                    _$onedit$_: t => this._$_offTime$_ = t
                }, {
                    name: t + ".is-flashing",
                    value: 0 < this._$_timeLeft$_
                }, {
                    name: t + ".time-left",
                    value: this._$_timeLeft$_
                } ]
            } ];
        }
        _$GetScriptInterfaceClass$_() {
            return self._$IFlashBehaviorInstance$_;
        }
    }, new WeakMap());
    self._$IFlashBehaviorInstance$_ = class extends V0 {
        constructor() {
            super(), U0.set(this, V0._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        _$flash$_(t, s, i) {
            j0._$RequireFiniteNumber$_(t), j0._$RequireFiniteNumber$_(s), j0._$RequireFiniteNumber$_(i), 
            U0.get(this)._$_Flash$_(t, s, i);
        }
        stop() {
            U0.get(this)._$_StopFlashing$_();
        }
        get _$isFlashing$_() {
            return U0.get(this)._$_IsFlashing$_();
        }
    };
}

{
    const H0 = self._$C3$_;
    H0._$Behaviors$_._$Flash$_._$Cnds$_ = {
        _$IsFlashing$_() {
            return this._$_IsFlashing$_();
        },
        _$OnFlashEnded$_() {
            return !0;
        }
    };
}

{
    const z0 = self._$C3$_;
    z0._$Behaviors$_._$Flash$_._$Acts$_ = {
        _$Flash$_(t, s, i) {
            this._$_Flash$_(t, s, i);
        },
        _$StopFlashing$_() {
            this._$_StopFlashing$_();
        }
    };
}

{
    const J0 = self._$C3$_;
    J0._$Behaviors$_._$Flash$_._$Exps$_ = {};
}

{
    const q0 = self._$C3$_;
    q0._$Behaviors$_._$Platform$_ = class extends q0._$SDKBehaviorBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const X0 = self._$C3$_;
    X0._$Behaviors$_._$Platform$_._$Type$_ = class extends X0._$SDKBehaviorTypeBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$OnCreate$_() {}
    };
}

{
    let v = function(t, s, i, e, h) {
        const r = s * h, n = i * h;
        return A._$clamp$_(t * h + .5 * e * h * h, r, n);
    };
    v;
    const A = self._$C3$_, Y0 = self._$C3X$_, $0 = self._$IBehaviorInstance$_, F = (A._$Behaviors$_._$Platform$_.Instance = class extends A._$SDKBehaviorInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_keyboardDisposables$_ = null, this._$_leftKey$_ = !1, 
            this._$_rightKey$_ = !1, this._$_jumpKey$_ = !1, this._$_jumped$_ = !1, 
            this._$_doubleJumped$_ = !1, this._$_canDoubleJump$_ = !1, this._$_ignoreInput$_ = !1, 
            this._$_simLeft$_ = !1, this._$_simRight$_ = !1, this._$_simJump$_ = !1, 
            this._$_lastFloorObject$_ = null, this._$_loadFloorUid$_ = -1, this._$_lastFloorX$_ = 0, 
            this._$_lastFloorY$_ = 0, this._$_floorIsJumpthru$_ = !1, this._$_wasOnFloor$_ = !1, 
            this._$_wasOverJumpthru$_ = this._$_runtime$_._$GetCollisionEngine$_()._$TestOverlapJumpthru$_(this._$_inst$_), 
            this._$_loadJumpthruUid$_ = -1, this._$_animMode$_ = "stopped", this._$_fallThroughTime$_ = -1, 
            this._$_isFirstTick$_ = !0, this._$_dx$_ = 0, this._$_dy$_ = 0, this._$_downX$_ = 0, 
            this._$_downY$_ = 0, this._$_rightX$_ = 0, this._$_rightY$_ = 0, this._$_g$_ = 1500, 
            this._$_g1$_ = 1500, this._$_ga$_ = A._$toRadians$_(90), this._$_maxSpeed$_ = 330, 
            this._$_acc$_ = 1500, this._$_dec$_ = 1500, this._$_jumpStrength$_ = 650, 
            this._$_maxFall$_ = 1e3, this._$_enableDoubleJump$_ = !1, this._$_jumpSustain$_ = 0, 
            this._$_sustainTime$_ = 0, this._$_defaultControls$_ = !0, this._$_ceilingCollisionMode$_ = 0, 
            this._$_isEnabled$_ = !0, s && (this._$_maxSpeed$_ = s[0], this._$_acc$_ = s[1], 
            this._$_dec$_ = s[2], this._$_jumpStrength$_ = s[3], this._$_g$_ = s[4], 
            this._$_maxFall$_ = s[5], this._$_enableDoubleJump$_ = !!s[6], this._$_jumpSustain$_ = s[7] / 1e3, 
            this._$_defaultControls$_ = !!s[8], this._$_isEnabled$_ = !!s[9]);
            const i = this._$_runtime$_._$Dispatcher$_();
            this._$_disposables$_ = new A._$CompositeDisposable$_(A._$Disposable$_._$From$_(i, "instancedestroy", t => this._$_OnInstanceDestroyed$_(t._$instance$_)), A._$Disposable$_._$From$_(i, "afterload", t => this._$_OnAfterLoad$_())), 
            this._$_defaultControls$_ && this._$_BindEvents$_(), this._$_isEnabled$_ && this._$_StartPostTicking$_(), 
            this._$_UpdateGravity$_();
        }
        _$Release$_() {
            this._$_keyboardDisposables$_ && (this._$_keyboardDisposables$_._$Release$_(), 
            this._$_keyboardDisposables$_ = null), this._$_lastFloorObject$_ = null, 
            this._$_wasOverJumpthru$_ = null, super._$Release$_();
        }
        _$_BindEvents$_() {
            if (!this._$_keyboardDisposables$_) {
                const t = this._$_runtime$_._$Dispatcher$_();
                this._$_keyboardDisposables$_ = new A._$CompositeDisposable$_(A._$Disposable$_._$From$_(t, "keydown", t => this._$_OnKeyDown$_(t.data)), A._$Disposable$_._$From$_(t, "keyup", t => this._$_OnKeyUp$_(t.data)), A._$Disposable$_._$From$_(t, "window-blur", () => this._$_OnWindowOrKeyboardBlur$_()), A._$Disposable$_._$From$_(t, "keyboard-blur", () => this._$_OnWindowOrKeyboardBlur$_()));
            }
        }
        _$_UnBindEvents$_() {
            this._$_keyboardDisposables$_ && (this._$_keyboardDisposables$_._$Release$_(), 
            this._$_keyboardDisposables$_ = null);
        }
        _$_OnInstanceDestroyed$_(t) {
            this._$_lastFloorObject$_ === t && (this._$_lastFloorObject$_ = null), 
            this._$_wasOverJumpthru$_ === t && (this._$_wasOverJumpthru$_ = null);
        }
        _$_OnKeyDown$_(t) {
            switch (t.key) {
              case "ArrowLeft":
                this._$_leftKey$_ = !0;
                break;

              case "ArrowRight":
                this._$_rightKey$_ = !0;
                break;

              case "ArrowUp":
                this._$_jumpKey$_ = !0;
            }
        }
        _$_OnKeyUp$_(t) {
            switch (t.key) {
              case "ArrowLeft":
                this._$_leftKey$_ = !1;
                break;

              case "ArrowRight":
                this._$_rightKey$_ = !1;
                break;

              case "ArrowUp":
                this._$_jumpKey$_ = !1, this._$_jumped$_ = !1;
            }
        }
        _$_OnWindowOrKeyboardBlur$_() {
            this._$_leftKey$_ = !1, this._$_rightKey$_ = !1, this._$_jumpKey$_ = !1, 
            this._$_jumped$_ = !1;
        }
        _$SaveToJson$_() {
            return {
                ii: this._$_ignoreInput$_,
                lfx: this._$_lastFloorX$_,
                lfy: this._$_lastFloorY$_,
                lfo: this._$_lastFloorObject$_ ? this._$_lastFloorObject$_._$GetUID$_() : -1,
                am: this._$_animMode$_,
                en: this._$_isEnabled$_,
                fallt: this._$_fallThroughTime$_,
                ft: this._$_isFirstTick$_,
                dx: this._$_dx$_,
                dy: this._$_dy$_,
                ms: this._$_maxSpeed$_,
                acc: this._$_acc$_,
                dec: this._$_dec$_,
                js: this._$_jumpStrength$_,
                g: this._$_g$_,
                g1: this._$_g1$_,
                mf: this._$_maxFall$_,
                wof: this._$_wasOnFloor$_,
                woj: this._$_wasOverJumpthru$_ ? this._$_wasOverJumpthru$_._$GetUID$_() : -1,
                ga: this._$_ga$_,
                edj: this._$_enableDoubleJump$_,
                cdj: this._$_canDoubleJump$_,
                dj: this._$_doubleJumped$_,
                sus: this._$_jumpSustain$_,
                dc: this._$_defaultControls$_,
                cc: this._$_ceilingCollisionMode$_
            };
        }
        _$LoadFromJson$_(t) {
            this._$_ignoreInput$_ = t.ii, this._$_lastFloorX$_ = t.lfx, this._$_lastFloorY$_ = t.lfy, 
            this._$_loadFloorUid$_ = t.lfo, this._$_animMode$_ = t.am;
            const s = t.en;
            this._$_fallThroughTime$_ = t.fallt || -1, this._$_isFirstTick$_ = t.ft, 
            this._$_dx$_ = t.dx, this._$_dy$_ = t.dy, this._$_maxSpeed$_ = t.ms, 
            this._$_acc$_ = t.acc, this._$_dec$_ = t.dec, this._$_jumpStrength$_ = t.js, 
            this._$_g$_ = t.g, this._$_g1$_ = t.g1, this._$_maxFall$_ = t.mf, this._$_wasOnFloor$_ = t.wof, 
            this._$_loadJumpthruUid$_ = t.woj, this._$_ga$_ = t.ga, this._$_enableDoubleJump$_ = t.edj, 
            this._$_canDoubleJump$_ = t.cdj, this._$_doubleJumped$_ = t.dj, this._$_jumpSustain$_ = t.sus, 
            this._$_defaultControls$_ = t.dc, this._$_ceilingCollisionMode$_ = t.cc || 0, 
            this._$_leftKey$_ = !1, this._$_rightKey$_ = !1, this._$_jumpKey$_ = !1, 
            this._$_jumped$_ = !1, this._$_simLeft$_ = !1, this._$_simRight$_ = !1, 
            this._$_simJump$_ = !1, this._$_sustainTime$_ = 0, this._$_defaultControls$_ ? this._$_BindEvents$_() : this._$_UnBindEvents$_(), 
            this._$_SetEnabled$_(s), this._$_UpdateGravity$_();
        }
        _$_OnAfterLoad$_() {
            -1 === this._$_loadFloorUid$_ ? this._$_lastFloorObject$_ = null : this._$_lastFloorObject$_ = this._$_runtime$_._$GetInstanceByUID$_(this._$_loadFloorUid$_), 
            -1 === this._$_loadJumpthruUid$_ ? this._$_wasOverJumpthru$_ = null : this._$_wasOverJumpthru$_ = this._$_runtime$_._$GetInstanceByUID$_(this._$_loadJumpthruUid$_);
        }
        _$_SetLastFloorObject$_(t) {
            if (this._$_lastFloorObject$_ = t) {
                const s = t._$GetWorldInfo$_();
                this._$_lastFloorX$_ = s._$GetX$_(), this._$_lastFloorY$_ = s._$GetY$_();
            }
        }
        _$_IsFallThroughEnabled$_() {
            return this._$_runtime$_._$GetGameTime$_() > this._$_fallThroughTime$_ + .05;
        }
        _$_UpdateGravity$_() {
            this._$_downX$_ = Math.cos(this._$_ga$_), this._$_downY$_ = Math.sin(this._$_ga$_), 
            this._$_rightX$_ = Math.cos(this._$_ga$_ - Math.PI / 2), this._$_rightY$_ = Math.sin(this._$_ga$_ - Math.PI / 2), 
            this._$_downX$_ = A._$roundToDp$_(this._$_downX$_, 6), this._$_downY$_ = A._$roundToDp$_(this._$_downY$_, 6), 
            this._$_rightX$_ = A._$roundToDp$_(this._$_rightX$_, 6), this._$_rightY$_ = A._$roundToDp$_(this._$_rightY$_, 6), 
            this._$_g1$_ = this._$_g$_, this._$_g$_ < 0 && (this._$_downX$_ *= -1, 
            this._$_downY$_ *= -1, this._$_g$_ = Math.abs(this._$_g$_));
        }
        _$_GetGDir$_() {
            return this._$_g$_ < 0 ? -1 : 1;
        }
        _$_IsOnFloor$_() {
            const s = this._$_inst$_._$GetWorldInfo$_(), h = this._$_runtime$_._$GetCollisionEngine$_(), r = this._$_inst$_, t = this._$_lastFloorObject$_, i = s._$GetX$_(), n = s._$GetY$_();
            if (s._$OffsetXY$_(this._$_downX$_, this._$_downY$_), s._$SetBboxChanged$_(), 
            !t || !h._$TestOverlap$_(r, t) || t._$GetObjectClass$_()._$HasSolidBehavior$_() && !h._$IsSolidCollisionAllowed$_(t, r) || t._$GetObjectClass$_()._$HasJumpthruBehavior$_() && !t._$_IsJumpthruEnabled$_()) {
                let t = h._$TestOverlapSolid$_(r), e = null;
                if (!t && this._$_IsFallThroughEnabled$_() && (e = h._$TestOverlapJumpthru$_(r, !0)), 
                s._$SetXY$_(i, n), s._$SetBboxChanged$_(), t) return h._$TestOverlap$_(r, t) ? null : (this._$_floorIsJumpthru$_ = !1, 
                t);
                if (e && e.length) {
                    let i = 0;
                    for (let t = 0, s = e.length; t < s; ++t) e[i] = e[t], h._$TestOverlap$_(r, e[t]) || ++i;
                    if (1 <= i) return this._$_floorIsJumpthru$_ = !0, e[0];
                }
                return null;
            }
            return s._$SetXY$_(i, n), s._$SetBboxChanged$_(), t;
        }
        _$PostTick$_() {
            if (this._$_isEnabled$_) {
                const c = this._$_runtime$_._$GetDt$_(this._$_inst$_);
                this._$_jumpKey$_ || this._$_simJump$_ || (this._$_jumped$_ = !1);
                let e = this._$_leftKey$_ || this._$_simLeft$_, h = this._$_rightKey$_ || this._$_simRight$_, r = this._$_jumpKey$_ || this._$_simJump$_, n = r && !this._$_jumped$_, [ o, , a ] = (this._$_simLeft$_ = !1, 
                this._$_simRight$_ = !1, this._$_simJump$_ = !1, this._$_ignoreInput$_ && (e = !1, 
                h = !1, r = !1, n = !1), r || (this._$_sustainTime$_ = 0), this._$_HandleFirstTick$_(), 
                this._$_TrackMovingPlatform$_()), l = this._$_IsOnFloor$_(), u = l && !this._$_wasOnFloor$_, t = !1;
                if ([ t, l ] = this._$_MaybePushOutSolid$_(l), !t) {
                    this._$_TrackFloor$_(l, a, o, r), n = this._$_HandleJump$_(l, n, r), 
                    l || this._$_HandleAirTime$_(n, r, c), this._$_wasOnFloor$_ = !!l;
                    let t = this._$_CalculateHorizontalAcceleration$_(e, h), s = !1, i = 0;
                    if (0 !== this._$_dx$_ && ([ s, l ] = this._$_HandleHorizontalMovement$_(c, t, l, n)), 
                    0 !== this._$_dy$_) {
                        const [ f, d ] = this._$_HandleVerticalMovement$_(c, l);
                        s = s || f, i = d;
                    }
                    !s && u && this._$_dy$_ < 0 && 0 < i && (this._$_dy$_ = 0, s = !0), 
                    this._$_ApplyHorizontalAcceleration$_(e, h, t, c), l && !n || s || (this._$_dy$_ = Math.min(this._$_dy$_ + this._$_g$_ * c, this._$_maxFall$_)), 
                    this._$_HandleAnimationTriggers$_(l, s, n), this._$_wasOverJumpthru$_ = this._$_runtime$_._$GetCollisionEngine$_()._$TestOverlapJumpthru$_(this._$_inst$_);
                }
            }
        }
        _$_HandleFirstTick$_() {
            if (this._$_isFirstTick$_) {
                const t = this._$_inst$_, s = this._$_runtime$_._$GetCollisionEngine$_();
                (s._$TestOverlapSolid$_(t) || s._$TestOverlapJumpthru$_(t)) && s._$PushOutSolid$_(t, -this._$_downX$_, -this._$_downY$_, 4, !0), 
                this._$_isFirstTick$_ = !1;
            }
        }
        _$_TrackMovingPlatform$_() {
            let t = this._$_lastFloorObject$_, s = t ? t._$GetWorldInfo$_() : null, i = 0, e = 0, h = !1;
            if (t && 0 === this._$_dy$_ && (s._$GetY$_() !== this._$_lastFloorY$_ || s._$GetX$_() !== this._$_lastFloorX$_)) {
                const r = this._$_inst$_, n = r._$GetWorldInfo$_(), o = this._$_runtime$_._$GetCollisionEngine$_(), a = s._$GetX$_(), l = s._$GetY$_(), u = (i = a - this._$_lastFloorX$_, 
                e = l - this._$_lastFloorY$_, n._$OffsetXY$_(i, e), n._$SetBboxChanged$_(), 
                this._$_lastFloorX$_ = a, this._$_lastFloorY$_ = l, h = !0, o._$TestOverlapSolid$_(r));
                u && (o._$RegisterCollision$_(r, u), o._$PushOutSolid$_(r, -i, -e, 2.5 * Math.hypot(i, e)));
            }
            return [ i, e, h ];
        }
        _$_MaybePushOutSolid$_(t) {
            let s = !1, i = this._$_inst$_, e = i._$GetWorldInfo$_(), h = this._$_runtime$_._$GetCollisionEngine$_(), r = h._$TestOverlapSolid$_(i);
            if (!r) return [ !1, t ];
            const n = Math.abs(e._$GetWidth$_()), o = Math.abs(e._$GetHeight$_());
            return h._$PushOutSolid$_(i, -this._$_downX$_, -this._$_downY$_, o / 8) ? (h._$RegisterCollision$_(i, r), 
            this._$_SetLastFloorObject$_(t = r), this._$_floorIsJumpthru$_ = !1, 
            this._$_dy$_ = 0) : h._$PushOutSolidAxis$_(i, this._$_rightX$_, this._$_rightY$_, n / 2) || h._$PushOutSolidAxis$_(i, this._$_downX$_, this._$_downY$_, o / 2) || h._$PushOutSolidNearest$_(i, Math.max(n, o) / 2) ? h._$RegisterCollision$_(i, r) : s = !0, 
            [ s, t ];
        }
        _$_TrackFloor$_(t, s, i, e) {
            const h = this._$_inst$_, r = this._$_runtime$_._$GetCollisionEngine$_();
            if (t) {
                const n = this._$_downX$_, o = this._$_downY$_, a = this._$_rightX$_, l = this._$_rightY$_;
                if (this._$_doubleJumped$_ = !1, this._$_canDoubleJump$_ = !1, 0 < this._$_dy$_ && (this._$_wasOnFloor$_ || (r._$PushInFractional$_(h, -n, -o, t, 16), 
                this._$_wasOnFloor$_ = !0), this._$_dy$_ = 0), this._$_lastFloorObject$_ !== t) this._$_SetLastFloorObject$_(t), 
                r._$RegisterCollision$_(h, t); else if (s) {
                    const u = r._$TestOverlapSolid$_(h);
                    u && (r._$RegisterCollision$_(h, u), 0 !== i && (0 < i ? r._$PushOutSolid$_(h, -a, -l) : r._$PushOutSolid$_(h, a, l)), 
                    r._$PushOutSolid$_(h, -n, -o));
                }
            } else e || (this._$_canDoubleJump$_ = !0);
        }
        _$_HandleJump$_(t, s, i) {
            if (t && s || !t && this._$_enableDoubleJump$_ && i && this._$_canDoubleJump$_ && !this._$_doubleJumped$_) {
                const e = this._$_inst$_, h = e._$GetWorldInfo$_(), r = this._$_runtime$_._$GetCollisionEngine$_(), n = h._$GetX$_(), o = h._$GetY$_();
                h._$OffsetXY$_(-this._$_downX$_, -this._$_downY$_), h._$SetBboxChanged$_(), 
                r._$TestOverlapSolid$_(e) ? s = !1 : (this._$_sustainTime$_ = this._$_jumpSustain$_, 
                this._$Trigger$_(A._$Behaviors$_._$Platform$_._$Cnds$_._$OnJump$_), 
                this._$_animMode$_ = "jumping", this._$_dy$_ = -this._$_jumpStrength$_, 
                s = !0, t ? this._$_jumped$_ = !0 : this._$_doubleJumped$_ = !0), 
                h._$SetXY$_(n, o), h._$SetBboxChanged$_();
            }
            return s;
        }
        _$_HandleAirTime$_(t, s, i) {
            s && 0 < this._$_sustainTime$_ ? (this._$_dy$_ = -this._$_jumpStrength$_, 
            this._$_sustainTime$_ -= i) : this._$_lastFloorObject$_ = null, t && (this._$_jumped$_ = !0);
        }
        _$_CalculateHorizontalAcceleration$_(t, s) {
            let i = 0, e = this._$_acc$_, h = this._$_dec$_;
            return t && !s && (i = 0 < this._$_dx$_ ? -(e + h) : -e), i = s && !t ? this._$_dx$_ < 0 ? e + h : e : i;
        }
        _$_ApplyHorizontalAcceleration$_(t, s, i, e) {
            const h = this._$_dec$_, r = (t === s && (this._$_dx$_ < 0 ? this._$_dx$_ = Math.min(this._$_dx$_ + h * e, 0) : 0 < this._$_dx$_ && (this._$_dx$_ = Math.max(this._$_dx$_ - h * e, 0))), 
            this._$_dx$_ = A._$clamp$_(this._$_dx$_ + i * e, -this._$_maxSpeed$_, this._$_maxSpeed$_), 
            this._$_runtime$_._$GetCollisionEngine$_()), n = this._$_dx$_ < 0 ? this._$_GetWallObstacle$_(0, 1, 1) : null;
            if (n) this._$_dx$_ = 0, r._$RegisterCollision$_(this._$_inst$_, n); else {
                const o = 0 < this._$_dx$_ ? this._$_GetWallObstacle$_(1, 1, 1) : null;
                o && (this._$_dx$_ = 0, r._$RegisterCollision$_(this._$_inst$_, o));
            }
        }
        _$_HandleHorizontalMovement$_(e, t, h, s) {
            let r = this._$_inst$_, n = r._$GetWorldInfo$_(), o = this._$_runtime$_._$GetCollisionEngine$_(), a = this._$_downX$_, l = this._$_downY$_, i = this._$_rightX$_, u = this._$_rightY$_, c = this._$_maxSpeed$_, f = !1, d = new Set(o._$TestOverlapJumpthru$_(r, !0)), p = n._$GetX$_(), m = n._$GetY$_(), g = v(this._$_dx$_, -c, c, t, e) * i, y = v(this._$_dx$_, -c, c, t, e) * u, w = (n._$OffsetXY$_(i * (1 < this._$_dx$_ ? 1 : -1) - a, u * (1 < this._$_dx$_ ? 1 : -1) - l), 
            n._$SetBboxChanged$_(), !1), S = o._$TestOverlapSolid$_(r), b = (n._$SetXY$_(p + g, m + y), 
            n._$SetBboxChanged$_(), o._$TestOverlapSolid$_(r));
            if (!b && h && this._$_floorIsJumpthru$_ && (b = o._$TestOverlapJumpthru$_(r), 
            d.has(b) ? b = null : w = !0), b) {
                let t = Math.abs(this._$_dx$_ * e) + 2;
                S || !o._$PushOutSolid$_(r, -a, -l, t, w, b) ? (o._$RegisterCollision$_(r, b), 
                t = Math.max(Math.abs(this._$_dx$_ * e * 2.5), Math.floor(n._$GetWidth$_())), 
                o._$PushOutSolid$_(r, i * (this._$_dx$_ < 0 ? 1 : -1), u * (this._$_dx$_ < 0 ? 1 : -1), t, !1) && (!h || w || this._$_floorIsJumpthru$_ || (p = n._$GetX$_(), 
                m = n._$GetY$_(), n._$OffsetXY$_(a, l), o._$TestOverlapSolid$_(r) && o._$PushOutSolid$_(r, -a, -l, 3, !1))) || (n._$SetXY$_(p, m), 
                n._$SetBboxChanged$_()), w || (this._$_dx$_ = 0)) : !S && !s && Math.abs(this._$_dy$_) < Math.abs(this._$_jumpStrength$_ / 4) && (this._$_dy$_ = 0, 
                h || (f = !0));
            } else {
                const M = this._$_IsOnFloor$_();
                if (h && !M) {
                    let t = Math.ceil(Math.abs(this._$_dx$_ * e)) + 2, s = (p = n._$GetX$_(), 
                    m = n._$GetY$_(), n._$OffsetXY$_(a * t, l * t), n._$SetBboxChanged$_(), 
                    o._$TestOverlapJumpthru$_(r)), i = !1;
                    s && !d.has(s) && o._$PushOutSolid$_(r, -a, -l, t + 2, !0, s) && (this._$_SetLastFloorObject$_(h = s), 
                    this._$_floorIsJumpthru$_ = !0, i = !0), i || (o._$TestOverlapSolid$_(r) ? o._$PushOutSolid$_(r, -a, -l, t + 2, !1) : (n._$SetXY$_(p, m), 
                    n._$SetBboxChanged$_()));
                } else M && (!h && this._$_floorIsJumpthru$_ && (this._$_SetLastFloorObject$_(M), 
                this._$_dy$_ = 0, f = !0), 0 === this._$_dy$_) && o._$PushInFractional$_(r, -a, -l, M, 16);
            }
            return [ f, h ];
        }
        _$_HandleVerticalMovement$_(s, t) {
            let e = this._$_inst$_, h = e._$GetWorldInfo$_(), r = this._$_runtime$_._$GetCollisionEngine$_(), i = this._$_downX$_, n = this._$_downY$_, o = !1, a = h._$GetX$_(), l = h._$GetY$_(), u = v(this._$_dy$_, -1 / 0, this._$_maxFall$_, this._$_g$_, s);
            h._$OffsetXY$_(u * i, u * n);
            const c = h._$GetX$_(), f = h._$GetY$_();
            h._$SetBboxChanged$_();
            let d = r._$TestOverlapSolid$_(e), p = !1;
            if (!d && 0 < this._$_dy$_ && !t) {
                const m = this._$_IsFallThroughEnabled$_() ? r._$TestOverlapJumpthru$_(e, !0) : null;
                if (m && m.length) {
                    if (this._$_wasOverJumpthru$_) {
                        h._$SetXY$_(a, l), h._$SetBboxChanged$_();
                        let i = 0;
                        for (let t = 0, s = m.length; t < s; ++t) m[i] = m[t], r._$TestOverlap$_(e, m[t]) || ++i;
                        A._$truncateArray$_(m, i), h._$SetXY$_(c, f), h._$SetBboxChanged$_();
                    }
                    1 <= m.length && (d = m[0]);
                }
                p = !!d;
            }
            if (d) {
                r._$RegisterCollision$_(e, d), this._$_sustainTime$_ = 0;
                let t = 1.1;
                p && !this._$_wasOverJumpthru$_ && (t = 2);
                const g = Math.max(Math.abs(this._$_dy$_ * s * t), 2);
                r._$PushOutSolid$_(e, i * (this._$_dy$_ < 0 ? 1 : -1), n * (this._$_dy$_ < 0 ? 1 : -1), g, p, d) ? (this._$_SetLastFloorObject$_(d), 
                this._$_floorIsJumpthru$_ = p, 0 < this._$_dy$_ && (o = !0), (0 < this._$_dy$_ || 0 === this._$_ceilingCollisionMode$_) && (this._$_dy$_ = 0), 
                this._$_dy$_ < 0 && 1 === this._$_ceilingCollisionMode$_ && r._$PushInFractional$_(e, i, n, d, 32)) : (h._$SetXY$_(a, l), 
                h._$SetBboxChanged$_(), this._$_wasOnFloor$_ = !0, p || (this._$_dy$_ = 0));
            }
            return [ o, u ];
        }
        _$_HandleAnimationTriggers$_(t, s, i) {
            "falling" !== this._$_animMode$_ && 0 < this._$_dy$_ && !t && (this._$Trigger$_(A._$Behaviors$_._$Platform$_._$Cnds$_._$OnFall$_), 
            this._$_animMode$_ = "falling"), (t || s) && 0 <= this._$_dy$_ && ("falling" === this._$_animMode$_ || s || i && 0 === this._$_dy$_ ? (this._$Trigger$_(A._$Behaviors$_._$Platform$_._$Cnds$_._$OnLand$_), 
            0 === this._$_dx$_ && 0 === this._$_dy$_ ? this._$_animMode$_ = "stopped" : this._$_animMode$_ = "moving") : ("stopped" !== this._$_animMode$_ && 0 === this._$_dx$_ && 0 === this._$_dy$_ && (this._$Trigger$_(A._$Behaviors$_._$Platform$_._$Cnds$_._$OnStop$_), 
            this._$_animMode$_ = "stopped"), "moving" === this._$_animMode$_ || 0 === this._$_dx$_ && 0 === this._$_dy$_ || i || (this._$Trigger$_(A._$Behaviors$_._$Platform$_._$Cnds$_._$OnMove$_), 
            this._$_animMode$_ = "moving")));
        }
        _$_IsMoving$_() {
            return 0 !== this._$_GetVectorX$_() || 0 !== this._$_GetVectorY$_();
        }
        _$_CheckIfStandingOnFloor$_() {
            if (0 === this._$_dy$_) {
                let e = this._$_inst$_, t = this._$GetWorldInfo$_(), h = this._$_runtime$_._$GetCollisionEngine$_(), s = t._$GetX$_(), i = t._$GetY$_(), r = (t._$OffsetXY$_(this._$_downX$_, this._$_downY$_), 
                t._$SetBboxChanged$_(), h._$TestOverlapSolid$_(e)), n = null;
                if (!r && this._$_IsFallThroughEnabled$_() && (n = h._$TestOverlapJumpthru$_(e, !0)), 
                t._$SetXY$_(s, i), t._$SetBboxChanged$_(), r) return !h._$TestOverlap$_(e, r);
                if (n && n.length) {
                    let i = 0;
                    for (let t = 0, s = n.length; t < s; ++t) n[i] = n[t], h._$TestOverlap$_(e, n[t]) || i++;
                    if (1 <= i) return !0;
                }
            }
            return !1;
        }
        _$_IsByWall$_(t, s = 2, i = 3) {
            return !!this._$_GetWallObstacle$_(t, s, i);
        }
        _$_GetWallObstacle$_(t, s = 2, i = 3) {
            const e = this._$_inst$_, h = this._$GetWorldInfo$_(), r = this._$_runtime$_._$GetCollisionEngine$_(), n = h._$GetX$_(), o = h._$GetY$_();
            if (0 === t ? h._$OffsetXY$_(-this._$_rightX$_ * s, -this._$_rightY$_ * s) : h._$OffsetXY$_(this._$_rightX$_ * s, this._$_rightY$_ * s), 
            h._$SetBboxChanged$_(), !r._$TestOverlapSolid$_(e)) return h._$SetXY$_(n, o), 
            h._$SetBboxChanged$_(), null;
            h._$OffsetXY$_(-this._$_downX$_ * i, -this._$_downY$_ * i), h._$SetBboxChanged$_();
            const a = r._$TestOverlapSolid$_(e);
            return h._$SetXY$_(n, o), h._$SetBboxChanged$_(), a;
        }
        _$_FallThroughJumpThru$_() {
            const t = this._$GetWorldInfo$_(), s = t._$GetX$_(), i = t._$GetY$_(), e = (t._$OffsetXY$_(this._$_downX$_, this._$_downY$_), 
            t._$SetBboxChanged$_(), this._$_runtime$_._$GetCollisionEngine$_()._$TestOverlapJumpthru$_(this._$_inst$_, !1));
            t._$SetXY$_(s, i), t._$SetBboxChanged$_(), e && (this._$_fallThroughTime$_ = this._$_runtime$_._$GetGameTime$_(), 
            this._$_lastFloorObject$_ = null);
        }
        _$_ResetDoubleJump$_(t) {
            this._$_doubleJumped$_ = !t;
        }
        _$_GetSpeed$_() {
            return Math.hypot(this._$_dx$_, this._$_dy$_);
        }
        _$_GetMovingAngle$_() {
            return Math.atan2(this._$_dy$_, this._$_dx$_);
        }
        _$_IsJumping$_() {
            return this._$_dy$_ < 0;
        }
        _$_IsFalling$_() {
            return 0 < this._$_dy$_;
        }
        _$_SetMaxSpeed$_(t) {
            this._$_maxSpeed$_ = Math.max(t, 0);
        }
        _$_GetMaxSpeed$_() {
            return this._$_maxSpeed$_;
        }
        _$_SetAcceleration$_(t) {
            this._$_acc$_ = Math.max(t, 0);
        }
        _$_GetAcceleration$_() {
            return this._$_acc$_;
        }
        _$_SetDeceleration$_(t) {
            this._$_dec$_ = Math.max(t, 0);
        }
        _$_GetDeceleration$_() {
            return this._$_dec$_;
        }
        _$_SetJumpStrength$_(t) {
            this._$_jumpStrength$_ = Math.max(t, 0);
        }
        _$_GetJumpStrength$_() {
            return this._$_jumpStrength$_;
        }
        _$_SetMaxFallSpeed$_(t) {
            this._$_maxFall$_ = Math.max(t, 0);
        }
        _$_GetMaxFallSpeed$_() {
            return this._$_maxFall$_;
        }
        _$_SetGravity$_(t) {
            if (this._$_g1$_ !== t) {
                this._$_g$_ = t, this._$_UpdateGravity$_();
                const s = this._$_runtime$_._$GetCollisionEngine$_(), i = this._$GetWorldInfo$_();
                s._$TestOverlapSolid$_(this._$_inst$_) && (s._$PushOutSolid$_(this._$_inst$_, this._$_downX$_, this._$_downY$_, 10), 
                i._$OffsetXY$_(2 * this._$_downX$_, 2 * this._$_downY$_), i._$SetBboxChanged$_()), 
                this._$_lastFloorObject$_ = null;
            }
        }
        _$_GetGravity$_() {
            return this._$_g$_;
        }
        _$_SetGravityAngle$_(t) {
            t = A._$clampAngle$_(t), this._$_ga$_ !== t && (this._$_ga$_ = t, this._$_UpdateGravity$_(), 
            this._$_lastFloorObject$_ = null);
        }
        _$_GetGravityAngle$_() {
            return this._$_ga$_;
        }
        _$_SetDoubleJumpEnabled$_(t) {
            this._$_enableDoubleJump$_ = !!t;
        }
        _$_IsDoubleJumpEnabled$_() {
            return this._$_enableDoubleJump$_;
        }
        _$_SetJumpSustain$_(t) {
            this._$_jumpSustain$_ = t;
        }
        _$_GetJumpSustain$_() {
            return this._$_jumpSustain$_;
        }
        _$_SetCeilingCollisionMode$_(t) {
            this._$_ceilingCollisionMode$_ = t;
        }
        _$_GetCeilingCollisionMode$_() {
            return this._$_ceilingCollisionMode$_;
        }
        _$_SetVectorX$_(t) {
            this._$_dx$_ = t;
        }
        _$_GetVectorX$_() {
            return this._$_dx$_;
        }
        _$_SetVectorY$_(t) {
            this._$_dy$_ = t;
        }
        _$_GetVectorY$_() {
            return this._$_dy$_;
        }
        _$_SimulateControl$_(t) {
            if (this._$_isEnabled$_) switch (t) {
              case 0:
                this._$_simLeft$_ = !0;
                break;

              case 1:
                this._$_simRight$_ = !0;
                break;

              case 2:
                this._$_simJump$_ = !0;
            }
        }
        _$_SetDefaultControls$_(t) {
            this._$_defaultControls$_ !== (t = !!t) && (this._$_defaultControls$_ = t, 
            this._$_defaultControls$_ ? this._$_BindEvents$_() : (this._$_UnBindEvents$_(), 
            this._$_OnWindowOrKeyboardBlur$_()));
        }
        _$_IsDefaultControls$_() {
            return this._$_defaultControls$_;
        }
        _$_SetIgnoreInput$_(t) {
            this._$_ignoreInput$_ = !!t;
        }
        _$_IsIgnoreInput$_() {
            return this._$_ignoreInput$_;
        }
        _$_SetEnabled$_(t) {
            this._$_isEnabled$_ !== (t = !!t) && (this._$_isEnabled$_ = t, this._$_isEnabled$_ ? this._$_StartPostTicking$_() : (this._$_StopPostTicking$_(), 
            this._$_lastFloorObject$_ = null, this._$_simLeft$_ = !1, this._$_simRight$_ = !1, 
            this._$_simJump$_ = !1));
        }
        _$_IsEnabled$_() {
            return this._$_isEnabled$_;
        }
        _$GetPropertyValueByIndex$_(t) {
            switch (t) {
              case 0:
                return this._$_GetMaxSpeed$_();

              case 1:
                return this._$_GetAcceleration$_();

              case 2:
                return this._$_GetDeceleration$_();

              case 3:
                return this._$_GetJumpStrength$_();

              case 4:
                return this._$_GetGravity$_();

              case 5:
                return this._$_GetMaxFallSpeed$_();

              case 6:
                return this._$_IsDoubleJumpEnabled$_();

              case 7:
                return 1e3 * this._$_GetJumpSustain$_();

              case 8:
                return this._$_IsDefaultControls$_();

              case 9:
                return this._$_IsEnabled$_();
            }
        }
        _$SetPropertyValueByIndex$_(t, s) {
            switch (t) {
              case 0:
                this._$_SetMaxSpeed$_(s);
                break;

              case 1:
                this._$_SetAcceleration$_(s);
                break;

              case 2:
                this._$_SetDeceleration$_(s);
                break;

              case 3:
                this._$_SetJumpStrength$_(s);
                break;

              case 4:
                this._$_SetGravity$_(s);
                break;

              case 5:
                this._$_SetMaxFallSpeed$_(s);
                break;

              case 6:
                this._$_SetDoubleJumpEnabled$_(!!s);
                break;

              case 7:
                this._$_SetJumpSustain$_(s / 1e3);
                break;

              case 8:
                this._$_SetDefaultControls$_(!!s);
                break;

              case 9:
                this._$_SetEnabled$_(!!s);
            }
        }
        _$GetDebuggerProperties$_() {
            const t = "behaviors.platform";
            return [ {
                title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                properties: [ {
                    name: t + ".debugger.vector-x",
                    value: this._$_GetVectorX$_(),
                    _$onedit$_: t => this._$_SetVectorX$_(t)
                }, {
                    name: t + ".debugger.vector-y",
                    value: this._$_GetVectorY$_(),
                    _$onedit$_: t => this._$_SetVectorY$_(t)
                }, {
                    name: t + ".properties.max-speed.name",
                    value: this._$_GetMaxSpeed$_(),
                    _$onedit$_: t => this._$_SetMaxSpeed$_(t)
                }, {
                    name: t + ".properties.acceleration.name",
                    value: this._$_GetAcceleration$_(),
                    _$onedit$_: t => this._$_SetAcceleration$_(t)
                }, {
                    name: t + ".properties.deceleration.name",
                    value: this._$_GetDeceleration$_(),
                    _$onedit$_: t => this._$_SetDeceleration$_(t)
                }, {
                    name: t + ".properties.jump-strength.name",
                    value: this._$_GetJumpStrength$_(),
                    _$onedit$_: t => this._$_SetJumpStrength$_(t)
                }, {
                    name: t + ".properties.gravity.name",
                    value: this._$_GetGravity$_(),
                    _$onedit$_: t => this._$_SetGravity$_(t)
                }, {
                    name: t + ".debugger.gravity-angle",
                    value: A._$toDegrees$_(this._$_GetGravityAngle$_()),
                    _$onedit$_: t => this._$_SetGravityAngle$_(A._$toRadians$_(t))
                }, {
                    name: t + ".properties.max-fall-speed.name",
                    value: this._$_GetMaxFallSpeed$_(),
                    _$onedit$_: t => this._$_SetMaxFallSpeed$_(t)
                }, {
                    name: t + ".properties.double-jump.name",
                    value: this._$_IsDoubleJumpEnabled$_(),
                    _$onedit$_: t => this._$_SetDoubleJumpEnabled$_(t)
                }, {
                    name: t + ".properties.jump-sustain.name",
                    value: 1e3 * this._$_GetJumpSustain$_(),
                    _$onedit$_: t => this._$_SetJumpSustain$_(t / 1e3)
                }, {
                    name: t + ".debugger.animation-mode",
                    value: [ t + ".debugger.anim-" + this._$_animMode$_ ]
                }, {
                    name: t + ".properties.enabled.name",
                    value: this._$_IsEnabled$_(),
                    _$onedit$_: t => this._$_SetEnabled$_(t)
                } ]
            } ];
        }
        _$GetScriptInterfaceClass$_() {
            return self._$IPlatformBehaviorInstance$_;
        }
    }, new WeakMap()), K0 = new Map([ [ "left", 0 ], [ "right", 1 ], [ "jump", 2 ] ]);
    self._$IPlatformBehaviorInstance$_ = class extends $0 {
        constructor() {
            super(), F.set(this, $0._$_GetInitInst$_()._$GetSdkInstance$_());
        }
        _$fallThrough$_() {
            F.get(this)._$_FallThroughJumpThru$_();
        }
        _$resetDoubleJump$_(t) {
            F.get(this)._$_ResetDoubleJump$_(!!t);
        }
        _$simulateControl$_(t) {
            Y0._$RequireString$_(t);
            const s = K0.get(t);
            if ("number" != typeof s) throw new Error("invalid control");
            F.get(this)._$_SimulateControl$_(s);
        }
        get speed() {
            return F.get(this)._$_GetSpeed$_();
        }
        get _$maxSpeed$_() {
            return F.get(this)._$_GetMaxSpeed$_();
        }
        set _$maxSpeed$_(t) {
            Y0._$RequireFiniteNumber$_(t), F.get(this)._$_SetMaxSpeed$_(t);
        }
        get acceleration() {
            return F.get(this)._$_GetAcceleration$_();
        }
        set acceleration(t) {
            Y0._$RequireFiniteNumber$_(t), F.get(this)._$_SetAcceleration$_(t);
        }
        get _$deceleration$_() {
            return F.get(this)._$_GetDeceleration$_();
        }
        set _$deceleration$_(t) {
            Y0._$RequireFiniteNumber$_(t), F.get(this)._$_SetDeceleration$_(t);
        }
        get _$jumpStrength$_() {
            return F.get(this)._$_GetJumpStrength$_();
        }
        set _$jumpStrength$_(t) {
            Y0._$RequireFiniteNumber$_(t), F.get(this)._$_SetJumpStrength$_(t);
        }
        get _$maxFallSpeed$_() {
            return F.get(this)._$_GetMaxFallSpeed$_();
        }
        set _$maxFallSpeed$_(t) {
            Y0._$RequireFiniteNumber$_(t), F.get(this)._$_SetMaxFallSpeed$_(t);
        }
        get _$gravity$_() {
            return F.get(this)._$_GetGravity$_();
        }
        set _$gravity$_(t) {
            Y0._$RequireFiniteNumber$_(t), F.get(this)._$_SetGravity$_(t);
        }
        get _$gravityAngle$_() {
            return F.get(this)._$_GetGravityAngle$_();
        }
        set _$gravityAngle$_(t) {
            Y0._$RequireFiniteNumber$_(t), F.get(this)._$_SetGravityAngle$_(t);
        }
        get _$isDoubleJumpEnabled$_() {
            return F.get(this)._$_IsDoubleJumpEnabled$_();
        }
        set _$isDoubleJumpEnabled$_(t) {
            F.get(this)._$_SetDoubleJumpEnabled$_(!!t);
        }
        get _$jumpSustain$_() {
            return F.get(this)._$_GetJumpSustain$_();
        }
        set _$jumpSustain$_(t) {
            Y0._$RequireFiniteNumber$_(t), F.get(this)._$_SetJumpSustain$_(t);
        }
        get _$ceilingCollisionMode$_() {
            const t = F.get(this)._$_GetCeilingCollisionMode$_();
            return 0 === t ? "stop" : "preserve-momentum";
        }
        set _$ceilingCollisionMode$_(t) {
            Y0._$RequireString$_(t);
            const s = F.get(this);
            if ("stop" === t) s._$_SetCeilingCollisionMode$_(0); else {
                if ("preserve-momentum" !== t) throw new Error("invalid mode");
                s._$_SetCeilingCollisionMode$_(1);
            }
        }
        get _$isOnFloor$_() {
            return F.get(this)._$_CheckIfStandingOnFloor$_();
        }
        _$isByWall$_(t) {
            Y0._$RequireString$_(t);
            const s = F.get(this);
            if ("left" === t) return s._$_IsByWall$_(0);
            if ("right" === t) return s._$_IsByWall$_(1);
            throw new Error("invalid side");
        }
        get _$isMoving$_() {
            return F.get(this)._$_IsMoving$_();
        }
        get _$isJumping$_() {
            return F.get(this)._$_IsJumping$_();
        }
        get _$isFalling$_() {
            return F.get(this)._$_IsFalling$_();
        }
        get _$vectorX$_() {
            return F.get(this)._$_GetVectorX$_();
        }
        set _$vectorX$_(t) {
            Y0._$RequireFiniteNumber$_(t), F.get(this)._$_SetVectorX$_(t);
        }
        get _$vectorY$_() {
            return F.get(this)._$_GetVectorY$_();
        }
        set _$vectorY$_(t) {
            Y0._$RequireFiniteNumber$_(t), F.get(this)._$_SetVectorY$_(t);
        }
        _$setVector$_(t, s) {
            Y0._$RequireFiniteNumber$_(t), Y0._$RequireFiniteNumber$_(s);
            const i = F.get(this);
            i._$_SetVectorX$_(t), i._$_SetVectorY$_(s);
        }
        _$getVector$_() {
            const t = F.get(this);
            return [ t._$_GetVectorX$_(), t._$_GetVectorY$_() ];
        }
        get _$isDefaultControls$_() {
            return F.get(this)._$_IsDefaultControls$_();
        }
        set _$isDefaultControls$_(t) {
            F.get(this)._$_SetDefaultControls$_(!!t);
        }
        get _$isIgnoringInput$_() {
            return F.get(this)._$_IsIgnoreInput$_();
        }
        set _$isIgnoringInput$_(t) {
            F.get(this)._$_SetIgnoreInput$_(!!t);
        }
        get isEnabled() {
            return F.get(this)._$_IsEnabled$_();
        }
        set isEnabled(t) {
            F.get(this)._$_SetEnabled$_(!!t);
        }
    };
}

{
    const Z0 = self._$C3$_;
    Z0._$Behaviors$_._$Platform$_._$Cnds$_ = {
        _$IsMoving$_() {
            return this._$_IsMoving$_();
        },
        _$CompareSpeed$_(t, s) {
            return Z0.compare(this._$_GetSpeed$_(), t, s);
        },
        _$IsOnFloor$_() {
            return this._$_CheckIfStandingOnFloor$_();
        },
        _$IsByWall$_(t) {
            return this._$_IsByWall$_(t);
        },
        _$IsJumping$_() {
            return this._$_IsJumping$_();
        },
        _$IsFalling$_() {
            return this._$_IsFalling$_();
        },
        _$IsDoubleJumpEnabled$_() {
            return this._$_IsDoubleJumpEnabled$_();
        },
        _$OnJump$_() {
            return !0;
        },
        _$OnFall$_() {
            return !0;
        },
        _$OnStop$_() {
            return !0;
        },
        _$OnMove$_() {
            return !0;
        },
        _$OnLand$_() {
            return !0;
        },
        _$IsEnabled$_() {
            return this._$_IsEnabled$_();
        }
    };
}

{
    const Q0 = self._$C3$_;
    Q0._$Behaviors$_._$Platform$_._$Acts$_ = {
        _$SetMaxSpeed$_(t) {
            this._$_SetMaxSpeed$_(t);
        },
        _$SetAcceleration$_(t) {
            this._$_SetAcceleration$_(t);
        },
        _$SetDeceleration$_(t) {
            this._$_SetDeceleration$_(t);
        },
        _$SetJumpStrength$_(t) {
            this._$_SetJumpStrength$_(t);
        },
        _$SetMaxFallSpeed$_(t) {
            this._$_SetMaxFallSpeed$_(t);
        },
        _$SetGravity$_(t) {
            this._$_SetGravity$_(t);
        },
        _$SimulateControl$_(t) {
            this._$_SimulateControl$_(t);
        },
        _$SetIgnoreInput$_(t) {
            this._$_SetIgnoreInput$_(!!t);
        },
        _$SetVectorX$_(t) {
            this._$_SetVectorX$_(t);
        },
        _$SetVectorY$_(t) {
            this._$_SetVectorY$_(t);
        },
        _$SetGravityAngle$_(t) {
            this._$_SetGravityAngle$_(Q0._$toRadians$_(t));
        },
        _$SetEnabled$_(t) {
            this._$_SetEnabled$_(0 !== t);
        },
        _$FallThrough$_() {
            this._$_FallThroughJumpThru$_();
        },
        _$SetDoubleJumpEnabled$_(t) {
            this._$_SetDoubleJumpEnabled$_(0 !== t);
        },
        _$SetJumpSustain$_(t) {
            this._$_SetJumpSustain$_(t / 1e3);
        },
        _$SetCeilingCollision$_(t) {
            this._$_SetCeilingCollisionMode$_(t);
        },
        _$SetDefaultControls$_(t) {
            this._$_SetDefaultControls$_(t);
        },
        _$ResetDoubleJump$_(t) {
            this._$_ResetDoubleJump$_(t);
        }
    };
}

{
    const t1 = self._$C3$_;
    t1._$Behaviors$_._$Platform$_._$Exps$_ = {
        _$Speed$_() {
            return this._$_GetSpeed$_();
        },
        _$MaxSpeed$_() {
            return this._$_GetMaxSpeed$_();
        },
        _$Acceleration$_() {
            return this._$_GetAcceleration$_();
        },
        _$Deceleration$_() {
            return this._$_GetDeceleration$_();
        },
        _$JumpStrength$_() {
            return this._$_GetJumpStrength$_();
        },
        _$Gravity$_() {
            return this._$_GetGravity$_();
        },
        _$GravityAngle$_() {
            return t1._$toDegrees$_(this._$_GetGravityAngle$_());
        },
        _$MaxFallSpeed$_() {
            return this._$_GetMaxFallSpeed$_();
        },
        _$MovingAngle$_() {
            return t1._$toDegrees$_(this._$_GetMovingAngle$_());
        },
        _$VectorX$_() {
            return this._$_GetVectorX$_();
        },
        _$VectorY$_() {
            return this._$_GetVectorY$_();
        },
        _$JumpSustain$_() {
            return 1e3 * this._$_GetJumpSustain$_();
        }
    };
}

{
    const s1 = self._$C3$_;
    s1._$Behaviors$_._$LOS$_ = class extends s1._$SDKBehaviorBase$_ {
        constructor(t) {
            super(t);
        }
        _$Release$_() {
            super._$Release$_();
        }
    };
}

{
    const i1 = self._$C3$_;
    i1._$Behaviors$_._$LOS$_._$Type$_ = class extends i1._$SDKBehaviorTypeBase$_ {
        constructor(t) {
            super(t), this._$_obstacleTypes$_ = [];
        }
        _$Release$_() {
            i1._$clearArray$_(this._$_obstacleTypes$_), super._$Release$_();
        }
        _$OnCreate$_() {}
        _$AddObstacle$_(t) {
            if (!this._$_obstacleTypes$_.includes(t)) {
                for (const s of this._$_obstacleTypes$_) if (s._$IsFamily$_() && s._$FamilyHasMember$_(t)) return;
                this._$_obstacleTypes$_.push(t);
            }
        }
        _$ClearObstacles$_() {
            i1._$clearArray$_(this._$_obstacleTypes$_);
        }
        _$GetObstacleTypes$_() {
            return this._$_obstacleTypes$_;
        }
        _$FindLOSBehavior$_(t) {
            const s = this._$GetBehaviorType$_();
            for (const i of t._$GetBehaviorInstances$_()) if (i._$GetBehaviorType$_() === s) return i._$GetSdkInstance$_();
            return null;
        }
    };
}

{
    const e1 = self._$C3$_, h1 = self._$C3X$_, r1 = self._$IBehaviorInstance$_, n1 = [], o1 = (e1._$Behaviors$_._$LOS$_.Instance = class extends e1._$SDKBehaviorInstanceBase$_ {
        constructor(t, s) {
            super(t), this._$_obstacleMode$_ = 0, this._$_range$_ = 1e4, this._$_cone$_ = e1._$toRadians$_(360), 
            this._$_useCollisionCells$_ = !0, this._$_ray$_ = new e1._$Ray$_(), 
            s && (this._$_obstacleMode$_ = s[0], this._$_range$_ = s[1], this._$_cone$_ = e1._$toRadians$_(s[2]), 
            this._$_useCollisionCells$_ = s[3]);
        }
        _$Release$_() {
            super._$Release$_();
        }
        _$SaveToJson$_() {
            return {
                r: this._$_range$_,
                c: this._$_cone$_,
                om: this._$_obstacleMode$_,
                ucc: this._$_useCollisionCells$_,
                t: this._$GetSdkType$_()._$GetObstacleTypes$_().map(t => t._$GetSID$_())
            };
        }
        _$LoadFromJson$_(t) {
            this._$_range$_ = t.r, this._$_cone$_ = t.c, this._$_obstacleMode$_ = t.om || 0, 
            this._$_useCollisionCells$_ = !!t.ucc;
            const s = this._$GetSdkType$_()._$GetObstacleTypes$_();
            e1._$clearArray$_(s);
            for (const i of t.t) {
                const e = this._$_runtime$_._$GetObjectClassBySID$_(i);
                e && s.push(e);
            }
        }
        _$HasLOSToInstance$_(t, s) {
            const i = t._$GetUID$_(), [ e, h ] = t._$GetImagePoint$_(s), r = this._$HasLOSTo$_(e, h);
            return r || this._$_ray$_._$DidCollide$_() && this._$_ray$_._$hitUid$_ === i;
        }
        _$HasLOSTo$_(t, s) {
            let i = this._$GetWorldInfo$_(), e = i._$GetAngle$_();
            return i._$GetWidth$_() < 0 && (e += Math.PI), this._$HasLOSBetweenPositions$_(i._$GetX$_(), i._$GetY$_(), e, t, s);
        }
        _$HasLOSBetweenPositions$_(t, s, i, e, h) {
            this._$_ray$_._$Reset$_();
            const r = this._$_range$_;
            if (e1._$distanceSquared$_(t, s, e, h) > r * r) return !1;
            const n = e1._$angleTo$_(t, s, e, h);
            if (e1._$angleDiff$_(i, n) > this._$_cone$_ / 2) return !1;
            const o = this._$CastRay$_(t, s, e, h, this._$_useCollisionCells$_);
            return !o._$DidCollide$_();
        }
        _$_GetCollisionCandidates$_(t, s) {
            if (s) {
                const i = this._$GetWorldInfo$_()._$GetLayer$_(), e = this._$_runtime$_._$GetCollisionEngine$_();
                0 === this._$_obstacleMode$_ ? e._$GetSolidCollisionCandidates$_(i, t.rect, n1) : e._$GetObjectClassesCollisionCandidates$_(i, this._$_GetObstacleTypes$_(), t.rect, n1);
            } else {
                if (0 === this._$_obstacleMode$_) {
                    const h = this._$_runtime$_._$GetSolidBehavior$_();
                    return h ? h._$GetInstances$_() : n1;
                }
                for (const r of this._$_GetObstacleTypes$_()) e1._$appendArray$_(n1, r._$GetInstances$_());
            }
            return n1;
        }
        _$_GetObstacleTypes$_() {
            return this._$GetSdkType$_()._$GetObstacleTypes$_();
        }
        _$CastRay$_(t, s, i, e, h) {
            const r = this._$_ray$_.Set(t, s, i, e), n = this._$_GetCollisionCandidates$_(r, h), o = this._$_runtime$_._$GetCollisionEngine$_(), a = 0 === this._$_obstacleMode$_, l = this._$_inst$_;
            for (let t = 0, s = n.length; t < s; ++t) {
                const u = n[t];
                u === l || a && !o._$IsSolidCollisionAllowed$_(u, l) || o._$TestRayIntersectsInstance$_(u, r);
            }
            return r._$Complete$_(), e1._$clearArray$_(n1), r;
        }
        _$_GetRay$_() {
            return this._$_ray$_;
        }
        _$_GetRayHitX$_() {
            const t = this._$_ray$_;
            return t._$DidCollide$_() ? t._$hitX$_ : 0;
        }
        _$_GetRayHitY$_() {
            const t = this._$_ray$_;
            return t._$DidCollide$_() ? t._$hitY$_ : 0;
        }
        _$_GetRayHitDistance$_() {
            const t = this._$_ray$_;
            return t._$DidCollide$_() ? t._$distance$_ : 0;
        }
        _$_GetRayHitUID$_() {
            const t = this._$_ray$_;
            return t._$DidCollide$_() ? t._$hitUid$_ : -1;
        }
        _$_GetRayNormalX$_(t) {
            const s = this._$_ray$_;
            return s._$DidCollide$_() ? s._$hitX$_ + t * s._$normalX$_ : 0;
        }
        _$_GetRayNormalY$_(t) {
            const s = this._$_ray$_;
            return s._$DidCollide$_() ? s._$hitY$_ + t * s._$normalY$_ : 0;
        }
        _$_GetRayNormalAngle$_() {
            const t = this._$_ray$_;
            return t._$DidCollide$_() ? t._$hitNormal$_ : 0;
        }
        _$_GetRayReflectionX$_(t) {
            const s = this._$_ray$_;
            return s._$DidCollide$_() ? s._$hitX$_ + t * s._$reflectionX$_ : 0;
        }
        _$_GetRayReflectionY$_(t) {
            const s = this._$_ray$_;
            return s._$DidCollide$_() ? s._$hitY$_ + t * s._$reflectionY$_ : 0;
        }
        _$_GetRayReflectionAngle$_() {
            const t = this._$_ray$_;
            return t._$DidCollide$_() ? Math.atan2(t._$reflectionY$_, t._$reflectionX$_) : 0;
        }
        _$_SetRange$_(t) {
            this._$_range$_ = t;
        }
        _$_GetRange$_() {
            return this._$_range$_;
        }
        _$_SetConeOfView$_(t) {
            this._$_cone$_ = t;
        }
        _$_GetConeOfView$_() {
            return this._$_cone$_;
        }
        _$GetPropertyValueByIndex$_(t) {
            switch (t) {
              case 0:
                return this._$_obstacleMode$_;

              case 1:
                return this._$_range$_;

              case 2:
                return e1._$toDegrees$_(this._$_cone$_);

              case 3:
                return this._$_useCollisionCells$_;
            }
        }
        _$SetPropertyValueByIndex$_(t, s) {
            switch (t) {
              case 0:
                this._$_obstacleMode$_ = s;
                break;

              case 1:
                this._$_range$_ = s;
                break;

              case 2:
                this._$_cone$_ = e1._$toRadians$_(s);
                break;

              case 3:
                this._$_useCollisionCells$_ = !!s;
            }
        }
        _$GetDebuggerProperties$_() {
            const t = "behaviors.los.properties";
            return [ {
                title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                properties: [ {
                    name: t + ".range.name",
                    value: this._$_GetRange$_(),
                    _$onedit$_: t => this._$_SetRange$_(t)
                }, {
                    name: t + ".cone-of-view.name",
                    value: e1._$toDegrees$_(this._$_GetConeOfView$_()),
                    _$onedit$_: t => this._$_SetConeOfView$_(e1._$toRadians$_(t))
                } ]
            } ];
        }
        _$GetScriptInterfaceClass$_() {
            return self._$ILOSBehaviorInstance$_;
        }
    }, new WeakMap());
    self._$ILOSBehaviorInstance$_ = class extends r1 {
        constructor() {
            super();
            const t = r1._$_GetInitInst$_()._$GetSdkInstance$_();
            o1.set(this, t), this._$ray$_ = new self._$ILOSBehaviorRay$_(t);
        }
        set range(t) {
            h1._$RequireFiniteNumber$_(t), o1.get(this)._$_SetRange$_(t);
        }
        get range() {
            return o1.get(this)._$_GetRange$_();
        }
        set _$coneOfView$_(t) {
            h1._$RequireFiniteNumber$_(t), o1.get(this)._$_SetConeOfView$_(t);
        }
        get _$coneOfView$_() {
            return o1.get(this)._$_GetConeOfView$_();
        }
        _$hasLOStoPosition$_(t, s) {
            return h1._$RequireNumber$_(t), h1._$RequireNumber$_(s), o1.get(this)._$HasLOSTo$_(t, s);
        }
        _$hasLOSBetweenPositions$_(t, s, i, e, h) {
            return h1._$RequireNumber$_(t), h1._$RequireNumber$_(s), h1._$RequireNumber$_(i), 
            h1._$RequireNumber$_(e), h1._$RequireNumber$_(h), o1.get(this)._$HasLOSBetweenPositions$_(t, s, i, e, h);
        }
        _$castRay$_(t, s, i, e, h = !0) {
            return h1._$RequireNumber$_(t), h1._$RequireNumber$_(s), h1._$RequireNumber$_(i), 
            h1._$RequireNumber$_(e), o1.get(this)._$CastRay$_(t, s, i, e, h), this._$ray$_;
        }
        _$addObstacle$_(t) {
            const s = o1.get(this), i = s._$GetRuntime$_()._$_UnwrapIObjectClass$_(t);
            s._$GetSdkType$_()._$AddObstacle$_(i);
        }
        _$clearObstacles$_() {
            o1.get(this)._$GetSdkType$_()._$ClearObstacles$_();
        }
    }, self._$ILOSBehaviorRay$_ = class {
        constructor(t) {
            o1.set(this, t);
        }
        get _$didCollide$_() {
            return o1.get(this)._$_GetRay$_()._$DidCollide$_();
        }
        get _$hitX$_() {
            return o1.get(this)._$_GetRayHitX$_();
        }
        get _$hitY$_() {
            return o1.get(this)._$_GetRayHitY$_();
        }
        _$getHitPosition$_() {
            const t = o1.get(this);
            return [ t._$_GetRayHitX$_(), t._$_GetRayHitY$_() ];
        }
        get _$hitDistance$_() {
            return o1.get(this)._$_GetRayHitDistance$_();
        }
        get _$hitUid$_() {
            return o1.get(this)._$_GetRayHitUID$_();
        }
        _$getNormalX$_(t) {
            return h1._$RequireFiniteNumber$_(t), o1.get(this)._$_GetRayNormalX$_(t);
        }
        _$getNormalY$_(t) {
            return h1._$RequireFiniteNumber$_(t), o1.get(this)._$_GetRayNormalY$_(t);
        }
        _$getNormal$_(t) {
            h1._$RequireFiniteNumber$_(t);
            const s = o1.get(this);
            return [ s._$_GetRayNormalX$_(t), s._$_GetRayNormalY$_(t) ];
        }
        get _$normalAngle$_() {
            return o1.get(this)._$_GetRayNormalAngle$_();
        }
        _$getReflectionX$_(t) {
            return h1._$RequireFiniteNumber$_(t), o1.get(this)._$_GetRayReflectionX$_(t);
        }
        _$getReflectionY$_(t) {
            return h1._$RequireFiniteNumber$_(t), o1.get(this)._$_GetRayReflectionY$_(t);
        }
        _$getReflection$_(t) {
            h1._$RequireFiniteNumber$_(t);
            const s = o1.get(this);
            return [ s._$_GetRayReflectionX$_(t), s._$_GetRayReflectionY$_(t) ];
        }
        get _$reflectionAngle$_() {
            return o1.get(this)._$_GetRayReflectionAngle$_();
        }
    };
}

{
    const a1 = self._$C3$_, l1 = new Set(), u1 = new Set();
    a1._$Behaviors$_._$LOS$_._$Cnds$_ = {
        _$HasLOSToPosition$_(t, s) {
            return this._$HasLOSTo$_(t, s);
        },
        _$RayIntersected$_() {
            return this._$_ray$_._$DidCollide$_();
        },
        _$HasLOSBetweenPositions$_(t, s, i, e, h) {
            return this._$HasLOSBetweenPositions$_(t, s, a1._$toRadians$_(i), e, h);
        },
        _$HasLOSToObject$_(t, i) {
            if (!t) return !1;
            let s = this._$_runtime$_._$GetCurrentCondition$_(), e = s._$GetEventBlock$_()._$IsOrBlock$_(), h = s._$GetRuntime$_(), r = s._$GetObjectClass$_()._$GetCurrentSol$_(), n = t._$GetCurrentSol$_(), o = r._$GetInstances$_(), a = n._$GetInstances$_();
            r._$IsSelectAll$_() ? a1._$clearArray$_(r._$_GetOwnElseInstances$_()) : e && (o = h._$IsCurrentConditionFirst$_() && !r._$_GetOwnElseInstances$_().length && r._$_GetOwnInstances$_().length ? r._$_GetOwnInstances$_() : r._$_GetOwnElseInstances$_()), 
            n._$IsSelectAll$_() ? a1._$clearArray$_(n._$_GetOwnElseInstances$_()) : e && (a = h._$IsCurrentConditionFirst$_() && !n._$_GetOwnElseInstances$_().length && n._$_GetOwnInstances$_().length ? n._$_GetOwnInstances$_() : n._$_GetOwnElseInstances$_());
            const l = s._$IsInverted$_(), u = this._$GetSdkType$_();
            for (const c of o) {
                let t = !1, s = u._$FindLOSBehavior$_(c);
                if (0 === a.length) l && (t = !0); else for (const f of a) c !== f && a1.xor(s._$HasLOSToInstance$_(f, i), l) && (t = !0, 
                u1.add(f));
                t && l1.add(c);
            }
            return e ? (o === r._$_GetOwnElseInstances$_() ? r._$TransferElseInstancesToOwn$_(l1) : (r._$AddElseInstances$_(l1, o), 
            r._$SetSetPicked$_(l1)), a === n._$_GetOwnElseInstances$_() ? n._$TransferElseInstancesToOwn$_(u1) : (n._$AddElseInstances$_(u1, a), 
            n._$SetSetPicked$_(u1))) : (r._$SetSetPicked$_(l1), n._$SetSetPicked$_(u1)), 
            l1.clear(), u1.clear(), r._$HasAnyInstances$_();
        }
    };
}

{
    const c1 = self._$C3$_;
    c1._$Behaviors$_._$LOS$_._$Acts$_ = {
        _$SetRange$_(t) {
            this._$_SetRange$_(t);
        },
        _$SetCone$_(t) {
            this._$_SetConeOfView$_(c1._$toRadians$_(t));
        },
        _$CastRay$_(t, s, i, e, h) {
            this._$CastRay$_(t, s, i, e, h);
        },
        _$AddObstacle$_(t) {
            this._$GetSdkType$_()._$AddObstacle$_(t);
        },
        _$ClearObstacles$_() {
            this._$GetSdkType$_()._$ClearObstacles$_();
        }
    };
}

{
    const f1 = self._$C3$_;
    f1._$Behaviors$_._$LOS$_._$Exps$_ = {
        Range() {
            return this._$_GetRange$_();
        },
        _$ConeOfView$_() {
            return f1._$toDegrees$_(this._$_GetConeOfView$_());
        },
        _$HitX$_() {
            return this._$_GetRayHitX$_();
        },
        _$HitY$_() {
            return this._$_GetRayHitY$_();
        },
        _$HitDistance$_() {
            return this._$_GetRayHitDistance$_();
        },
        _$HitUID$_() {
            return this._$_GetRayHitUID$_();
        },
        _$NormalX$_(t) {
            return this._$_GetRayNormalX$_(t);
        },
        _$NormalY$_(t) {
            return this._$_GetRayNormalY$_(t);
        },
        _$NormalAngle$_() {
            return f1._$toDegrees$_(this._$_GetRayNormalAngle$_());
        },
        _$ReflectionX$_(t) {
            return this._$_GetRayReflectionX$_(t);
        },
        _$ReflectionY$_(t) {
            return this._$_GetRayReflectionY$_(t);
        },
        _$ReflectionAngle$_() {
            return f1._$toDegrees$_(this._$_GetRayReflectionAngle$_());
        }
    };
}

{
    let t = function(t, s) {
        return "number" == typeof t && "number" == typeof s;
    }, e = function(i, e) {
        if ("string" != typeof i && "string" != typeof e) return i && e ? 1 : 0;
        {
            let t, s;
            return t = "number" == typeof i ? (Math.round(1e10 * i) / 1e10).toString() : i, 
            s = "number" == typeof e ? (Math.round(1e10 * e) / 1e10).toString() : e, 
            t + s;
        }
    };
    t, e, 0;
    const d1 = self._$C3$_;
    self._$C3_ExpressionFuncs$_ = [ () => "system", t => {
        const s = t._$_GetNode$_(0)._$GetBoundMethod$_(), i = t._$_GetNode$_(1)._$GetBoundMethod$_();
        return () => s(i());
    }, t => {
        const s = t._$_GetNode$_(0)._$GetBoundMethod$_(), i = t._$_GetNode$_(1);
        return () => s(i._$ExpObject$_(0), 1);
    }, () => 3, () => 0, t => {
        const s = t._$_GetNode$_(0);
        return () => s._$ExpObject$_();
    }, () => 1.4, () => 6, t => {
        const s = t._$_GetNode$_(0), i = t._$_GetNode$_(1);
        return () => d1._$lerp$_(s._$ExpObject$_(), i._$ExpObject$_(), .06);
    }, t => {
        const s = t._$_GetNode$_(0)._$GetVar$_();
        return () => s._$GetValue$_();
    }, () => "character", () => "animation", () => "idle", () => "jump", () => "fall", () => "run", () => "movements", () => -50, () => "jumpSound", () => 65, () => 30, () => "enemies", () => "enemy01", () => 1, () => 2, () => "enemy02", () => "enemy03", () => "life", () => "in collision with enemies", t => {
        const s = t._$_GetNode$_(0);
        return () => s._$ExpObject$_() - 5;
    }, () => -60, () => "hitSound", () => -800, () => "center", () => "", () => .07, () => .06, () => "Default", () => "in collision with lifeUp", () => "items", () => "liveSound", () => "Game Over", () => "Character", () => 640, () => 360, () => 1300, () => 800, () => 320, () => "select", () => 830, () => -10, () => "Paused Screen", () => 350, () => 186, () => -217, () => 20, () => 1359, () => -374, () => "Win Screen", t => {
        const s = t._$_GetNode$_(0)._$GetBoundMethod$_();
        return () => s();
    }, () => "1", () => "highscore1", () => "2", () => "highscore2", () => "3", () => "highscore3", () => "4", () => "highscore4", () => "5", () => "highscore5", () => "6", () => "highscore6", () => "winSound", () => 300, t => {
        const s = t._$_GetNode$_(0), i = t._$_GetNode$_(1)._$GetVar$_(), e = t._$_GetNode$_(2)._$GetVar$_(), h = t._$_GetNode$_(3)._$GetVar$_(), r = t._$_GetNode$_(4), n = t._$_GetNode$_(5)._$GetVar$_();
        return () => s._$ExpObject$_(i._$GetValue$_()) < e._$GetValue$_() ? h._$GetValue$_() : r._$ExpObject$_(n._$GetValue$_());
    }, t => {
        const s = t._$_GetNode$_(0)._$GetVar$_(), i = t._$_GetNode$_(1)._$GetBoundMethod$_(), e = t._$_GetNode$_(2), h = t._$_GetNode$_(3)._$GetVar$_(), r = t._$_GetNode$_(4)._$GetVar$_();
        return () => s._$GetValue$_() >= i(e._$ExpObject$_(0)) ? h._$GetValue$_() + 1 : r._$GetValue$_();
    }, t => {
        const s = t._$_GetNode$_(0)._$GetVar$_();
        return () => s._$GetValue$_() + 1;
    }, () => .05, t => {
        const s = t._$_GetNode$_(0)._$GetBoundMethod$_(), i = t._$_GetNode$_(1)._$GetBoundMethod$_();
        return () => (s(i()) + 1).toString();
    }, () => "collected stars", () => "domSound", () => 1e4, () => "points", () => "coinSound", () => 500, () => "item blocks", () => "hitbox", () => "hitbox2", () => 325, () => "elements", () => .15, t => {
        const s = t._$_GetNode$_(0);
        return () => s._$ExpInstVar$_();
    }, () => "box01inactive", () => "box02inactive", () => "hit", () => "local storage high scores", () => "highscore7", () => "highscore8", () => "highscore9", () => "highscore10", () => "local storage levels and stars", t => {
        const s = t._$_GetNode$_(0), i = t._$_GetNode$_(1)._$GetBoundMethod$_();
        return () => e(s._$ExpObject$_(i() + 1), "star");
    }, () => "lock", () => "ready", () => "sound button programming code3", () => -6, () => "initial", () => -150, () => -200, () => 1660, () => 1080, () => .5, t => {
        const s = t._$_GetNode$_(0);
        return () => s._$ExpInstVar$_().toString();
    }, () => -4, () => "intro", () => 224, t => {
        const s = t._$_GetNode$_(0), i = t._$_GetNode$_(1);
        return () => d1._$lerp$_(s._$ExpObject$_(), i._$ExpInstVar$_(), .08);
    }, t => {
        const s = t._$_GetNode$_(0), i = t._$_GetNode$_(1);
        return () => d1._$lerp$_(s._$ExpObject$_(), i._$ExpInstVar$_(), .07);
    }, t => {
        const s = t._$_GetNode$_(0), i = t._$_GetNode$_(1);
        return () => d1._$lerp$_(s._$ExpObject$_(), i._$ExpInstVar$_(), .06);
    }, () => 330, () => 641, () => -378, () => "sound button programming code" ];
}

var t = self._$C3$_;

self._$C3_GetObjectRefTable$_ = function() {
    return [ t._$Plugins$_.Audio, t._$Plugins$_.Keyboard, t._$Plugins$_.Touch, t._$Plugins$_.gamepad, t._$Plugins$_._$Arr$_, t._$Plugins$_._$LocalStorage$_, t._$Plugins$_._$Sprite$_, t._$Behaviors$_._$Pin$_, t._$Behaviors$_._$Sin$_, t._$Plugins$_._$Tilemap$_, t._$Plugins$_._$Spritefont2$_, t._$Plugins$_._$TiledBg$_, t._$Behaviors$_._$Fade$_, t._$Behaviors$_._$destroy$_, t._$Behaviors$_._$Bullet$_, t._$Behaviors$_._$Tween$_, t._$Behaviors$_._$scrollto$_, t._$Behaviors$_._$solid$_, t._$Behaviors$_._$jumpthru$_, t._$Behaviors$_._$Flash$_, t._$Behaviors$_._$Platform$_, t._$Behaviors$_._$LOS$_, t._$Plugins$_._$Particles$_, t._$Plugins$_._$System$_._$Cnds$_._$IsGroupActive$_, t._$Plugins$_._$System$_._$Cnds$_._$OnLayoutStart$_, t._$Plugins$_._$System$_._$Acts$_._$SetVar$_, t._$Plugins$_._$System$_._$Exps$_._$int$_, t._$Plugins$_._$System$_._$Exps$_._$layoutname$_, t._$Plugins$_._$System$_._$Exps$_.max, t._$Plugins$_._$Arr$_._$Exps$_._$At$_, t._$Plugins$_._$Particles$_._$Acts$_._$Destroy$_, t._$Plugins$_._$Sprite$_._$Acts$_._$SetPos$_, t._$Plugins$_._$Sprite$_._$Exps$_._$X$_, t._$Plugins$_._$Sprite$_._$Exps$_._$Y$_, t._$Behaviors$_._$Pin$_._$Acts$_._$Pin$_, t._$Plugins$_._$System$_._$Acts$_._$SetLayoutScale$_, t._$Plugins$_._$System$_._$Cnds$_._$Compare$_, t._$Plugins$_._$Sprite$_._$Acts$_._$Destroy$_, t._$Plugins$_._$System$_._$Cnds$_._$EveryTick$_, t._$Plugins$_._$Spritefont2$_._$Acts$_._$SetText$_, t._$Behaviors$_._$Platform$_._$Cnds$_._$CompareSpeed$_, t._$Behaviors$_._$Platform$_._$Cnds$_._$IsOnFloor$_, t._$Plugins$_._$Sprite$_._$Cnds$_._$IsBoolInstanceVarSet$_, t._$Plugins$_._$Sprite$_._$Acts$_._$SetAnim$_, t._$Behaviors$_._$Platform$_._$Cnds$_._$IsJumping$_, t._$Behaviors$_._$Platform$_._$Cnds$_._$IsFalling$_, t._$Plugins$_.Keyboard._$Cnds$_._$IsKeyDown$_, t._$Behaviors$_._$Platform$_._$Acts$_._$SimulateControl$_, t._$Plugins$_._$Sprite$_._$Acts$_._$SetMirrored$_, t._$Plugins$_.gamepad._$Cnds$_._$IsButtonDown$_, t._$Plugins$_.Touch._$Cnds$_._$IsTouchingObject$_, t._$Behaviors$_._$Platform$_._$Cnds$_._$OnJump$_, t._$Plugins$_.Audio._$Acts$_.Play, t._$Plugins$_._$Sprite$_._$Acts$_._$SetOpacity$_, t._$Plugins$_._$System$_._$Cnds$_._$Else$_, t._$Plugins$_._$Sprite$_._$Cnds$_._$CompareInstanceVar$_, t._$Plugins$_._$Sprite$_._$Cnds$_._$IsOverlapping$_, t._$Plugins$_._$Sprite$_._$Acts$_._$SetInstanceVar$_, t._$Plugins$_._$Sprite$_._$Cnds$_._$OnCollision$_, t._$Behaviors$_._$Flash$_._$Cnds$_._$IsFlashing$_, t._$Plugins$_._$Sprite$_._$Cnds$_._$CompareY$_, t._$Behaviors$_._$Platform$_._$Acts$_._$SetVectorY$_, t._$Plugins$_._$Sprite$_._$Acts$_._$Spawn$_, t._$Plugins$_._$System$_._$Acts$_._$SubVar$_, t._$Plugins$_._$Sprite$_._$Acts$_._$SetAnimFrame$_, t._$Behaviors$_._$Flash$_._$Acts$_._$Flash$_, t._$Behaviors$_._$Flash$_._$Cnds$_._$OnFlashEnded$_, t._$Plugins$_._$Sprite$_._$Cnds$_._$OnAnimFinished$_, t._$Plugins$_._$System$_._$Cnds$_._$CompareVar$_, t._$Plugins$_._$System$_._$Acts$_._$AddVar$_, t._$Behaviors$_._$Flash$_._$Acts$_._$StopFlashing$_, t._$Plugins$_._$System$_._$Acts$_._$SetGroupActive$_, t._$Plugins$_._$Sprite$_._$Acts$_._$SetSize$_, t._$Plugins$_._$System$_._$Acts$_._$SetTimescale$_, t._$Plugins$_._$System$_._$Acts$_._$RestartLayout$_, t._$Plugins$_.Touch._$Cnds$_._$OnTouchObject$_, t._$Plugins$_._$System$_._$Acts$_._$GoToLayout$_, t._$Plugins$_._$Sprite$_._$Cnds$_._$IsOutsideLayout$_, t._$ScriptsInEvents$_._$Esgame_Event74_Act1$_, t._$Plugins$_._$LocalStorage$_._$Acts$_._$SetItem$_, t._$Plugins$_.Audio._$Acts$_._$StopAll$_, t._$Plugins$_._$Arr$_._$Acts$_._$SetX$_, t._$Plugins$_._$Arr$_._$Exps$_._$AsJSON$_, t._$Plugins$_._$System$_._$Acts$_._$Wait$_, t._$Plugins$_._$System$_._$Acts$_._$GoToLayoutByName$_, t._$Plugins$_.Audio._$Acts$_._$Stop$_, t._$Plugins$_._$Sprite$_._$Acts$_._$SetPosToObject$_, t._$Plugins$_._$System$_._$Acts$_._$CreateObject$_, t._$Plugins$_._$Sprite$_._$Acts$_._$SubInstanceVar$_, t._$Behaviors$_._$Sin$_._$Acts$_._$SetEnabled$_, t._$Behaviors$_._$Sin$_._$Acts$_._$SetPhase$_, t._$Plugins$_._$Sprite$_._$Acts$_._$SetY$_, t._$Plugins$_._$Sprite$_._$Cnds$_._$IsAnimPlaying$_, t._$Plugins$_._$LocalStorage$_._$Acts$_._$CheckItemExists$_, t._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnItemExists$_, t._$Plugins$_._$LocalStorage$_._$Acts$_._$GetItem$_, t._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnItemGet$_, t._$Plugins$_._$LocalStorage$_._$Exps$_._$ItemValue$_, t._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnItemMissing$_, t._$Plugins$_._$Arr$_._$Acts$_._$JSONLoad$_, t._$Plugins$_._$System$_._$Cnds$_._$ForEach$_, t._$Plugins$_._$System$_._$Exps$_._$loopindex$_, t._$Plugins$_.Audio._$Acts$_._$SetMasterVolume$_, t._$Plugins$_.Audio._$Cnds$_._$IsAnyPlaying$_, t._$Plugins$_._$TiledBg$_._$Acts$_._$SetPos$_, t._$Plugins$_._$TiledBg$_._$Acts$_._$SetSize$_, t._$Plugins$_._$Spritefont2$_._$Acts$_._$SetVisible$_, t._$Behaviors$_._$Tween$_._$Acts$_._$TweenOneProperty$_, t._$Plugins$_._$Sprite$_._$Cnds$_._$CompareX$_, t._$Plugins$_._$Sprite$_._$Acts$_._$SetX$_, t._$Plugins$_._$Sprite$_._$Cnds$_._$IsVisible$_, t._$Plugins$_._$Sprite$_._$Cnds$_._$CompareFrame$_, t._$Plugins$_._$LocalStorage$_._$Acts$_._$ClearStorage$_, t._$Plugins$_._$Arr$_._$Acts$_._$Clear$_, t._$Plugins$_._$Sprite$_._$Acts$_._$SetVisible$_ ];
}, self._$C3_JsPropNameTable$_ = [ {
    Audio: 0
}, {
    Keyboard: 0
}, {
    Touch: 0
}, {
    Gamepad: 0
}, {
    Array: 0
}, {
    _$LocalStorage$_: 0
}, {
    _$Pin$_: 0
}, {
    _$btnNo$_: 0
}, {
    _$btn_yes$_: 0
}, {
    _$btn_Right$_: 0
}, {
    _$btn_continue$_: 0
}, {
    _$btn_Left$_: 0
}, {
    _$btn_home$_: 0
}, {
    _$btn_SoundOnOff$_: 0
}, {
    _$btn_menu$_: 0
}, {
    _$Fixar$_: 0
}, {
    _$btn_fullscreen$_: 0
}, {
    _$btn_pause$_: 0
}, {
    _$btn_no_newgame$_: 0
}, {
    targetX: 0
}, {
    _$btn_newGame2$_: 0
}, {
    _$btn_yes_newgame$_: 0
}, {
    _$btn_back$_: 0
}, {
    _$btn_back02$_: 0
}, {
    level: 0
}, {
    _$btn_back_initialScreen$_: 0
}, {
    _$btn_Jump$_: 0
}, {
    _$btn_newGame$_: 0
}, {
    _$btn_nextLevel$_: 0
}, {
    _$btn_credits$_: 0
}, {
    _$btn_controls$_: 0
}, {
    _$btnFull$_: 0
}, {
    _$btnAudio$_: 0
}, {
    _$btnMenu$_: 0
}, {
    _$Sine$_: 0
}, {
    _$coins$_: 0
}, {
    _$stars$_: 0
}, {
    _$lifeUp$_: 0
}, {
    _$Tileset1$_: 0
}, {
    _$Tileset2$_: 0
}, {
    _$Tileset3$_: 0
}, {
    loading: 0
}, {
    _$stars_GUI$_: 0
}, {
    _$starsWin$_: 0
}, {
    _$game_over_screen$_: 0
}, {
    _$label_Record$_: 0
}, {
    _$labelStarsCount2$_: 0
}, {
    _$count_stars_label1$_: 0
}, {
    _$points_count_label$_: 0
}, {
    _$labelPointsWin$_: 0
}, {
    _$newGameScreen$_: 0
}, {
    _$shadow$_: 0
}, {
    _$pauseScreen$_: 0
}, {
    _$ref_outsideLayout$_: 0
}, {
    _$highscore1_SF$_: 0
}, {
    _$highscore2_SF$_: 0
}, {
    _$highscore3_SF$_: 0
}, {
    _$winScreen$_: 0
}, {
    _$lifeUp_marker$_: 0
}, {
    _$highscore4_SF$_: 0
}, {
    _$highscore5_SF$_: 0
}, {
    _$loadingBGNew$_: 0
}, {
    _$highscore6_SF$_: 0
}, {
    _$creditsScreen$_: 0
}, {
    _$Fade$_: 0
}, {
    _$DestroyOutsideLayout$_: 0
}, {
    _$Bullet$_: 0
}, {
    _$labelPoints10000$_: 0
}, {
    _$score_label$_: 0
}, {
    _$logo_mn$_: 0
}, {
    _$Tween$_: 0
}, {
    _$logo_maria$_: 0
}, {
    _$ScrollTo$_: 0
}, {
    _$camera$_: 0
}, {
    _$explosion$_: 0
}, {
    _$box_shatter$_: 0
}, {
    _$splash_punch$_: 0
}, {
    _$startingY$_: 0
}, {
    _$itemCount$_: 0
}, {
    _$Solid$_: 0
}, {
    _$boxCoin01$_: 0
}, {
    _$boxCoin02$_: 0
}, {
    _$block_hitbox01$_: 0
}, {
    _$block_hitbox02$_: 0
}, {
    _$coin$_: 0
}, {
    _$bg_infoScreen$_: 0
}, {
    _$bgNightSky$_: 0
}, {
    _$initialScreen$_: 0
}, {
    _$levelselectbg$_: 0
}, {
    _$backgrounds_levels$_: 0
}, {
    _$Jumpthru$_: 0
}, {
    _$jumpCollision$_: 0
}, {
    _$solidCollision$_: 0
}, {
    _$in_level$_: 0
}, {
    _$winCollision$_: 0
}, {
    _$collision_L$_: 0
}, {
    _$collision_R$_: 0
}, {
    _$attackFloor$_: 0
}, {
    _$airAttack$_: 0
}, {
    _$Flash$_: 0
}, {
    _$player$_: 0
}, {
    _$Platform$_: 0
}, {
    _$charBox$_: 0
}, {
    _$moving$_: 0
}, {
    _$LineOfSight$_: 0
}, {
    _$enemy01$_: 0
}, {
    _$enemy02$_: 0
}, {
    _$enemy03$_: 0
}, {
    _$items_particle$_: 0
}, {
    _$enemies$_: 0
}, {
    _$score$_: 0
}, {
    _$audioGame$_: 0
}, {
    _$life$_: 0
}, {
    _$levelSelected$_: 0
}, {
    _$currentLevel$_: 0
}, {
    _$playableLevel$_: 0
}, {
    _$LSname$_: 0
}, {
    _$highscore1$_: 0
}, {
    _$highscore2$_: 0
}, {
    _$highscore3$_: 0
}, {
    _$highscore4$_: 0
}, {
    _$highscore5$_: 0
}, {
    _$highscore6$_: 0
} ], self._$InstanceType$_ = {
    Audio: class extends self._$IInstance$_ {},
    Keyboard: class extends self._$IInstance$_ {},
    Touch: class extends self._$IInstance$_ {},
    Gamepad: class extends self._$IInstance$_ {},
    Array: class extends self._$IArrayInstance$_ {},
    _$LocalStorage$_: class extends self._$IInstance$_ {},
    _$btnNo$_: class extends self._$ISpriteInstance$_ {},
    _$btn_yes$_: class extends self._$ISpriteInstance$_ {},
    _$btn_Right$_: class extends self._$ISpriteInstance$_ {},
    _$btn_continue$_: class extends self._$ISpriteInstance$_ {},
    _$btn_Left$_: class extends self._$ISpriteInstance$_ {},
    _$btn_home$_: class extends self._$ISpriteInstance$_ {},
    _$btn_SoundOnOff$_: class extends self._$ISpriteInstance$_ {},
    _$btn_menu$_: class extends self._$ISpriteInstance$_ {},
    _$btn_fullscreen$_: class extends self._$ISpriteInstance$_ {},
    _$btn_pause$_: class extends self._$ISpriteInstance$_ {},
    _$btn_no_newgame$_: class extends self._$ISpriteInstance$_ {},
    _$btn_newGame2$_: class extends self._$ISpriteInstance$_ {},
    _$btn_yes_newgame$_: class extends self._$ISpriteInstance$_ {},
    _$btn_back$_: class extends self._$ISpriteInstance$_ {},
    _$btn_back02$_: class extends self._$ISpriteInstance$_ {},
    level: class extends self._$ISpriteInstance$_ {},
    _$btn_back_initialScreen$_: class extends self._$ISpriteInstance$_ {},
    _$btn_Jump$_: class extends self._$ISpriteInstance$_ {},
    _$btn_newGame$_: class extends self._$ISpriteInstance$_ {},
    _$btn_nextLevel$_: class extends self._$ISpriteInstance$_ {},
    _$btn_credits$_: class extends self._$ISpriteInstance$_ {},
    _$btn_controls$_: class extends self._$ISpriteInstance$_ {},
    _$btnFull$_: class extends self._$ISpriteInstance$_ {},
    _$btnAudio$_: class extends self._$ISpriteInstance$_ {},
    _$btnMenu$_: class extends self._$ISpriteInstance$_ {},
    _$coins$_: class extends self._$ISpriteInstance$_ {},
    _$stars$_: class extends self._$ISpriteInstance$_ {},
    _$lifeUp$_: class extends self._$ISpriteInstance$_ {},
    _$Tileset1$_: class extends self._$ITilemapInstance$_ {},
    _$Tileset2$_: class extends self._$ITilemapInstance$_ {},
    _$Tileset3$_: class extends self._$ITilemapInstance$_ {},
    loading: class extends self._$ISpriteFontInstance$_ {},
    _$stars_GUI$_: class extends self._$ISpriteInstance$_ {},
    _$starsWin$_: class extends self._$ISpriteInstance$_ {},
    _$game_over_screen$_: class extends self._$ISpriteInstance$_ {},
    _$label_Record$_: class extends self._$ISpriteFontInstance$_ {},
    _$labelStarsCount2$_: class extends self._$ISpriteFontInstance$_ {},
    _$count_stars_label1$_: class extends self._$ISpriteFontInstance$_ {},
    _$points_count_label$_: class extends self._$ISpriteFontInstance$_ {},
    _$labelPointsWin$_: class extends self._$ISpriteFontInstance$_ {},
    _$newGameScreen$_: class extends self._$ISpriteInstance$_ {},
    _$shadow$_: class extends self._$ISpriteInstance$_ {},
    _$pauseScreen$_: class extends self._$ISpriteInstance$_ {},
    _$ref_outsideLayout$_: class extends self._$ISpriteInstance$_ {},
    _$highscore1_SF$_: class extends self._$ISpriteFontInstance$_ {},
    _$highscore2_SF$_: class extends self._$ISpriteFontInstance$_ {},
    _$highscore3_SF$_: class extends self._$ISpriteFontInstance$_ {},
    _$winScreen$_: class extends self._$ISpriteInstance$_ {},
    _$lifeUp_marker$_: class extends self._$ISpriteInstance$_ {},
    _$highscore4_SF$_: class extends self._$ISpriteFontInstance$_ {},
    _$highscore5_SF$_: class extends self._$ISpriteFontInstance$_ {},
    _$loadingBGNew$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$highscore6_SF$_: class extends self._$ISpriteFontInstance$_ {},
    _$creditsScreen$_: class extends self._$ISpriteInstance$_ {},
    _$labelPoints10000$_: class extends self._$ISpriteInstance$_ {},
    _$score_label$_: class extends self._$ISpriteFontInstance$_ {},
    _$logo_mn$_: class extends self._$ISpriteInstance$_ {},
    _$logo_maria$_: class extends self._$ISpriteInstance$_ {},
    _$camera$_: class extends self._$ISpriteInstance$_ {},
    _$explosion$_: class extends self._$ISpriteInstance$_ {},
    _$box_shatter$_: class extends self._$ISpriteInstance$_ {},
    _$splash_punch$_: class extends self._$ISpriteInstance$_ {},
    _$boxCoin01$_: class extends self._$ISpriteInstance$_ {},
    _$boxCoin02$_: class extends self._$ISpriteInstance$_ {},
    _$block_hitbox01$_: class extends self._$ISpriteInstance$_ {},
    _$block_hitbox02$_: class extends self._$ISpriteInstance$_ {},
    _$coin$_: class extends self._$ISpriteInstance$_ {},
    _$bg_infoScreen$_: class extends self._$ISpriteInstance$_ {},
    _$bgNightSky$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$initialScreen$_: class extends self._$ISpriteInstance$_ {},
    _$levelselectbg$_: class extends self._$ISpriteInstance$_ {},
    _$backgrounds_levels$_: class extends self._$ISpriteInstance$_ {},
    _$jumpCollision$_: class extends self._$ISpriteInstance$_ {},
    _$solidCollision$_: class extends self._$ISpriteInstance$_ {},
    _$winCollision$_: class extends self._$ISpriteInstance$_ {},
    _$collision_L$_: class extends self._$ISpriteInstance$_ {},
    _$collision_R$_: class extends self._$ISpriteInstance$_ {},
    _$player$_: class extends self._$ISpriteInstance$_ {},
    _$charBox$_: class extends self._$ISpriteInstance$_ {},
    _$enemy01$_: class extends self._$ISpriteInstance$_ {},
    _$enemy02$_: class extends self._$ISpriteInstance$_ {},
    _$enemy03$_: class extends self._$ISpriteInstance$_ {},
    _$items_particle$_: class extends self._$IParticlesInstance$_ {},
    _$enemies$_: class extends self._$ISpriteInstance$_ {}
}, runOnStartup(async t => {
    t.addEventListener("beforeprojectstart", () => (async t => {
         document.body.style.backgroundColor = 'transparent';
        t.addEventListener("tick", () => {});
    })(t));
}), self._$C3$_._$ScriptsInEvents$_ = {
    async _$Esgame_Event74_Act1$_(t, s) {
        parent.postMessage("completeFase", "*");
    }
};