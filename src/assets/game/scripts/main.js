// Generated by Construct, the game and animation creation tool
// Visit: https://www.construct.net

"use strict";

window._$DOMHandler$_ = class {
    constructor(t, s) {
        this._$_iRuntime$_ = t, this._$_componentId$_ = s, this._$_hasTickCallback$_ = !1, 
        this._$_tickCallback$_ = () => this._$Tick$_();
    }
    _$Attach$_() {}
    _$PostToRuntime$_(t, s, i, e) {
        this._$_iRuntime$_._$PostToRuntimeComponent$_(this._$_componentId$_, t, s, i, e);
    }
    _$PostToRuntimeAsync$_(t, s, i, e) {
        return this._$_iRuntime$_._$PostToRuntimeComponentAsync$_(this._$_componentId$_, t, s, i, e);
    }
    _$_PostToRuntimeMaybeSync$_(t, s, i) {
        this._$_iRuntime$_._$UsesWorker$_() ? this._$PostToRuntime$_(t, s, i) : this._$_iRuntime$_._$_GetLocalRuntime$_()._OnMessageFromDOM({
            type: "event",
            component: this._$_componentId$_,
            handler: t,
            dispatchOpts: i || null,
            data: s,
            responseId: null
        });
    }
    _$AddRuntimeMessageHandler$_(t, s) {
        this._$_iRuntime$_._$AddRuntimeComponentMessageHandler$_(this._$_componentId$_, t, s);
    }
    _$AddRuntimeMessageHandlers$_(t) {
        for (const [ s, i ] of t) this._$AddRuntimeMessageHandler$_(s, i);
    }
    _$GetRuntimeInterface$_() {
        return this._$_iRuntime$_;
    }
    _$GetComponentID$_() {
        return this._$_componentId$_;
    }
    _$_StartTicking$_() {
        this._$_hasTickCallback$_ || (this._$_iRuntime$_._$_AddRAFCallback$_(this._$_tickCallback$_), 
        this._$_hasTickCallback$_ = !0);
    }
    _$_StopTicking$_() {
        this._$_hasTickCallback$_ && (this._$_iRuntime$_._$_RemoveRAFCallback$_(this._$_tickCallback$_), 
        this._$_hasTickCallback$_ = !1);
    }
    _$Tick$_() {}
}, window._$RateLimiter$_ = class {
    constructor(t, s) {
        this._$_callback$_ = t, this._$_interval$_ = s, this._$_timerId$_ = -1, 
        this._$_lastCallTime$_ = -1 / 0, this._$_timerCallFunc$_ = () => this._$_OnTimer$_(), 
        this._$_ignoreReset$_ = !1, this._$_canRunImmediate$_ = !1;
    }
    _$SetCanRunImmediate$_(t) {
        this._$_canRunImmediate$_ = !!t;
    }
    _$Call$_() {
        if (-1 === this._$_timerId$_) {
            const t = Date.now(), s = t - this._$_lastCallTime$_, i = this._$_interval$_;
            i <= s && this._$_canRunImmediate$_ ? (this._$_lastCallTime$_ = t, this._$_RunCallback$_()) : this._$_timerId$_ = self.setTimeout(this._$_timerCallFunc$_, Math.max(i - s, 4));
        }
    }
    _$_RunCallback$_() {
        this._$_ignoreReset$_ = !0, this._$_callback$_(), this._$_ignoreReset$_ = !1;
    }
    _$Reset$_() {
        this._$_ignoreReset$_ || (this._$_CancelTimer$_(), this._$_lastCallTime$_ = Date.now());
    }
    _$_OnTimer$_() {
        this._$_timerId$_ = -1, this._$_lastCallTime$_ = Date.now(), this._$_RunCallback$_();
    }
    _$_CancelTimer$_() {
        -1 !== this._$_timerId$_ && (self.clearTimeout(this._$_timerId$_), this._$_timerId$_ = -1);
    }
    _$Release$_() {
        this._$_CancelTimer$_(), this._$_callback$_ = null, this._$_timerCallFunc$_ = null;
    }
};

{
    class A {
        constructor(t) {
            this._$_elem$_ = t, this._$_hadFirstUpdate$_ = !1, this._$_isVisibleFlag$_ = !0, 
            this._$_wantHtmlIndex$_ = -1, this._$_actualHtmlIndex$_ = -1, this._$_htmlZIndex$_ = -1;
        }
        _$SetVisibleFlag$_(t) {
            this._$_isVisibleFlag$_ = !!t;
        }
        _$GetVisibleFlag$_() {
            return this._$_isVisibleFlag$_;
        }
        _$HadFirstUpdate$_() {
            return this._$_hadFirstUpdate$_;
        }
        _$SetHadFirstUpdate$_() {
            this._$_hadFirstUpdate$_ = !0;
        }
        _$GetWantHTMLIndex$_() {
            return this._$_wantHtmlIndex$_;
        }
        _$SetWantHTMLIndex$_(t) {
            this._$_wantHtmlIndex$_ = t;
        }
        _$GetActualHTMLIndex$_() {
            return this._$_actualHtmlIndex$_;
        }
        _$SetActualHTMLIndex$_(t) {
            this._$_actualHtmlIndex$_ = t;
        }
        _$SetHTMLZIndex$_(t) {
            this._$_htmlZIndex$_ = t;
        }
        _$GetHTMLZIndex$_() {
            return this._$_htmlZIndex$_;
        }
        _$GetElement$_() {
            return this._$_elem$_;
        }
    }
    window._$DOMElementHandler$_ = class extends self._$DOMHandler$_ {
        constructor(t, s) {
            super(t, s), this._$_elementMap$_ = new Map(), this._$_autoAttach$_ = !0, 
            this._$AddRuntimeMessageHandlers$_([ [ "create", t => this._$_OnCreate$_(t) ], [ "destroy", t => this._$_OnDestroy$_(t) ], [ "set-visible", t => this._$_OnSetVisible$_(t) ], [ "update-position", t => this._$_OnUpdatePosition$_(t) ], [ "update-state", t => this._$_OnUpdateState$_(t) ], [ "focus", t => this._$_OnSetFocus$_(t) ], [ "set-css-style", t => this._$_OnSetCssStyle$_(t) ], [ "set-attribute", t => this._$_OnSetAttribute$_(t) ], [ "remove-attribute", t => this._$_OnRemoveAttribute$_(t) ] ]), 
            this._$AddDOMElementMessageHandler$_("get-element", t => t);
        }
        _$SetAutoAttach$_(t) {
            this._$_autoAttach$_ = !!t;
        }
        _$AddDOMElementMessageHandler$_(t, e) {
            this._$AddRuntimeMessageHandler$_(t, t => {
                const s = t.elementId, i = this._$GetElementById$_(s);
                return e(i, t);
            });
        }
        _$AddDOMElementMessageHandlers$_(t) {
            for (const [ s, i ] of t) this._$AddDOMElementMessageHandler$_(s, i);
        }
        _$_OnCreate$_(t) {
            const s = t.elementId, i = this._$CreateElement$_(s, t), e = new A(i), h = (this._$_elementMap$_.set(s, e), 
            i.style.boxSizing = "border-box", i.style.display = "none", e._$SetVisibleFlag$_(t.isVisible), 
            this._$_GetFocusElement$_(i)), n = (h.addEventListener("focus", t => this._$_OnFocus$_(s)), 
            h.addEventListener("blur", t => this._$_OnBlur$_(s)), t.htmlIndex);
            if (e._$SetWantHTMLIndex$_(n), e._$SetHTMLZIndex$_(t.htmlZIndex), this._$_autoAttach$_) {
                const o = this._$GetRuntimeInterface$_()._$GetAvailableHTMLIndex$_(n), r = (e._$SetActualHTMLIndex$_(o), 
                this._$GetRuntimeInterface$_()._$GetHTMLWrapElement$_(o));
                r.appendChild(i);
            }
        }
        _$CreateElement$_(t, s) {
            throw new Error("required override");
        }
        _$DestroyElement$_(t) {}
        _$_OnDestroy$_(t) {
            const s = t.elementId, i = this._$GetElementById$_(s);
            this._$DestroyElement$_(i), this._$_autoAttach$_ && i.parentElement.removeChild(i), 
            this._$_elementMap$_.delete(s);
        }
        _$PostToRuntimeElement$_(t, s, i) {
            (i = i || {}).elementId = s, this._$PostToRuntime$_(t, i);
        }
        _$_PostToRuntimeElementMaybeSync$_(t, s, i) {
            (i = i || {}).elementId = s, this._$_PostToRuntimeMaybeSync$_(t, i);
        }
        _$_OnSetVisible$_(t) {
            if (this._$_autoAttach$_) {
                const s = this._$_elementMap$_.get(t.elementId), i = s._$GetElement$_();
                s._$HadFirstUpdate$_() ? i.style.display = t.isVisible ? "" : "none" : s._$SetVisibleFlag$_(t.isVisible);
            }
        }
        _$_OnUpdatePosition$_(t) {
            if (this._$_autoAttach$_) {
                const s = this._$_elementMap$_.get(t.elementId), i = s._$GetElement$_(), e = this._$GetRuntimeInterface$_(), h = (i.style.left = t.left + "px", 
                i.style.top = t.top + "px", i.style.width = t.width + "px", i.style.height = t.height + "px", 
                t.fontSize), n = (null !== h && (i.style.fontSize = h + "em"), t.htmlIndex), o = (s._$SetWantHTMLIndex$_(n), 
                e._$GetAvailableHTMLIndex$_(n));
                if (o !== s._$GetActualHTMLIndex$_()) {
                    i.remove();
                    const a = e._$GetHTMLWrapElement$_(o);
                    a.appendChild(i), s._$SetActualHTMLIndex$_(o), e._$_UpdateHTMLElementsZOrder$_();
                }
                const r = t.htmlZIndex;
                r !== s._$GetHTMLZIndex$_() && (s._$SetHTMLZIndex$_(r), e._$_UpdateHTMLElementsZOrder$_()), 
                s._$HadFirstUpdate$_() || (s._$SetHadFirstUpdate$_(), s._$GetVisibleFlag$_() && (i.style.display = ""));
            }
        }
        _$_OnHTMLLayersChanged$_() {
            if (this._$_autoAttach$_) for (const t of this._$_elementMap$_.values()) {
                const s = this._$GetRuntimeInterface$_()._$GetAvailableHTMLIndex$_(t._$GetWantHTMLIndex$_()), i = t._$GetActualHTMLIndex$_();
                if (-1 !== s && -1 !== i && s !== i) {
                    const e = t._$GetElement$_(), h = (e.remove(), this._$GetRuntimeInterface$_()._$GetHTMLWrapElement$_(s));
                    h.appendChild(e), t._$SetActualHTMLIndex$_(s);
                }
            }
        }
        _$_GetAllElementStatesForZOrderUpdate$_() {
            return this._$_autoAttach$_ ? [ ...this._$_elementMap$_.values() ] : null;
        }
        _$_OnUpdateState$_(t) {
            const s = this._$GetElementById$_(t.elementId);
            this._$UpdateState$_(s, t);
        }
        _$UpdateState$_(t, s) {
            throw new Error("required override");
        }
        _$_GetFocusElement$_(t) {
            return t;
        }
        _$_OnFocus$_(t) {
            this._$PostToRuntimeElement$_("elem-focused", t);
        }
        _$_OnBlur$_(t) {
            this._$PostToRuntimeElement$_("elem-blurred", t);
        }
        _$_OnSetFocus$_(t) {
            const s = this._$_GetFocusElement$_(this._$GetElementById$_(t.elementId));
            t.focus ? s.focus() : s.blur();
        }
        _$_OnSetCssStyle$_(t) {
            const s = this._$GetElementById$_(t.elementId), i = t.prop, e = t.val;
            i.startsWith("--") ? s.style.setProperty(i, e) : s.style[i] = e;
        }
        _$_OnSetAttribute$_(t) {
            const s = this._$GetElementById$_(t.elementId);
            s.setAttribute(t.name, t.val);
        }
        _$_OnRemoveAttribute$_(t) {
            const s = this._$GetElementById$_(t.elementId);
            s.removeAttribute(t.name);
        }
        _$GetElementById$_(t) {
            const s = this._$_elementMap$_.get(t);
            if (s) return s._$GetElement$_();
            throw new Error("no element with id " + t);
        }
    };
}

{
    const e0 = /(iphone|ipod|ipad|macos|macintosh|mac os x)/i.test(navigator.userAgent), f0 = /android/i.test(navigator.userAgent), g0 = /safari/i.test(navigator.userAgent) && !/(chrome|chromium|edg\/|OPR\/|nwjs)/i.test(navigator.userAgent);
    let h = 0;
    function AddScript(i) {
        const e = document.createElement("script");
        return e.async = !1, e.type = "module", i._$isStringSrc$_ ? new Promise(t => {
            const s = "c3_resolve_" + h;
            ++h, self[s] = t, e.textContent = i.str + `

self["${s}"]();`, document.head.appendChild(e);
        }) : new Promise((t, s) => {
            e.onload = t, e.onerror = s, e.src = i, document.head.appendChild(e);
        });
    }
    async function CheckSupportsWorkerMode() {
        if (!navigator.userActivation || "undefined" == typeof OffscreenCanvas) return !1;
        try {
            let t = !1;
            const s = new Blob([ `
	self.addEventListener("message", () =>
	{
		try {
			const offscreenCanvas = new OffscreenCanvas(32, 32);
			const gl = offscreenCanvas.getContext("webgl");
			self.postMessage(!!gl);
		}
		catch (err)
		{
			console.warn("Feature detection worker error:", err);
			self.postMessage(false);
		}
	});` ], {
                type: "text/javascript"
            }), i = new Worker(URL.createObjectURL(s), {
                get type() {
                    t = !0;
                }
            }), e = await new Promise(s => {
                i.addEventListener("message", t => {
                    i.terminate(), s(t.data);
                }), i.postMessage("");
            });
            return t && e;
        } catch (t) {
            return console.warn("Error feature detecting worker mode: ", t), !1;
        }
    }
    let t = new Audio();
    const j0 = {
        "audio/webm; codecs=opus": !!t.canPlayType("audio/webm; codecs=opus"),
        "audio/ogg; codecs=opus": !!t.canPlayType("audio/ogg; codecs=opus"),
        "audio/webm; codecs=vorbis": !!t.canPlayType("audio/webm; codecs=vorbis"),
        "audio/ogg; codecs=vorbis": !!t.canPlayType("audio/ogg; codecs=vorbis"),
        "audio/mp4": !!t.canPlayType("audio/mp4"),
        "audio/mpeg": !!t.canPlayType("audio/mpeg")
    };
    async function BlobToString(t) {
        const s = await BlobToArrayBuffer(t), i = new TextDecoder("utf-8");
        return i.decode(s);
    }
    function BlobToArrayBuffer(e) {
        return new Promise((s, i) => {
            const t = new FileReader();
            t.onload = t => s(t.target.result), t.onerror = t => i(t), t.readAsArrayBuffer(e);
        });
    }
    t = null;
    const k0 = [];
    let e = 0;
    const m0 = 8, n0 = (window.RealFile = window.File, []), o0 = new Map(), p0 = new Map();
    let r = 0;
    const r0 = [], s0 = (self.runOnStartup = function(t) {
        if ("function" != typeof t) throw new Error("runOnStartup called without a function");
        r0.push(t);
    }, new Set([ "cordova", "playable-ad-single-file", "playable-ad-zip", "instant-games" ]));
    function IsWebViewExportType(t) {
        return s0.has(t);
    }
    let s = !1;
    window._$RuntimeInterface$_ = class U0 {
        constructor(t) {
            if (this._$_useWorker$_ = t._$useWorker$_, this._$_messageChannelPort$_ = null, 
            this._$_runtimeBaseUrl$_ = "", this._$_scriptFolder$_ = t.scriptFolder, 
            this._$_worker$_ = null, this._$_localRuntime$_ = null, this._$_domHandlers$_ = [], 
            this._$_runtimeDomHandler$_ = null, this._$_isFirstSizeUpdate$_ = !0, 
            this._$_canvasLayers$_ = [], this._$_pendingRemoveElements$_ = [], this._$_pendingUpdateHTMLZOrder$_ = !1, 
            this._$_updateHTMLZOrderRAFCallback$_ = () => this._$_DoUpdateHTMLElementsZOrder$_(), 
            this._$_isExportingToVideo$_ = !1, this._$_exportToVideoDuration$_ = 0, 
            this._$_jobScheduler$_ = null, this._$_rafId$_ = -1, this._$_rafFunc$_ = () => this._$_OnRAFCallback$_(), 
            this._$_rafCallbacks$_ = new Set(), this._$_wrapperInitResolve$_ = null, 
            this._$_wrapperComponentIds$_ = [], this._$_exportType$_ = t.exportType, 
            this._$_isFileProtocol$_ = "file" === location.protocol.substr(0, 4), 
            this._$_directoryHandles$_ = [], "playable-ad-single-file" !== this._$_exportType$_ && "playable-ad-zip" !== this._$_exportType$_ && "instant-games" !== this._$_exportType$_ || (this._$_useWorker$_ = !1), 
            g0 && (this._$_useWorker$_ = !1), "cordova" === this._$_exportType$_ && this._$_useWorker$_ && f0) {
                const s = /Chrome\/(\d+)/i.exec(navigator.userAgent);
                s && 90 <= parseInt(s[1], 10) || (this._$_useWorker$_ = !1);
            }
            this._$IsAnyWebView2Wrapper$_() ? self.chrome.webview.addEventListener("message", t => this._$_OnWrapperMessage$_(t.data, t.additionalObjects)) : "macos-wkwebview" === this._$_exportType$_ && (self.C3WrapperOnMessage = t => this._$_OnWrapperMessage$_(t)), 
            this._$_localFileBlobs$_ = null, this._$_localFileStrings$_ = null, 
            "html5" !== this._$_exportType$_ || window.isSecureContext || console.warn("[Construct] Warning: the browser indicates this is not a secure context. Some features may be unavailable. Use secure (HTTPS) hosting to ensure all features are available."), 
            this._$AddRuntimeComponentMessageHandler$_("canvas", "update-size", t => this._$_OnUpdateCanvasSize$_(t)), 
            this._$AddRuntimeComponentMessageHandler$_("canvas", "set-html-layer-count", t => this._OnSetHTMLLayerCount(t)), 
            this._$AddRuntimeComponentMessageHandler$_("canvas", "cleanup-html-layers", () => this._$_OnCleanUpHTMLLayers$_()), 
            this._$AddRuntimeComponentMessageHandler$_("runtime", "cordova-fetch-local-file", t => this._$_OnCordovaFetchLocalFile$_(t)), 
            this._$AddRuntimeComponentMessageHandler$_("runtime", "create-job-worker", t => this._$_OnCreateJobWorker$_(t)), 
            this._$AddRuntimeComponentMessageHandler$_("runtime", "send-wrapper-extension-message", t => this._$_OnSendWrapperExtensionMessage$_(t)), 
            "cordova" === this._$_exportType$_ ? document.addEventListener("deviceready", () => this._$_Init$_(t)) : this._$_Init$_(t);
        }
        _$Release$_() {
            this._$_CancelAnimationFrame$_(), this._$_messageChannelPort$_ && (this._$_messageChannelPort$_.onmessage = null, 
            this._$_messageChannelPort$_ = null), this._$_worker$_ && (this._$_worker$_.terminate(), 
            this._$_worker$_ = null), this._$_localRuntime$_ && (this._$_localRuntime$_._$Release$_(), 
            this._$_localRuntime$_ = null);
            for (const {
                canvas: t,
                _$htmlWrap$_: s
            } of this._$_canvasLayers$_) t.remove(), s.remove();
            this._$_canvasLayers$_.length = 0;
        }
        _$GetMainCanvas$_() {
            return this._$_canvasLayers$_[0].canvas;
        }
        _$GetAvailableHTMLIndex$_(t) {
            return Math.min(t, this._$_canvasLayers$_.length - 1);
        }
        _$GetHTMLWrapElement$_(t) {
            if (t < 0 || t >= this._$_canvasLayers$_.length) throw new RangeError("invalid canvas layer");
            return this._$_canvasLayers$_[t]._$htmlWrap$_;
        }
        ["_GetHTMLWrapElement"](t) {
            return this._$GetHTMLWrapElement$_(t);
        }
        _$GetRuntimeBaseURL$_() {
            return this._$_runtimeBaseUrl$_;
        }
        _$UsesWorker$_() {
            return this._$_useWorker$_;
        }
        _$GetExportType$_() {
            return this._$_exportType$_;
        }
        _$IsFileProtocol$_() {
            return this._$_isFileProtocol$_;
        }
        _$GetScriptFolder$_() {
            return this._$_scriptFolder$_;
        }
        _$IsiOSCordova$_() {
            return e0 && "cordova" === this._$_exportType$_;
        }
        _$IsiOSWebView$_() {
            const t = navigator.userAgent;
            return e0 && IsWebViewExportType(this._$_exportType$_) || navigator.standalone || /crios\/|fxios\/|edgios\//i.test(t);
        }
        _$IsAndroid$_() {
            return f0;
        }
        _$IsAndroidWebView$_() {
            return f0 && IsWebViewExportType(this._$_exportType$_);
        }
        _$IsWindowsWebView2$_() {
            return "windows-webview2" === this._$_exportType$_ || !!("preview" === this._$_exportType$_ && window.chrome && window.chrome.webview && window.chrome.webview.postMessage);
        }
        _$IsAnyWebView2Wrapper$_() {
            return this._$IsWindowsWebView2$_() || "xbox-uwp-webview2" === this._$_exportType$_;
        }
        async _$_Init$_(t) {
            if (this._$_useWorker$_) {
                const i = await CheckSupportsWorkerMode();
                i || (this._$_useWorker$_ = !1);
            }
            if ("macos-wkwebview" === this._$_exportType$_) this._$_SendWrapperMessage$_({
                type: "ready"
            }); else if (this._$IsAnyWebView2Wrapper$_()) {
                this._$_SetupWebView2Polyfills$_();
                const e = await this._$_InitWrapper$_();
                this._$_wrapperComponentIds$_ = e.registeredComponentIds;
            }
            if ("playable-ad-single-file" === this._$_exportType$_ && (this._$_localFileBlobs$_ = self.c3_base64files, 
            this._$_localFileStrings$_ = {}, await this._$_ConvertDataUrisToBlobs$_()), 
            "nwjs" === this._$_exportType$_ && self.nw && self.nw.App.manifest["c3-steam-mode"]) {
                let t = 0;
                this._$_AddRAFCallback$_(() => {
                    t++, document.documentElement.style.opacity = t % 2 == 0 ? "1" : "0.999";
                });
            }
            if (t.runtimeBaseUrl) this._$_runtimeBaseUrl$_ = t.runtimeBaseUrl; else {
                const h = location.origin, n = (this._$_runtimeBaseUrl$_ = ("null" === h ? "file:///" : h) + location.pathname, 
                this._$_runtimeBaseUrl$_.lastIndexOf("/"));
                -1 !== n && (this._$_runtimeBaseUrl$_ = this._$_runtimeBaseUrl$_.substr(0, n + 1));
            }
            const s = new MessageChannel();
            if (this._$_messageChannelPort$_ = s.port1, this._$_messageChannelPort$_.onmessage = t => this._OnMessageFromRuntime(t.data), 
            window.c3_addPortMessageHandler && window.c3_addPortMessageHandler(t => this._$_OnMessageFromDebugger$_(t)), 
            this._$_jobScheduler$_ = new self._$JobSchedulerDOM$_(this), await this._$_jobScheduler$_._$Init$_(), 
            "object" == typeof window.StatusBar && window.StatusBar.hide(), "object" == typeof window.AndroidFullScreen) try {
                await new Promise((t, s) => {
                    window.AndroidFullScreen.immersiveMode(t, s);
                });
            } catch (t) {
                console.error("Failed to enter Android immersive mode: ", t);
            }
            this._$_useWorker$_ ? await this._$_InitWorker$_(t, s.port2) : await this._$_InitDOM$_(t, s.port2);
        }
        _$_GetCommonRuntimeOptions$_(t) {
            return {
                runtimeBaseUrl: this._$_runtimeBaseUrl$_,
                previewUrl: location.href,
                windowInnerWidth: this._$_GetWindowInnerWidth$_(),
                windowInnerHeight: this._$_GetWindowInnerHeight$_(),
                cssDisplayMode: this._$GetCssDisplayMode$_(),
                devicePixelRatio: window.devicePixelRatio,
                isFullscreen: U0._$IsDocumentFullscreen$_(),
                swClientId: window.cr_swClientId || "",
                exportType: t.exportType,
                fileMap: globalThis.c3_swFileMap ?? new Map(Object.entries(this._$_localFileBlobs$_ ?? {})),
                scriptFolder: this._$_scriptFolder$_,
                isDebug: new URLSearchParams(self.location.search).has("debug"),
                ife: !!self.ife,
                jobScheduler: this._$_jobScheduler$_._$GetPortData$_(),
                supportedAudioFormats: j0,
                isFileProtocol: this._$_isFileProtocol$_,
                isiOSCordova: this._$IsiOSCordova$_(),
                isiOSWebView: this._$IsiOSWebView$_(),
                isWindowsWebView2: this._$IsWindowsWebView2$_(),
                isAnyWebView2Wrapper: this._$IsAnyWebView2Wrapper$_(),
                wrapperComponentIds: this._$_wrapperComponentIds$_,
                isFBInstantAvailable: void 0 !== self.FBInstant
            };
        }
        async _$_InitWorker$_(t, s) {
            const h = t._$workerMainUrl$_, i = ("preview" === this._$_exportType$_ ? (this._$_worker$_ = new Worker("previewworker.js", {
                type: "module",
                name: "Runtime"
            }), await new Promise((s, i) => {
                const e = t => {
                    this._$_worker$_.removeEventListener("message", e), (t.data && "ok" === t.data.type ? s : i)();
                };
                this._$_worker$_.addEventListener("message", e), this._$_worker$_.postMessage({
                    type: "construct-worker-init",
                    import: new URL(h, this._$_runtimeBaseUrl$_).toString()
                });
            })) : this._$_worker$_ = await this._$CreateWorker$_(h, {
                type: "module",
                name: "Runtime"
            }), document.createElement("canvas")), e = (i.style.display = "none", 
            i.transferControlToOffscreen()), n = (document.body.appendChild(i), 
            document.createElement("div"));
            n.className = "c3htmlwrap", document.body.appendChild(n), this._$_canvasLayers$_.push({
                canvas: i,
                _$htmlWrap$_: n
            }), window.c3canvas = i, self.C3_InsertHTMLPlaceholders && self.C3_InsertHTMLPlaceholders(), 
            this._$_worker$_.postMessage(Object.assign(this._$_GetCommonRuntimeOptions$_(t), {
                type: "init-runtime",
                isInWorker: !0,
                messagePort: s,
                canvas: e,
                runtimeScriptList: t.runtimeScriptList,
                projectMainScriptPath: t.projectMainScriptPath,
                scriptsInEventsPath: t.scriptsInEventsPath
            }), [ s, e, ...this._$_jobScheduler$_._$GetPortTransferables$_() ]), 
            this._$_domHandlers$_ = n0.map(t => new t(this)), this._$_FindRuntimeDOMHandler$_(), 
            this._$_runtimeDomHandler$_._$_AddDefaultCanvasEventHandlers$_(i), this._$_runtimeDomHandler$_._$_AddDefaultHTMLWrapEventHandlers$_(n), 
            this._$_runtimeDomHandler$_._$_EnableWindowResizeEvent$_(), self.c3_callFunction = (t, s) => this._$_runtimeDomHandler$_._$_InvokeFunctionFromJS$_(t, s), 
            "preview" === this._$_exportType$_ && (self.goToLastErrorScript = () => this._$PostToRuntimeComponent$_("runtime", "go-to-last-error-script"));
        }
        async _$_InitDOM$_(t, s) {
            const i = document.createElement("canvas"), e = (i.style.display = "none", 
            document.body.appendChild(i), document.createElement("div")), h = (e.className = "c3htmlwrap", 
            document.body.appendChild(e), this._$_canvasLayers$_.push({
                canvas: i,
                _$htmlWrap$_: e
            }), window.c3canvas = i, self.C3_InsertHTMLPlaceholders && self.C3_InsertHTMLPlaceholders(), 
            this._$_domHandlers$_ = n0.map(t => new t(this)), this._$_FindRuntimeDOMHandler$_(), 
            this._$_runtimeDomHandler$_._$_AddDefaultCanvasEventHandlers$_(i), this._$_runtimeDomHandler$_._$_AddDefaultHTMLWrapEventHandlers$_(e), 
            await Promise.all(t.runtimeScriptList.map(t => this._$_MaybeGetPlatformSpecificScriptURL$_(t)))), n = (await Promise.all(h.map(t => AddScript(t))), 
            t.projectMainScriptPath), o = t.scriptsInEventsPath;
            if (n) try {
                if (await AddScript(n), "preview" === this._$_exportType$_ && !globalThis.C3_ProjectMainScriptOK) throw new Error("main script did not run to completion");
            } catch (t) {
                this._$_RemoveLoadingMessage$_(), console.error("Error loading project main script: ", t), 
                alert(`Failed to load the project main script (${n}). Check all your JavaScript code has valid syntax, all imports are written correctly, and that an exception was not thrown running the script. Press F12 and check the console for error details.`);
            }
            if (o) try {
                if (await AddScript(o), "preview" === this._$_exportType$_ && !globalThis.C3.ScriptsInEvents) throw new Error("scripts in events did not run to completion");
            } catch (t) {
                this._$_RemoveLoadingMessage$_(), console.error("Error loading scripts in events: ", t), 
                alert("Failed to load scripts in events. Check all your JavaScript code has valid syntax, all imports are written correctly, and that an exception was not thrown running the 'Imports for events' script. Press F12 and check the console for error details.");
            }
            const r = Object.assign(this._$_GetCommonRuntimeOptions$_(t), {
                isInWorker: !1,
                messagePort: s,
                canvas: i,
                runOnStartupFunctions: r0
            });
            this._$_runtimeDomHandler$_._$_EnableWindowResizeEvent$_(), this._$_OnBeforeCreateRuntime$_(), 
            this._$_localRuntime$_ = self.C3_CreateRuntime(r), await self.C3_InitRuntime(this._$_localRuntime$_, r);
        }
        async _$CreateWorker$_(t, s) {
            if (t.startsWith("blob:")) return new Worker(t, s);
            if ("cordova" === this._$_exportType$_ && this._$_isFileProtocol$_) {
                const h = await this._$CordovaFetchLocalFileAsArrayBuffer$_(t), n = new Blob([ h ], {
                    type: "application/javascript"
                });
                return new Worker(URL.createObjectURL(n), s);
            }
            if ("playable-ad-single-file" === this._$_exportType$_) {
                const o = this._$_localFileBlobs$_[t];
                if (o) return new Worker(URL.createObjectURL(o), s);
                throw new Error("missing script: " + t);
            }
            const i = new URL(t, location.href), e = location.origin !== i.origin;
            if (e) {
                const r = await fetch(i);
                if (!r.ok) throw new Error("failed to fetch worker script");
                const a = await r.blob();
                return new Worker(URL.createObjectURL(a), s);
            }
            return new Worker(i, s);
        }
        _$_GetWindowInnerWidth$_() {
            return Math.max(window.innerWidth, 1);
        }
        _$_GetWindowInnerHeight$_() {
            return Math.max(window.innerHeight, 1);
        }
        _$GetCssDisplayMode$_() {
            if (this._$IsAnyWebView2Wrapper$_()) return "standalone";
            const t = this._$GetExportType$_(), s = new Set([ "cordova", "nwjs", "macos-wkwebview" ]);
            return s.has(t) ? "standalone" : window.matchMedia("(display-mode: fullscreen)").matches ? "fullscreen" : window.matchMedia("(display-mode: standalone)").matches ? "standalone" : window.matchMedia("(display-mode: minimal-ui)").matches ? "minimal-ui" : navigator.standalone ? "standalone" : "browser";
        }
        _$_OnBeforeCreateRuntime$_() {
            this._$_RemoveLoadingMessage$_();
        }
        _$_RemoveLoadingMessage$_() {
            const t = window.cr_previewLoadingElem;
            t && (t.parentElement.removeChild(t), window.cr_previewLoadingElem = null);
        }
        async _$_OnCreateJobWorker$_(t) {
            const s = await this._$_jobScheduler$_._$_CreateJobWorker$_();
            return {
                outputPort: s,
                transferables: [ s ]
            };
        }
        _$_OnUpdateCanvasSize$_(t) {
            if (!this._$IsExportingToVideo$_()) {
                const s = t.styleWidth + "px", i = t.styleHeight + "px", e = t.marginLeft + "px", h = t.marginTop + "px";
                for (const {
                    canvas: n,
                    _$htmlWrap$_: o
                } of this._$_canvasLayers$_) n.style.width = s, n.style.height = i, 
                n.style.marginLeft = e, n.style.marginTop = h, o.style.width = s, 
                o.style.height = i, o.style.marginLeft = e, o.style.marginTop = h, 
                this._$_isFirstSizeUpdate$_ && (n.style.display = "", o.style.display = "");
                document.documentElement.style.setProperty("--construct-scale", t.displayScale), 
                this._$_isFirstSizeUpdate$_ = !1;
            }
        }
        ["_OnSetHTMLLayerCount"](t) {
            const i = t.count, s = t.immediate, e = t.styleWidth + "px", h = t.styleHeight + "px", n = t.marginLeft + "px", o = t.marginTop + "px", r = [], a = [];
            if (i < this._$_canvasLayers$_.length) for (;this._$_canvasLayers$_.length > i; ) {
                const {
                    canvas: c,
                    _$htmlWrap$_: l
                } = this._$_canvasLayers$_.pop();
                l.remove(), this._$_useWorker$_ && !s ? this._$_pendingRemoveElements$_.push(c) : c.remove();
            } else if (i > this._$_canvasLayers$_.length) for (let t = 0, s = i - this._$_canvasLayers$_.length; t < s; ++t) {
                const u = document.createElement("canvas");
                if (u.classList.add("c3overlay"), this._$_useWorker$_) {
                    const f = u.transferControlToOffscreen();
                    r.push(f), a.push(f);
                } else r.push(u);
                document.body.appendChild(u);
                const d = document.createElement("div");
                d.classList.add("c3htmlwrap", "c3overlay"), document.body.appendChild(d), 
                u.style.width = e, u.style.height = h, u.style.marginLeft = n, u.style.marginTop = o, 
                d.style.width = e, d.style.height = h, d.style.marginLeft = n, d.style.marginTop = o, 
                this._$_runtimeDomHandler$_._$_AddDefaultCanvasEventHandlers$_(u), 
                this._$_runtimeDomHandler$_._$_AddDefaultHTMLWrapEventHandlers$_(d), 
                this._$_canvasLayers$_.push({
                    canvas: u,
                    _$htmlWrap$_: d
                });
            }
            for (const w of this._$_domHandlers$_) w instanceof window._$DOMElementHandler$_ && w._$_OnHTMLLayersChanged$_();
            return this._$_UpdateHTMLElementsZOrder$_(), {
                addedCanvases: r,
                transferables: a
            };
        }
        _$_OnCleanUpHTMLLayers$_() {
            for (const t of this._$_pendingRemoveElements$_) t.remove();
            this._$_pendingRemoveElements$_.length = 0;
        }
        _$_UpdateHTMLElementsZOrder$_() {
            this._$_pendingUpdateHTMLZOrder$_ || (this._$_pendingUpdateHTMLZOrder$_ = !0, 
            this._$_AddRAFCallback$_(this._$_updateHTMLZOrderRAFCallback$_));
        }
        _$_DoUpdateHTMLElementsZOrder$_() {
            this._$_RemoveRAFCallback$_(this._$_updateHTMLZOrderRAFCallback$_), 
            this._$_pendingUpdateHTMLZOrder$_ = !1;
            let t = [];
            for (const n of this._$_domHandlers$_) if (n instanceof window._$DOMElementHandler$_) {
                const o = n._$_GetAllElementStatesForZOrderUpdate$_();
                o && t.push(...o);
            }
            t.sort((t, s) => {
                const i = t._$GetActualHTMLIndex$_(), e = s._$GetActualHTMLIndex$_();
                if (i !== e) return i - e;
                const h = t._$GetHTMLZIndex$_(), n = s._$GetHTMLZIndex$_();
                return h - n;
            });
            let s = 0, i = 0, e = 0, h = t.length;
            for (;e < h; ++e) {
                const r = t[e];
                r._$GetActualHTMLIndex$_() !== s && (this._$_DoUpdateHTMLElementsZOrderOnHTMLLayer$_(s, t.slice(i, e)), 
                s = r._$GetActualHTMLIndex$_(), i = e);
            }
            i < e && this._$_DoUpdateHTMLElementsZOrderOnHTMLLayer$_(s, t.slice(i, e));
        }
        _$_DoUpdateHTMLElementsZOrderOnHTMLLayer$_(e, h) {
            if (!(h.length <= 1 || e >= this._$_canvasLayers$_.length)) {
                const n = h.map(t => t._$GetElement$_()), o = new Set(n), r = this._$GetHTMLWrapElement$_(e), a = Array.from(r.children).filter(t => o.has(t));
                let t = 0, s = Math.min(n.length, a.length);
                for (;t < s && n[t] === a[t]; ++t);
                let i = t;
                for (;i < s; ++i) a[i].remove();
                for (i = t; i < s; ++i) r.appendChild(n[i]);
            }
        }
        _$_GetLocalRuntime$_() {
            if (this._$_useWorker$_) throw new Error("not available in worker mode");
            return this._$_localRuntime$_;
        }
        _$PostToRuntimeComponent$_(t, s, i, e, h) {
            this._$_messageChannelPort$_.postMessage({
                type: "event",
                component: t,
                handler: s,
                dispatchOpts: e || null,
                data: i,
                responseId: null
            }, h);
        }
        _$PostToRuntimeComponentAsync$_(t, s, i, e, h) {
            const n = r++, o = new Promise((t, s) => {
                p0.set(n, {
                    resolve: t,
                    reject: s
                });
            });
            return this._$_messageChannelPort$_.postMessage({
                type: "event",
                component: t,
                handler: s,
                dispatchOpts: e || null,
                data: i,
                responseId: n
            }, h), o;
        }
        ["_OnMessageFromRuntime"](t) {
            const s = t.type;
            if ("event" === s) return this._$_OnEventFromRuntime$_(t);
            if ("result" === s) this._$_OnResultFromRuntime$_(t); else if ("runtime-ready" === s) this._$_OnRuntimeReady$_(); else if ("alert-error" === s) this._$_RemoveLoadingMessage$_(), 
            alert(t.message); else {
                if ("creating-runtime" !== s) throw new Error(`unknown message '${s}'`);
                this._$_OnBeforeCreateRuntime$_();
            }
        }
        _$_OnEventFromRuntime$_(t) {
            const s = t.component, i = t.handler, e = t.data, h = t.responseId, n = o0.get(s);
            if (n) {
                const o = n.get(i);
                if (o) {
                    let t = null;
                    try {
                        t = o(e);
                    } catch (t) {
                        return console.error(`Exception in '${s}' handler '${i}':`, t), 
                        void (null !== h && this._$_PostResultToRuntime$_(h, !1, "" + t));
                    }
                    if (null === h) return t;
                    t && t.then ? t.then(t => this._$_PostResultToRuntime$_(h, !0, t)).catch(t => {
                        console.error(`Rejection from '${s}' handler '${i}':`, t), 
                        this._$_PostResultToRuntime$_(h, !1, "" + t);
                    }) : this._$_PostResultToRuntime$_(h, !0, t);
                } else console.warn(`[DOM] No handler '${i}' for component '${s}'`);
            } else console.warn(`[DOM] No event handlers for component '${s}'`);
        }
        _$_PostResultToRuntime$_(t, s, i) {
            let e;
            i && i.transferables && (e = i.transferables), this._$_messageChannelPort$_.postMessage({
                type: "result",
                responseId: t,
                isOk: s,
                result: i
            }, e);
        }
        _$_OnResultFromRuntime$_(t) {
            const s = t.responseId, i = t.isOk, e = t.result, h = p0.get(s);
            i ? h.resolve(e) : h.reject(e), p0.delete(s);
        }
        _$AddRuntimeComponentMessageHandler$_(t, s, i) {
            let e = o0.get(t);
            if (e || (e = new Map(), o0.set(t, e)), e.has(s)) throw new Error(`[DOM] Component '${t}' already has handler '${s}'`);
            e.set(s, i);
        }
        static _$AddDOMHandlerClass$_(t) {
            if (n0.includes(t)) throw new Error("DOM handler already added");
            n0.push(t);
        }
        _$_FindRuntimeDOMHandler$_() {
            for (const t of this._$_domHandlers$_) if ("runtime" === t._$GetComponentID$_()) return void (this._$_runtimeDomHandler$_ = t);
            throw new Error("cannot find runtime DOM handler");
        }
        _$_OnMessageFromDebugger$_(t) {
            this._$PostToRuntimeComponent$_("debugger", "message", t);
        }
        _$_OnRuntimeReady$_() {
            for (const t of this._$_domHandlers$_) t._$Attach$_();
        }
        static _$IsDocumentFullscreen$_() {
            return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || s);
        }
        static _$_SetWrapperIsFullscreenFlag$_(t) {
            s = !!t;
        }
        async _$GetRemotePreviewStatusInfo$_() {
            return this._$PostToRuntimeComponentAsync$_("runtime", "get-remote-preview-status-info");
        }
        _$_AddRAFCallback$_(t) {
            this._$_rafCallbacks$_.add(t), this._$_RequestAnimationFrame$_();
        }
        _$_RemoveRAFCallback$_(t) {
            this._$_rafCallbacks$_.delete(t), 0 === this._$_rafCallbacks$_.size && this._$_CancelAnimationFrame$_();
        }
        _$_RequestAnimationFrame$_() {
            -1 === this._$_rafId$_ && 0 < this._$_rafCallbacks$_.size && (this._$_rafId$_ = requestAnimationFrame(this._$_rafFunc$_));
        }
        _$_CancelAnimationFrame$_() {
            -1 !== this._$_rafId$_ && (cancelAnimationFrame(this._$_rafId$_), this._$_rafId$_ = -1);
        }
        _$_OnRAFCallback$_() {
            this._$_rafId$_ = -1;
            for (const t of this._$_rafCallbacks$_) t();
            this._$_RequestAnimationFrame$_();
        }
        _$TryPlayMedia$_(t) {
            this._$_runtimeDomHandler$_._$TryPlayMedia$_(t);
        }
        _$RemovePendingPlay$_(t) {
            this._$_runtimeDomHandler$_._$RemovePendingPlay$_(t);
        }
        _$_PlayPendingMedia$_() {
            this._$_runtimeDomHandler$_._$_PlayPendingMedia$_();
        }
        _$SetSilent$_(t) {
            this._$_runtimeDomHandler$_._$SetSilent$_(t);
        }
        _$IsAudioFormatSupported$_(t) {
            return !!j0[t];
        }
        async _$_WasmDecodeWebMOpus$_(t) {
            const s = await this._$PostToRuntimeComponentAsync$_("runtime", "opus-decode", {
                arrayBuffer: t
            }, null, [ t ]);
            return new Float32Array(s);
        }
        _$SetIsExportingToVideo$_(t) {
            this._$_isExportingToVideo$_ = !0, this._$_exportToVideoDuration$_ = t;
        }
        _$IsExportingToVideo$_() {
            return this._$_isExportingToVideo$_;
        }
        _$GetExportToVideoDuration$_() {
            return this._$_exportToVideoDuration$_;
        }
        _$IsAbsoluteURL$_(t) {
            return /^(?:[a-z\-]+:)?\/\//.test(t) || "data:" === t.substr(0, 5) || "blob:" === t.substr(0, 5);
        }
        _$IsRelativeURL$_(t) {
            return !this._$IsAbsoluteURL$_(t);
        }
        async _$_MaybeGetPlatformSpecificScriptURL$_(s) {
            if ("cordova" === this._$_exportType$_ && (s.startsWith("file:") || this._$_isFileProtocol$_ && this._$IsRelativeURL$_(s))) {
                let t = s;
                t.startsWith(this._$_runtimeBaseUrl$_) && (t = t.substr(this._$_runtimeBaseUrl$_.length));
                const i = await this._$CordovaFetchLocalFileAsArrayBuffer$_(t), e = new Blob([ i ], {
                    type: "application/javascript"
                });
                return URL.createObjectURL(e);
            }
            if ("playable-ad-single-file" !== this._$_exportType$_) return s;
            if (this._$_localFileStrings$_.hasOwnProperty(s)) return {
                _$isStringSrc$_: !0,
                str: this._$_localFileStrings$_[s]
            };
            if (this._$_localFileBlobs$_.hasOwnProperty(s)) return URL.createObjectURL(this._$_localFileBlobs$_[s]);
            throw new Error("missing script: " + s);
        }
        async _$_OnCordovaFetchLocalFile$_(t) {
            const s = t.filename;
            switch (t.as) {
              case "text":
                return this._$CordovaFetchLocalFileAsText$_(s);

              case "buffer":
                return this._$CordovaFetchLocalFileAsArrayBuffer$_(s);

              default:
                throw new Error("unsupported type");
            }
        }
        _$CordovaFetchLocalFile$_(t) {
            const e = window.cordova.file.applicationDirectory + "www/" + t;
            return new Promise((s, i) => {
                window.resolveLocalFileSystemURL(e, t => {
                    t.file(s, i);
                }, i);
            });
        }
        async _$CordovaFetchLocalFileAsText$_(t) {
            const s = await this._$CordovaFetchLocalFile$_(t);
            return BlobToString(s);
        }
        _$_CordovaMaybeStartNextArrayBufferRead$_() {
            if (k0.length && !(e >= m0)) {
                e++;
                const t = k0.shift();
                this._$_CordovaDoFetchLocalFileAsAsArrayBuffer$_(t.filename, t._$successCallback$_, t._$errorCallback$_);
            }
        }
        _$CordovaFetchLocalFileAsArrayBuffer$_(t) {
            return new Promise((s, i) => {
                k0.push({
                    filename: t,
                    _$successCallback$_: t => {
                        e--, this._$_CordovaMaybeStartNextArrayBufferRead$_(), s(t);
                    },
                    _$errorCallback$_: t => {
                        e--, this._$_CordovaMaybeStartNextArrayBufferRead$_(), i(t);
                    }
                }), this._$_CordovaMaybeStartNextArrayBufferRead$_();
            });
        }
        async _$_CordovaDoFetchLocalFileAsAsArrayBuffer$_(t, s, i) {
            try {
                const e = await this._$CordovaFetchLocalFile$_(t), h = await BlobToArrayBuffer(e);
                s(h);
            } catch (t) {
                i(t);
            }
        }
        ["_PlayableAdFetchBlob"](t) {
            if (this._$_localFileBlobs$_.hasOwnProperty(t)) return this._$_localFileBlobs$_[t];
            throw new Error("missing file: " + t);
        }
        _$_GetPermissionAPI$_() {
            const t = window.cordova && window.cordova.plugins && window.cordova.plugins.permissions;
            if ("object" != typeof t) throw new Error("Permission API is not loaded");
            return t;
        }
        _$_MapPermissionID$_(t, s) {
            const i = t[s];
            if ("string" != typeof i) throw new Error("Invalid permission name");
            return i;
        }
        _$_HasPermission$_(i) {
            const e = this._$_GetPermissionAPI$_();
            return new Promise((s, t) => e.checkPermission(this._$_MapPermissionID$_(e, i), t => s(!!t.hasPermission), t));
        }
        _$_RequestPermission$_(i) {
            const e = this._$_GetPermissionAPI$_();
            return new Promise((s, t) => e.requestPermission(this._$_MapPermissionID$_(e, i), t => s(!!t.hasPermission), t));
        }
        async _$RequestPermissions$_(t) {
            if ("cordova" === this._$GetExportType$_() && !this._$IsiOSCordova$_()) for (const s of t) {
                const i = await this._$_HasPermission$_(s);
                if (!i) {
                    const e = await this._$_RequestPermission$_(s);
                    if (!1 === e) return !1;
                }
            }
            return !0;
        }
        async _$RequirePermissions$_(...t) {
            if (!1 === await this._$RequestPermissions$_(t)) throw new Error("Permission not granted");
        }
        _$_OnWrapperMessage$_(t, s) {
            if ("entered-fullscreen" === t) U0._$_SetWrapperIsFullscreenFlag$_(!0), 
            this._$_runtimeDomHandler$_._$_OnFullscreenChange$_(); else if ("exited-fullscreen" === t) U0._$_SetWrapperIsFullscreenFlag$_(!1), 
            this._$_runtimeDomHandler$_._$_OnFullscreenChange$_(); else if ("object" == typeof t) {
                const i = t.type;
                "directory-handles" === i ? this._$_directoryHandles$_ = s : "wrapper-init-response" === i ? (this._$_wrapperInitResolve$_(t), 
                this._$_wrapperInitResolve$_ = null) : "extension-message" === i ? this._$PostToRuntimeComponent$_("runtime", "wrapper-extension-message", t) : console.warn("Unknown wrapper message: ", t);
            } else console.warn("Unknown wrapper message: ", t);
        }
        _$_OnSendWrapperExtensionMessage$_(t) {
            this._$_SendWrapperMessage$_({
                type: "extension-message",
                componentId: t.componentId,
                messageId: t.messageId,
                params: t.params || [],
                asyncId: t.asyncId
            });
        }
        _$_SendWrapperMessage$_(t) {
            this._$IsAnyWebView2Wrapper$_() ? window.chrome.webview.postMessage(JSON.stringify(t)) : "macos-wkwebview" === this._$_exportType$_ && window.webkit.messageHandlers.C3Wrapper.postMessage(JSON.stringify(t));
        }
        _$_SetupWebView2Polyfills$_() {
            window.moveTo = (t, s) => {
                this._$_SendWrapperMessage$_({
                    type: "set-window-position",
                    windowX: Math.ceil(t),
                    windowY: Math.ceil(s)
                });
            }, window.resizeTo = (t, s) => {
                this._$_SendWrapperMessage$_({
                    type: "set-window-size",
                    windowWidth: Math.ceil(t),
                    windowHeight: Math.ceil(s)
                });
            };
        }
        _$_InitWrapper$_() {
            return this._$IsAnyWebView2Wrapper$_() ? new Promise(t => {
                this._$_wrapperInitResolve$_ = t, this._$_SendWrapperMessage$_({
                    type: "wrapper-init"
                });
            }) : Promise.resolve();
        }
        _$_GetDirectoryHandles$_() {
            return this._$_directoryHandles$_;
        }
        async _$_ConvertDataUrisToBlobs$_() {
            const t = [];
            for (const [ s, i ] of Object.entries(this._$_localFileBlobs$_)) t.push(this._$_ConvertDataUriToBlobs$_(s, i));
            await Promise.all(t);
        }
        async _$_ConvertDataUriToBlobs$_(s, i) {
            if ("object" == typeof i) this._$_localFileBlobs$_[s] = new Blob([ i.str ], {
                type: i.type
            }), this._$_localFileStrings$_[s] = i.str; else {
                let t = await this._$_FetchDataUri$_(i);
                t = t || this._$_DataURIToBinaryBlobSync$_(i), this._$_localFileBlobs$_[s] = t;
            }
        }
        async _$_FetchDataUri$_(t) {
            try {
                const s = await fetch(t);
                return await s.blob();
            } catch (t) {
                return console.warn("Failed to fetch a data: URI. Falling back to a slower workaround. This is probably because the Content Security Policy unnecessarily blocked it. Allow data: URIs in your CSP to avoid this.", t), 
                null;
            }
        }
        _$_DataURIToBinaryBlobSync$_(t) {
            const s = this._$_ParseDataURI$_(t);
            return this._$_BinaryStringToBlob$_(s.data, s._$mime_type$_);
        }
        _$_ParseDataURI$_(t) {
            const s = t.indexOf(",");
            if (s < 0) throw new URIError("expected comma in data: uri");
            const i = t.substring(5, s), e = t.substring(s + 1), h = i.split(";"), n = h[0] || "", o = h[1], r = h[2];
            let a;
            return {
                _$mime_type$_: n,
                data: a = ("base64" === o || "base64" === r ? atob : decodeURIComponent)(e)
            };
        }
        _$_BinaryStringToBlob$_(t, s) {
            let i = t.length, e = i >> 2, h = new Uint8Array(i), n = new Uint32Array(h.buffer, 0, e), o, r;
            for (o = 0, r = 0; o < e; ++o) n[o] = t.charCodeAt(r++) | t.charCodeAt(r++) << 8 | t.charCodeAt(r++) << 16 | t.charCodeAt(r++) << 24;
            let a = 3 & i;
            for (;a--; ) h[r] = t.charCodeAt(r), ++r;
            return new Blob([ h ], {
                type: s
            });
        }
    };
}

{
    const Kd = self._$RuntimeInterface$_;
    function IsCompatibilityMouseEvent(t) {
        return t.sourceCapabilities && t.sourceCapabilities.firesTouchEvents || t.originalEvent && t.originalEvent.sourceCapabilities && t.originalEvent.sourceCapabilities.firesTouchEvents;
    }
    const Ld = new Map([ [ "OSLeft", "MetaLeft" ], [ "OSRight", "MetaRight" ] ]), Md = {
        dispatchRuntimeEvent: !0,
        dispatchUserScriptEvent: !0
    }, Nd = {
        dispatchUserScriptEvent: !0
    }, Od = {
        dispatchRuntimeEvent: !0
    };
    function AddStyleSheet(e) {
        return new Promise((t, s) => {
            const i = document.createElement("link");
            i.onload = () => t(i), i.onerror = t => s(t), i.rel = "stylesheet", 
            i.href = e, document.head.appendChild(i);
        });
    }
    function FetchImage(e) {
        return new Promise((t, s) => {
            const i = new Image();
            i.onload = () => t(i), i.onerror = t => s(t), i.src = e;
        });
    }
    async function BlobToImage(t) {
        const s = URL.createObjectURL(t);
        try {
            return await FetchImage(s);
        } finally {
            URL.revokeObjectURL(s);
        }
    }
    function BlobToString(e) {
        return new Promise((s, i) => {
            let t = new FileReader();
            t.onload = t => s(t.target.result), t.onerror = t => i(t), t.readAsText(e);
        });
    }
    function IsInContentEditable(t) {
        do {
            if (t.parentNode && t.hasAttribute("contenteditable")) return !0;
        } while (t = t.parentNode);
        return !1;
    }
    const Pd = new Set([ "input", "textarea", "datalist", "select" ]);
    function IsKeyboardInputElement(t) {
        return Pd.has(t.tagName.toLowerCase()) || IsInContentEditable(t);
    }
    const Qd = new Set([ "canvas", "body", "html" ]);
    function PreventDefaultOnCanvasOrDoc(t) {
        if (t.target.tagName) {
            const s = t.target.tagName.toLowerCase();
            Qd.has(s) && t.preventDefault();
        }
    }
    function PreventDefaultOnHTMLWrap(t) {
        t.target.tagName && t.target.classList.contains("c3htmlwrap") && t.preventDefault();
    }
    function BlockWheelZoom(t) {
        (t.metaKey || t.ctrlKey) && t.preventDefault();
    }
    self.C3_GetSvgImageSize = async function(t) {
        const s = await BlobToImage(t);
        if (0 < s.width && 0 < s.height) return [ s.width, s.height ];
        {
            s.style.position = "absolute", s.style.left = "0px", s.style.top = "0px", 
            s.style.visibility = "hidden", document.body.appendChild(s);
            const i = s.getBoundingClientRect();
            return document.body.removeChild(s), [ i.width, i.height ];
        }
    };
    let t = !(self.C3_RasterSvgImageBlob = async function(t, s, i, e, h) {
        const n = await BlobToImage(t), o = document.createElement("canvas"), r = (o.width = e, 
        o.height = h, o.getContext("2d"));
        return r.drawImage(n, 0, 0, s, i), o;
    });
    function ParentHasFocus() {
        try {
            return window.parent && window.parent.document.hasFocus();
        } catch (t) {
            return !1;
        }
    }
    document.addEventListener("pause", () => t = !0), document.addEventListener("resume", () => t = !1);
    const Sd = "runtime", Td = class extends self._$DOMHandler$_ {
        constructor(t) {
            super(t, Sd), this._$_enableWindowResizeEvent$_ = !1, this._$_simulatedResizeTimerId$_ = -1, 
            this._$_targetOrientation$_ = "any", this._$_attachedDeviceOrientationEvent$_ = !1, 
            this._$_attachedDeviceMotionEvent$_ = !1, this._$_pageVisibilityIsHidden$_ = !1, 
            this._$_screenReaderTextWrap$_ = document.createElement("div"), this._$_screenReaderTextWrap$_.className = "c3-screen-reader-text", 
            this._$_screenReaderTextWrap$_.setAttribute("aria-live", "polite"), 
            document.body.appendChild(this._$_screenReaderTextWrap$_), this._$_debugHighlightElem$_ = null, 
            this._$_isExportToVideo$_ = !1, this._$_exportVideoProgressMessage$_ = "", 
            this._$_exportVideoUpdateTimerId$_ = -1, this._$_enableAndroidVKDetection$_ = !1, 
            this._$_lastWindowWidth$_ = t._$_GetWindowInnerWidth$_(), this._$_lastWindowHeight$_ = t._$_GetWindowInnerHeight$_(), 
            this._$_virtualKeyboardHeight$_ = 0, this._$_vkTranslateYOffset$_ = 0, 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "invoke-download", t => this._$_OnInvokeDownload$_(t)), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "load-webfonts", t => this._$_OnLoadWebFonts$_(t)), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "raster-svg-image", t => this._$_OnRasterSvgImage$_(t)), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "get-svg-image-size", t => this._$_OnGetSvgImageSize$_(t)), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "set-target-orientation", t => this._$_OnSetTargetOrientation$_(t)), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "register-sw", () => this._$_OnRegisterSW$_()), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "post-to-debugger", t => this._$_OnPostToDebugger$_(t)), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "go-to-script", t => this._$_OnPostToDebugger$_(t)), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "before-start-ticking", () => this._$_OnBeforeStartTicking$_()), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "debug-highlight", t => this._$_OnDebugHighlight$_(t)), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "enable-device-orientation", () => this._$_AttachDeviceOrientationEvent$_()), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "enable-device-motion", () => this._$_AttachDeviceMotionEvent$_()), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "add-stylesheet", t => this._$_OnAddStylesheet$_(t)), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "script-create-worker", t => this._$_OnScriptCreateWorker$_(t)), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "alert", t => this._$_OnAlert$_(t)), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "screen-reader-text", t => this._$_OnScreenReaderTextEvent$_(t)), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "hide-cordova-splash", () => this._$_OnHideCordovaSplash$_()), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "set-exporting-to-video", t => this._$_SetExportingToVideo$_(t)), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "export-to-video-progress", t => this._$_OnExportVideoProgress$_(t)), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "exported-to-video", t => this._$_OnExportedToVideo$_(t)), 
            t._$AddRuntimeComponentMessageHandler$_("runtime", "exported-to-image-sequence", t => this._$_OnExportedToImageSequence$_(t));
            const e = new Set([ "input", "textarea", "datalist" ]);
            if (window.addEventListener("contextmenu", t => {
                const s = t.target, i = s.tagName.toLowerCase();
                e.has(i) || IsInContentEditable(s) || t.preventDefault();
            }), window.addEventListener("selectstart", PreventDefaultOnCanvasOrDoc), 
            window.addEventListener("gesturehold", PreventDefaultOnCanvasOrDoc), 
            window.addEventListener("touchstart", PreventDefaultOnCanvasOrDoc, {
                passive: !1
            }), window.addEventListener("pointerdown", PreventDefaultOnCanvasOrDoc, {
                passive: !1
            }), this._$_mousePointerLastButtons$_ = 0, window.addEventListener("mousedown", t => {
                1 === t.button && t.preventDefault();
            }), window.addEventListener("mousewheel", BlockWheelZoom, {
                passive: !1
            }), window.addEventListener("wheel", BlockWheelZoom, {
                passive: !1
            }), window.addEventListener("resize", () => this._$_OnWindowResize$_()), 
            window.addEventListener("fullscreenchange", () => this._$_OnFullscreenChange$_()), 
            window.addEventListener("webkitfullscreenchange", () => this._$_OnFullscreenChange$_()), 
            window.addEventListener("mozfullscreenchange", () => this._$_OnFullscreenChange$_()), 
            window.addEventListener("fullscreenerror", t => this._$_OnFullscreenError$_(t)), 
            window.addEventListener("webkitfullscreenerror", t => this._$_OnFullscreenError$_(t)), 
            window.addEventListener("mozfullscreenerror", t => this._$_OnFullscreenError$_(t)), 
            t._$IsiOSWebView$_()) {
                let s = 1 / 0;
                window.visualViewport.addEventListener("resize", () => {
                    const t = window.visualViewport.height;
                    t > s && (document.scrollingElement.scrollTop = 0, document.scrollingElement.scrollLeft = 0), 
                    s = t;
                }), document.documentElement.setAttribute("ioswebview", "");
            }
            this._$_mediaPendingPlay$_ = new Set(), this._$_mediaRemovedPendingPlay$_ = new WeakSet(), 
            this._$_isSilent$_ = !1;
        }
        _$_AddDefaultCanvasEventHandlers$_(t) {
            t.addEventListener("selectstart", PreventDefaultOnCanvasOrDoc), t.addEventListener("gesturehold", PreventDefaultOnCanvasOrDoc), 
            t.addEventListener("pointerdown", PreventDefaultOnCanvasOrDoc);
        }
        _$_AddDefaultHTMLWrapEventHandlers$_(t) {
            t.addEventListener("selectstart", PreventDefaultOnHTMLWrap), t.addEventListener("gesturehold", PreventDefaultOnHTMLWrap), 
            t.addEventListener("touchstart", PreventDefaultOnHTMLWrap);
        }
        _$_OnBeforeStartTicking$_() {
            return self.setTimeout(() => {
                this._$_enableAndroidVKDetection$_ = !0;
            }, 1e3), "cordova" === this._$_iRuntime$_._$GetExportType$_() ? (document.addEventListener("pause", () => this._$_OnVisibilityChange$_(!0)), 
            document.addEventListener("resume", () => this._$_OnVisibilityChange$_(!1))) : document.addEventListener("visibilitychange", () => this._$_OnVisibilityChange$_("hidden" === document.visibilityState)), 
            this._$_pageVisibilityIsHidden$_ = !("hidden" !== document.visibilityState && !t), 
            {
                isSuspended: this._$_pageVisibilityIsHidden$_
            };
        }
        _$Attach$_() {
            window.addEventListener("focus", () => this._$_PostRuntimeEvent$_("window-focus")), 
            window.addEventListener("blur", () => {
                this._$_PostRuntimeEvent$_("window-blur", {
                    parentHasFocus: ParentHasFocus()
                }), this._$_mousePointerLastButtons$_ = 0;
            }), window.addEventListener("focusin", t => {
                IsKeyboardInputElement(t.target) && this._$_PostRuntimeEvent$_("keyboard-blur");
            }), window.addEventListener("keydown", t => this._$_OnKeyEvent$_("keydown", t)), 
            window.addEventListener("keyup", t => this._$_OnKeyEvent$_("keyup", t)), 
            window.addEventListener("mousedown", t => this._$_OnMouseEvent$_("mousedown", t, Nd)), 
            window.addEventListener("mousemove", t => this._$_OnMouseEvent$_("mousemove", t, Nd)), 
            window.addEventListener("mouseup", t => this._$_OnMouseEvent$_("mouseup", t, Nd)), 
            window.addEventListener("dblclick", t => this._$_OnMouseEvent$_("dblclick", t, Md)), 
            window.addEventListener("wheel", t => this._$_OnMouseWheelEvent$_("wheel", t, Md)), 
            window.addEventListener("pointerdown", t => {
                this._$_HandlePointerDownFocus$_(t), this._$_OnPointerEvent$_("pointerdown", t);
            }), this._$_iRuntime$_._$UsesWorker$_() && void 0 !== window.onpointerrawupdate && self === self.top ? window.addEventListener("pointerrawupdate", t => this._$_OnPointerRawUpdate$_(t)) : window.addEventListener("pointermove", t => this._$_OnPointerEvent$_("pointermove", t)), 
            window.addEventListener("pointerup", t => this._$_OnPointerEvent$_("pointerup", t)), 
            window.addEventListener("pointercancel", t => this._$_OnPointerEvent$_("pointercancel", t));
            const t = () => this._$_PlayPendingMedia$_();
            window.addEventListener("pointerup", t, !0), window.addEventListener("touchend", t, !0), 
            window.addEventListener("click", t, !0), window.addEventListener("keydown", t, !0), 
            window.addEventListener("gamepadconnected", t, !0), this._$_iRuntime$_._$IsAndroid$_() && !this._$_iRuntime$_._$IsAndroidWebView$_() && navigator.virtualKeyboard && (navigator.virtualKeyboard.overlaysContent = !0, 
            navigator.virtualKeyboard.addEventListener("geometrychange", () => {
                this._$_OnAndroidVirtualKeyboardChange$_(this._$_GetWindowInnerHeight$_(), navigator.virtualKeyboard.boundingRect.height);
            })), this._$_iRuntime$_._$IsiOSWebView$_() && (document.scrollingElement.scrollTop = 0, 
            document.scrollingElement.scrollLeft = 0);
        }
        _$_OnAndroidVirtualKeyboardChange$_(s, i) {
            if (document.body.style.position = "", document.body.style.overflow = "", 
            document.body.style.transform = "", (this._$_vkTranslateYOffset$_ = 0) < i) {
                const e = document.activeElement;
                if (e) {
                    const h = e.getBoundingClientRect(), n = (h.top + h.bottom) / 2, o = (s - i) / 2;
                    let t = n - o;
                    0 < (t = (t = t > i ? i : t) < 0 ? 0 : t) && (document.body.style.position = "absolute", 
                    document.body.style.overflow = "visible", document.body.style.transform = `translateY(${-t}px)`, 
                    this._$_vkTranslateYOffset$_ = t);
                }
            }
        }
        _$_PostRuntimeEvent$_(t, s) {
            this._$PostToRuntime$_(t, s || null, Od);
        }
        _$_GetWindowInnerWidth$_() {
            return this._$_iRuntime$_._$_GetWindowInnerWidth$_();
        }
        _$_GetWindowInnerHeight$_() {
            return this._$_iRuntime$_._$_GetWindowInnerHeight$_();
        }
        _$_EnableWindowResizeEvent$_() {
            this._$_enableWindowResizeEvent$_ = !0, this._$_lastWindowWidth$_ = this._$_iRuntime$_._$_GetWindowInnerWidth$_(), 
            this._$_lastWindowHeight$_ = this._$_iRuntime$_._$_GetWindowInnerHeight$_();
        }
        _$_OnWindowResize$_() {
            if (!this._$_isExportToVideo$_ && this._$_enableWindowResizeEvent$_) {
                const t = this._$_GetWindowInnerWidth$_(), s = this._$_GetWindowInnerHeight$_();
                if (this._$_iRuntime$_._$IsAndroidWebView$_()) {
                    if (this._$_enableAndroidVKDetection$_) {
                        if (this._$_lastWindowWidth$_ === t && s < this._$_lastWindowHeight$_) return this._$_virtualKeyboardHeight$_ = this._$_lastWindowHeight$_ - s, 
                        void this._$_OnAndroidVirtualKeyboardChange$_(this._$_lastWindowHeight$_, this._$_virtualKeyboardHeight$_);
                        0 < this._$_virtualKeyboardHeight$_ && (this._$_virtualKeyboardHeight$_ = 0, 
                        this._$_OnAndroidVirtualKeyboardChange$_(s, this._$_virtualKeyboardHeight$_));
                    }
                    this._$_lastWindowWidth$_ = t, this._$_lastWindowHeight$_ = s;
                }
                this._$PostToRuntime$_("window-resize", {
                    innerWidth: t,
                    innerHeight: s,
                    devicePixelRatio: window.devicePixelRatio,
                    isFullscreen: Kd._$IsDocumentFullscreen$_(),
                    cssDisplayMode: this._$_iRuntime$_._$GetCssDisplayMode$_()
                }), this._$_iRuntime$_._$IsiOSWebView$_() && (-1 !== this._$_simulatedResizeTimerId$_ && clearTimeout(this._$_simulatedResizeTimerId$_), 
                this._$_OnSimulatedResize$_(t, s, 0));
            }
        }
        _$_ScheduleSimulatedResize$_(t, s, i) {
            -1 !== this._$_simulatedResizeTimerId$_ && clearTimeout(this._$_simulatedResizeTimerId$_), 
            this._$_simulatedResizeTimerId$_ = setTimeout(() => this._$_OnSimulatedResize$_(t, s, i), 48);
        }
        _$_OnSimulatedResize$_(t, s, i) {
            const e = this._$_GetWindowInnerWidth$_(), h = this._$_GetWindowInnerHeight$_();
            this._$_simulatedResizeTimerId$_ = -1, e != t || h != s ? this._$PostToRuntime$_("window-resize", {
                innerWidth: e,
                innerHeight: h,
                devicePixelRatio: window.devicePixelRatio,
                isFullscreen: Kd._$IsDocumentFullscreen$_(),
                cssDisplayMode: this._$_iRuntime$_._$GetCssDisplayMode$_()
            }) : i < 10 && this._$_ScheduleSimulatedResize$_(e, h, i + 1);
        }
        _$_OnSetTargetOrientation$_(t) {
            this._$_targetOrientation$_ = t.targetOrientation;
        }
        _$_TrySetTargetOrientation$_() {
            const s = this._$_targetOrientation$_;
            if (screen.orientation && screen.orientation.lock) screen.orientation.lock(s).catch(t => console.warn("[Construct] Failed to lock orientation: ", t)); else try {
                let t = !1;
                screen.lockOrientation ? t = screen.lockOrientation(s) : screen.webkitLockOrientation ? t = screen.webkitLockOrientation(s) : screen.mozLockOrientation ? t = screen.mozLockOrientation(s) : screen.msLockOrientation && (t = screen.msLockOrientation(s)), 
                t || console.warn("[Construct] Failed to lock orientation");
            } catch (t) {
                console.warn("[Construct] Failed to lock orientation: ", t);
            }
        }
        _$_OnFullscreenChange$_() {
            if (!this._$_isExportToVideo$_) {
                const t = Kd._$IsDocumentFullscreen$_();
                t && "any" !== this._$_targetOrientation$_ && this._$_TrySetTargetOrientation$_(), 
                this._$PostToRuntime$_("fullscreenchange", {
                    isFullscreen: t,
                    innerWidth: this._$_GetWindowInnerWidth$_(),
                    innerHeight: this._$_GetWindowInnerHeight$_()
                });
            }
        }
        _$_OnFullscreenError$_(t) {
            console.warn("[Construct] Fullscreen request failed: ", t), this._$PostToRuntime$_("fullscreenerror", {
                isFullscreen: Kd._$IsDocumentFullscreen$_(),
                innerWidth: this._$_GetWindowInnerWidth$_(),
                innerHeight: this._$_GetWindowInnerHeight$_()
            });
        }
        _$_OnVisibilityChange$_(t) {
            if (this._$_pageVisibilityIsHidden$_ !== t && ((this._$_pageVisibilityIsHidden$_ = t) ? this._$_iRuntime$_._$_CancelAnimationFrame$_() : this._$_iRuntime$_._$_RequestAnimationFrame$_(), 
            this._$PostToRuntime$_("visibilitychange", {
                hidden: t
            }), !t) && this._$_iRuntime$_._$IsiOSWebView$_()) {
                const s = () => {
                    document.scrollingElement.scrollTop = 0, document.scrollingElement.scrollLeft = 0;
                };
                setTimeout(s, 50), setTimeout(s, 100), setTimeout(s, 250), setTimeout(s, 500);
            }
        }
        _$_OnKeyEvent$_(t, s) {
            if (void 0 !== s.key && ("Backspace" === s.key && PreventDefaultOnCanvasOrDoc(s), 
            "nwjs" === this._$_iRuntime$_._$GetExportType$_() && "u" === s.key && (s.ctrlKey || s.metaKey) && s.preventDefault(), 
            !this._$_isExportToVideo$_)) {
                const i = Ld.get(s.code) || s.code;
                this._$_PostToRuntimeMaybeSync$_(t, {
                    code: i,
                    key: s.key,
                    which: s.which,
                    repeat: s.repeat,
                    altKey: s.altKey,
                    ctrlKey: s.ctrlKey,
                    metaKey: s.metaKey,
                    shiftKey: s.shiftKey,
                    timeStamp: s.timeStamp
                }, Md);
            }
        }
        _$_OnMouseWheelEvent$_(t, s, i) {
            this._$_isExportToVideo$_ || this._$PostToRuntime$_(t, {
                clientX: s.clientX,
                clientY: s.clientY + this._$_vkTranslateYOffset$_,
                pageX: s.pageX,
                pageY: s.pageY + this._$_vkTranslateYOffset$_,
                deltaX: s.deltaX,
                deltaY: s.deltaY,
                deltaZ: s.deltaZ,
                deltaMode: s.deltaMode,
                timeStamp: s.timeStamp
            }, i);
        }
        _$_OnMouseEvent$_(t, s, i) {
            this._$_isExportToVideo$_ || IsCompatibilityMouseEvent(s) || this._$_PostToRuntimeMaybeSync$_(t, {
                button: s.button,
                buttons: s.buttons,
                clientX: s.clientX,
                clientY: s.clientY + this._$_vkTranslateYOffset$_,
                pageX: s.pageX,
                pageY: s.pageY + this._$_vkTranslateYOffset$_,
                movementX: s.movementX || 0,
                movementY: s.movementY || 0,
                timeStamp: s.timeStamp
            }, i);
        }
        _$_OnPointerEvent$_(s, i) {
            if (!this._$_isExportToVideo$_) {
                let t = 0;
                "mouse" === i.pointerType && (t = this._$_mousePointerLastButtons$_), 
                this._$_PostToRuntimeMaybeSync$_(s, {
                    pointerId: i.pointerId,
                    pointerType: i.pointerType,
                    button: i.button,
                    buttons: i.buttons,
                    lastButtons: t,
                    clientX: i.clientX,
                    clientY: i.clientY + this._$_vkTranslateYOffset$_,
                    pageX: i.pageX,
                    pageY: i.pageY + this._$_vkTranslateYOffset$_,
                    movementX: i.movementX || 0,
                    movementY: i.movementY || 0,
                    width: i.width || 0,
                    height: i.height || 0,
                    pressure: i.pressure || 0,
                    tangentialPressure: i.tangentialPressure || 0,
                    tiltX: i.tiltX || 0,
                    tiltY: i.tiltY || 0,
                    twist: i.twist || 0,
                    timeStamp: i.timeStamp
                }, Md), "mouse" === i.pointerType && (this._$_mousePointerLastButtons$_ = i.buttons);
            }
        }
        _$_OnPointerRawUpdate$_(t) {
            this._$_OnPointerEvent$_("pointermove", t);
        }
        _$_OnTouchEvent$_(i, e) {
            if (!this._$_isExportToVideo$_) for (let t = 0, s = e.changedTouches.length; t < s; ++t) {
                const h = e.changedTouches[t];
                this._$_PostToRuntimeMaybeSync$_(i, {
                    pointerId: h.identifier,
                    pointerType: "touch",
                    button: 0,
                    buttons: 0,
                    lastButtons: 0,
                    clientX: h.clientX,
                    clientY: h.clientY + this._$_vkTranslateYOffset$_,
                    pageX: h.pageX,
                    pageY: h.pageY + this._$_vkTranslateYOffset$_,
                    movementX: e.movementX || 0,
                    movementY: e.movementY || 0,
                    width: 2 * (h.radiusX || h.webkitRadiusX || 0),
                    height: 2 * (h.radiusY || h.webkitRadiusY || 0),
                    pressure: h.force || h.webkitForce || 0,
                    tangentialPressure: 0,
                    tiltX: 0,
                    tiltY: 0,
                    twist: h.rotationAngle || 0,
                    timeStamp: e.timeStamp
                }, Md);
            }
        }
        _$_HandlePointerDownFocus$_(t) {
            window !== window.top && window.focus(), this._$_IsElementCanvasOrDocument$_(t.target) && document.activeElement && !this._$_IsElementCanvasOrDocument$_(document.activeElement) && document.activeElement.blur();
        }
        _$_IsElementCanvasOrDocument$_(t) {
            return !t || t === document || t === window || t === document.body || "canvas" === t.tagName.toLowerCase();
        }
        _$_AttachDeviceOrientationEvent$_() {
            this._$_attachedDeviceOrientationEvent$_ || (this._$_attachedDeviceOrientationEvent$_ = !0, 
            window.addEventListener("deviceorientation", t => this._$_OnDeviceOrientation$_(t)), 
            window.addEventListener("deviceorientationabsolute", t => this._$_OnDeviceOrientationAbsolute$_(t)));
        }
        _$_AttachDeviceMotionEvent$_() {
            this._$_attachedDeviceMotionEvent$_ || (this._$_attachedDeviceMotionEvent$_ = !0, 
            window.addEventListener("devicemotion", t => this._$_OnDeviceMotion$_(t)));
        }
        _$_OnDeviceOrientation$_(t) {
            this._$_isExportToVideo$_ || this._$PostToRuntime$_("deviceorientation", {
                absolute: !!t.absolute,
                alpha: t.alpha || 0,
                beta: t.beta || 0,
                gamma: t.gamma || 0,
                timeStamp: t.timeStamp,
                webkitCompassHeading: t.webkitCompassHeading,
                webkitCompassAccuracy: t.webkitCompassAccuracy
            }, Md);
        }
        _$_OnDeviceOrientationAbsolute$_(t) {
            this._$_isExportToVideo$_ || this._$PostToRuntime$_("deviceorientationabsolute", {
                absolute: !!t.absolute,
                alpha: t.alpha || 0,
                beta: t.beta || 0,
                gamma: t.gamma || 0,
                timeStamp: t.timeStamp
            }, Md);
        }
        _$_OnDeviceMotion$_(e) {
            if (!this._$_isExportToVideo$_) {
                let t = null;
                const h = e.acceleration;
                h && (t = {
                    x: h.x || 0,
                    y: h.y || 0,
                    z: h.z || 0
                });
                let s = null;
                const n = e.accelerationIncludingGravity;
                n && (s = {
                    x: n.x || 0,
                    y: n.y || 0,
                    z: n.z || 0
                });
                let i = null;
                const o = e.rotationRate;
                o && (i = {
                    alpha: o.alpha || 0,
                    beta: o.beta || 0,
                    gamma: o.gamma || 0
                }), this._$PostToRuntime$_("devicemotion", {
                    acceleration: t,
                    accelerationIncludingGravity: s,
                    rotationRate: i,
                    interval: e.interval,
                    timeStamp: e.timeStamp
                }, Md);
            }
        }
        _$_OnInvokeDownload$_(t) {
            const s = t.url, i = t.filename, e = document.createElement("a"), h = document.body;
            e.textContent = i, e.href = s, e.download = i, h.appendChild(e), e.click(), 
            h.removeChild(e);
        }
        async _$_OnLoadWebFonts$_(t) {
            const s = t.webfonts;
            await Promise.all(s.map(async t => {
                const s = new FontFace(t.name, `url('${t.url}')`);
                document.fonts.add(s), await s.load();
            }));
        }
        async _$_OnRasterSvgImage$_(t) {
            const s = t.blob, i = t.imageWidth, e = t.imageHeight, h = t.surfaceWidth, n = t.surfaceHeight, o = t.imageBitmapOpts, r = await self.C3_RasterSvgImageBlob(s, i, e, h, n);
            let a;
            return {
                imageBitmap: a = o ? await createImageBitmap(r, o) : await createImageBitmap(r),
                transferables: [ a ]
            };
        }
        async _$_OnGetSvgImageSize$_(t) {
            return self.C3_GetSvgImageSize(t.blob);
        }
        async _$_OnAddStylesheet$_(t) {
            await AddStyleSheet(t.url);
        }
        _$_PlayPendingMedia$_() {
            const t = [ ...this._$_mediaPendingPlay$_ ];
            if (this._$_mediaPendingPlay$_.clear(), !this._$_isSilent$_) for (const s of t) {
                const i = s.play();
                i && i.catch(t => {
                    this._$_mediaRemovedPendingPlay$_.has(s) || this._$_mediaPendingPlay$_.add(s);
                });
            }
        }
        _$TryPlayMedia$_(s) {
            if ("function" != typeof s.play) throw new Error("missing play function");
            this._$_mediaRemovedPendingPlay$_.delete(s);
            let t;
            try {
                t = s.play();
            } catch (t) {
                return void this._$_mediaPendingPlay$_.add(s);
            }
            t && t.catch(t => {
                this._$_mediaRemovedPendingPlay$_.has(s) || this._$_mediaPendingPlay$_.add(s);
            });
        }
        _$RemovePendingPlay$_(t) {
            this._$_mediaPendingPlay$_.delete(t), this._$_mediaRemovedPendingPlay$_.add(t);
        }
        _$SetSilent$_(t) {
            this._$_isSilent$_ = !!t;
        }
        _$_OnHideCordovaSplash$_() {
            navigator.splashscreen && navigator.splashscreen.hide && navigator.splashscreen.hide();
        }
        _$_OnDebugHighlight$_(t) {
            const s = t.show;
            if (s) {
                this._$_debugHighlightElem$_ || (this._$_debugHighlightElem$_ = document.createElement("div"), 
                this._$_debugHighlightElem$_.id = "inspectOutline", document.body.appendChild(this._$_debugHighlightElem$_));
                const i = this._$_debugHighlightElem$_;
                i.style.display = "", i.style.left = t.left - 1 + "px", i.style.top = t.top - 1 + "px", 
                i.style.width = t.width + 2 + "px", i.style.height = t.height + 2 + "px", 
                i.textContent = t.name;
            } else this._$_debugHighlightElem$_ && (this._$_debugHighlightElem$_.style.display = "none");
        }
        _$_OnRegisterSW$_() {
            window.C3_RegisterSW && window.C3_RegisterSW();
        }
        _$_OnPostToDebugger$_(t) {
            window.c3_postToMessagePort && (t.from = "runtime", window.c3_postToMessagePort(t));
        }
        _$_InvokeFunctionFromJS$_(t, s) {
            return this._$PostToRuntimeAsync$_("js-invoke-function", {
                name: t,
                params: s
            });
        }
        _$_OnScriptCreateWorker$_(t) {
            const s = t.url, i = t.opts, e = t.port2, h = new Worker(s, i);
            h.postMessage({
                type: "construct-worker-init",
                port2: e
            }, [ e ]);
        }
        _$_OnAlert$_(t) {
            alert(t.message);
        }
        _$_OnScreenReaderTextEvent$_(t) {
            const s = t.type;
            if ("create" === s) {
                const i = document.createElement("p");
                i.id = "c3-sr-" + t.id, i.textContent = t.text, this._$_screenReaderTextWrap$_.appendChild(i);
            } else if ("update" === s) {
                const e = document.getElementById("c3-sr-" + t.id);
                e ? e.textContent = t.text : console.warn("[Construct] Missing screen reader text with id " + t.id);
            } else if ("release" === s) {
                const h = document.getElementById("c3-sr-" + t.id);
                h ? h.remove() : console.warn("[Construct] Missing screen reader text with id " + t.id);
            } else console.warn(`[Construct] Unknown screen reader text update '${s}'`);
        }
        _$_SetExportingToVideo$_(t) {
            this._$_isExportToVideo$_ = !0;
            const s = document.createElement("h1");
            s.id = "exportToVideoMessage", s.textContent = t.message, document.body.prepend(s), 
            document.body.classList.add("exportingToVideo"), this._$GetRuntimeInterface$_()._$GetMainCanvas$_().style.display = "", 
            this._$_iRuntime$_._$SetIsExportingToVideo$_(t.duration);
        }
        _$_OnExportVideoProgress$_(t) {
            this._$_exportVideoProgressMessage$_ = t.message, -1 === this._$_exportVideoUpdateTimerId$_ && (this._$_exportVideoUpdateTimerId$_ = setTimeout(() => this._$_DoUpdateExportVideoProgressMessage$_(), 250));
        }
        _$_DoUpdateExportVideoProgressMessage$_() {
            this._$_exportVideoUpdateTimerId$_ = -1;
            const t = document.getElementById("exportToVideoMessage");
            t && (t.textContent = this._$_exportVideoProgressMessage$_);
        }
        _$_OnExportedToVideo$_(t) {
            window.c3_postToMessagePort({
                type: "exported-video",
                arrayBuffer: t.arrayBuffer,
                contentType: t.contentType,
                time: t.time
            });
        }
        _$_OnExportedToImageSequence$_(t) {
            window.c3_postToMessagePort({
                type: "exported-image-sequence",
                blobArr: t.blobArr,
                time: t.time,
                gif: t.gif
            });
        }
    };
    Kd._$AddDOMHandlerClass$_(Td);
}

{
    const zf = "dispatchworker.js", Af = "jobworker.js";
    self._$JobSchedulerDOM$_ = class {
        constructor(t) {
            this._$_runtimeInterface$_ = t, this._$_maxNumWorkers$_ = Math.min(navigator.hardwareConcurrency || 2, 16), 
            this._$_dispatchWorker$_ = null, this._$_jobWorkers$_ = [], this._$_inputPort$_ = null, 
            this._$_outputPort$_ = null;
        }
        async _$Init$_() {
            if (this._$_hasInitialised$_) throw new Error("already initialised");
            this._$_hasInitialised$_ = !0;
            const t = this._$_runtimeInterface$_._$GetScriptFolder$_() + zf, s = (this._$_dispatchWorker$_ = await this._$_runtimeInterface$_._$CreateWorker$_(t, {
                name: "DispatchWorker"
            }), new MessageChannel());
            this._$_inputPort$_ = s.port1, this._$_dispatchWorker$_.postMessage({
                type: "_init",
                "in-port": s.port2
            }, [ s.port2 ]), this._$_outputPort$_ = await this._$_CreateJobWorker$_();
        }
        async _$_CreateJobWorker$_() {
            const t = this._$_jobWorkers$_.length, s = this._$_runtimeInterface$_._$GetScriptFolder$_() + Af, i = await this._$_runtimeInterface$_._$CreateWorker$_(s, {
                name: "JobWorker" + t
            }), e = new MessageChannel(), h = new MessageChannel();
            return this._$_dispatchWorker$_.postMessage({
                type: "_addJobWorker",
                port: e.port1
            }, [ e.port1 ]), i.postMessage({
                type: "init",
                number: t,
                "dispatch-port": e.port2,
                "output-port": h.port2
            }, [ e.port2, h.port2 ]), this._$_jobWorkers$_.push(i), h.port1;
        }
        _$GetPortData$_() {
            return {
                inputPort: this._$_inputPort$_,
                outputPort: this._$_outputPort$_,
                maxNumWorkers: this._$_maxNumWorkers$_
            };
        }
        _$GetPortTransferables$_() {
            return [ this._$_inputPort$_, this._$_outputPort$_ ];
        }
    };
}

{
    const Kf = 180 / Math.PI, Lf = "audio";
    self._$AudioDOMHandler$_ = class extends self._$DOMHandler$_ {
        constructor(t) {
            super(t, Lf), this._$_audioContext$_ = null, this._$_destinationNode$_ = null, 
            this._$_hasUnblocked$_ = !1, this._$_hasAttachedUnblockEvents$_ = !1, 
            this._$_unblockFunc$_ = () => this._$_UnblockAudioContext$_(), this._$_audioBuffers$_ = [], 
            this._$_audioInstances$_ = [], this._$_lastAudioInstance$_ = null, this._$_lastPlayedTags$_ = [], 
            this._$_loadedAudioUrls$_ = new Set(), this._$_lastTickCount$_ = -1, 
            this._$_pendingTags$_ = new Map(), this._$_masterVolume$_ = 1, this._$_isSilent$_ = !1, 
            this._$_timeScaleMode$_ = 0, this._$_timeScale$_ = 1, this._$_gameTime$_ = 0, 
            this._$_panningModel$_ = "HRTF", this._$_distanceModel$_ = "inverse", 
            this._$_refDistance$_ = 600, this._$_maxDistance$_ = 1e4, this._$_rolloffFactor$_ = 1, 
            this._$_lastListenerPos$_ = [ 0, 0, 0 ], this._$_lastListenerOrientation$_ = [ 0, 0, -1, 0, 1, 0 ], 
            this._$_playMusicAsSound$_ = !1, this._$_hasAnySoftwareDecodedMusic$_ = !1, 
            this._$_supportsWebMOpus$_ = this._$_iRuntime$_._$IsAudioFormatSupported$_("audio/webm; codecs=opus"), 
            this._$_effects$_ = new Map(), this._$_analysers$_ = new Set(), this._$_isPendingPostFxState$_ = !1, 
            this._$_hasStartedOfflineRender$_ = !1, this._$_microphoneTag$_ = "", 
            this._$_microphoneSource$_ = null, self.C3Audio_OnMicrophoneStream = (t, s) => this._$_OnMicrophoneStream$_(t, s), 
            this._$_destMediaStreamNode$_ = null, self.C3Audio_GetOutputStream = () => this._$_OnGetOutputStream$_(), 
            (self.C3Audio_DOMInterface = this)._$AddRuntimeMessageHandlers$_([ [ "create-audio-context", t => this._$_CreateAudioContext$_(t) ], [ "play", t => this._$_Play$_(t) ], [ "stop", t => this._$_Stop$_(t) ], [ "stop-all", () => this._$_StopAll$_() ], [ "set-paused", t => this._$_SetPaused$_(t) ], [ "set-volume", t => this._$_SetVolume$_(t) ], [ "fade-volume", t => this._$_FadeVolume$_(t) ], [ "set-master-volume", t => this._$_SetMasterVolume$_(t) ], [ "set-muted", t => this._$_SetMuted$_(t) ], [ "set-silent", t => this._$_SetSilent$_(t) ], [ "set-looping", t => this._$_SetLooping$_(t) ], [ "set-playback-rate", t => this._$_SetPlaybackRate$_(t) ], [ "set-stereo-pan", t => this._$_SetStereoPan$_(t) ], [ "seek", t => this._$_Seek$_(t) ], [ "preload", t => this._$_Preload$_(t) ], [ "unload", t => this._$_Unload$_(t) ], [ "unload-all", () => this._$_UnloadAll$_() ], [ "set-suspended", t => this._$_SetSuspended$_(t) ], [ "add-effect", t => this._$_AddEffect$_(t) ], [ "set-effect-param", t => this._$_SetEffectParam$_(t) ], [ "remove-effects", t => this._$_RemoveEffects$_(t) ], [ "tick", t => this._$_OnTick$_(t) ], [ "load-state", t => this._$_OnLoadState$_(t) ], [ "offline-render-audio", t => this._$_OnOfflineRenderAudio$_(t) ], [ "offline-render-finish", () => this._$_OnOfflineRenderFinish$_() ] ]);
        }
        async _$_CreateAudioContext$_(t) {
            if (t.usePlayMusicAsSoundWorkaround && (this._$_playMusicAsSound$_ = !0), 
            this._$_timeScaleMode$_ = t.timeScaleMode, this._$_panningModel$_ = [ "equalpower", "HRTF", "soundfield" ][t.panningModel], 
            this._$_distanceModel$_ = [ "linear", "inverse", "exponential" ][t.distanceModel], 
            this._$_refDistance$_ = t.refDistance, this._$_maxDistance$_ = t.maxDistance, 
            this._$_rolloffFactor$_ = t.rolloffFactor, this._$_iRuntime$_._$IsExportingToVideo$_()) {
                this._$_playMusicAsSound$_ = !0;
                this._$_audioContext$_ = new OfflineAudioContext({
                    numberOfChannels: 2,
                    sampleRate: 48e3,
                    length: Math.ceil(48e3 * this._$_iRuntime$_._$GetExportToVideoDuration$_())
                });
            } else {
                const i = {
                    latencyHint: t.latencyHint
                };
                if (this._$SupportsWebMOpus$_() || (i.sampleRate = 48e3), "undefined" != typeof AudioContext) this._$_audioContext$_ = new AudioContext(i); else {
                    if ("undefined" == typeof webkitAudioContext) throw new Error("Web Audio API not supported");
                    this._$_audioContext$_ = new webkitAudioContext(i);
                }
                this._$_AttachUnblockEvents$_(), this._$_audioContext$_.onstatechange = () => {
                    "running" !== this._$_audioContext$_.state && this._$_AttachUnblockEvents$_(), 
                    this._$PostToRuntime$_("audiocontext-state", {
                        audioContextState: this._$_audioContext$_.state
                    });
                };
            }
            this._$_destinationNode$_ = this._$_audioContext$_.createGain(), this._$_destinationNode$_.connect(this._$_audioContext$_.destination);
            const s = t.listenerPos;
            this._$_lastListenerPos$_[0] = s[0], this._$_lastListenerPos$_[1] = s[1], 
            this._$_lastListenerPos$_[2] = s[2], this._$_audioContext$_.listener.setPosition(s[0], s[1], s[2]), 
            this._$_audioContext$_.listener.setOrientation(...this._$_lastListenerOrientation$_), 
            self.C3_GetAudioContextCurrentTime = () => this._$GetAudioCurrentTime$_();
            try {
                await Promise.all(t.preloadList.map(t => this._$_GetAudioBuffer$_(t.originalUrl, t.url, t.type, !1)));
            } catch (t) {
                console.error("[Construct] Preloading sounds failed: ", t);
            }
            return {
                sampleRate: this._$_audioContext$_.sampleRate,
                audioContextState: this._$_audioContext$_.state,
                outputLatency: this._$_audioContext$_.outputLatency || 0
            };
        }
        _$_AttachUnblockEvents$_() {
            this._$_hasAttachedUnblockEvents$_ || (this._$_hasUnblocked$_ = !1, 
            window.addEventListener("pointerup", this._$_unblockFunc$_, !0), window.addEventListener("touchend", this._$_unblockFunc$_, !0), 
            window.addEventListener("click", this._$_unblockFunc$_, !0), window.addEventListener("keydown", this._$_unblockFunc$_, !0), 
            this._$_hasAttachedUnblockEvents$_ = !0);
        }
        _$_DetachUnblockEvents$_() {
            this._$_hasAttachedUnblockEvents$_ && (this._$_hasUnblocked$_ = !0, 
            window.removeEventListener("pointerup", this._$_unblockFunc$_, !0), 
            window.removeEventListener("touchend", this._$_unblockFunc$_, !0), window.removeEventListener("click", this._$_unblockFunc$_, !0), 
            window.removeEventListener("keydown", this._$_unblockFunc$_, !0), this._$_hasAttachedUnblockEvents$_ = !1);
        }
        _$_UnblockAudioContext$_() {
            if (!this._$_hasUnblocked$_) {
                const t = this._$_audioContext$_, s = ("suspended" === t.state && t.resume && t.resume(), 
                t.createBuffer(1, 220, 22050)), i = t.createBufferSource();
                i.buffer = s, i.connect(t.destination), i.start(0), "running" === t.state && this._$_DetachUnblockEvents$_();
            }
        }
        _$_MatchTagLists$_(s, t) {
            for (const i of t) {
                let t = !1;
                for (const e of s) if (self._$AudioDOMHandler$_._$EqualsNoCase$_(e, i)) {
                    t = !0;
                    break;
                }
                if (!t) return !1;
            }
            return !0;
        }
        _$GetAudioContext$_() {
            return this._$_audioContext$_;
        }
        _$GetAudioCurrentTime$_() {
            return this._$_audioContext$_.currentTime;
        }
        _$GetDestinationNode$_() {
            return this._$_destinationNode$_;
        }
        ["GetAudioContextExtern"]() {
            return this._$GetAudioContext$_();
        }
        ["GetDestinationNodeExtern"]() {
            return this._$GetDestinationNode$_();
        }
        _$GetDestinationForTag$_(t) {
            const s = this._$_effects$_.get(t.toLowerCase());
            return s ? s[0]._$GetInputNode$_() : this._$GetDestinationNode$_();
        }
        _$AddEffectForTag$_(t, s) {
            t = t.toLowerCase();
            let i = this._$_effects$_.get(t);
            i || (i = [], this._$_effects$_.set(t, i)), s._$_SetIndex$_(i.length), 
            s._$_SetTag$_(t), i.push(s), this._$_ReconnectEffects$_(t);
        }
        _$_ReconnectEffects$_(t) {
            t = t.toLowerCase();
            let s = this._$GetDestinationNode$_();
            const i = this._$_effects$_.get(t);
            if (i && i.length) {
                s = i[0]._$GetInputNode$_();
                for (let t = 0, s = i.length; t < s; ++t) {
                    const e = i[t];
                    t + 1 === s ? e._$ConnectTo$_(this._$GetDestinationNode$_()) : e._$ConnectTo$_(i[t + 1]._$GetInputNode$_());
                }
            }
            for (const h of this._$audioInstancesByEffectTag$_(t)) h._$Reconnect$_(s);
            this._$_microphoneSource$_ && this._$_microphoneTag$_ === t && (this._$_microphoneSource$_.disconnect(), 
            this._$_microphoneSource$_.connect(s));
        }
        _$GetMasterVolume$_() {
            return this._$_masterVolume$_;
        }
        _$IsSilent$_() {
            return this._$_isSilent$_;
        }
        _$GetTimeScaleMode$_() {
            return this._$_timeScaleMode$_;
        }
        _$GetTimeScale$_() {
            return this._$_timeScale$_;
        }
        _$GetGameTime$_() {
            return this._$_gameTime$_;
        }
        _$IsPlayMusicAsSound$_() {
            return this._$_playMusicAsSound$_;
        }
        _$SupportsWebMOpus$_() {
            return this._$_supportsWebMOpus$_;
        }
        _$_SetHasAnySoftwareDecodedMusic$_() {
            this._$_hasAnySoftwareDecodedMusic$_ = !0;
        }
        _$GetPanningModel$_() {
            return this._$_panningModel$_;
        }
        _$GetDistanceModel$_() {
            return this._$_distanceModel$_;
        }
        _$GetReferenceDistance$_() {
            return this._$_refDistance$_;
        }
        _$GetMaxDistance$_() {
            return this._$_maxDistance$_;
        }
        _$GetRolloffFactor$_() {
            return this._$_rolloffFactor$_;
        }
        _$DecodeAudioData$_(i, t) {
            return t ? this._$_iRuntime$_._$_WasmDecodeWebMOpus$_(i).then(t => {
                const s = this._$_audioContext$_.createBuffer(1, t.length, 48e3), i = s.getChannelData(0);
                return i.set(t), s;
            }) : new Promise((t, s) => {
                this._$_audioContext$_.decodeAudioData(i, t, s);
            });
        }
        _$TryPlayMedia$_(t) {
            this._$_iRuntime$_._$TryPlayMedia$_(t);
        }
        _$RemovePendingPlay$_(t) {
            this._$_iRuntime$_._$RemovePendingPlay$_(t);
        }
        _$ReleaseInstancesForBuffer$_(i) {
            let e = 0;
            for (let t = 0, s = this._$_audioInstances$_.length; t < s; ++t) {
                const h = this._$_audioInstances$_[t];
                (this._$_audioInstances$_[e] = h)._$GetBuffer$_() === i ? h._$Release$_() : ++e;
            }
            this._$_audioInstances$_.length = e;
        }
        _$ReleaseAllMusicBuffers$_() {
            let i = 0;
            for (let t = 0, s = this._$_audioBuffers$_.length; t < s; ++t) {
                const e = this._$_audioBuffers$_[t];
                (this._$_audioBuffers$_[i] = e)._$IsMusic$_() ? e._$Release$_() : ++i;
            }
            this._$_audioBuffers$_.length = i;
        }
        *_$audioInstancesMatchingTags$_(t) {
            if (0 < t.length) for (const s of this._$_audioInstances$_) this._$_MatchTagLists$_(s._$GetTags$_(), t) && (yield s); else this._$_lastAudioInstance$_ && !this._$_lastAudioInstance$_._$HasEnded$_() && (yield this._$_lastAudioInstance$_);
        }
        *_$audioInstancesByEffectTag$_(t) {
            if (t) for (const s of this._$_audioInstances$_) self._$AudioDOMHandler$_._$EqualsNoCase$_(s._$GetEffectTag$_(), t) && (yield s); else this._$_lastAudioInstance$_ && !this._$_lastAudioInstance$_._$HasEnded$_() && (yield this._$_lastAudioInstance$_);
        }
        async _$_GetAudioBuffer$_(t, s, i, e, h) {
            for (const o of this._$_audioBuffers$_) if (o._$GetUrl$_() === s) return await o._$Load$_(), 
            o;
            if (h) return null;
            e && (this._$_playMusicAsSound$_ || this._$_hasAnySoftwareDecodedMusic$_) && this._$ReleaseAllMusicBuffers$_();
            const n = self._$C3AudioBuffer$_._$Create$_(this, t, s, i, e);
            return this._$_audioBuffers$_.push(n), await n._$Load$_(), this._$_loadedAudioUrls$_.has(t) || (this._$PostToRuntime$_("buffer-metadata", {
                originalUrl: t,
                duration: n._$GetDuration$_()
            }), this._$_loadedAudioUrls$_.add(t)), n;
        }
        async _$_GetAudioInstance$_(t, s, i, e, h) {
            for (const r of this._$_audioInstances$_) if (r._$GetUrl$_() === s && (r._$CanBeRecycled$_() || h)) return r._$SetTags$_(e), 
            r;
            const n = await this._$_GetAudioBuffer$_(t, s, i, h), o = n._$CreateInstance$_(e);
            return this._$_audioInstances$_.push(o), o;
        }
        _$_AddPendingTags$_(t) {
            const i = t.join(" ");
            let e = this._$_pendingTags$_.get(i);
            if (!e) {
                let s = null;
                const h = new Promise(t => s = t);
                e = {
                    _$pendingCount$_: 0,
                    promise: h,
                    resolve: s
                }, this._$_pendingTags$_.set(i, e);
            }
            e._$pendingCount$_++;
        }
        _$_RemovePendingTags$_(t) {
            const s = t.join(" "), i = this._$_pendingTags$_.get(s);
            if (!i) throw new Error("expected pending tag");
            i._$pendingCount$_--, 0 === i._$pendingCount$_ && (i.resolve(), this._$_pendingTags$_.delete(s));
        }
        _$TagsReady$_(t) {
            const s = (0 === t.length ? this._$_lastPlayedTags$_ : t).join(" "), i = this._$_pendingTags$_.get(s);
            return i ? i.promise : Promise.resolve();
        }
        _$_MaybeStartTicking$_() {
            if (0 < this._$_analysers$_.size) this._$_StartTicking$_(); else for (const t of this._$_audioInstances$_) if (t._$IsActive$_()) return void this._$_StartTicking$_();
        }
        _$Tick$_() {
            for (const i of this._$_analysers$_) i._$Tick$_();
            const t = this._$GetAudioCurrentTime$_();
            for (const e of this._$_audioInstances$_) e._$Tick$_(t);
            const s = this._$_audioInstances$_.filter(t => t._$IsActive$_()).map(t => t._$GetState$_());
            this._$PostToRuntime$_("state", {
                tickCount: this._$_lastTickCount$_,
                outputLatency: this._$_audioContext$_.outputLatency || 0,
                audioInstances: s,
                analysers: [ ...this._$_analysers$_ ].map(t => t._$GetData$_())
            }), 0 === s.length && 0 === this._$_analysers$_.size && this._$_StopTicking$_();
        }
        _$PostTrigger$_(t, s, i) {
            this._$PostToRuntime$_("trigger", {
                type: t,
                tags: s,
                aiid: i
            });
        }
        async _$_Play$_(t) {
            const s = t.originalUrl, i = t.url, e = t.type, h = t.isMusic, n = t.tags, o = t.isLooping, r = t.vol, a = t.pos, c = t.panning, l = t.stereoPan;
            let u = t.off;
            if (0 < u && !t.trueClock) if (this._$_audioContext$_.getOutputTimestamp) {
                const d = this._$_audioContext$_.getOutputTimestamp();
                u = u - d.performanceTime / 1e3 + d.contextTime;
            } else u = u - performance.now() / 1e3 + this._$_audioContext$_.currentTime;
            this._$_lastPlayedTags$_ = n.slice(0), this._$_AddPendingTags$_(n);
            try {
                this._$_lastAudioInstance$_ = await this._$_GetAudioInstance$_(s, i, e, n, h), 
                c ? (this._$_lastAudioInstance$_._$SetPannerEnabled$_(!0), this._$_lastAudioInstance$_._$SetPan$_(c.x, c.y, c.z, c.angle, c.innerAngle, c.outerAngle, c.outerGain), 
                c.hasOwnProperty("uid") && this._$_lastAudioInstance$_._$SetUID$_(c.uid)) : "number" == typeof l && 0 !== l ? (this._$_lastAudioInstance$_._$SetStereoPannerEnabled$_(!0), 
                this._$_lastAudioInstance$_._$SetStereoPan$_(l)) : (this._$_lastAudioInstance$_._$SetPannerEnabled$_(!1), 
                this._$_lastAudioInstance$_._$SetStereoPannerEnabled$_(!1)), this._$_lastAudioInstance$_.Play(o, r, a, u);
            } catch (t) {
                return void console.error("[Construct] Audio: error starting playback: ", t);
            } finally {
                this._$_RemovePendingTags$_(n);
            }
            this._$_StartTicking$_();
        }
        _$_Stop$_(t) {
            const s = t.tags;
            for (const i of this._$audioInstancesMatchingTags$_(s)) i._$Stop$_();
        }
        _$_StopAll$_() {
            for (const t of this._$_audioInstances$_) t._$Stop$_();
        }
        _$_SetPaused$_(t) {
            const s = t.tags, i = t.paused;
            for (const e of this._$audioInstancesMatchingTags$_(s)) i ? e._$Pause$_() : e._$Resume$_();
            this._$_MaybeStartTicking$_();
        }
        _$_SetVolume$_(t) {
            const s = t.tags, i = t.vol;
            for (const e of this._$audioInstancesMatchingTags$_(s)) e._$SetVolume$_(i);
        }
        _$_SetStereoPan$_(t) {
            const s = t.tags, i = t.p;
            for (const e of this._$audioInstancesMatchingTags$_(s)) e._$SetStereoPannerEnabled$_(!0), 
            e._$SetStereoPan$_(i);
        }
        async _$_FadeVolume$_(t) {
            const s = t.tags, i = t.vol, e = t.duration, h = t.stopOnEnd;
            await this._$TagsReady$_(s);
            for (const n of this._$audioInstancesMatchingTags$_(s)) n._$FadeVolume$_(i, e, h);
            this._$_MaybeStartTicking$_();
        }
        _$_SetMasterVolume$_(t) {
            this._$_masterVolume$_ = t.vol, this._$_destinationNode$_.gain.value = this._$_masterVolume$_;
        }
        _$_SetMuted$_(t) {
            const s = t.tags, i = t.isMuted;
            for (const e of this._$audioInstancesMatchingTags$_(s)) e._$SetMuted$_(i);
        }
        _$_SetSilent$_(t) {
            this._$_isSilent$_ = t.isSilent, this._$_iRuntime$_._$SetSilent$_(this._$_isSilent$_);
            for (const s of this._$_audioInstances$_) s._$_UpdateMuted$_();
        }
        _$_SetLooping$_(t) {
            const s = t.tags, i = t.isLooping;
            for (const e of this._$audioInstancesMatchingTags$_(s)) e._$SetLooping$_(i);
        }
        async _$_SetPlaybackRate$_(t) {
            const s = t.tags, i = t.rate;
            await this._$TagsReady$_(s);
            for (const e of this._$audioInstancesMatchingTags$_(s)) e._$SetPlaybackRate$_(i);
        }
        async _$_Seek$_(t) {
            const s = t.tags, i = t.pos;
            await this._$TagsReady$_(s);
            for (const e of this._$audioInstancesMatchingTags$_(s)) e._$Seek$_(i);
        }
        async _$_Preload$_(t) {
            const s = t.originalUrl, i = t.url, e = t.type, h = t.isMusic;
            try {
                await this._$_GetAudioInstance$_(s, i, e, "", h);
            } catch (t) {
                console.error("[Construct] Audio: error preloading: ", t);
            }
        }
        async _$_Unload$_(t) {
            const s = t.url, i = t.type, e = t.isMusic, h = await this._$_GetAudioBuffer$_("", s, i, e, !0);
            if (h) {
                h._$Release$_();
                const n = this._$_audioBuffers$_.indexOf(h);
                -1 !== n && this._$_audioBuffers$_.splice(n, 1);
            }
        }
        _$_UnloadAll$_() {
            for (const t of this._$_audioBuffers$_) t._$Release$_();
            this._$_audioBuffers$_.length = 0;
        }
        _$_SetSuspended$_(t) {
            const s = t.isSuspended;
            !s && this._$_audioContext$_.resume && this._$_audioContext$_.resume();
            for (const i of this._$_audioInstances$_) i._$SetSuspended$_(s);
            s && this._$_audioContext$_.suspend && this._$_audioContext$_.suspend();
        }
        _$_OnTick$_(t) {
            if (this._$_timeScale$_ = t.timeScale, this._$_gameTime$_ = t.gameTime, 
            this._$_lastTickCount$_ = t.tickCount, 0 !== this._$_timeScaleMode$_) for (const e of this._$_audioInstances$_) e._$_UpdatePlaybackRate$_();
            const s = t.listenerPos, i = (!s || this._$_lastListenerPos$_[0] === s[0] && this._$_lastListenerPos$_[1] === s[1] && this._$_lastListenerPos$_[2] === s[2] || (this._$_lastListenerPos$_[0] = s[0], 
            this._$_lastListenerPos$_[1] = s[1], this._$_lastListenerPos$_[2] = s[2], 
            this._$_audioContext$_.listener.setPosition(s[0], s[1], s[2])), t.listenerOrientation);
            if (i && (this._$_lastListenerOrientation$_[0] !== i[0] || this._$_lastListenerOrientation$_[1] !== i[1] || this._$_lastListenerOrientation$_[2] !== i[2] || this._$_lastListenerOrientation$_[3] !== i[3] || this._$_lastListenerOrientation$_[4] !== i[4] || this._$_lastListenerOrientation$_[5] !== i[5])) {
                for (let t = 0; t < 6; ++t) this._$_lastListenerOrientation$_[t] = i[t];
                this._$_audioContext$_.listener.setOrientation(...this._$_lastListenerOrientation$_);
            }
            for (const h of t.instPans) {
                const n = h.uid;
                for (const o of this._$_audioInstances$_) o._$GetUID$_() === n && o._$SetPanXYZA$_(h.x, h.y, h.z, h.angle);
            }
        }
        async _$_AddEffect$_(t) {
            const s = t.type, i = t.hasOwnProperty("tags") ? t.tags : [ t.tag ], e = t.params;
            let h, n;
            if ("convolution" === s) try {
                n = await this._$_GetAudioBuffer$_(t.bufferOriginalUrl, t.bufferUrl, t.bufferType, !1);
            } catch (t) {
                return void console.log("[Construct] Audio: error loading convolution: ", t);
            }
            for (const o of i) {
                if ("filter" === s) h = new self._$C3AudioFilterFX$_(this, ...e); else if ("delay" === s) h = new self._$C3AudioDelayFX$_(this, ...e); else if ("convolution" === s) (h = new self._$C3AudioConvolveFX$_(this, n._$GetAudioBuffer$_(), ...e))._$_SetBufferInfo$_(t.bufferOriginalUrl, t.bufferUrl, t.bufferType); else if ("flanger" === s) h = new self._$C3AudioFlangerFX$_(this, ...e); else if ("phaser" === s) h = new self._$C3AudioPhaserFX$_(this, ...e); else if ("gain" === s) h = new self._$C3AudioGainFX$_(this, ...e); else if ("stereopan" === s) h = new self._$C3AudioStereoPanFX$_(this, ...e); else if ("tremolo" === s) h = new self._$C3AudioTremoloFX$_(this, ...e); else if ("ringmod" === s) h = new self._$C3AudioRingModFX$_(this, ...e); else if ("distortion" === s) h = new self._$C3AudioDistortionFX$_(this, ...e); else if ("compressor" === s) h = new self._$C3AudioCompressorFX$_(this, ...e); else {
                    if ("analyser" !== s) throw new Error("invalid effect type");
                    h = new self._$C3AudioAnalyserFX$_(this, ...e);
                }
                this._$AddEffectForTag$_(o, h);
            }
            this._$_PostUpdatedFxState$_();
        }
        _$_SetEffectParam$_(t) {
            const s = t.tags, i = t.index, e = t.param, h = t.value, n = t.ramp, o = t.time;
            for (const r of s) {
                const a = this._$_effects$_.get(r.toLowerCase());
                !a || i < 0 || i >= a.length || a[i]._$SetParam$_(e, h, n, o);
            }
            this._$_PostUpdatedFxState$_();
        }
        _$_RemoveEffects$_(t) {
            const s = t.tags;
            for (const i of s) {
                const e = i.toLowerCase(), h = this._$_effects$_.get(e);
                if (!h || !h.length) return;
                for (const n of h) n._$Release$_();
                this._$_effects$_.delete(e), this._$_ReconnectEffects$_(e);
            }
        }
        _$_AddAnalyser$_(t) {
            this._$_analysers$_.add(t), this._$_MaybeStartTicking$_();
        }
        _$_RemoveAnalyser$_(t) {
            this._$_analysers$_.delete(t);
        }
        _$_PostUpdatedFxState$_() {
            this._$_isPendingPostFxState$_ || (this._$_isPendingPostFxState$_ = !0, 
            Promise.resolve().then(() => this._$_DoPostUpdatedFxState$_()));
        }
        _$_DoPostUpdatedFxState$_() {
            const t = {};
            for (const [ s, i ] of this._$_effects$_) t[s] = i.map(t => t._$GetState$_());
            this._$PostToRuntime$_("fxstate", {
                fxstate: t
            }), this._$_isPendingPostFxState$_ = !1;
        }
        async _$_OnLoadState$_(t) {
            const s = t.saveLoadMode;
            if (3 !== s) {
                const n = [];
                for (const o of this._$_audioInstances$_) o._$IsMusic$_() && 1 === s || !o._$IsMusic$_() && 2 === s ? n.push(o) : o._$Release$_();
                this._$_audioInstances$_ = n;
            }
            for (const r of this._$_effects$_.values()) for (const a of r) a._$Release$_();
            this._$_effects$_.clear(), this._$_timeScale$_ = t.timeScale, this._$_gameTime$_ = t.gameTime;
            const i = t.listenerPos, e = (this._$_lastListenerPos$_[0] = i[0], this._$_lastListenerPos$_[1] = i[1], 
            this._$_lastListenerPos$_[2] = i[2], this._$_audioContext$_.listener.setPosition(i[0], i[1], i[2]), 
            t.listenerOrientation);
            if (Array.isArray(e)) {
                for (let t = 0; t < 6; ++t) this._$_lastListenerOrientation$_[t] = e[t];
                this._$_audioContext$_.listener.setOrientation(...this._$_lastListenerOrientation$_);
            }
            this._$_isSilent$_ = t.isSilent, this._$_iRuntime$_._$SetSilent$_(this._$_isSilent$_), 
            this._$_masterVolume$_ = t.masterVolume, this._$_destinationNode$_.gain.value = this._$_masterVolume$_;
            const h = [];
            for (const c of Object.values(t.effects)) h.push(Promise.all(c.map(t => this._$_AddEffect$_(t))));
            await Promise.all(h), await Promise.all(t.playing.map(t => this._$_LoadAudioInstance$_(t, s))), 
            this._$_MaybeStartTicking$_();
        }
        async _$_LoadAudioInstance$_(s, t) {
            if (3 !== t) {
                const i = s.bufferOriginalUrl, e = s.bufferUrl, h = s.bufferType, n = s.isMusic, o = s.tags, r = s.isLooping, a = s.volume, c = s.playbackTime;
                if ((!n || 1 !== t) && (n || 2 !== t)) {
                    let t = null;
                    try {
                        t = await this._$_GetAudioInstance$_(i, e, h, o, n);
                    } catch (t) {
                        return void console.error("[Construct] Audio: error loading audio state: ", t);
                    }
                    t._$LoadPanState$_(s.pan), t._$LoadStereoPanState$_(s.stereoPan), 
                    t.Play(r, a, c, 0), s.isPlaying || t._$Pause$_(), t._$_LoadAdditionalState$_(s);
                }
            }
        }
        _$_OnMicrophoneStream$_(t, s) {
            this._$_microphoneSource$_ && this._$_microphoneSource$_.disconnect(), 
            this._$_microphoneTag$_ = s.toLowerCase(), this._$_microphoneSource$_ = this._$_audioContext$_.createMediaStreamSource(t), 
            this._$_microphoneSource$_.connect(this._$GetDestinationForTag$_(this._$_microphoneTag$_));
        }
        _$_OnGetOutputStream$_() {
            return this._$_destMediaStreamNode$_ || (this._$_destMediaStreamNode$_ = this._$_audioContext$_.createMediaStreamDestination(), 
            this._$_destinationNode$_.connect(this._$_destMediaStreamNode$_)), this._$_destMediaStreamNode$_.stream;
        }
        async _$_OnOfflineRenderAudio$_(t) {
            try {
                const s = t.time, i = this._$_audioContext$_.suspend(s);
                this._$_hasStartedOfflineRender$_ ? this._$_audioContext$_.resume() : (this._$_audioContext$_.startRendering().then(t => this._$_OnOfflineRenderCompleted$_(t)).catch(t => this._$_OnOfflineRenderError$_(t)), 
                this._$_hasStartedOfflineRender$_ = !0), await i;
            } catch (t) {
                this._$_OnOfflineRenderError$_(t);
            }
        }
        _$_OnOfflineRenderFinish$_() {
            this._$_audioContext$_.resume();
        }
        _$_OnOfflineRenderCompleted$_(i) {
            const e = [];
            for (let t = 0, s = i.numberOfChannels; t < s; ++t) {
                const h = i.getChannelData(t);
                e.push(h.buffer);
            }
            this._$_iRuntime$_._$PostToRuntimeComponent$_("runtime", "offline-audio-render-completed", {
                duration: i.duration,
                length: i.length,
                numberOfChannels: i.numberOfChannels,
                sampleRate: i.sampleRate,
                channelData: e
            }, null, e);
        }
        _$_OnOfflineRenderError$_(t) {
            console.error("[Audio] Offline rendering error: ", t);
        }
        static _$EqualsNoCase$_(t, s) {
            return t === s || t.normalize().toLowerCase() === s.normalize().toLowerCase();
        }
        static _$ToDegrees$_(t) {
            return t * Kf;
        }
        static _$DbToLinearNoCap$_(t) {
            return Math.pow(10, t / 20);
        }
        static _$DbToLinear$_(t) {
            return Math.max(Math.min(self._$AudioDOMHandler$_._$DbToLinearNoCap$_(t), 1), 0);
        }
        static _$LinearToDbNoCap$_(t) {
            return Math.log(t) / Math.log(10) * 20;
        }
        static _$LinearToDb$_(t) {
            return self._$AudioDOMHandler$_._$LinearToDbNoCap$_(Math.max(Math.min(t, 1), 0));
        }
        static _$e4$_(t, s) {
            return 1 - Math.exp(-s * t);
        }
    }, self._$RuntimeInterface$_._$AddDOMHandlerClass$_(self._$AudioDOMHandler$_);
}

self._$C3AudioBuffer$_ = class {
    constructor(t, s, i, e, h) {
        this._$_audioDomHandler$_ = t, this._$_originalUrl$_ = s, this._$_url$_ = i, 
        this._$_type$_ = e, this._$_isMusic$_ = h, this._$_api$_ = "", this._$_loadState$_ = "not-loaded", 
        this._$_loadPromise$_ = null;
    }
    _$Release$_() {
        this._$_loadState$_ = "not-loaded", this._$_audioDomHandler$_ = null, this._$_loadPromise$_ = null;
    }
    static _$Create$_(t, s, i, e, h) {
        const n = "audio/webm; codecs=opus" === e && !t._$SupportsWebMOpus$_();
        return h && n && t._$_SetHasAnySoftwareDecodedMusic$_(), !h || t._$IsPlayMusicAsSound$_() || n ? new self._$C3WebAudioBuffer$_(t, s, i, e, h, n) : new self._$C3Html5AudioBuffer$_(t, s, i, e, h);
    }
    _$CreateInstance$_(t) {
        return new ("html5" === this._$_api$_ ? self._$C3Html5AudioInstance$_ : self._$C3WebAudioInstance$_)(this._$_audioDomHandler$_, this, t);
    }
    _$_Load$_() {}
    _$Load$_() {
        return this._$_loadPromise$_ || (this._$_loadPromise$_ = this._$_Load$_()), 
        this._$_loadPromise$_;
    }
    _$IsLoaded$_() {}
    _$IsLoadedAndDecoded$_() {}
    _$HasFailedToLoad$_() {
        return "failed" === this._$_loadState$_;
    }
    _$GetAudioContext$_() {
        return this._$_audioDomHandler$_._$GetAudioContext$_();
    }
    _$GetApi$_() {
        return this._$_api$_;
    }
    _$GetOriginalUrl$_() {
        return this._$_originalUrl$_;
    }
    _$GetUrl$_() {
        return this._$_url$_;
    }
    _$GetContentType$_() {
        return this._$_type$_;
    }
    _$IsMusic$_() {
        return this._$_isMusic$_;
    }
    _$GetDuration$_() {}
}, self._$C3Html5AudioBuffer$_ = class extends self._$C3AudioBuffer$_ {
    constructor(t, s, i, e, h) {
        super(t, s, i, e, h), this._$_api$_ = "html5", this._$_audioElem$_ = new Audio(), 
        this._$_audioElem$_.crossOrigin = "anonymous", this._$_audioElem$_.autoplay = !1, 
        this._$_audioElem$_.preload = "auto", this._$_loadResolve$_ = null, this._$_loadReject$_ = null, 
        this._$_reachedCanPlayThrough$_ = !1, this._$_audioElem$_.addEventListener("canplaythrough", () => this._$_reachedCanPlayThrough$_ = !0), 
        this._$_outNode$_ = this._$GetAudioContext$_().createGain(), this._$_mediaSourceNode$_ = null, 
        this._$_audioElem$_.addEventListener("canplay", () => {
            this._$_loadResolve$_ && (this._$_loadState$_ = "loaded", this._$_loadResolve$_(), 
            this._$_loadResolve$_ = null, this._$_loadReject$_ = null), !this._$_mediaSourceNode$_ && this._$_audioElem$_ && (this._$_mediaSourceNode$_ = this._$GetAudioContext$_().createMediaElementSource(this._$_audioElem$_), 
            this._$_mediaSourceNode$_.connect(this._$_outNode$_));
        }), this.onended = null, this._$_audioElem$_.addEventListener("ended", () => {
            this.onended && this.onended();
        }), this._$_audioElem$_.addEventListener("error", t => this._$_OnError$_(t));
    }
    _$Release$_() {
        this._$_audioDomHandler$_._$ReleaseInstancesForBuffer$_(this), this._$_outNode$_.disconnect(), 
        this._$_outNode$_ = null, this._$_mediaSourceNode$_.disconnect(), this._$_mediaSourceNode$_ = null, 
        this._$_audioElem$_ && !this._$_audioElem$_.paused && this._$_audioElem$_.pause(), 
        this.onended = null, this._$_audioElem$_ = null, super._$Release$_();
    }
    _$_Load$_() {
        return this._$_loadState$_ = "loading", new Promise((t, s) => {
            this._$_loadResolve$_ = t, this._$_loadReject$_ = s, this._$_audioElem$_.src = this._$_url$_;
        });
    }
    _$_OnError$_(t) {
        console.error(`[Construct] Audio '${this._$_url$_}' error: `, t), this._$_loadReject$_ && (this._$_loadState$_ = "failed", 
        this._$_loadReject$_(t), this._$_loadResolve$_ = null, this._$_loadReject$_ = null);
    }
    _$IsLoaded$_() {
        const t = 4 <= this._$_audioElem$_.readyState;
        return t && (this._$_reachedCanPlayThrough$_ = !0), t || this._$_reachedCanPlayThrough$_;
    }
    _$IsLoadedAndDecoded$_() {
        return this._$IsLoaded$_();
    }
    _$GetAudioElement$_() {
        return this._$_audioElem$_;
    }
    _$GetOutputNode$_() {
        return this._$_outNode$_;
    }
    _$GetDuration$_() {
        return this._$_audioElem$_.duration;
    }
}, self._$C3WebAudioBuffer$_ = class extends self._$C3AudioBuffer$_ {
    constructor(t, s, i, e, h, n) {
        super(t, s, i, e, h), this._$_api$_ = "webaudio", this._$_audioData$_ = null, 
        this._$_audioBuffer$_ = null, this._$_needsSoftwareDecode$_ = !!n;
    }
    _$Release$_() {
        this._$_audioDomHandler$_._$ReleaseInstancesForBuffer$_(this), this._$_audioData$_ = null, 
        this._$_audioBuffer$_ = null, super._$Release$_();
    }
    async _$_Fetch$_() {
        if (this._$_audioData$_) return this._$_audioData$_;
        const t = this._$_audioDomHandler$_._$GetRuntimeInterface$_();
        if ("cordova" === t._$GetExportType$_() && t._$IsRelativeURL$_(this._$_url$_) && t._$IsFileProtocol$_()) this._$_audioData$_ = await t._$CordovaFetchLocalFileAsArrayBuffer$_(this._$_url$_); else if ("playable-ad-single-file" === t._$GetExportType$_() && t._$IsRelativeURL$_(this._$_url$_)) {
            const s = t._PlayableAdFetchBlob(this._$_url$_);
            this._$_audioData$_ = await s.arrayBuffer();
        } else {
            const i = await fetch(this._$_url$_);
            if (!i.ok) throw new Error(`error fetching audio data: ${i.status} ` + i.statusText);
            this._$_audioData$_ = await i.arrayBuffer();
        }
    }
    async _$_Decode$_() {
        if (this._$_audioBuffer$_) return this._$_audioBuffer$_;
        this._$_audioBuffer$_ = await this._$_audioDomHandler$_._$DecodeAudioData$_(this._$_audioData$_, this._$_needsSoftwareDecode$_), 
        this._$_audioData$_ = null;
    }
    async _$_Load$_() {
        try {
            this._$_loadState$_ = "loading", await this._$_Fetch$_(), await this._$_Decode$_(), 
            this._$_loadState$_ = "loaded";
        } catch (t) {
            this._$_loadState$_ = "failed", console.error(`[Construct] Failed to load audio '${this._$_url$_}': `, t);
        }
    }
    _$IsLoaded$_() {
        return !(!this._$_audioData$_ && !this._$_audioBuffer$_);
    }
    _$IsLoadedAndDecoded$_() {
        return !!this._$_audioBuffer$_;
    }
    _$GetAudioBuffer$_() {
        return this._$_audioBuffer$_;
    }
    _$GetDuration$_() {
        return this._$_audioBuffer$_ ? this._$_audioBuffer$_.duration : 0;
    }
};

{
    let h = 0;
    self._$C3AudioInstance$_ = class {
        constructor(t, s, i) {
            this._$_audioDomHandler$_ = t, this._$_buffer$_ = s, this._$_tags$_ = i, 
            this._$_aiId$_ = h++, this._$_gainNode$_ = this._$GetAudioContext$_().createGain(), 
            this._$_gainNode$_.connect(this._$GetDestinationNode$_()), this._$_pannerNode$_ = null, 
            this._$_isPannerEnabled$_ = !1, this._$_pannerPosition$_ = [ 0, 0, 0 ], 
            this._$_pannerOrientation$_ = [ 0, 0, 0 ], this._$_pannerConeParams$_ = [ 0, 0, 0 ], 
            this._$_stereoPannerNode$_ = null, this._$_isStereoPannerEnabled$_ = !1, 
            this._$_stereoPan$_ = 0, this._$_isStopped$_ = !0, this._$_isPaused$_ = !1, 
            this._$_resumeMe$_ = !1, this._$_isLooping$_ = !1, this._$_volume$_ = 1, 
            this._$_isMuted$_ = !1, this._$_playbackRate$_ = 1;
            const e = this._$_audioDomHandler$_._$GetTimeScaleMode$_();
            this._$_isTimescaled$_ = 1 === e && !this._$IsMusic$_() || 2 === e, 
            this._$_instUid$_ = -1, this._$_fadeEndTime$_ = -1, this._$_stopOnFadeEnd$_ = !1;
        }
        _$Release$_() {
            this._$_audioDomHandler$_ = null, this._$_buffer$_ = null, this._$_pannerNode$_ && (this._$_pannerNode$_.disconnect(), 
            this._$_pannerNode$_ = null), this._$_stereoPannerNode$_ && (this._$_stereoPannerNode$_.disconnect(), 
            this._$_stereoPannerNode$_ = null), this._$_gainNode$_.disconnect(), 
            this._$_gainNode$_ = null;
        }
        _$GetAudioContext$_() {
            return this._$_audioDomHandler$_._$GetAudioContext$_();
        }
        _$SetTags$_(t) {
            this._$_tags$_ = t;
        }
        _$GetTags$_() {
            return this._$_tags$_;
        }
        _$GetEffectTag$_() {
            return 0 < this._$_tags$_.length ? this._$_tags$_[0] : "";
        }
        _$GetDestinationNode$_() {
            return this._$_audioDomHandler$_._$GetDestinationForTag$_(this._$GetEffectTag$_());
        }
        _$GetCurrentTime$_() {
            return this._$_isTimescaled$_ ? this._$_audioDomHandler$_._$GetGameTime$_() : performance.now() / 1e3;
        }
        _$GetOriginalUrl$_() {
            return this._$_buffer$_._$GetOriginalUrl$_();
        }
        _$GetUrl$_() {
            return this._$_buffer$_._$GetUrl$_();
        }
        _$GetContentType$_() {
            return this._$_buffer$_._$GetContentType$_();
        }
        _$GetBuffer$_() {
            return this._$_buffer$_;
        }
        _$IsMusic$_() {
            return this._$_buffer$_._$IsMusic$_();
        }
        _$GetAiId$_() {
            return this._$_aiId$_;
        }
        _$HasEnded$_() {}
        _$CanBeRecycled$_() {}
        IsPlaying() {
            return !this._$_isStopped$_ && !this._$_isPaused$_ && !this._$HasEnded$_();
        }
        _$IsActive$_() {
            return !this._$_isStopped$_ && !this._$HasEnded$_();
        }
        _$GetPlaybackTime$_() {}
        _$GetDuration$_(t) {
            let s = this._$_buffer$_._$GetDuration$_();
            return t && (s /= this._$_playbackRate$_ || .001), s;
        }
        Play(t, s, i, e) {}
        _$Stop$_() {}
        _$Pause$_() {}
        _$IsPaused$_() {
            return this._$_isPaused$_;
        }
        _$Resume$_() {}
        _$SetVolume$_(t) {
            this._$_volume$_ = t, this._$_gainNode$_.gain.cancelScheduledValues(0), 
            this._$_fadeEndTime$_ = -1, this._$_gainNode$_.gain.value = this._$GetOutputVolume$_();
        }
        _$FadeVolume$_(t, s, i) {
            if (!this._$IsMuted$_()) {
                const e = this._$_gainNode$_.gain, h = (e.cancelScheduledValues(0), 
                this._$_audioDomHandler$_._$GetAudioCurrentTime$_()), n = h + s;
                e.setValueAtTime(e.value, h), e.linearRampToValueAtTime(t, n), this._$_volume$_ = t, 
                this._$_fadeEndTime$_ = n, this._$_stopOnFadeEnd$_ = i;
            }
        }
        _$_UpdateVolume$_() {
            this._$SetVolume$_(this._$_volume$_);
        }
        _$Tick$_(t) {
            -1 !== this._$_fadeEndTime$_ && t >= this._$_fadeEndTime$_ && (this._$_fadeEndTime$_ = -1, 
            this._$_stopOnFadeEnd$_ && this._$Stop$_(), this._$_audioDomHandler$_._$PostTrigger$_("fade-ended", this._$_tags$_, this._$_aiId$_));
        }
        _$GetOutputVolume$_() {
            const t = this._$_volume$_;
            return isFinite(t) ? t : 0;
        }
        _$SetMuted$_(t) {
            this._$_isMuted$_ !== (t = !!t) && (this._$_isMuted$_ = t, this._$_UpdateMuted$_());
        }
        _$IsMuted$_() {
            return this._$_isMuted$_;
        }
        _$IsSilent$_() {
            return this._$_audioDomHandler$_._$IsSilent$_();
        }
        _$_UpdateMuted$_() {}
        _$SetLooping$_(t) {}
        _$IsLooping$_() {
            return this._$_isLooping$_;
        }
        _$SetPlaybackRate$_(t) {
            this._$_playbackRate$_ !== t && (this._$_playbackRate$_ = t, this._$_UpdatePlaybackRate$_());
        }
        _$_UpdatePlaybackRate$_() {}
        _$GetPlaybackRate$_() {
            return this._$_playbackRate$_;
        }
        _$Seek$_(t) {}
        _$SetSuspended$_(t) {}
        _$SetPannerEnabled$_(t) {
            this._$_isPannerEnabled$_ !== (t = !!t) && (this._$_isPannerEnabled$_ = t, 
            (this._$_isPannerEnabled$_ ? (this._$SetStereoPannerEnabled$_(!1), this._$_pannerNode$_ || (this._$_pannerNode$_ = this._$GetAudioContext$_().createPanner(), 
            this._$_pannerNode$_.panningModel = this._$_audioDomHandler$_._$GetPanningModel$_(), 
            this._$_pannerNode$_.distanceModel = this._$_audioDomHandler$_._$GetDistanceModel$_(), 
            this._$_pannerNode$_.refDistance = this._$_audioDomHandler$_._$GetReferenceDistance$_(), 
            this._$_pannerNode$_.maxDistance = this._$_audioDomHandler$_._$GetMaxDistance$_(), 
            this._$_pannerNode$_.rolloffFactor = this._$_audioDomHandler$_._$GetRolloffFactor$_()), 
            this._$_gainNode$_.disconnect(), this._$_gainNode$_.connect(this._$_pannerNode$_), 
            this._$_pannerNode$_) : (this._$_pannerNode$_.disconnect(), this._$_gainNode$_.disconnect(), 
            this._$_gainNode$_)).connect(this._$GetDestinationNode$_()));
        }
        _$SetPan$_(t, s, i, e, h, n, o) {
            if (this._$_isPannerEnabled$_) {
                this._$SetPanXYZA$_(t, s, i, e);
                const r = self._$AudioDOMHandler$_._$ToDegrees$_;
                this._$_pannerConeParams$_[0] !== r(h) && (this._$_pannerConeParams$_[0] = r(h), 
                this._$_pannerNode$_.coneInnerAngle = r(h)), this._$_pannerConeParams$_[1] !== r(n) && (this._$_pannerConeParams$_[1] = r(n), 
                this._$_pannerNode$_.coneOuterAngle = r(n)), this._$_pannerConeParams$_[2] !== o && (this._$_pannerConeParams$_[2] = o, 
                this._$_pannerNode$_.coneOuterGain = o);
            }
        }
        _$SetPanXYZA$_(t, s, i, e) {
            if (this._$_isPannerEnabled$_) {
                const h = this._$_pannerPosition$_, n = this._$_pannerOrientation$_, o = Math.cos(e), r = Math.sin(e);
                h[0] === t && h[1] === s && h[2] === i || (h[0] = t, h[1] = s, h[2] = i, 
                this._$_pannerNode$_.setPosition(...h)), n[0] === o && n[1] === r && 0 === n[2] || (n[0] = o, 
                n[1] = r, n[2] = 0, this._$_pannerNode$_.setOrientation(...n));
            }
        }
        _$SetStereoPannerEnabled$_(t) {
            this._$_isStereoPannerEnabled$_ !== (t = !!t) && (this._$_isStereoPannerEnabled$_ = t, 
            (this._$_isStereoPannerEnabled$_ ? (this._$SetPannerEnabled$_(!1), this._$_stereoPannerNode$_ = this._$GetAudioContext$_().createStereoPanner(), 
            this._$_gainNode$_.disconnect(), this._$_gainNode$_.connect(this._$_stereoPannerNode$_), 
            this._$_stereoPannerNode$_) : (this._$_stereoPannerNode$_.disconnect(), 
            this._$_stereoPannerNode$_ = null, this._$_gainNode$_.disconnect(), 
            this._$_gainNode$_)).connect(this._$GetDestinationNode$_()));
        }
        _$SetStereoPan$_(t) {
            this._$_isStereoPannerEnabled$_ && this._$_stereoPan$_ !== t && (this._$_stereoPannerNode$_.pan.value = t, 
            this._$_stereoPan$_ = t);
        }
        _$SetUID$_(t) {
            this._$_instUid$_ = t;
        }
        _$GetUID$_() {
            return this._$_instUid$_;
        }
        _$GetResumePosition$_() {}
        _$Reconnect$_(t) {
            const s = this._$_stereoPannerNode$_ || this._$_pannerNode$_ || this._$_gainNode$_;
            s.disconnect(), s.connect(t);
        }
        _$GetState$_() {
            return {
                aiid: this._$GetAiId$_(),
                tags: this._$_tags$_,
                duration: this._$GetDuration$_(),
                volume: -1 === this._$_fadeEndTime$_ ? this._$_volume$_ : this._$_gainNode$_.gain.value,
                isPlaying: this.IsPlaying(),
                playbackTime: this._$GetPlaybackTime$_(),
                playbackRate: this._$GetPlaybackRate$_(),
                uid: this._$_instUid$_,
                bufferOriginalUrl: this._$GetOriginalUrl$_(),
                bufferUrl: "",
                bufferType: this._$GetContentType$_(),
                isMusic: this._$IsMusic$_(),
                isLooping: this._$IsLooping$_(),
                isMuted: this._$IsMuted$_(),
                resumePosition: this._$GetResumePosition$_(),
                pan: this._$GetPanState$_(),
                stereoPan: this._$GetStereoPanState$_()
            };
        }
        _$_LoadAdditionalState$_(t) {
            this._$SetPlaybackRate$_(t.playbackRate), this._$SetMuted$_(t.isMuted);
        }
        _$GetPanState$_() {
            if (!this._$_pannerNode$_) return null;
            const t = this._$_pannerNode$_;
            return {
                pos: this._$_pannerPosition$_,
                orient: this._$_pannerOrientation$_,
                cia: t.coneInnerAngle,
                coa: t.coneOuterAngle,
                cog: t.coneOuterGain,
                uid: this._$_instUid$_
            };
        }
        _$LoadPanState$_(t) {
            if (t) {
                this._$SetPannerEnabled$_(!0);
                const s = this._$_pannerNode$_, i = t.pos, e = (this._$_pannerPosition$_[0] = i[0], 
                this._$_pannerPosition$_[1] = i[1], this._$_pannerPosition$_[2] = i[2], 
                t.orient);
                this._$_pannerOrientation$_[0] = e[0], this._$_pannerOrientation$_[1] = e[1], 
                this._$_pannerOrientation$_[2] = e[2], s.setPosition(...this._$_pannerPosition$_), 
                s.setOrientation(...this._$_pannerOrientation$_), this._$_pannerConeParams$_[0] = t.cia, 
                this._$_pannerConeParams$_[1] = t.coa, this._$_pannerConeParams$_[2] = t.cog, 
                s.coneInnerAngle = t.cia, s.coneOuterAngle = t.coa, s.coneOuterGain = t.cog, 
                this._$_instUid$_ = t.uid;
            } else this._$SetPannerEnabled$_(!1);
        }
        _$GetStereoPanState$_() {
            return this._$_stereoPannerNode$_ ? this._$_stereoPan$_ : null;
        }
        _$LoadStereoPanState$_(t) {
            "number" != typeof t ? this._$SetStereoPannerEnabled$_(!1) : (this._$SetStereoPannerEnabled$_(!0), 
            this._$SetStereoPan$_(t));
        }
    };
}

self._$C3Html5AudioInstance$_ = class extends self._$C3AudioInstance$_ {
    constructor(t, s, i) {
        super(t, s, i), this._$_buffer$_._$GetOutputNode$_().connect(this._$_gainNode$_), 
        this._$_buffer$_.onended = () => this._$_OnEnded$_();
    }
    _$Release$_() {
        this._$Stop$_(), this._$_buffer$_._$GetOutputNode$_().disconnect(), super._$Release$_();
    }
    _$GetAudioElement$_() {
        return this._$_buffer$_._$GetAudioElement$_();
    }
    _$_OnEnded$_() {
        this._$_isStopped$_ = !0, this._$_instUid$_ = -1, this._$_audioDomHandler$_._$PostTrigger$_("ended", this._$_tags$_, this._$_aiId$_);
    }
    _$HasEnded$_() {
        return this._$GetAudioElement$_().ended;
    }
    _$CanBeRecycled$_() {
        return !!this._$_isStopped$_ || this._$HasEnded$_();
    }
    _$GetPlaybackTime$_() {
        let t = this._$GetAudioElement$_().currentTime;
        return t = this._$_isLooping$_ ? t : Math.min(t, this._$GetDuration$_());
    }
    Play(t, s, i, e) {
        const h = this._$GetAudioElement$_();
        if (1 !== h.playbackRate && (h.playbackRate = 1), h.loop !== t && (h.loop = t), 
        this._$SetVolume$_(s), this._$_isMuted$_ = !1, h.muted && (h.muted = !1), 
        h.currentTime !== i) try {
            h.currentTime = i;
        } catch (t) {
            console.warn(`[Construct] Exception seeking audio '${this._$_buffer$_._$GetUrl$_()}' to position '${i}': `, t);
        }
        this._$_audioDomHandler$_._$TryPlayMedia$_(h), this._$_isStopped$_ = !1, 
        this._$_isPaused$_ = !1, this._$_isLooping$_ = t, this._$_playbackRate$_ = 1;
    }
    _$Stop$_() {
        const t = this._$GetAudioElement$_();
        t.paused || t.pause(), this._$_audioDomHandler$_._$RemovePendingPlay$_(t), 
        this._$_isStopped$_ = !0, this._$_isPaused$_ = !1, this._$_instUid$_ = -1;
    }
    _$Pause$_() {
        if (!(this._$_isPaused$_ || this._$_isStopped$_ || this._$HasEnded$_())) {
            const t = this._$GetAudioElement$_();
            t.paused || t.pause(), this._$_audioDomHandler$_._$RemovePendingPlay$_(t), 
            this._$_isPaused$_ = !0;
        }
    }
    _$Resume$_() {
        !this._$_isPaused$_ || this._$_isStopped$_ || this._$HasEnded$_() || (this._$_audioDomHandler$_._$TryPlayMedia$_(this._$GetAudioElement$_()), 
        this._$_isPaused$_ = !1);
    }
    _$_UpdateMuted$_() {
        this._$GetAudioElement$_().muted = this._$_isMuted$_ || this._$IsSilent$_();
    }
    _$SetLooping$_(t) {
        this._$_isLooping$_ !== (t = !!t) && (this._$_isLooping$_ = t, this._$GetAudioElement$_().loop = t);
    }
    _$_UpdatePlaybackRate$_() {
        let s = this._$_playbackRate$_;
        this._$_isTimescaled$_ && (s *= this._$_audioDomHandler$_._$GetTimeScale$_());
        try {
            this._$GetAudioElement$_().playbackRate = s;
        } catch (t) {
            console.warn(`[Construct] Unable to set playback rate '${s}':`, t);
        }
    }
    _$Seek$_(s) {
        if (!this._$_isStopped$_ && !this._$HasEnded$_()) try {
            this._$GetAudioElement$_().currentTime = s;
        } catch (t) {
            console.warn(`[Construct] Error seeking audio to '${s}': `, t);
        }
    }
    _$GetResumePosition$_() {
        return this._$GetPlaybackTime$_();
    }
    _$SetSuspended$_(t) {
        t ? this.IsPlaying() ? (this._$GetAudioElement$_().pause(), this._$_resumeMe$_ = !0) : this._$_resumeMe$_ = !1 : this._$_resumeMe$_ && (this._$_audioDomHandler$_._$TryPlayMedia$_(this._$GetAudioElement$_()), 
        this._$_resumeMe$_ = !1);
    }
}, self._$C3WebAudioInstance$_ = class extends self._$C3AudioInstance$_ {
    constructor(t, s, i) {
        super(t, s, i), this._$_bufferSource$_ = null, this._$_onended_handler$_ = t => this._$_OnEnded$_(t), 
        this._$_hasPlaybackEnded$_ = !0, this._$_activeSource$_ = null, this._$_playStartTime$_ = 0, 
        this._$_playFromSeekPos$_ = 0, this._$_resumePosition$_ = 0, this._$_muteVol$_ = 1;
    }
    _$Release$_() {
        this._$Stop$_(), this._$_ReleaseBufferSource$_(), this._$_onended_handler$_ = null, 
        super._$Release$_();
    }
    _$_ReleaseBufferSource$_() {
        this._$_bufferSource$_ && (this._$_bufferSource$_.onended = null, this._$_bufferSource$_.disconnect(), 
        this._$_bufferSource$_.buffer = null), this._$_bufferSource$_ = null, this._$_activeSource$_ = null;
    }
    _$_OnEnded$_(t) {
        this._$_isPaused$_ || this._$_resumeMe$_ || t.target === this._$_activeSource$_ && (this._$_hasPlaybackEnded$_ = !0, 
        this._$_isStopped$_ = !0, this._$_instUid$_ = -1, this._$_ReleaseBufferSource$_(), 
        this._$_audioDomHandler$_._$PostTrigger$_("ended", this._$_tags$_, this._$_aiId$_));
    }
    _$HasEnded$_() {
        return !(!this._$_isStopped$_ && this._$_bufferSource$_ && this._$_bufferSource$_.loop || this._$_isPaused$_) && this._$_hasPlaybackEnded$_;
    }
    _$CanBeRecycled$_() {
        return !(this._$_bufferSource$_ && !this._$_isStopped$_) || this._$HasEnded$_();
    }
    _$GetPlaybackTime$_() {
        let t = 0;
        return t = this._$_isPaused$_ ? this._$_resumePosition$_ : this._$_playFromSeekPos$_ + (this._$GetCurrentTime$_() - this._$_playStartTime$_) * this._$_playbackRate$_, 
        t = this._$_isLooping$_ ? t : Math.min(t, this._$GetDuration$_());
    }
    Play(t, s, i, e) {
        this._$_isMuted$_ = !1, this._$_muteVol$_ = 1, this._$SetVolume$_(s), this._$_ReleaseBufferSource$_(), 
        this._$_bufferSource$_ = this._$GetAudioContext$_().createBufferSource(), 
        this._$_bufferSource$_.buffer = this._$_buffer$_._$GetAudioBuffer$_(), this._$_bufferSource$_.connect(this._$_gainNode$_), 
        this._$_activeSource$_ = this._$_bufferSource$_, this._$_bufferSource$_.onended = this._$_onended_handler$_, 
        this._$_bufferSource$_.loop = t, this._$_bufferSource$_.start(e, i), this._$_hasPlaybackEnded$_ = !1, 
        this._$_isStopped$_ = !1, this._$_isPaused$_ = !1, this._$_isLooping$_ = t, 
        this._$_playbackRate$_ = 1, this._$_playStartTime$_ = this._$GetCurrentTime$_(), 
        this._$_playFromSeekPos$_ = i;
    }
    _$Stop$_() {
        if (this._$_bufferSource$_) try {
            this._$_bufferSource$_.stop(0);
        } catch (t) {}
        this._$_isStopped$_ = !0, this._$_isPaused$_ = !1, this._$_instUid$_ = -1;
    }
    _$Pause$_() {
        this._$_isPaused$_ || this._$_isStopped$_ || this._$HasEnded$_() || (this._$_resumePosition$_ = this._$GetPlaybackTime$_(), 
        this._$_isLooping$_ && (this._$_resumePosition$_ %= this._$GetDuration$_()), 
        this._$_isPaused$_ = !0, this._$_bufferSource$_.stop(0));
    }
    _$Resume$_() {
        !this._$_isPaused$_ || this._$_isStopped$_ || this._$HasEnded$_() || (this._$_ReleaseBufferSource$_(), 
        this._$_bufferSource$_ = this._$GetAudioContext$_().createBufferSource(), 
        this._$_bufferSource$_.buffer = this._$_buffer$_._$GetAudioBuffer$_(), this._$_bufferSource$_.connect(this._$_gainNode$_), 
        this._$_activeSource$_ = this._$_bufferSource$_, this._$_bufferSource$_.onended = this._$_onended_handler$_, 
        this._$_bufferSource$_.loop = this._$_isLooping$_, this._$_UpdateVolume$_(), 
        this._$_UpdatePlaybackRate$_(), this._$_bufferSource$_.start(0, this._$_resumePosition$_), 
        this._$_playStartTime$_ = this._$GetCurrentTime$_(), this._$_playFromSeekPos$_ = this._$_resumePosition$_, 
        this._$_isPaused$_ = !1);
    }
    _$GetOutputVolume$_() {
        return super._$GetOutputVolume$_() * this._$_muteVol$_;
    }
    _$_UpdateMuted$_() {
        this._$_muteVol$_ = this._$_isMuted$_ || this._$IsSilent$_() ? 0 : 1, this._$_UpdateVolume$_();
    }
    _$SetLooping$_(t) {
        this._$_isLooping$_ !== (t = !!t) && (this._$_isLooping$_ = t, this._$_bufferSource$_) && (this._$_bufferSource$_.loop = t);
    }
    _$_UpdatePlaybackRate$_() {
        let t = this._$_playbackRate$_;
        this._$_isTimescaled$_ && (t *= this._$_audioDomHandler$_._$GetTimeScale$_()), 
        this._$_bufferSource$_ && (this._$_bufferSource$_.playbackRate.value = t);
    }
    _$Seek$_(t) {
        this._$_isStopped$_ || this._$HasEnded$_() || (this._$_isPaused$_ ? this._$_resumePosition$_ = t : (this._$Pause$_(), 
        this._$_resumePosition$_ = t, this._$Resume$_()));
    }
    _$GetResumePosition$_() {
        return this._$_resumePosition$_;
    }
    _$SetSuspended$_(t) {
        t ? this.IsPlaying() ? (this._$_resumeMe$_ = !0, this._$_resumePosition$_ = this._$GetPlaybackTime$_(), 
        this._$_isLooping$_ && (this._$_resumePosition$_ %= this._$GetDuration$_()), 
        this._$_bufferSource$_.stop(0)) : this._$_resumeMe$_ = !1 : this._$_resumeMe$_ && (this._$_ReleaseBufferSource$_(), 
        this._$_bufferSource$_ = this._$GetAudioContext$_().createBufferSource(), 
        this._$_bufferSource$_.buffer = this._$_buffer$_._$GetAudioBuffer$_(), this._$_bufferSource$_.connect(this._$_gainNode$_), 
        this._$_activeSource$_ = this._$_bufferSource$_, this._$_bufferSource$_.onended = this._$_onended_handler$_, 
        this._$_bufferSource$_.loop = this._$_isLooping$_, this._$_UpdateVolume$_(), 
        this._$_UpdatePlaybackRate$_(), this._$_bufferSource$_.start(0, this._$_resumePosition$_), 
        this._$_playStartTime$_ = this._$GetCurrentTime$_(), this._$_playFromSeekPos$_ = this._$_resumePosition$_, 
        this._$_resumeMe$_ = !1);
    }
    _$_LoadAdditionalState$_(t) {
        super._$_LoadAdditionalState$_(t), this._$_resumePosition$_ = t.resumePosition;
    }
};

{
    class bj {
        constructor(t) {
            this._$_audioDomHandler$_ = t, this._$_audioContext$_ = t._$GetAudioContext$_(), 
            this._$_index$_ = -1, this._$_tag$_ = "", this._$_type$_ = "", this._$_params$_ = null;
        }
        _$Release$_() {
            this._$_audioContext$_ = null;
        }
        _$_SetIndex$_(t) {
            this._$_index$_ = t;
        }
        _$GetIndex$_() {
            return this._$_index$_;
        }
        _$_SetTag$_(t) {
            this._$_tag$_ = t;
        }
        _$GetTag$_() {
            return this._$_tag$_;
        }
        _$CreateGain$_() {
            return this._$_audioContext$_.createGain();
        }
        _$GetInputNode$_() {}
        _$ConnectTo$_(t) {}
        _$SetAudioParam$_(t, s, i, e) {
            if (t.cancelScheduledValues(0), 0 === e) t.value = s; else {
                const h = this._$_audioContext$_.currentTime;
                switch (e += h, i) {
                  case 0:
                    t.setValueAtTime(s, e);
                    break;

                  case 1:
                    t.setValueAtTime(t.value, h), t.linearRampToValueAtTime(s, e);
                    break;

                  case 2:
                    t.setValueAtTime(t.value, h), t.exponentialRampToValueAtTime(s, e);
                }
            }
        }
        _$GetState$_() {
            return {
                type: this._$_type$_,
                tag: this._$_tag$_,
                params: this._$_params$_
            };
        }
    }
    self._$C3AudioFilterFX$_ = class extends bj {
        constructor(t, s, i, e, h, n, o) {
            super(t), this._$_type$_ = "filter", this._$_params$_ = [ s, i, e, h, n, o ], 
            this._$_inputNode$_ = this._$CreateGain$_(), this._$_wetNode$_ = this._$CreateGain$_(), 
            this._$_wetNode$_.gain.value = o, this._$_dryNode$_ = this._$CreateGain$_(), 
            this._$_dryNode$_.gain.value = 1 - o, this._$_filterNode$_ = this._$_audioContext$_.createBiquadFilter(), 
            this._$_filterNode$_.type = s, this._$_filterNode$_.frequency.value = i, 
            this._$_filterNode$_.detune.value = e, this._$_filterNode$_.Q.value = h, 
            this._$_filterNode$_.gain.vlaue = n, this._$_inputNode$_.connect(this._$_filterNode$_), 
            this._$_inputNode$_.connect(this._$_dryNode$_), this._$_filterNode$_.connect(this._$_wetNode$_);
        }
        _$Release$_() {
            this._$_inputNode$_.disconnect(), this._$_filterNode$_.disconnect(), 
            this._$_wetNode$_.disconnect(), this._$_dryNode$_.disconnect(), super._$Release$_();
        }
        _$ConnectTo$_(t) {
            this._$_wetNode$_.disconnect(), this._$_wetNode$_.connect(t), this._$_dryNode$_.disconnect(), 
            this._$_dryNode$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_inputNode$_;
        }
        _$SetParam$_(t, s, i, e) {
            switch (t) {
              case 0:
                s = Math.max(Math.min(s / 100, 1), 0), this._$_params$_[5] = s, 
                this._$SetAudioParam$_(this._$_wetNode$_.gain, s, i, e), this._$SetAudioParam$_(this._$_dryNode$_.gain, 1 - s, i, e);
                break;

              case 1:
                this._$_params$_[1] = s, this._$SetAudioParam$_(this._$_filterNode$_.frequency, s, i, e);
                break;

              case 2:
                this._$_params$_[2] = s, this._$SetAudioParam$_(this._$_filterNode$_.detune, s, i, e);
                break;

              case 3:
                this._$_params$_[3] = s, this._$SetAudioParam$_(this._$_filterNode$_.Q, s, i, e);
                break;

              case 4:
                this._$_params$_[4] = s, this._$SetAudioParam$_(this._$_filterNode$_.gain, s, i, e);
            }
        }
    }, self._$C3AudioDelayFX$_ = class extends bj {
        constructor(t, s, i, e) {
            super(t), this._$_type$_ = "delay", this._$_params$_ = [ s, i, e ], 
            this._$_inputNode$_ = this._$CreateGain$_(), this._$_wetNode$_ = this._$CreateGain$_(), 
            this._$_wetNode$_.gain.value = e, this._$_dryNode$_ = this._$CreateGain$_(), 
            this._$_dryNode$_.gain.value = 1 - e, this._$_mainNode$_ = this._$CreateGain$_(), 
            this._$_delayNode$_ = this._$_audioContext$_.createDelay(s), this._$_delayNode$_.delayTime.value = s, 
            this._$_delayGainNode$_ = this._$CreateGain$_(), this._$_delayGainNode$_.gain.value = i, 
            this._$_inputNode$_.connect(this._$_mainNode$_), this._$_inputNode$_.connect(this._$_dryNode$_), 
            this._$_mainNode$_.connect(this._$_wetNode$_), this._$_mainNode$_.connect(this._$_delayNode$_), 
            this._$_delayNode$_.connect(this._$_delayGainNode$_), this._$_delayGainNode$_.connect(this._$_mainNode$_);
        }
        _$Release$_() {
            this._$_inputNode$_.disconnect(), this._$_wetNode$_.disconnect(), this._$_dryNode$_.disconnect(), 
            this._$_mainNode$_.disconnect(), this._$_delayNode$_.disconnect(), this._$_delayGainNode$_.disconnect(), 
            super._$Release$_();
        }
        _$ConnectTo$_(t) {
            this._$_wetNode$_.disconnect(), this._$_wetNode$_.connect(t), this._$_dryNode$_.disconnect(), 
            this._$_dryNode$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_inputNode$_;
        }
        _$SetParam$_(t, s, i, e) {
            const h = self._$AudioDOMHandler$_._$DbToLinear$_;
            switch (t) {
              case 0:
                s = Math.max(Math.min(s / 100, 1), 0), this._$_params$_[2] = s, 
                this._$SetAudioParam$_(this._$_wetNode$_.gain, s, i, e), this._$SetAudioParam$_(this._$_dryNode$_.gain, 1 - s, i, e);
                break;

              case 4:
                this._$_params$_[1] = h(s), this._$SetAudioParam$_(this._$_delayGainNode$_.gain, h(s), i, e);
                break;

              case 5:
                this._$_params$_[0] = s, this._$SetAudioParam$_(this._$_delayNode$_.delayTime, s, i, e);
            }
        }
    }, self._$C3AudioConvolveFX$_ = class extends bj {
        constructor(t, s, i, e) {
            super(t), this._$_type$_ = "convolution", this._$_params$_ = [ i, e ], 
            this._$_bufferOriginalUrl$_ = "", this._$_bufferUrl$_ = "", this._$_bufferType$_ = "", 
            this._$_inputNode$_ = this._$CreateGain$_(), this._$_wetNode$_ = this._$CreateGain$_(), 
            this._$_wetNode$_.gain.value = e, this._$_dryNode$_ = this._$CreateGain$_(), 
            this._$_dryNode$_.gain.value = 1 - e, this._$_convolveNode$_ = this._$_audioContext$_.createConvolver(), 
            this._$_convolveNode$_.normalize = i, this._$_convolveNode$_.buffer = s, 
            this._$_inputNode$_.connect(this._$_convolveNode$_), this._$_inputNode$_.connect(this._$_dryNode$_), 
            this._$_convolveNode$_.connect(this._$_wetNode$_);
        }
        _$Release$_() {
            this._$_inputNode$_.disconnect(), this._$_convolveNode$_.disconnect(), 
            this._$_wetNode$_.disconnect(), this._$_dryNode$_.disconnect(), super._$Release$_();
        }
        _$ConnectTo$_(t) {
            this._$_wetNode$_.disconnect(), this._$_wetNode$_.connect(t), this._$_dryNode$_.disconnect(), 
            this._$_dryNode$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_inputNode$_;
        }
        _$SetParam$_(t, s, i, e) {
            0 === t && (s = Math.max(Math.min(s / 100, 1), 0), this._$_params$_[1] = s, 
            this._$SetAudioParam$_(this._$_wetNode$_.gain, s, i, e), this._$SetAudioParam$_(this._$_dryNode$_.gain, 1 - s, i, e));
        }
        _$_SetBufferInfo$_(t, s, i) {
            this._$_bufferOriginalUrl$_ = t, this._$_bufferUrl$_ = s, this._$_bufferType$_ = i;
        }
        _$GetState$_() {
            const t = super._$GetState$_();
            return t.bufferOriginalUrl = this._$_bufferOriginalUrl$_, t.bufferUrl = "", 
            t.bufferType = this._$_bufferType$_, t;
        }
    }, self._$C3AudioFlangerFX$_ = class extends bj {
        constructor(t, s, i, e, h, n) {
            super(t), this._$_type$_ = "flanger", this._$_params$_ = [ s, i, e, h, n ], 
            this._$_inputNode$_ = this._$CreateGain$_(), this._$_dryNode$_ = this._$CreateGain$_(), 
            this._$_dryNode$_.gain.value = 1 - n / 2, this._$_wetNode$_ = this._$CreateGain$_(), 
            this._$_wetNode$_.gain.value = n / 2, this._$_feedbackNode$_ = this._$CreateGain$_(), 
            this._$_feedbackNode$_.gain.value = h, this._$_delayNode$_ = this._$_audioContext$_.createDelay(s + i), 
            this._$_delayNode$_.delayTime.value = s, this._$_oscNode$_ = this._$_audioContext$_.createOscillator(), 
            this._$_oscNode$_.frequency.value = e, this._$_oscGainNode$_ = this._$CreateGain$_(), 
            this._$_oscGainNode$_.gain.value = i, this._$_inputNode$_.connect(this._$_delayNode$_), 
            this._$_inputNode$_.connect(this._$_dryNode$_), this._$_delayNode$_.connect(this._$_wetNode$_), 
            this._$_delayNode$_.connect(this._$_feedbackNode$_), this._$_feedbackNode$_.connect(this._$_delayNode$_), 
            this._$_oscNode$_.connect(this._$_oscGainNode$_), this._$_oscGainNode$_.connect(this._$_delayNode$_.delayTime), 
            this._$_oscNode$_.start(0);
        }
        _$Release$_() {
            this._$_oscNode$_.stop(0), this._$_inputNode$_.disconnect(), this._$_delayNode$_.disconnect(), 
            this._$_oscNode$_.disconnect(), this._$_oscGainNode$_.disconnect(), 
            this._$_dryNode$_.disconnect(), this._$_wetNode$_.disconnect(), this._$_feedbackNode$_.disconnect(), 
            super._$Release$_();
        }
        _$ConnectTo$_(t) {
            this._$_wetNode$_.disconnect(), this._$_wetNode$_.connect(t), this._$_dryNode$_.disconnect(), 
            this._$_dryNode$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_inputNode$_;
        }
        _$SetParam$_(t, s, i, e) {
            switch (t) {
              case 0:
                s = Math.max(Math.min(s / 100, 1), 0), this._$_params$_[4] = s, 
                this._$SetAudioParam$_(this._$_wetNode$_.gain, s / 2, i, e), this._$SetAudioParam$_(this._$_dryNode$_.gain, 1 - s / 2, i, e);
                break;

              case 6:
                this._$_params$_[1] = s / 1e3, this._$SetAudioParam$_(this._$_oscGainNode$_.gain, s / 1e3, i, e);
                break;

              case 7:
                this._$_params$_[2] = s, this._$SetAudioParam$_(this._$_oscNode$_.frequency, s, i, e);
                break;

              case 8:
                this._$_params$_[3] = s / 100, this._$SetAudioParam$_(this._$_feedbackNode$_.gain, s / 100, i, e);
            }
        }
    }, self._$C3AudioPhaserFX$_ = class extends bj {
        constructor(t, s, i, e, h, n, o) {
            super(t), this._$_type$_ = "phaser", this._$_params$_ = [ s, i, e, h, n, o ], 
            this._$_inputNode$_ = this._$CreateGain$_(), this._$_dryNode$_ = this._$CreateGain$_(), 
            this._$_dryNode$_.gain.value = 1 - o / 2, this._$_wetNode$_ = this._$CreateGain$_(), 
            this._$_wetNode$_.gain.value = o / 2, this._$_filterNode$_ = this._$_audioContext$_.createBiquadFilter(), 
            this._$_filterNode$_.type = "allpass", this._$_filterNode$_.frequency.value = s, 
            this._$_filterNode$_.detune.value = i, this._$_filterNode$_.Q.value = e, 
            this._$_oscNode$_ = this._$_audioContext$_.createOscillator(), this._$_oscNode$_.frequency.value = n, 
            this._$_oscGainNode$_ = this._$CreateGain$_(), this._$_oscGainNode$_.gain.value = h, 
            this._$_inputNode$_.connect(this._$_filterNode$_), this._$_inputNode$_.connect(this._$_dryNode$_), 
            this._$_filterNode$_.connect(this._$_wetNode$_), this._$_oscNode$_.connect(this._$_oscGainNode$_), 
            this._$_oscGainNode$_.connect(this._$_filterNode$_.frequency), this._$_oscNode$_.start(0);
        }
        _$Release$_() {
            this._$_oscNode$_.stop(0), this._$_inputNode$_.disconnect(), this._$_filterNode$_.disconnect(), 
            this._$_oscNode$_.disconnect(), this._$_oscGainNode$_.disconnect(), 
            this._$_dryNode$_.disconnect(), this._$_wetNode$_.disconnect(), super._$Release$_();
        }
        _$ConnectTo$_(t) {
            this._$_wetNode$_.disconnect(), this._$_wetNode$_.connect(t), this._$_dryNode$_.disconnect(), 
            this._$_dryNode$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_inputNode$_;
        }
        _$SetParam$_(t, s, i, e) {
            switch (t) {
              case 0:
                s = Math.max(Math.min(s / 100, 1), 0), this._$_params$_[5] = s, 
                this._$SetAudioParam$_(this._$_wetNode$_.gain, s / 2, i, e), this._$SetAudioParam$_(this._$_dryNode$_.gain, 1 - s / 2, i, e);
                break;

              case 1:
                this._$_params$_[0] = s, this._$SetAudioParam$_(this._$_filterNode$_.frequency, s, i, e);
                break;

              case 2:
                this._$_params$_[1] = s, this._$SetAudioParam$_(this._$_filterNode$_.detune, s, i, e);
                break;

              case 3:
                this._$_params$_[2] = s, this._$SetAudioParam$_(this._$_filterNode$_.Q, s, i, e);
                break;

              case 6:
                this._$_params$_[3] = s, this._$SetAudioParam$_(this._$_oscGainNode$_.gain, s, i, e);
                break;

              case 7:
                this._$_params$_[4] = s, this._$SetAudioParam$_(this._$_oscNode$_.frequency, s, i, e);
            }
        }
    }, self._$C3AudioGainFX$_ = class extends bj {
        constructor(t, s) {
            super(t), this._$_type$_ = "gain", this._$_params$_ = [ s ], this._$_node$_ = this._$CreateGain$_(), 
            this._$_node$_.gain.value = s;
        }
        _$Release$_() {
            this._$_node$_.disconnect(), super._$Release$_();
        }
        _$ConnectTo$_(t) {
            this._$_node$_.disconnect(), this._$_node$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_node$_;
        }
        _$SetParam$_(t, s, i, e) {
            const h = self._$AudioDOMHandler$_._$DbToLinear$_;
            4 === t && (this._$_params$_[0] = h(s), this._$SetAudioParam$_(this._$_node$_.gain, h(s), i, e));
        }
    }, self._$C3AudioStereoPanFX$_ = class extends bj {
        constructor(t, s) {
            super(t), this._$_type$_ = "stereopan", this._$_params$_ = [ s ], this._$_node$_ = this._$_audioContext$_.createStereoPanner(), 
            this._$_node$_.pan.value = s;
        }
        _$Release$_() {
            this._$_node$_.disconnect(), super._$Release$_();
        }
        _$ConnectTo$_(t) {
            this._$_node$_.disconnect(), this._$_node$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_node$_;
        }
        _$SetParam$_(t, s, i, e) {
            s = Math.min(Math.max(s / 100, -1), 1), 9 === t && (this._$_params$_[0] = s, 
            this._$SetAudioParam$_(this._$_node$_.pan, s, i, e));
        }
    }, self._$C3AudioTremoloFX$_ = class extends bj {
        constructor(t, s, i) {
            super(t), this._$_type$_ = "tremolo", this._$_params$_ = [ s, i ], this._$_node$_ = this._$CreateGain$_(), 
            this._$_node$_.gain.value = 1 - i / 2, this._$_oscNode$_ = this._$_audioContext$_.createOscillator(), 
            this._$_oscNode$_.frequency.value = s, this._$_oscGainNode$_ = this._$CreateGain$_(), 
            this._$_oscGainNode$_.gain.value = i / 2, this._$_oscNode$_.connect(this._$_oscGainNode$_), 
            this._$_oscGainNode$_.connect(this._$_node$_.gain), this._$_oscNode$_.start(0);
        }
        _$Release$_() {
            this._$_oscNode$_.stop(0), this._$_oscNode$_.disconnect(), this._$_oscGainNode$_.disconnect(), 
            this._$_node$_.disconnect(), super._$Release$_();
        }
        _$ConnectTo$_(t) {
            this._$_node$_.disconnect(), this._$_node$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_node$_;
        }
        _$SetParam$_(t, s, i, e) {
            switch (t) {
              case 0:
                s = Math.max(Math.min(s / 100, 1), 0), this._$_params$_[1] = s, 
                this._$SetAudioParam$_(this._$_node$_.gain, 1 - s / 2, i, e), this._$SetAudioParam$_(this._$_oscGainNode$_.gain, s / 2, i, e);
                break;

              case 7:
                this._$_params$_[0] = s, this._$SetAudioParam$_(this._$_oscNode$_.frequency, s, i, e);
            }
        }
    }, self._$C3AudioRingModFX$_ = class extends bj {
        constructor(t, s, i) {
            super(t), this._$_type$_ = "ringmod", this._$_params$_ = [ s, i ], this._$_inputNode$_ = this._$CreateGain$_(), 
            this._$_wetNode$_ = this._$CreateGain$_(), this._$_wetNode$_.gain.value = i, 
            this._$_dryNode$_ = this._$CreateGain$_(), this._$_dryNode$_.gain.value = 1 - i, 
            this._$_ringNode$_ = this._$CreateGain$_(), this._$_ringNode$_.gain.value = 0, 
            this._$_oscNode$_ = this._$_audioContext$_.createOscillator(), this._$_oscNode$_.frequency.value = s, 
            this._$_oscNode$_.connect(this._$_ringNode$_.gain), this._$_oscNode$_.start(0), 
            this._$_inputNode$_.connect(this._$_ringNode$_), this._$_inputNode$_.connect(this._$_dryNode$_), 
            this._$_ringNode$_.connect(this._$_wetNode$_);
        }
        _$Release$_() {
            this._$_oscNode$_.stop(0), this._$_oscNode$_.disconnect(), this._$_ringNode$_.disconnect(), 
            this._$_inputNode$_.disconnect(), this._$_wetNode$_.disconnect(), this._$_dryNode$_.disconnect(), 
            super._$Release$_();
        }
        _$ConnectTo$_(t) {
            this._$_wetNode$_.disconnect(), this._$_wetNode$_.connect(t), this._$_dryNode$_.disconnect(), 
            this._$_dryNode$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_inputNode$_;
        }
        _$SetParam$_(t, s, i, e) {
            switch (t) {
              case 0:
                s = Math.max(Math.min(s / 100, 1), 0), this._$_params$_[1] = s, 
                this._$SetAudioParam$_(this._$_wetNode$_.gain, s, i, e), this._$SetAudioParam$_(this._$_dryNode$_.gain, 1 - s, i, e);
                break;

              case 7:
                this._$_params$_[0] = s, this._$SetAudioParam$_(this._$_oscNode$_.frequency, s, i, e);
            }
        }
    }, self._$C3AudioDistortionFX$_ = class extends bj {
        constructor(t, s, i, e, h, n) {
            super(t), this._$_type$_ = "distortion", this._$_params$_ = [ s, i, e, h, n ], 
            this._$_inputNode$_ = this._$CreateGain$_(), this._$_preGain$_ = this._$CreateGain$_(), 
            this._$_postGain$_ = this._$CreateGain$_(), this._$_SetDrive$_(e, h), 
            this._$_wetNode$_ = this._$CreateGain$_(), this._$_wetNode$_.gain.value = n, 
            this._$_dryNode$_ = this._$CreateGain$_(), this._$_dryNode$_.gain.value = 1 - n, 
            this._$_waveShaper$_ = this._$_audioContext$_.createWaveShaper(), this._$_curve$_ = new Float32Array(65536), 
            this._$_GenerateColortouchCurve$_(s, i), this._$_waveShaper$_.curve = this._$_curve$_, 
            this._$_inputNode$_.connect(this._$_preGain$_), this._$_inputNode$_.connect(this._$_dryNode$_), 
            this._$_preGain$_.connect(this._$_waveShaper$_), this._$_waveShaper$_.connect(this._$_postGain$_), 
            this._$_postGain$_.connect(this._$_wetNode$_);
        }
        _$Release$_() {
            this._$_inputNode$_.disconnect(), this._$_preGain$_.disconnect(), this._$_waveShaper$_.disconnect(), 
            this._$_postGain$_.disconnect(), this._$_wetNode$_.disconnect(), this._$_dryNode$_.disconnect(), 
            super._$Release$_();
        }
        _$_SetDrive$_(t, s) {
            this._$_preGain$_.gain.value = t = t < .01 ? .01 : t, this._$_postGain$_.gain.value = Math.pow(1 / t, .6) * s;
        }
        _$_GenerateColortouchCurve$_(i, e) {
            const h = 32768;
            for (let s = 0; s < h; ++s) {
                let t = s / h;
                t = this._$_Shape$_(t, i, e), this._$_curve$_[h + s] = t, this._$_curve$_[h - s - 1] = -t;
            }
        }
        _$_Shape$_(t, s, i) {
            const e = 1.05 * i * s, h = e - s, n = t < 0 ? -1 : 1, o = t < 0 ? -t : t;
            let r = o < s ? o : s + h * self._$AudioDOMHandler$_._$e4$_(o - s, 1 / h);
            return r *= n;
        }
        _$ConnectTo$_(t) {
            this._$_wetNode$_.disconnect(), this._$_wetNode$_.connect(t), this._$_dryNode$_.disconnect(), 
            this._$_dryNode$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_inputNode$_;
        }
        _$SetParam$_(t, s, i, e) {
            0 === t && (s = Math.max(Math.min(s / 100, 1), 0), this._$_params$_[4] = s, 
            this._$SetAudioParam$_(this._$_wetNode$_.gain, s, i, e), this._$SetAudioParam$_(this._$_dryNode$_.gain, 1 - s, i, e));
        }
    }, self._$C3AudioCompressorFX$_ = class extends bj {
        constructor(t, s, i, e, h, n) {
            super(t), this._$_type$_ = "compressor", this._$_params$_ = [ s, i, e, h, n ], 
            this._$_node$_ = this._$_audioContext$_.createDynamicsCompressor(), 
            this._$_node$_.threshold.value = s, this._$_node$_.knee.value = i, this._$_node$_.ratio.value = e, 
            this._$_node$_.attack.value = h, this._$_node$_.release.value = n;
        }
        _$Release$_() {
            this._$_node$_.disconnect(), super._$Release$_();
        }
        _$ConnectTo$_(t) {
            this._$_node$_.disconnect(), this._$_node$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_node$_;
        }
        _$SetParam$_(t, s, i, e) {}
    }, self._$C3AudioAnalyserFX$_ = class extends bj {
        constructor(t, s, i) {
            super(t), this._$_type$_ = "analyser", this._$_params$_ = [ s, i ], 
            this._$_node$_ = this._$_audioContext$_.createAnalyser(), this._$_node$_.fftSize = s, 
            this._$_node$_.smoothingTimeConstant = i, this._$_freqBins$_ = new Float32Array(this._$_node$_.frequencyBinCount), 
            this._$_signal$_ = new Uint8Array(s), this._$_peak$_ = 0, this._$_rms$_ = 0, 
            this._$_audioDomHandler$_._$_AddAnalyser$_(this);
        }
        _$Release$_() {
            this._$_audioDomHandler$_._$_RemoveAnalyser$_(this), this._$_node$_.disconnect(), 
            super._$Release$_();
        }
        _$Tick$_() {
            this._$_node$_.getFloatFrequencyData(this._$_freqBins$_), this._$_node$_.getByteTimeDomainData(this._$_signal$_);
            const t = this._$_node$_.fftSize;
            let i = this._$_peak$_ = 0;
            for (let s = 0; s < t; ++s) {
                let t = (this._$_signal$_[s] - 128) / 128;
                t < 0 && (t = -t), this._$_peak$_ < t && (this._$_peak$_ = t), i += t * t;
            }
            const s = self._$AudioDOMHandler$_._$LinearToDb$_;
            this._$_peak$_ = s(this._$_peak$_), this._$_rms$_ = s(Math.sqrt(i / t));
        }
        _$ConnectTo$_(t) {
            this._$_node$_.disconnect(), this._$_node$_.connect(t);
        }
        _$GetInputNode$_() {
            return this._$_node$_;
        }
        _$SetParam$_(t, s, i, e) {}
        _$GetData$_() {
            return {
                tag: this._$GetTag$_(),
                index: this._$GetIndex$_(),
                peak: this._$_peak$_,
                rms: this._$_rms$_,
                binCount: this._$_node$_.frequencyBinCount,
                freqBins: this._$_freqBins$_
            };
        }
    };
}

{
    const bl = "touch", cl = class extends self._$DOMHandler$_ {
        constructor(t) {
            super(t, bl), this._$AddRuntimeMessageHandler$_("request-permission", t => this._$_OnRequestPermission$_(t));
        }
        async _$_OnRequestPermission$_(t) {
            const s = t.type;
            let i = !0;
            0 === s ? i = await this._$_RequestOrientationPermission$_() : 1 === s && (i = await this._$_RequestMotionPermission$_()), 
            this._$PostToRuntime$_("permission-result", {
                type: s,
                result: i
            });
        }
        async _$_RequestOrientationPermission$_() {
            if (!self.DeviceOrientationEvent || !self.DeviceOrientationEvent.requestPermission) return !0;
            try {
                const t = await self.DeviceOrientationEvent.requestPermission();
                return "granted" === t;
            } catch (t) {
                return console.warn("[Touch] Failed to request orientation permission: ", t), 
                !1;
            }
        }
        async _$_RequestMotionPermission$_() {
            if (!self.DeviceMotionEvent || !self.DeviceMotionEvent.requestPermission) return !0;
            try {
                const t = await self.DeviceMotionEvent.requestPermission();
                return "granted" === t;
            } catch (t) {
                return console.warn("[Touch] Failed to request motion permission: ", t), 
                !1;
            }
        }
    };
    self._$RuntimeInterface$_._$AddDOMHandlerClass$_(cl);
}

{
    const nl = "gamepad";
    let s = !1;
    const pl = class extends self._$DOMHandler$_ {
        constructor(t) {
            super(t, nl), this._$_isReady$_ = !1, this._$_timerId$_ = -1, this._$AddRuntimeMessageHandler$_("ready", () => this._$_OnReady$_()), 
            this._$AddRuntimeMessageHandler$_("vibrate-dual-rumble", t => this._$_OnGamepadVibrateDualRumble$_(t)), 
            this._$AddRuntimeMessageHandler$_("vibrate-trigger-rumble", t => this._$_OnGamepadVibrateTriggerRumble$_(t)), 
            this._$AddRuntimeMessageHandler$_("reset-vibrate", t => this._$_OnGamepadResetVibrate$_(t)), 
            this._$AddRuntimeMessageHandler$_("suspend", () => this._$_OnSuspend$_()), 
            this._$AddRuntimeMessageHandler$_("resume", () => this._$_OnResume$_()), 
            window.addEventListener("gamepadconnected", t => this._$_OnGamepadConnected$_(t)), 
            window.addEventListener("gamepaddisconnected", t => this._$_OnGamepadDisconnected$_(t)), 
            window.addEventListener("unload", () => this._$_OnWindowUnload$_());
        }
        _$_GetActiveGamepads$_() {
            try {
                return Array.from(navigator.getGamepads()).filter(t => t && t.connected);
            } catch (t) {
                return s || (console.warn("[Construct] Failed to access gamepads: ", t), 
                s = !0), [];
            }
        }
        _$_OnReady$_() {
            this._$_isReady$_ = !0;
            for (const t of this._$_GetActiveGamepads$_()) this._$_PostGamepadConnectedEvent$_(t);
            this._$_StartGamepadPollTimer$_();
        }
        _$_StartGamepadPollTimer$_() {
            -1 === this._$_timerId$_ && (this._$_timerId$_ = setInterval(() => this._$_PollGamepadState$_(), 4));
        }
        _$_StopGamepadPollTimer$_() {
            -1 !== this._$_timerId$_ && (clearInterval(this._$_timerId$_), this._$_timerId$_ = -1);
        }
        _$_OnSuspend$_() {
            this._$_StopGamepadPollTimer$_();
        }
        _$_OnResume$_() {
            this._$_StartGamepadPollTimer$_();
        }
        _$_OnGamepadConnected$_(t) {
            this._$_isReady$_ && this._$_PostGamepadConnectedEvent$_(t.gamepad);
        }
        _$_GetGamepadSupportedVibrationEffects$_(t) {
            const s = t.vibrationActuator;
            return s && s.playEffect && Array.isArray(s.effects) ? s.effects : [];
        }
        _$_GetGamepadInfoJSON$_(t) {
            return {
                index: t.index,
                id: t.id,
                vibrationEffects: this._$_GetGamepadSupportedVibrationEffects$_(t)
            };
        }
        _$_PostGamepadConnectedEvent$_(t) {
            this._$PostToRuntime$_("gamepad-connected", this._$_GetGamepadInfoJSON$_(t));
        }
        _$_OnGamepadDisconnected$_(t) {
            if (this._$_isReady$_) {
                const s = t.gamepad;
                this._$PostToRuntime$_("gamepad-disconnected", {
                    index: s.index
                });
            }
        }
        _$_PollGamepadState$_() {
            const t = this._$_GetActiveGamepads$_();
            if (t.length) {
                const s = t.map(t => Object.assign(this._$_GetGamepadInfoJSON$_(t), {
                    buttons: t.buttons.map(t => ({
                        pressed: t.pressed,
                        value: t.value
                    })),
                    axes: t.axes
                }));
                this._$PostToRuntime$_("input-update", s);
            }
        }
        _$_GetGamepadByIndex$_(t) {
            for (const s of this._$_GetActiveGamepads$_()) if (s.index === t) return s;
            return null;
        }
        async _$_OnGamepadVibrateDualRumble$_(t) {
            const s = this._$_GetGamepadByIndex$_(t.index);
            if (s) {
                const i = s.vibrationActuator;
                if (i && i.playEffect) try {
                    await i.playEffect("dual-rumble", {
                        duration: t.duration,
                        startDelay: 0,
                        weakMagnitude: t.weakMag,
                        strongMagnitude: t.strongMag
                    });
                } catch (t) {
                    console.warn("[Gamepad] Failed to vibrate gamepad (dual rumble): ", t);
                }
            }
        }
        async _$_OnGamepadVibrateTriggerRumble$_(t) {
            const s = this._$_GetGamepadByIndex$_(t.index);
            if (s) {
                const i = s.vibrationActuator;
                if (i && i.playEffect) try {
                    await i.playEffect("trigger-rumble", {
                        duration: t.duration,
                        startDelay: 0,
                        weakMagnitude: t.weakMag,
                        strongMagnitude: t.strongMag,
                        leftTrigger: t.leftMag,
                        rightTrigger: t.rightMag
                    });
                } catch (t) {
                    console.warn("[Gamepad] Failed to vibrate gamepad (trigger rumble): ", t);
                }
            }
        }
        _$_OnGamepadResetVibrate$_(t) {
            const s = this._$_GetGamepadByIndex$_(t.index);
            if (s) {
                const i = s.vibrationActuator;
                i && i.reset && i.reset();
            }
        }
        _$_OnWindowUnload$_() {
            for (const t of this._$_GetActiveGamepads$_()) {
                const s = t.vibrationActuator;
                s && s.reset && s.reset();
            }
        }
    };
    self._$RuntimeInterface$_._$AddDOMHandlerClass$_(pl);
}

{
    const $l = "localstorage", _l = class extends self._$DOMHandler$_ {
        constructor(t) {
            super(t, $l), this._$AddRuntimeMessageHandlers$_([ [ "init", () => this._$_Init$_() ], [ "request-persistent", () => this._$_OnRequestPersistent$_() ] ]);
        }
        async _$_Init$_() {
            let s = !1;
            try {
                s = await navigator.storage.persisted();
            } catch (t) {
                s = !1, console.warn("[Construct] Error checking storage persisted state: ", t);
            }
            return {
                isPersistent: s
            };
        }
        async _$_OnRequestPersistent$_() {
            try {
                const t = await navigator.storage.persist();
                return {
                    isOk: !0,
                    isPersistent: t
                };
            } catch (t) {
                return console.error("[Construct] Error requesting persistent storage: ", t), 
                {
                    isOk: !1
                };
            }
        }
    };
    self._$RuntimeInterface$_._$AddDOMHandlerClass$_(_l);
}

if (window.C3_Is_Supported) {
    const gm = !1;
    window.c3_runtimeInterface = new self._$RuntimeInterface$_({
        _$useWorker$_: gm,
        _$workerMainUrl$_: "workermain.js",
        runtimeScriptList: [ "scripts/c3main.js" ],
        scriptFolder: "scripts/",
        exportType: "html5"
    });
}